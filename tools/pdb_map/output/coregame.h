#if 1 // no source file
struct _player_save_data
{
    int32_t room_number;
    float pos_x;
    float pos_y;
    float pos_z;
    float rot_y;
    uint32_t pistol_ammo;
    uint32_t magnum_ammo;
    uint32_t uzi_ammo;
    uint32_t shotgun_ammo;
    uint32_t num_medis;
    uint32_t num_big_medis;
    uint32_t num_scions;
    char gun_status;
    char gun_type;
    uint32_t available;
    uint32_t got_pistols;
    uint32_t got_magnums;
    uint32_t got_uzis;
    uint32_t got_shotgun;
    uint32_t costume;
    uint32_t num_pickup1;
    uint32_t num_pickup2;
    uint32_t num_puzzle1;
    uint32_t num_puzzle2;
    uint32_t num_puzzle3;
    uint32_t num_puzzle4;
    uint32_t num_key1;
    uint32_t num_key2;
    uint32_t num_key3;
    uint32_t num_key4;
    uint32_t num_leadbar;
    uint32_t timer;
    uint32_t kills;
    uint32_t secrets;
    uint32_t pickups;
    uint32_t bonus_flag;
};

struct _level_data
{
    int32_t player_count;
    int32_t current_level;
    char miscData[5120];
};

struct TRFoliageObject : CoreAnimatingObject
{
    CoreS128Aligned m_memoryPot[256];
    TRFoliageObjectData* m_data;

    void TRFoliageObject();
    void Construct(CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
    void Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
    void Reset();
    void SetFileInfo(char* i_pPath, char* i_pFileName);
    void SetMaxWobble(float fWobble);
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void UpdateGameCycle(float i_time);
    void Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
    void Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
    void AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
    CoreScripted::CommandReturn FnSetDefaultObjectTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultTextureTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultAnimSet();
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    void ~TRFoliageObject();
};

struct CoreHash
{
    uint32_t m_hash;
    static bool m_storeHashStrings;

    void CoreHash(uint32_t i_hash, char* i_string);
    void ~CoreHash();
    void Set();
    bool IsNullHash();
    uint32_t GetHash();
    char* GetString();
    bool operator==(CoreHash i_compare);
    bool operator!=(CoreHash i_compare);
    void GenerateHashString(char* o_output);
    uint32_t GenerateHash(char* i_string);
    uint32_t GenerateHashCaseSensitive();
    bool AllocateDebugMemory(CoreMemory* i_memory, int32_t i_hashStringPoolSize);
    void StoreHashStrings();
};

struct TRFoliageObjectData
{
    int32_t nMeshCount;
    CoreStringBuffer<64> strPath;
    CoreStringBuffer<64> strFileName;
    float LeafRot[6];
    float LeafBounce[6];

    void TRFoliageObjectData();
};

enum ITEM_TYPE
{
    ITEM_TYPE_NULL,
    ITEM_TYPE_PLAYER,
    ITEM_TYPE_OBJECT,
    ITEM_TYPE_MAX,
};

struct TRAnimInfo
{
};

struct TRGlobals
{
    FRWorld* world;
    FRLevel* level;
    FRObjectController* objectController;
    TRObjectDB* objectDB;
    TRCollision* collision;
    TRSoundSystem* soundSystem;
    TRAIController* AI;
    TRAttractors* attractors;
    TRMenuSystem* menuSystem;
    TREditor* editor;
    TRTriggerController* triggers;
    TRSaveGame* saveGame;
    TREffects* effects;
    float deltaTimeScaled;
    float deltaTimeUnscaled;
    int32_t flipmap[10];
    int32_t flip_status;
    FRPlayerObject* playerObject[2];
    TRItem* playerItem[2];
    char currentLevelName[256];
    TRRoomEffects* m_roomEffects;
    uint32_t m_counter;
    uint32_t m_MultiplayerMode;
    PlayerDarts m_playerDarts[8];
    Darts m_darts[8];
    int32_t hintFlags[32];

    void TRGlobals();
    void Init();
    void SetupPointers();
    void UpdateDarts();
    void RenderDarts();
    void RenderPlayerDarts(FRPlayerObject* i_player);
    int32_t GetFreeDart();
    int32_t GetFreePlayerDart();
};

struct TRItem
{
    ITEM_TYPE m_type;
    int32_t m_objIndex;
    int32_t m_itemNum;
    bool active;
    int32_t objectNumber;
    int32_t room_number;
    int32_t box_number;
    int32_t ffloor;
    int32_t timer;
    int32_t flags;
    uint32_t touch_bits;
    uint32_t status;
    OLD_POS pos;
    int32_t anim_number;
    int32_t frame_number;
    int32_t current_anim_state;
    int32_t required_anim_state;
    int32_t goal_anim_state;
    int32_t speed;
    uint32_t hit_status : 1;
    int32_t fallspeed;
    uint32_t gravity_status : 1;
    int32_t shade;
    int32_t hit_points;
    uint32_t looked_at : 1;
    uint32_t collidable : 1;
    uint32_t mesh_bits;
    void* data;
    int32_t next_item;
    int32_t next_active;

    void InitialiseItem();
    void SetType();
    ITEM_TYPE GetType();
    void SetObject();
    CoreObject* GetObjectPtr();
    void TransferNewToOld();
    void TransferOldToNew();
    void AnimateItem();
    int32_t GetChange();
    void TranslateItem();
    int32_t TriggerActive();
};

struct OLD_POS
{
    int32_t x_pos;
    int32_t y_pos;
    int32_t z_pos;
    int32_t x_rot;
    int32_t y_rot;
    int32_t z_rot;
};

struct FRObjectController : CoreObjectController
{
    bool m_displayObjectDebug;
    int32_t m_nextItemActive;

    void FRObjectController();
    void RegisterTypes();
    TRChaseCamera* GetChaseCameraObject();
    TRFixedCamera* GetFixedCameraObject();
    FRPlayerObject* GetPlayerObject();
    CoreObject* GetPlayerObj(int32_t id);
    void UpdateGameObjects();
    void DoDebug();
    void InitialiseItemArray(int32_t numItems);
    void AddActiveItem(TRGameObject* i_object);
    void RemoveActiveItem(TRGameObject* i_object);
    void RemoveDrawnItem(TRItem* item);
    int32_t CreateItem(ITEM_TYPE i_type, CoreHash i_script, int32_t i_itemNum);
    void KillItem(TRGameObject* i_object);
    void RemoveDrawnObject(TRGameObject* i_object);
    void OnPostRender();
    int32_t GetNumPlayerObjects();
    FRPlayerObject* FindPlayerObject();
    FRPlayerObject* FindParentedPlayerObject();
    int32_t GetMaxPlayerObjects();
    int32_t GetNumChaseCameraObjects();
    TRChaseCamera* FindChaseCameraObject();
    TRChaseCamera* FindParentedChaseCameraObject();
    int32_t GetMaxChaseCameraObjects();
    int32_t GetNumFixedCameraObjects();
    TRFixedCamera* FindFixedCameraObject();
    TRFixedCamera* FindParentedFixedCameraObject();
    int32_t GetMaxFixedCameraObjects();
    FRBackgroundObject* GetBackgroundObject();
    int32_t GetNumBackgroundObjects();
    FRBackgroundObject* FindBackgroundObject();
    FRBackgroundObject* FindParentedBackgroundObject();
    int32_t GetMaxBackgroundObjects();
    TRGameObject* GetGameObjectObject();
    int32_t GetNumGameObjectObjects();
    TRGameObject* FindGameObjectObject();
    TRGameObject* FindParentedGameObjectObject();
    int32_t GetMaxGameObjectObjects();
    TRInvObject* GetInvObjectObject();
    int32_t GetNumInvObjectObjects();
    TRInvObject* FindInvObjectObject();
    TRInvObject* FindParentedInvObjectObject();
    int32_t GetMaxInvObjectObjects();
    TRMultiMeshObject* GetMultiMeshObjectObject();
    int32_t GetNumMultiMeshObjectObjects();
    TRMultiMeshObject* FindMultiMeshObjectObject();
    TRMultiMeshObject* FindParentedMultiMeshObjectObject();
    int32_t GetMaxMultiMeshObjectObjects();
    TRFoliageObject* GetFoliageObjectObject();
    int32_t GetNumFoliageObjectObjects();
    TRFoliageObject* FindFoliageObjectObject();
    TRFoliageObject* FindParentedFoliageObjectObject();
    int32_t GetMaxFoliageObjectObjects();
    void ~FRObjectController();
};

struct TRChaseCamera : CoreCameraObject
{
    enum TurnMode
    {
        TURN_EITHER,
        TURN_LEFT,
        TURN_RIGHT,
        TURN_NEITHER,
    };

    CoreGeometryObject* m_target;
    bool m_resetPosition;
    CoreVector m_targetPos;
    CoreVector m_offset;
    float m_idealDistance;
    float m_distance;
    float m_lastDistance;
    CoreEulerAngle m_angle;
    float m_angleVel;
    TRChaseCamera::TurnMode m_turnMode;
    bool m_cameraOverrideAngleManual;
    bool m_cameraOverridePitchManual;
    bool m_cameraOverrideAngleEffect;
    bool m_cameraOverridePitchEffect;
    float m_distanceCatchupSpeed;
    float m_springBackValue;
    float m_disableCameraEffectsTime;
    float m_disableCameraManualTime;
    float m_pitchSpeed;
    CoreS128Aligned m_memoryPot[256];

    void TRChaseCamera();
    void ~TRChaseCamera();
    void Construct(CoreMemory* io_memory);
    void AdjustCameraAngle(float i_deltaAngle, float i_deltaPitch, float i_deltaRoll);
    void AdjustCameraDistance(float i_requiredDistance);
    bool AdjustCameraAngleTo(float i_toAngle, float i_speed);
    bool AdjustCameraPitchTo(float i_toPitch, float i_speed, CAMMODE i_mode);
    bool AdjustCameraAngleOverride(float i_targetAngleX, float i_targetAngleY, float i_speed);
    void DisableCameraEffects();
    bool AreCameraEffectsDisabled();
    void DisableCameraManual();
    bool IsCameraManualDisabled();
    void OnSwitchedFrom(CoreCameraObject* io_toCam);
    void OnSwitchedTo(CoreCameraObject* io_fromCam);
    void UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
    void SetTarget(CoreGeometryObject* i_object);
    void ResetPosition();
    void SetOffset(CoreVector& i_offset);
    void SetSpring();
    CoreEulerAngle GetAngle();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void ExpandRegion(CoreVector& i_target, float i_distance, float i_angle, float i_pitch, CoreVector& io_min, CoreVector& io_max);
    float TestRay(CoreVector& i_target, float i_distance, float i_angle, float i_pitch);
    CoreVector GetTargetPosition(float i_time, CoreObjectUpdateStruct* updateStruct);
    float GetAutoMove();
    void UpdateDistance(float i_distance, float i_time);
    void UpdateAngleVelocity(float i_angleDelta, float i_time);
    CoreScripted::CommandReturn FnDefaultCameraLogic();
    CoreScripted::CommandReturn DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
    CoreScripted::CommandReturn LookatCameraLogic();
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
};

struct CoreCameraObject : CoreObject
{
    enum CoreCurveEquasion
    {
        CoreCurveEquasionNull,
        CoreCurveEquasionLinear,
        CoreCurveEquasionSmoothInOut,
    };

    enum CameraStateType
    {
        CameraStateTypeStateless,
        CameraStateTypeStatePreserving,
    };

    enum CameraTriggerObjectType
    {
        CameraTriggerObjectTypeNull,
        CameraTriggerObjectTypeVolume,
    };

    enum CameraTriggerInternalState
    {
        CameraTriggerInternalStateNull,
        CameraTriggerInternalStateInside,
        CameraTriggerInternalStateOutside,
    };

    enum CameraBlendType
    {
        CameraBlendTypeDontCare,
        CameraBlendTypeSmooth,
        CameraBlendTypeJump,
    };

    bool m_triggerActive;
    CoreCameraObject::CameraTriggerInternalState m_triggerInternalState;
    CoreCameraObject::CameraTriggerObjectType m_triggerType;
    CoreHash m_triggerShapeHash;
    CoreObject* m_triggeringObject;
    bool m_triggerIn;
    bool m_triggerOut;
    bool m_triggerJustIn;
    bool m_triggerJustOut;
    int32_t m_blendType;
    CoreCameraObjectData* m_data;

    float CoreCurveEquasionCalc(float i_inputval, CoreCameraObject::CoreCurveEquasion i_type);
    void Construct(CoreMemory* io_memory);
    void Init(CoreHash i_nameHash, CoreHash i_scriptHash, CoreObjectUpdateStruct* io_updateStruct);
    void UpdateTriggerFromViewer(CoreObjectUpdateStruct* i_updateStruct);
    void UpdateTriggerJustEntered();
    void UpdateTriggerJustLeft();
    void UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
    void Update(CoreObjectUpdateStruct* i_updateStruct);
    void AdjustCameraAngle(float i_deltaAngle, float i_deltaPitch, float i_deltaRoll);
    void AdjustCameraDistance(float i_requiredDistance);
    bool AdjustCameraAngleTo(float i_toAngle, float i_speed);
    bool AdjustCameraPitchTo(float i_toPitch, float i_speed);
    bool AdjustCameraAngleOverride(float i_targetAngleX, float i_targetAngleY, float i_speed);
    void OnSwitchedFrom(CoreCameraObject* io_toCam);
    void OnSwitchedTo(CoreCameraObject* io_fromCam);
    bool IsActive();
    bool IsUpdatable();
    void SetActive();
    bool GetFirstTimeFlag();
    void SetFirstTimeFlag();
    void SetNearClip(float val);
    void SetFarClip(float val);
    float GetNearClip();
    float GetFarClip();
    float GetVerticalFieldOfView();
    bool IsFogOn();
    float GetFogRed();
    float GetFogGreen();
    float GetFogBlue();
    float GetFogAlpha();
    float GetFogNear();
    float GetFogFar();
    bool GetBloom();
    float GetBloomIntensity();
    float GetBloomFeedback();
    float GetBloomThreshold();
    bool GetFocalBlur();
    float GetFocalBlurZ();
    float GetFocalBlurAmount();
    bool GetMotionBlur();
    float GetMotionBlurAmount();
    bool GetRadialBlur();
    float GetRadialBlurAngle();
    float GetRadialBlurScale();
    float GetRadialBlurCenterX();
    float GetRadialBlurCenterY();
    bool GetFSFX0();
    bool GetFSFX1();
    bool GetFSFX2();
    bool GetFSFX3();
    bool GetFSFX4();
    bool GetFSFX5();
    bool GetFSFX6();
    bool GetFSFX7();
    bool GetFSFX8();
    bool GetFSFX9();
    void SetRoll(float i_roll);
    float GetRoll();
    void SetCameraActive(bool i_var);
    void SetLookAtPos(CoreVector& i_pos);
    void LookAtLookAtPos();
    CoreVector GetLookAtPos();
    float GetDisplayAspectRatio();
    void SetFog(bool i_onOff, float i_red, float i_green, float i_blue, float i_alpha, float i_near, float i_far);
    void SetBloom();
    void SetFocalBlur();
    void SetMotionBlur(bool i_on, float i_motionBlurAmount);
    void SetView(float i_nearPlane, float i_farPlane, float i_fieldOfView);
    void SetTriggerable();
    bool GetTriggerable();
    CoreHash GetCameraEffectName();
    void SetCameraEffectName();
    bool GetSelectableAsNearestFlag();
    void SetSelectableAsNearestFlag();
    bool GetConnectedToViewerFlag();
    void SetConnectedToViewerFlag(bool i_var);
    void SetCurrentViewerObject(CoreViewerObject* i_var);
    CoreViewerObject* GetCurrentViewerObject();
    void ClearTriggers();
    CoreCameraObject::CameraStateType GetStateType();
    void SetStateType(CoreCameraObject::CameraStateType i_var);
    void DoDebug(CoreDebugInput* i_input, CoreObjectUpdateStruct* i_updateStruct);
    void SetTriggeringObject(CoreObject* i_obj);
    CoreObject* GetTriggeringObject();
    CoreScripted::CommandReturn FnSetCameraActive(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetCameraEffect(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetCameraSelectableAsNearest(CoreCommand* io_command);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetCameraBlendType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetTriggerType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetTriggerShape(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetTriggerActive(CoreCommand* io_command);
    void CoreCameraObject();
    void ~CoreCameraObject();
};

struct TRFixedCamera : CoreCameraObject
{
    CoreHash m_cameraHash;
    CoreHash m_lastHash;
    float m_timer;
    int32_t m_speed;
    int32_t m_type;
    TRItem* m_item;
    TRItem* m_lastItem;
    CoreEulerAngle m_angle;
    CoreS128Aligned m_memoryPot[256];

    void TRFixedCamera();
    void ~TRFixedCamera();
    void Construct(CoreMemory* io_memory);
    void OnSwitchedFrom(CoreCameraObject* io_toCam);
    void OnSwitchedTo(CoreCameraObject* io_fromCam);
    void UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreScripted::CommandReturn FnDefaultCameraLogic();
    CoreScripted::CommandReturn DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
};

struct FRPlayerObject : TRGameObject
{
    enum Effects
    {
        EFFECT_CAMERA_ZOOM,
        EFFECT_CAMERA_VERTIGO,
        EFFECT_CAMERA_OFFSET,
        EFFECT_CAMERA_RESET,
        EFFECT_CAMERA_ANGLE,
        EFFECT_CAMERA_PITCH,
        EFFECT_FOG_RED,
        EFFECT_MOTION_BLUR,
        EFFECT_TIME_SCALE,
        EFFECT_MAX,
    };

    CoreS128Aligned m_memoryPot[2560];
    FRPlayerObjectData* m_data;
    TRRagdoll m_ragdoll;
    int32_t item_number;
    LARA_GUN_STATUS gun_status;
    int32_t gun_type;
    int32_t request_gun_type;
    int32_t calc_fallspeed;
    LARA_WATER_STATE water_status;
    int32_t pose_count;
    int32_t hit_frame;
    int32_t hit_direction;
    int32_t air;
    int32_t dive_count;
    int32_t death_count;
    int32_t current_active;
    int32_t spaz_effect_count;
    TRNav m_nav;
    int32_t m_sinkTarget;
    float m_frontendTimer;
    CoreVector m_movePlayerToPos;
    CoreEulerAngle m_movePlayerToOrient;
    PLAYER_EFFECT m_effects[9];

    void FRPlayerObject();
    void Construct(CoreMemory* io_memory);
    void Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
    void ReInit();
    void Reset();
    void SetInputPad(uint32_t i_PadNumber);
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void DefaultPlayerLogic();
    void Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnIsCharacterFemale();
    CoreScripted::CommandReturn FnSetInputPad(CoreCommand* io_Command);
    CoreScripted::CommandReturn eFnLoadCharacter();
    CoreDetectResult* DoDetection(CoreVector vOldPos, CoreVector vNewPos);
    void ResetAllActionStates();
    void UpdateActionStates();
    void UpdateAIActionStates();
    void SetupActionState(CoreHash i_actionName);
    void ResetActionState(CoreHash i_actionName);
    void UpdateLaraRoom(float height);
    void UpdateLaraNav();
    float AnimTimeAdjust(float i_time);
    bool HandleAnimCommandCallback(CoreHash i_slotID, CoreAnimCommand* i_command);
    bool GetFloorSurfaceType(CoreVector& i_detectPosition, uint32_t& o_surfaceType);
    CoreVector* GetOldPos();
    CoreVector GetOldPos1();
    CoreVector* GetBonePos();
    void ClearLeanAngle();
    int32_t GetPlayerID();
    int32_t GetViewerIndex();
    void SetViewerIndex();
    void SetPlayerFlag();
    void ClearPlayerFlag(int32_t i_flagIndex);
    void ModifyPlayerFlag();
    bool TestPlayerFlag();
    void SetPlayerOnFire(bool i_burn);
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, CoreObjectUpdateStruct* lpoUpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, int32_t& iDataRead, CoreObjectUpdateStruct* lpoUpdateStruct);
    void NetworkPlayerLogic(CoreObjectUpdateStruct* i_UpdateStruct);
    void ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
    void ResetPlayerToStand(bool killRagdoll);
    void MovePlayerAfterMission();
    int32_t TakeDamage(int32_t i_damage, bool i_showBar);
    void SetMovePlayerTo(CoreVector i_pos, CoreEulerAngle i_rot);
    void UpdateMovePlayerTo();
    void PlayerSpecificEffects();
    void UpdateFlares();
    void LaunchFlare();
    bool ResetPlayerToLastCheckPoint();
    void OnPostRender();
    void InitWeaponData();
    void SetDetectionSpheres(bool i_blendSpheres, float i_blendTime);
    void CameraRelativeControls(CoreCameraObject* io_cameraObject);
    void GetControlInput(CoreInput* i_input, CoreEulerAngle& i_orient);
    void ClearControlInput(CoreInput* i_input, CoreEulerAngle& i_orient);
    void EmulateCallBacks();
    bool CheckFallenOffWorld();
    CoreVector SnapToFloor(CoreVector i_pos);
    void PrimeDetectionCache();
    CoreScripted::CommandReturn eFnPlayerInit(CoreCommand* lpoCommand);
    void GetBonePositions();
    void InitialiseHair();
    void UpdateHair();
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    bool ContextCanWalkForward(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCheckWalkBehind(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClearInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClearLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClearRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClearBack(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextMoveOffClearInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextNoFloorUnderneath(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextSetAnim(FRPlayerObject* i_obj, int32_t i_temp);
    bool Check2mPlusClimbs(float i_minHeight, float i_maxHeight, float i_actualHeight);
    bool Context2mPlusClimbMustHang(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context1mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context1_5mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context2mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context2_5mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context3mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context3_5mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextEndOfAnim(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context180DegreesOut(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextReverse(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context1mBelowWall(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context1mBelowWallLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context1mBelowWallRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context1mBelowWallBack(FRPlayerObject* i_obj, int32_t i_temp);
    bool Context0mBelowWall(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCheckSprintInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextLastChanceGrab(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextLastChanceGrabAlways(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbOntoLedge(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbOntoLedgeOverhang(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextSetTurnAngleAndAnim(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCanSprint(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextSetAverageForwardVelocity(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStepUpRun0_5m(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStepUpRun0_25m(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStepUpWalk0_5m(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStepUpWalk0_25m(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextSlowTurnLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextSlowTurnRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCloseToStance(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextTurnOnSpotLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextTurnOnSpotRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextRunTurnLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextRunTurnRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextLandedOnSlopeFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextLandedOnSlopeBack(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextSlopeUnderfoot(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextSlopeNormal(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextSlopeSteep(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionHandleAnalog(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionHandleIdling(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionNullFunction(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionHandleOrientChange();
    bool FunctionInitClimbBlend();
    bool FunctionAdjustToWidthOfPole(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionResetOrient(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionAlignPlayerToSlopeFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionAlignPlayerToSlopeBack(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionMovePlayerDownSlopeFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionMovePlayerDownSlopeBack(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionResetStanceTimer(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionSetActionWalk(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionDropLoopHitWall(FRPlayerObject* i_obj, int32_t i_temp);
    void CollideWithNPCs();
    float GetSlopeInFront();
    bool HandleWallSlide(bool i_glance);
    bool CheckWallInFront(CoreDetectResult* i_det, float i_height, bool i_align);
    bool CheckWallAtAngle(CoreDetectResult* i_det, float i_height, bool i_align, float i_angle);
    bool HandleLastChanceGrab(float i_deadlyHeight);
    bool AlignPlayerToSlope(bool i_initialise, bool i_backSlide);
    bool MovePlayerDownSlope(bool i_backSlide);
    bool OnSlope();
    bool StepHeightTest(float i_idealHeight, float i_idealDist, float i_heightTolerance, float i_lookAhead);
    bool ContextShimmyBlending(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCanShimmyLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyLeftExternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyLeftInternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCanShimmyRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyRightExternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyRightInternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCanShimmyJumpRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCanShimmyJumpLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyJumpToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyJumpToHang(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyJumpToClimbableWall(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableLedgeFromLRShimmyJump(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableLedgeFromLRHangJump(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableLedgeFromLRClimbableWallJump(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCanHPoleShimmyLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCanHPoleShimmyRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextHangToHPole(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextCanPlantFeet(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyToHangLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyToHangRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextHangToShimmyLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextHangToShimmyRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyLeftInternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyLeftExternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyRightInternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyRightExternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyLeftInternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyLeftExternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyRightInternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyRightExternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextHangLeftInternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextHangLeftExternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextHangRightInternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextHangRightExternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionAlignHang(FRPlayerObject* i_obj, int32_t i_temp);
    float GetShimmyAngle(TRAttractor* i_currentAttractor, TRAttractor* i_joiningAttractor, int32_t i_commonPoint);
    float GetAttractorYPos(TRAttractor* i_currentAttractor, TRAttractor* i_joiningAttractor, float i_distFromEdge, int32_t i_commonPoint, CoreVector& io_newPos);
    float GetAttractorYPosByVector(CoreVector& i_p0, CoreVector& i_p1, float i_distFromEdge, CoreVector& io_newPos);
    float CalculateShimmyJumpParams(float i_yOff, float i_jumpDist, bool i_jumpLeft, CoreEulerAngle& i_dir, CoreVector& o_source, CoreVector& o_target, CoreVector& o_externalVelocity);
    bool GetShimmyJumpLRDistance(float i_stepDist, bool i_setVel);
    AttractorTable* GetNearestIntersectingAttractor(CoreVector i_pos, CoreEulerAngle i_dir, bool i_jumpLeft, float i_minXZ, float i_maxXZ, float i_minY, float i_maxY, float& o_xzOffset, float& o_yOffset);
    bool ContextShimmyChangeFootPlantation(bool i_goingLeft, bool i_shimmyToHang);
    bool ContextShimmyInternal90ToHang(bool i_goingLeft, bool i_execute);
    bool ContextShimmyExternal90ToHang(bool i_goingLeft, bool i_execute);
    bool ContextHangInternal90(bool i_goingLeft);
    bool ContextHangExternal90(bool i_goingLeft);
    bool ContextShimmyInternal90(bool i_goingLeft);
    bool ContextShimmyExternal90(bool i_goingLeft);
    bool ContextClimbableWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallGetOff(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallDropOff(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallCanClimbUp(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallCanClimbDownStatic(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallCanClimbDownDynamic(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallCanClimbLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallCanClimbRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftInternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftExternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightInternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightExternal90(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableClimbableWallFromJumpUp(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableClimbableWallFromDropLoop(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableClimbableWallFromDropLoopDown(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableClimbableWallFromJumpForward(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableClimbableWallScramble(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableClimbableWallScramble2_0m(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableClimbableWallScramble2_5m(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableClimbableWallScramble3_0m(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableClimbableWallScramble3_5m(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallAllowRelease(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallFromClimb(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallFromShimmyStance(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallFromShimmyLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallFromShimmyRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftInternal90ToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftExternal90ToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightInternal90ToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightExternal90ToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftInternal90FromShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftExternal90FromShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightInternal90FromShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightExternal90FromShimmy(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftToHang(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightToHang(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftInternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftExternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightInternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightExternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftInternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftExternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightInternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightExternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftInternal90FromHang(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallLeftExternal90FromHang(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightInternal90FromHang(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbableWallRightExternal90FromHang(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionClimbableWallAlign(FRPlayerObject* i_obj, int32_t i_temp);
    void DrawClimbWallAttractor(TRClimbData& i_cd, bool i_selected);
    void GetClimbWallAttractorData(TRAttractor* i_aPtr, CoreVector& i_playerPos, TRClimbData& o_cd);
    void ClimbWallAttractorDataSetup(TRAttractor* i_aPtr, TRClimbData& o_cd);
    void ClimbWallAttractorDataSetPos(CoreVector& i_playerPos, TRClimbData& o_cd);
    TRAttractor* GetClimbWallAttractorNext(ClimbWallDirectionType i_climbWallDirection, CoreVector& i_playerPos, TRClimbData& i_cdCurr, TRClimbData& o_cd);
    float ClimbableWallGetVerticalSnap(CoreVector& i_playerPos, TRClimbData& i_cd);
    bool CheckClimbableWallHeight(AttractorTable* i_aPtr, float i_minHeight, float i_maxHeight, float i_climbHeight);
    bool CheckClimbableWallCanClimbDown(bool i_static);
    bool CheckClimbableWallExternal90(bool i_goingLeft);
    bool CheckClimbableWallInternal90(bool i_goingLeft);
    bool CheckClimbableWallGrabbable(float i_dist, float i_yMove, float i_minHeightDiff, float i_maxHeightDiff, float i_atrMaxDist, bool i_scrambleTest, bool i_shimmyTest, float i_maxAngle);
    bool ClimbWallEdgeCanAlign(ClimbWallDirectionType i_climbWallDirection, TRClimbData& i_cdCurr, bool& o_offsetRequired, CoreVector& o_offset);
    void ClimbWallEdgeAlign(ClimbWallDirectionType i_climbWallDirection, TRClimbData& i_cdCurr);
    bool CheckClimbableWallConnectsToShimmy(TRClimbData& i_cdCurr, AttractorTable* i_aPtrShimmy, CoreVector& o_nearPointOnLine, CoreVector& o_farPointOnLine, CoreVector& o_wallPoint, CoreVector& i_playerPos, CoreEulerAngle& i_playerRot, float i_moveDirection);
    bool CheckClimbableWallFromShimmy(float i_moveDirection, float i_cornerAngle, CoreVector& io_playerPos, AttractorTable*& o_aPtr, CoreVector& o_nearPointOnLine, CoreVector& o_farPointOnLine, CoreVector& o_wallPoint, float& o_edgeDist, TRClimbData& o_cdCurr, float i_maxEdgeDist);
    bool CheckClimbableWallToShimmy(float i_moveDirection, float i_cornerAngle, CoreVector& io_playerPos, AttractorTable*& o_aPtr, CoreVector& o_nearPointOnLine, CoreVector& o_farPointOnLine, CoreVector& o_wallPoint, float& o_edgeDist, TRAttractor*& o_atrCurr, float i_maxEdgeDist, bool i_feetPlantable);
    bool CheckClimbableWallToShimmyStraight(bool i_goingLeft);
    bool CheckClimbableWallToShimmyInternal90(bool i_goingLeft);
    bool CheckClimbableWallToShimmyExternal90(bool i_goingLeft);
    bool CheckClimbableWallFromShimmyStraight(bool i_goingLeft);
    bool CheckClimbableWallFromShimmyInternal90(bool i_goingLeft, float i_maxCornerDist, float i_idealCornerDist);
    bool CheckClimbableWallFromShimmyExternal90(bool i_goingLeft, float i_maxCornerDist, float i_idealCornerDist);
    bool CheckClimbableWallToHangStraight(bool i_goingLeft);
    bool CheckClimbableWallToHangInternal90(bool i_goingLeft, bool i_execute);
    bool CheckClimbableWallToHangExternal90(bool i_goingLeft, bool i_execute);
    bool CheckClimbableWallToAnyShimmy(bool i_goingLeft);
    bool CheckClimbableWallFromAnyShimmy(bool i_goingLeft);
    bool ContextCatchHPole(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextSetWallJump();
    bool ContextGrabbableHangLedgeFromJumpUp(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableHangLedgeFromDropLoop(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableLedgeFromJumpUp(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextJumpWaiting(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextLandOnFloor(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextPassedDownwardVelocityThreshold(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableLedgeFromDropLoop(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableLeftArm(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableRightArm(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableShort(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextGrabbableNormal(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStartJumpUp(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStartJumpForward(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStartJumpLeft(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStartJumpRight(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStartJumpBack(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStartJumpRun(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStartJumpHPole(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextStartJump();
    bool ContextFalling(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextShimmyJumpToDrop(FRPlayerObject* i_obj, int32_t i_temp);
    void InitEffects();
    bool AdjustEffectValueLog(float& io_current, float i_target, float i_amount);
    bool AdjustEffectValueLin(float& io_current, float i_target, float i_amount);
    void SetEffect(CoreHash i_name, float i_time, float i_param1, float i_param2);
    void ResetCameraEffects();
    void UpdateCameraEffects();
    bool LedgeGrab();
    bool LedgeGrabBlend(float i_planeBlendTime, float i_offsetBlendTime, float i_delayBlendTime);
    void GetLedgeGrabHandsHeightDiff(float& o_minHeightDiff, float& o_maxHeightDiff, float i_tolerance);
    void SetJumpVelocity(float i_jumpDistance, float i_extraRotY);
    void SetJumpVelocityHPole();
    void SetJumpVelocityOnEvent();
    bool AddAttractorJumpCalculate(jumpAttractor* jaPtr, AttractorJumpStatics* atrStatics, bool footlanding);
    void AddAttractorToJumpList(jumpAttractor*& jaPtr, int32_t& attractorIndex, AttractorJumpStatics* atrStatics);
    bool AddAttractorJump();
    bool AddAttractorJumpClimb(float minPos, float maxPos, float hOff, float vOff, jumpAttractor*& jaPtr, int32_t& attractorIndex, AttractorJumpStatics* atrStatics);
    bool CalculateAttractorJumpValues();
    bool SetAttractorJumpVelocity();
    void CalculateAttractorJumpCurve(CoreVector& o_jumpVector, float i_jumpDistance, float& o_jumpTime, float i_vOff, float i_jumpVel);
    bool CalculateAttractorJumpVerticalVelocity(jumpAttractor* ja, bool i_footlanding);
    void HandleFallingDamage();
    bool RequestAnimInternal(int32_t slotNo, CoreHash i_animState, uint32_t i_flags);
    bool RequestAnim(CoreHash i_animState, uint32_t i_flags);
    void EmulateNewAnimSystem();
    void SetupMaps(CoreMemory* io_memory);
    bool HandleCaseStatement(CoreHash*& io_scriptPtr, bool i_interruptFlag, bool& io_onlyFunctions);
    void UpdateAnimStates();
    void PlayerControl();
    void DoFlyCheat(CoreVector i_pos, CoreEulerAngle i_orient, TRChaseCamera* i_camera, CoreInput* i_input);
    void SetWallFacing(CorePlaneEquation i_plane);
    CoreHash GetWallPolyHeight(CorePlaneEquation& io_attractorPlane, float& o_angleDiff, float& o_wallHeight);
    float GetCeilingHeightAboveLedge(CoreVector& i_pos, CorePlaneEquation& i_plane);
    bool IsCeilingHeightAboveLedgeByPoly(CorePlaneEquation& i_plane, float& i_ledgeHeight);
    void GetAttractorToPlayerData(AttractorTable* i_aPtr, bool i_perpIntersect);
    void GetAttractorToPlayerDataClimbableWall(AttractorTable* i_aPtr, bool i_perpIntersect);
    void GetJumpIntersectionInfo(AttractorTable* i_aPtr, CoreVector i_intersect, float& o_wallPos, float& o_floorPos, float& o_angleDiff);
    float GetAttractorPosFloorDrop(CoreVector& i_pos, CoreVector& i_attractorNormal);
    void GetAttractorPlane(AttractorTable* i_aPtr, CorePlaneEquation& o_attractorPlane);
    void AlignToPlane(CorePlaneEquation i_plane, float i_dist, float i_blendTime, float i_blendDelay);
    void AlignToPlaneSeparate(CorePlaneEquation i_plane, float i_dist, float i_blendTimeOffset, float i_blendTimeAngle, float i_blendDelay);
    void AlignToPlaneAtAngle(CorePlaneEquation i_plane, float i_dist, float i_blendTime, float i_blendDelay, float i_angle);
    bool CheckGrabbableLedge(float i_dist, float i_yMove, float i_minHeightDiff, float i_maxHeightDiff, float i_maxLedgeHeight, float i_maxDist, float i_maxAngle, bool i_allowPoles);
    bool CheckGrabbableHangLedge(float i_dist, float i_yMove, float i_minHeightDiff, float i_maxHeightDiff, float i_maxLedgeHeight, float i_maxDist, float i_maxAngle);
    void ExtraAnimstateDependentBits();
    void ExtraRagdollDependentBits();
    void AnimSpecificEffects();
    void DoMenuDisplay(TRChaseCamera* i_camera);
    void LookAtCamera();
    void CameraControlAIEditor();
    bool FunctionSetNoGrabbingTimer(FRPlayerObject* i_obj, int32_t i_temp);
    void ShouldIBeUnderWater();
    bool IsInWater();
    bool CheckWaterClimbHeight(AttractorTable* i_aPtr, float i_minHeight, float i_maxHeight, float i_climbHeight);
    bool GetWaterHeight(CoreVector i_pos, float& o_waterHeight);
    bool IsPointUnderwater(CoreVector i_pos);
    void ApplyWaterCurrent();
    bool ContextDroppedIntoWater(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextIsHeadAboveWater(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextNoSwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextDiveUnderwater(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextResetSwimOrient(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextClimbOutOfWater(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextIsHeadBelowWater(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextNotInWater(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionHandleUnderwaterAnalog(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionHandleSurfaceAnalog(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionDecSwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionApplySwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionSetSurfaceSlowSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionSetSurfaceNormalSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionSetSurfaceFastSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionSetUnderwaterNormalSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionSetUnderwaterFastSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionIncUnderwaterSwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionIncSurfaceSwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
    bool FunctionBlendToWaterSurface(FRPlayerObject* i_obj, int32_t i_temp);
    FRPlayerObjectData* GetDataPointer();
    void GetCollisionInfo(CoreObjectUpdateStruct* i_updateStruct);
    void ClearCollisionInfo(CoreObjectUpdateStruct* i_updateStruct);
    void SetupCurrentAttractors();
    float GetHeightBehind();
    float GetFrontHeight();
    float GetPositionHeight();
    float GetCeilingHeight();
    void GetAttractorInfoFromControl();
    void GetAttractorInfo();
    AttractorTable* GetHandsAttractorFront();
    AttractorTable* GetHandsAttractorLeft();
    AttractorTable* GetHandsAttractorRight();
    CoreDetectResult* GetPositionCollision();
    CoreDetectResult* GetControlCollision();
    CoreDetectResult* GetFrontCollision();
    CoreDetectResult* GetLeftCollision();
    CoreDetectResult* GetRightCollision();
    CoreDetectResult* GetBackCollision();
    int32_t GetDebugModeSet();
    CoreCameraObject* GetCurrentCamera();
    void GetCurrentCameraOrient(CoreEulerAngle& ang);
    bool WeaponTargetIsValid(CoreObject* i_target, float* o_targetDist, CoreEulerAngle* o_targetRot, bool i_checkAngle);
    bool WeaponGetTargetPos(CoreObject* m_target, CoreVector& o_pos);
    void WeaponUpdate(TRWeaponAimControl& i_weaponAim);
    void BoneControlCallback(CoreGeometryObject* i_object, CoreMatrix* io_currMatrix, CoreMatrix* io_parentMatrix, CoreQuat* io_currJointQuat, void* io_data, CoreModelJoint* i_modelJoint);
    void WeaponFindTargets(TRWeaponTarget* o_targets, int32_t& o_targetCount, int32_t i_maxTargets);
    void WeaponEventDraw(CoreHash i_slotID);
    void WeaponEventFire(CoreHash i_slotID);
    void WeaponEventHolster(CoreHash i_slotID);
    WeaponInfoStruct* WeaponGetInfo();
    bool CanDrawWeapon();
    bool CanSuspendWeapon();
    bool CanAimBody();
    void WeaponSystemInit();
    void WeaponSystemUpdate();
    void WeaponCameraUpdate();
    void ForceWeaponDraw();
    int32_t WeaponUpdateTargetting(CoreObject** o_targets);
    void WeaponControlOneHanded();
    void WeaponControlTwoHanded();
    bool ContextWeaponDrawn(FRPlayerObject* i_obj, int32_t i_temp);
    bool ContextWeaponHolstered(FRPlayerObject* i_obj, int32_t i_temp);
    bool IsWeaponDrawn();
    bool IsWeaponAiming();
    void ForceWeaponHolster();
    void WeaponCreation();
    void WeaponPlacement();
    void RemoveGreenCrystal();
    void AddGreenCrystal();
    void UpdateGreenCrystalDisplay();
    void UpdateInventoryFlare();
    void ~FRPlayerObject();
};

struct CoreObject : CoreScripted
{
    enum CoreObjectFlags
    {
        MOVABLE,
        RENDERABLE,
        LIT,
        SHADOW_CASTER,
        SHADOW_RECEIVER,
        CAN_COLLIDE_WITH,
        UPDATE_WITHIN_DISTANCE,
    };

    struct CoreObjectNetworkUpdate
    {
        uint32_t uiFlags;
        float fCreationTimeStamp;
        CoreHash oObjectName;
        int32_t iDataSize;
        uint32_t lpuiData[1];
        int32_t lpiData[1];
        float lpfData[1];

        void CoreObjectNetworkUpdate();
        void ~CoreObjectNetworkUpdate();
    };

    CoreVector m_pos;
    CoreVector m_scale;
    CoreVector m_rot;
    uint32_t m_rotIsQuat;
    CoreHash m_parentBone;
    CoreHash m_localName;
    CoreHash m_type;
    int32_t m_typeIndex;
    CoreObject* m_parent;
    float m_pauseTimer;
    uint32_t m_flags;
    uint32_t m_id;
    bool m_active;
    bool m_inheritParentScale;
    bool m_inheritParentOrient;
    bool m_inited;
    uint32_t m_NetworkUpdateFrequency;
    uint32_t m_NetworkUpdateDelay;
    bool m_network;
    bool m_local;
    CoreObject* m_nextObject;
    CoreAudioObjectData* m_AudioObjectData;
    float m_maxUpdateDistance;
    int32_t m_iStackPtr;

    void CoreObject();
    void ~CoreObject();
    void Construct(CoreMemory*);
    void Destruct(CoreMemory*, CoreObjectUpdateStruct*);
    void Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Reset();
    void Update(CoreObjectUpdateStruct* lpoUpdateStruct);
    CoreHash GetType();
    int32_t GetTypeIndex();
    void SetType(CoreHash i_type, int32_t i_typeIndex);
    void SetPos(CoreVector& i_pos);
    void SetOrient(CoreQuat& i_orient);
    void SetOrientX(float i_x);
    void SetOrientY(float i_y);
    void SetOrientZ(float i_z);
    void SetOrientZYX(float i_x, float i_y, float i_z);
    void SetScale(CoreVector& i_scale);
    void SetWorldPosOrient(CoreVector& i_worldPos, CoreEulerAngle& i_worldOrient);
    void SetWorldOrient(CoreEulerAngle& i_worldOrient);
    bool GetUpdateWithinDistanceFlag();
    void SetUpdateWithinDistanceFlag();
    void SetMaxUpdateDistance();
    float GetMaxUpdateDistance();
    void SetID();
    void SetMovable();
    void SetRenderable();
    void SetShadowCaster();
    void SetShadowReceiver();
    void SetLit();
    void SetActive();
    void SetParent();
    void SetParentBone(CoreHash i_parentBone);
    void SetParentScaleInheritance();
    void SetParentOrientInheritance();
    void SetNetwork();
    void SetLocal();
    void SetInited();
    void SetCanCollideWith();
    void UnParent();
    bool SetAudioObjectAndCreateInstance(CoreHash i_AudioObjectID);
    bool SetAudioObject(CoreHash i_AudioObjectID);
    bool SetMaxDist();
    bool SetMinDist();
    bool SetAttenuation(uint32_t i_Attenuation);
    bool SetProcessingType(CoreHash i_ProcessingType);
    bool SetSourceType();
    bool SetOcclusion();
    bool SetFrequency();
    bool StartEvent(uint32_t i_EventID, bool i_Looping);
    bool StartEventParam(uint32_t i_EventID, bool i_Looping, uint32_t i_Param);
    bool StopEvent(uint32_t i_EventID);
    bool TriggerEvent(uint32_t i_EventID);
    bool UpdateEvent(uint32_t i_EventID);
    bool StopAllEvents();
    bool StartGlobalEvent(uint32_t i_EventID);
    bool StartGlobalEventParam(uint32_t i_EventID, uint32_t i_Param);
    bool StopGlobalEvent(uint32_t i_EventID);
    bool StopAllAudioLoops();
    bool ResumeAllAudioLoops();
    void UpdateAudioObject();
    CoreVector& GetPos();
    CoreEulerAngle GetOrient();
    CoreQuat GetOrientQuat();
    CoreVector GetScale();
    CoreVector GetWorldPos();
    CoreEulerAngle GetWorldOrient();
    CoreQuat GetWorldOrientQuat();
    CoreVector GetWorldScale();
    CoreMatrix MakeLocalToWorldMatrix();
    uint32_t GetID();
    bool IsDead();
    bool SupportAudio();
    uint32_t GetAudioObjectID();
    uint32_t GetAudioObjectInstance();
    bool IsAudioSupported();
    bool IsShadowCaster();
    bool IsShadowReceiver();
    bool IsMovable();
    bool IsRenderable();
    bool IsLit();
    bool IsActive();
    bool IsLocalActive();
    bool HasBeenInited();
    bool CanCollideWith();
    CoreHash GetLocalName();
    void SetLocalName(CoreHash i_localName);
    CoreObject* GetParent();
    CoreHash GetParentBone();
    bool HasParent();
    bool IsNetwork();
    bool IsLocal();
    CoreObject* GetNextObject();
    void SetNextObject();
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, CoreObjectUpdateStruct*);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate*, int32_t& iDataRead, CoreObjectUpdateStruct*);
    uint32_t GetNetworkUpdateFrequency();
    void SetNetworkUpdateFrequency(uint32_t i_FrameCount);
    bool IsNetworkUpdateRequired();
    void ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void* GetMemory(int32_t inSize);
    void ResetMemory();
    CoreAudioObjectData* GetAudioObjectData();
    bool Pause(float i_time, float i_deltaTime);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    CoreScripted::CommandReturn eFnSetPosAndOrient(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnRotate(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetScale(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnInstanceObject(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnInstanceObjectJoint(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnUnParentObject(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnPause(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnWaitForVariable(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnFXEmitter(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnGetObjectName(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn FnSetMaxUpdateDistance(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetAudioObjectAndCreateInstance(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetAudioObject(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMaxDist(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMinDist(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetAttenuation(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetFrequency(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetProcessingType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetSourceType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOcclusion(CoreCommand* io_command);
    CoreScripted::CommandReturn FnStartEvent(CoreCommand* io_command);
    CoreScripted::CommandReturn FnStartEventParam(CoreCommand* io_command);
    CoreScripted::CommandReturn FnStopEvent(CoreCommand* io_command);
    CoreScripted::CommandReturn FnTriggerEvent(CoreCommand* io_command);
    CoreScripted::CommandReturn FnUpdateEvent(CoreCommand* io_command);
    CoreScripted::CommandReturn FnStopAllEvents();
    CoreScripted::CommandReturn FnStartGlobalEvent(CoreCommand* io_command);
    CoreScripted::CommandReturn FnStartGlobalEventParam(CoreCommand* io_command);
    CoreScripted::CommandReturn FnStopGlobalEvent(CoreCommand* io_command);
};

struct FRBackgroundObject : CoreAnimatingObject
{
    CoreS128Aligned m_memoryPot[320];
    FRBackgroundObjectData* m_data;

    void FRBackgroundObject();
    void Construct(CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
    void Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
    void Reset();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void UpdateGameCycle(float i_time);
    void Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
    void Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    bool GetFloorSurfaceType(CoreVector& i_detectPosition, uint32_t& o_surfaceType);
    CoreScripted::CommandReturn eFnFXSpecific();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void InitOnSpline(int32_t i_objectType, CoreCurveSetData* i_curve, CoreHash i_curveName, float i_startPos, float i_speed, float i_waitTime);
    void SetArrowTarget();
    bool GetIsNPC();
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
    void AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
    bool SimpleRoute(float i_x, float i_z, float i_turnSpeed, float i_moveSpeed);
    void DoEffects(CoreObjectUpdateStruct* io_updateStruct);
    void GetNewTargetPos();
    CoreScripted::CommandReturn FnSetDefaultObjectTemplate();
    CoreScripted::CommandReturn FnSetDefaultTextureTemplate();
    CoreScripted::CommandReturn eFnMoveTo(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnTurnTo(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnAnimate(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnSkyBox();
    CoreScripted::CommandReturn eFnFX();
    CoreScripted::CommandReturn eFnSlowSpin();
    CoreScripted::CommandReturn eFnSpinAndFlyOff();
    CoreScripted::CommandReturn eFnArrowControl();
    CoreScripted::CommandReturn eFnSweepControl();
    CoreScripted::CommandReturn eFnSetFadeDistance(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetFadeValue(CoreCommand* io_command);
    CoreScripted::CommandReturn FnUpdateOnSpline(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnUpdateNPC();
    CoreScripted::CommandReturn eFnNPCSetStartPoint(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnNPCAddAnim(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnNPCSetMode(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnNPCSetInteractionDistance(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnNPCSetFacePlayer(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnNPCSetNearMode(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnLogoControl();
    CoreScripted::CommandReturn eFnCutsceneSweepControl();
    bool HandleDistance();
    float npcTurnTo();
    float npcSetAnim();
    void npcDoPath();
    void npcSetState();
    int32_t npcGetNumAnims();
    FRPlayerObject* npcGetNearestPlayer();
    float npcGetDistanceToPlayer();
    float npcGetHeadingToPlayer();
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    void ~FRBackgroundObject();
};

struct TRGameObject : CoreAnimatingObject
{
    enum TRGOGameFlags
    {
        TRGO_JUST_LANDED_SMALL = (1 << 0),
        TRGO_JUST_LANDED_BIG = (1 << 1),
        TRGO_FALLING = (1 << 2),
        TRGO_TURNING_AWAY = (1 << 3),
    };

    CoreS128Aligned m_memoryPot[256];
    TRItem* m_item;
    int32_t m_objectNumber;
    uint32_t m_nodeHash;
    bool m_collidable;
    uint32_t m_initialCodeFlags;
    void* m_data;
    GAME_OBJECT_STATE m_status;
    char m_modelExists;
    char m_textureExists;
    char m_animExists;
    char m_gravityStatus;
    int32_t m_current_anim;
    CoreHash m_currentAnimState;
    CoreHash m_requiredAnimState;
    CoreHash m_goalAnimState;
    CoreHash m_lastAnimState;
    CoreVector m_controlVelocity;
    CoreVector m_externalVelocity;
    CoreVector m_extraControlVelocity;
    CoreVector m_averageMovementVector;
    int32_t m_health;
    int32_t m_hitStatus;
    uint32_t m_touchBits;
    bool m_isGameObjectActive;
    int32_t m_nextActive;
    TRGameObjectAIData m_aiInfo;
    TRObjectNode* m_pObjectNode;
    float m_timer;
    int32_t m_generalVars[4];
    float m_generalFloats[4];
    float m_animScale;
    uint32_t m_gameFlags;
    CoreFXEmitter* m_emitter;
    OffsetBlend m_offsetBlends[6];
    TRObjectInfo* m_objectInfo;
    int32_t m_index;
    int32_t m_AIIndex;
    int32_t m_roomNumber;

    void TRGameObject();
    void Construct(CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
    void Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
    void Reset();
    bool HandleAnimCommandCallback(CoreHash i_slotID, CoreAnimCommand* i_command);
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void UpdateGameCycle(float i_time);
    void Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
    void Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    bool GetFloorSurfaceType(CoreVector& i_detectPosition, uint32_t& o_surfaceType);
    CoreDetectResult* DoDetection(CoreVector i_oldPos, CoreVector i_newPos);
    int32_t TriggerActive();
    int32_t GetIndex();
    void SetIndex();
    void SetAIIndex();
    int32_t GetAIIndex();
    TRCreature* GetAIPtr();
    void InitFromObjectDB();
    CoreScripted::CommandReturn eFnFXSpecific();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    TRItem* GetTRItem();
    void SetRoomNumber(int32_t i_room);
    int32_t GetRoomNumber();
    void ObjectNewRoom();
    void RequestAnim(CoreHash i_animState, int32_t i_flags);
    void NewAnimate(bool i_applyVelocity);
    void NewAnimateMovableBlock(int32_t i_direction);
    bool IsBaddieTargettedByPlayer();
    void GetTarget();
    void BoneControlCallback(CoreGeometryObject* i_object, CoreMatrix* io_currMatrix, CoreMatrix* io_parentMatrix, CoreQuat* io_currJointQuat, void* io_data, CoreModelJoint* i_modelJoint);
    void MoveBlockCallback();
    void ClearOffsetBlends();
    void ClearOffsetOrientBlends();
    void DoOffsetBlending(bool i_complete);
    void SetOffsetBlend(CoreVector i_vector, float i_orient, float i_time, int32_t i_slot, float i_delay);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
    CoreScripted::CommandReturn FnSetDefaultObjectTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultTextureTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultEngineTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultAnimSet(CoreCommand* io_command);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    void ~TRGameObject();
};

struct TRInvObject : CoreAnimatingObject
{
    CoreS128Aligned m_memoryPot[256];
    TRInvObjectData* m_data;

    void TRInvObject();
    void Construct(CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
    void Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
    void Reset();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void UpdateGameCycle(float i_time);
    void Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
    void Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    void SetObjectNumber();
    int32_t GetObjectNumber();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
    void AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
    CoreScripted::CommandReturn FnSetDefaultObjectTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultTextureTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultEngineTemplate();
    CoreScripted::CommandReturn FnSetDefaultAnimSet(CoreCommand* io_command);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    void ~TRInvObject();
};

struct TRMultiMeshObject : CoreAnimatingObject
{
    CoreS128Aligned m_memoryPot[256];
    TRMultiMeshObjectData* m_data;

    void TRMultiMeshObject();
    void Construct(CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
    void Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
    void Reset();
    void SetActiveMesh();
    void SetMeshPosition();
    void SetMeshOrientation();
    void SetFileInfo();
    void SetAsPanelObject();
    bool IsPanelObject();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void UpdateGameCycle(float i_time);
    void Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
    void Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
    void AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
    CoreScripted::CommandReturn FnSetDefaultObjectTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultTextureTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultAnimSet();
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    void ~TRMultiMeshObject();
};

struct CoreStringBuffer<64>
{
    char m_buffer[64];

    void CoreStringBuffer<64>();
    void Clear();
    char* operator const char *();
    char* GetString();
    uint32_t GetLength();
    uint32_t GetMaxLength();
    bool IsSame();
    bool IsSameIgnoreCase();
    void operator=();
    void Copy();
    void NCopy();
    void Cat();
    void ToUpper();
    void ToLower();
    float ToFloat();
    int32_t ToInt();
    int32_t FindChar();
    int32_t ReverseFindChar();
    int32_t VSPrint();
    int32_t SPrint();
    int32_t CatPrint();
};

struct TRSaveGame
{
    int32_t current_level;
    char checksum;
    _player_save_data playerData[2];
    _level_data levelData;
    int32_t m_nBufferOffset;

    void TRSaveGame();
    void ~TRSaveGame();
    void CreateSaveGameData();
    void RetrievePlayerData(int32_t nPlayer, TRInventory* pInventory);
    void ResetVariables();
    void StorePlayerPosition();
    void StorePlayerWeapons(int32_t nPlayer);
    void StorePlayerItems(int32_t nPlayer);
    void ResetLevelMiscData();
    void WriteLevelMiscData();
    void ReadLevelMiscData();
    void CreateChecksum();
    bool isValidChecksum();
    void RetrievePlayerPosition(int32_t nPlayer);
    void RetrievePlayerWeapons(int32_t nPlayer, TRInventory* pInventory);
    void RetrievePlayerItems(int32_t nPlayer, TRInventory* pInventory);
};

struct PlayerDarts
{
    int32_t life;
    char jointNum;
    char pad[1];
    CoreMatrix dartMatrix;
    CoreRGBA frontCol;
    CoreRGBA backCol;

    void PlayerDarts();
};

struct Darts
{
    char life;
    CoreVector frontPos;
    CoreVector backPos;
    CoreRGBA frontCol;
    CoreRGBA backCol;

    void Darts();
};

struct CoreVector : CoreVectorData
{
    void CoreVector();
    float GetX();
    float GetY();
    float GetZ();
    float GetW();
    float Get();
    void SetX();
    void SetY();
    void SetZ();
    void SetW();
    void Set();
    void SetXYZ();
    void SetZero();
    CoreVector operator+=();
    CoreVector operator-=();
    CoreVector operator*=();
    CoreVector operator/=(float i_value);
    CoreVector operator+();
    CoreVector operator-();
    CoreVector operator*();
    CoreVector operator/(float i_value);
    bool IsEqualToXYZ(CoreVector& i_vec, float i_tolerance);
    bool IsEqualToXYZW();
    bool IsZeroXYZ();
    bool IsOneXYZ();
    float SquareMagnitudeXZ();
    float MagnitudeXZ();
    float SquareMagnitudeXYZ();
    float MagnitudeXYZ();
    float InvMagnitudeXYZ();
    float DotProductXYZ();
    float DotProductXYZII();
    float DotProductXYZW();
    void NormalizeXYZ();
    CoreVector GetNormalizeXYZ();
    CoreVector CrossProductXYZ(CoreVector& i_vec);
    void Abs();
    CoreVector GetAbs();
    void Minimize();
    void Maximize(CoreVector& i_vec);
    CoreVector GetMinimize(CoreVector& i_vec);
    CoreVector GetMaximize(CoreVector& i_vec);
    float GetSquaredDistanceToPoint(CoreVector& i_vec);
    float GetDistanceToPoint();
    float CosAngleBetweenVectors(CoreVector& i_vec);
    float GetAngleBetweenVectors();
    float BezierInterpolateDeCasteljau(float i_time);
    void PowXYZ();
    CoreVector Add();
    CoreVector Sub();
    CoreVector Div();
    CoreVector Mul();
    void SetXYZW();
    float SquareMagnitudeXYZW();
    float MagnitudeXYZW();
    float InvMagnitudeXYZW();
    void NormalizeXYZW();
    CoreVector GetNormalizeXYZW();
};

struct CoreEulerAngle : CoreVector
{
    void CoreEulerAngle();
    CoreEulerAngle& operator+=(CoreEulerAngle& i_euler);
    CoreEulerAngle& operator-=(CoreEulerAngle& i_euler);
    CoreEulerAngle& operator*=(float i_scale);
    bool IsEqualTo(CoreEulerAngle& i_euler, float i_tolerance);
    CoreEulerAngle Interpolate(CoreEulerAngle& i_targetAngles, float i_alpha);
    void Clamp();
    CoreVector ToVector();
    void FromVector(CoreVector& i_from);
    void FromVector2(CoreVector& i_from);
    void FromVectorYXZ();
    void FromVectorXYZ();
};

struct CoreHashArray : CoreHashElementTable
{
    CoreHashElement m_elements;

    void CoreHashArray();
    void ~CoreHashArray();
    bool Find(CoreHash i_hash, uint32_t& o_foundData);
    bool Update();
    CoreHashElement* GetElementPtr();
};

struct CoreStringBuffer<256>
{
    char m_buffer[256];

    void CoreStringBuffer<256>(char* i_format);
    void Clear();
    char* operator const char *();
    char* GetString();
    uint32_t GetLength();
    uint32_t GetMaxLength();
    bool IsSame();
    bool IsSameIgnoreCase();
    void operator=();
    void Copy();
    void NCopy();
    void Cat();
    void ToUpper();
    void ToLower();
    float ToFloat();
    int32_t ToInt();
    int32_t FindChar();
    int32_t ReverseFindChar();
    int32_t VSPrint();
    int32_t SPrint(char* i_format);
    int32_t CatPrint();
};

struct TRMultiMeshObjectData
{
    bool bIsPanelObject;
    CoreStringBuffer<64> strPath;
    CoreStringBuffer<64> strFileName;
    bool bUpdateMesh;
    bool bUpdatePosOrient;
    CoreHash hashActive;
    CoreEulerAngle orient;
    CoreVector vPos;

    void TRMultiMeshObjectData();
    void ~TRMultiMeshObjectData();
};

enum
{
    OBLEND1 = 0,
    OBLEND2 = 1,
    OBLEND3 = 2,
    OBLEND4 = 3,
    CLIMB_BLEND = 3,
    SHIMMY_YBLEND = 4,
    SHIMMY_CHANGEBLEND = 5,
    NUM_OFFSET_BLENDS = 6,
};

enum object_types
{
    LARA,
    PISTOLS,
    SHOTGUN,
    MAGNUM,
    UZI,
    LARA_EXTRA,
    EVIL_LARA,
    WOLF,
    BEAR,
    BAT,
    CROCODILE,
    ALLIGATOR,
    LION,
    LIONESS,
    PUMA,
    APE,
    RAT,
    VOLE,
    DINOSAUR,
    RAPTOR,
    WARRIOR1,
    WARRIOR2,
    WARRIOR3,
    CENTAUR,
    MUMMY,
    DINO_WARRIOR,
    FISH,
    LARSON,
    PIERRE,
    SKATEBOARD,
    MERCENARY1,
    MERCENARY2,
    MERCENARY3,
    NATLA,
    EVIL_NATLA,
    FALLING_BLOCK,
    PENDULUM,
    SPIKES,
    ROLLING_BALL,
    DARTS,
    DART_EMITTER,
    DRAW_BRIDGE,
    TEETH_TRAP,
    DAMOCLES_SWORD,
    THORS_HANDLE,
    THORS_HEAD,
    LIGHTNING_EMITTER,
    MOVING_BAR,
    MOVABLE_BLOCK,
    MOVABLE_BLOCK2,
    MOVABLE_BLOCK3,
    MOVABLE_BLOCK4,
    ROLLING_BLOCK,
    FALLING_CEILING1,
    FALLING_CEILING2,
    SWITCH_TYPE1,
    SWITCH_TYPE2,
    DOOR_TYPE1,
    DOOR_TYPE2,
    DOOR_TYPE3,
    DOOR_TYPE4,
    DOOR_TYPE5,
    DOOR_TYPE6,
    DOOR_TYPE7,
    DOOR_TYPE8,
    TRAPDOOR,
    TRAPDOOR2,
    BIGTRAPDOOR,
    BRIDGE_FLAT,
    BRIDGE_TILT1,
    BRIDGE_TILT2,
    PASSPORT_OPTION,
    MAP_OPTION,
    PHOTO_OPTION,
    COG_1,
    COG_2,
    COG_3,
    PLAYER_1,
    PLAYER_2,
    PLAYER_3,
    PLAYER4,
    PASSPORT_CLOSED,
    MAP_CLOSED,
    BLUESAVE_ITEM,
    GUN_ITEM,
    SHOTGUN_ITEM,
    MAGNUM_ITEM,
    UZI_ITEM,
    GUN_AMMO_ITEM,
    SG_AMMO_ITEM,
    MAG_AMMO_ITEM,
    UZI_AMMO_ITEM,
    EXPLOSIVE_ITEM,
    MEDI_ITEM,
    BIGMEDI_ITEM,
    DETAIL_OPTION,
    SOUND_OPTION,
    CONTROL_OPTION,
    GAMMA_OPTION,
    GUN_OPTION,
    SHOTGUN_OPTION,
    MAGNUM_OPTION,
    UZI_OPTION,
    GUN_AMMO_OPTION,
    SG_AMMO_OPTION,
    MAG_AMMO_OPTION,
    UZI_AMMO_OPTION,
    EXPLOSIVE_OPTION,
    MEDI_OPTION,
    BIGMEDI_OPTION,
    PUZZLE_ITEM1,
    PUZZLE_ITEM2,
    PUZZLE_ITEM3,
    PUZZLE_ITEM4,
    PUZZLE_OPTION1,
    PUZZLE_OPTION2,
    PUZZLE_OPTION3,
    PUZZLE_OPTION4,
    PUZZLE_HOLE1,
    PUZZLE_HOLE2,
    PUZZLE_HOLE3,
    PUZZLE_HOLE4,
    PUZZLE_DONE1,
    PUZZLE_DONE2,
    PUZZLE_DONE3,
    PUZZLE_DONE4,
    LEADBAR_ITEM,
    LEADBAR_OPTION,
    MIDAS_TOUCH,
    KEY_ITEM1,
    KEY_ITEM2,
    KEY_ITEM3,
    KEY_ITEM4,
    KEY_OPTION1,
    KEY_OPTION2,
    KEY_OPTION3,
    KEY_OPTION4,
    KEY_HOLE1,
    KEY_HOLE2,
    KEY_HOLE3,
    KEY_HOLE4,
    PICKUP_ITEM1,
    PICKUP_ITEM2,
    SCION_ITEM,
    SCION_ITEM2,
    SCION_ITEM3,
    SCION_ITEM4,
    SCION_HOLDER,
    PICKUP_OPTION1,
    PICKUP_OPTION2,
    SCION_OPTION,
    EXPLOSION1,
    EXPLOSION2,
    SPLASH1,
    SPLASH2,
    BUBBLES1,
    BUBBLES2,
    BUBBLE_EMITTER,
    BLOOD1,
    BLOOD2,
    DART_EFFECT,
    STATUE,
    PORTACABIN,
    PODS,
    RICOCHET1,
    TWINKLE,
    GUN_FLASH,
    DUST,
    BODY_PART,
    CAMERA_TARGET,
    WATERFALL,
    MISSILE1,
    MISSILE2,
    MISSILE3,
    MISSILE4,
    MISSILE5,
    OLD_LAVA,
    LAVA_EMITTER,
    FLAME,
    FLAME_EMITTER,
    LAVA_WEDGE,
    BIG_POD,
    BOAT,
    EARTHQUAKE,
    TEMP5,
    TEMP6,
    TEMP7,
    TEMP8,
    TEMP9,
    TEMP10,
    ALPHABET,
    SPIDER,
    SPECIAL_OBJECT1,
    SPECIAL_OBJECT2,
    SPECIAL_OBJECT3,
    SPECIAL_OBJECT4,
    SKULL_FLAME_EMITTER,
    HINT_ITEM1,
    SPIKE_TRAP,
    HINT_ITEM2,
    REDSAVE_ITEM,
    GREENCRYSTAL_CODEUSE,
    GREENCRYSTAL_PICKUP,
    FLARE_ITEM,
    SPECIAL_OBJECT5,
    SPECIAL_OBJECT6,
    SPECIAL_OBJECT7,
    SPECIAL_OBJECT8,
    NUMBER_OBJECTS,
};

enum EFFECT
{
    EFFECT_TURN180_EFFECT,
    EFFECT_DINO_STOMP_EFFECT,
    EFFECT_LARA_NORMAL_EFFECT,
    EFFECT_LARABUBBLES,
    EFFECT_FINISH_LEVEL_EFFECT,
    EFFECT_EARTHQUAKEFX,
    EFFECT_FLOODFX,
    EFFECT_RAISINGBLOCKFX,
    EFFECT_STAIRS2SLOPEFX,
    EFFECT_SANDFX,
    EFFECT_POWERUPFX,
    EFFECT_EXPLOSIONFX,
    EFFECT_LARA_HANDS_FREE,
    EFFECT_FLIP_MAP_EFFECT,
    EFFECT_DRAW_RIGHT_GUN,
    EFFECT_CHAINBLOCKFX,
    EFFECT_FLICKERFX,
};

struct TREffects
{
    enum TREffectsFlags
    {
        RANDOM_CAMERA_SHAKE = 1,
        CAMERA_SHAKE_ON_TIMER,
    };

    uint32_t m_flags;
    float m_cameraBounce;
    float m_cameraBounceTimer;

    void DoEffect(int32_t i_effectNum, TRGameObject* i_object);
    void DinoStompEffect(TRGameObject* i_object, float i_maxCameraShakeDistance, float i_maxBounce);
};

enum CHEATS
{
    CHEAT_FLYCAM,
    CHEAT_SOAKTEST,
    CHEAT_PUZZLE_ITEMS,
    CHEAT_LEVEL_COMPLETE,
    NUM_CHEATS,
};

enum CAMMODE
{
    CAMMODE_SNAP,
    CAMMODE_CONSTANT,
    CAMMODE_ACCEL_DECEL,
    CAMMODE_ACCEL_ONLY,
    CAMMODE_DECEL_ONLY,
};

struct CoreGeometryObject : CoreRenderableObject
{
    CoreGeometryObjectData* m_lpoData;

    void CoreGeometryObject();
    void ~CoreGeometryObject();
    void Construct(CoreMemory* lpoMemory);
    void Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Reset();
    void AddToRenderList(CoreGameRender* lpoGraphics);
    void Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    void RenderShadow(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    bool SetSingleDetectorSphere();
    bool SetDetectorSphere(int32_t i_index, CoreVector i_origin, float i_radius, CoreHash i_exclusiveSubtype);
    void SetNumDetectorSpheres(int32_t i_numSpheres);
    CoreDetectorSpheres* GetDetectorSpheres();
    CoreCollidables* GetCollidables();
    CoreRagdollCollidables* GetRagdollCollidables();
    CoreDetectionMesh* GetDetectionMesh();
    CoreDetectionData* GetDetectionData();
    CoreFileSystem::CoreFileLoadReturn AttachModelCompiledFile(CoreObjectUpdateStruct* i_updateStruct, char* i_modelCompiledName);
    CoreFileSystem::CoreFileLoadReturn AttachModelCompiledShadowFile();
    CoreFileSystem::CoreFileLoadReturn AttachModelCompiledEngineFile(CoreObjectUpdateStruct* i_updateStruct, char* i_modelCompiledEngineName);
    CoreFileSystem::CoreFileLoadReturn AttachTextureSetFile(CoreObjectUpdateStruct* i_updateStruct, char* i_textureSetName, uint32_t i_index);
    CoreVector GetVOrigin();
    void SetExtraDrawFlags(uint32_t i_drawFlags);
    uint32_t GetExtraDrawFlags();
    void SetLightOffsetPoint(CoreVector& vOffsetPoint);
    void SetUseCharacterLights(bool i_enable);
    CoreVector GetLightOffsetPoint();
    void ResetLights();
    void ResetAmbientLight();
    void ResetIncandescentLight();
    void ResetDirectionalLights();
    void ResetDirectionalLight();
    void SetFadeValue(float i_value);
    void SetAmbientLight(CoreVector& vAmbientColour);
    CoreVector SetIncandescentLight();
    void SetDirectionalLight(int32_t iIndex, CoreVector& vDirection, CoreVector& vColour, CoreVector& vPosition, float fSpecularIntensity);
    CoreVector GetAmbientLight();
    CoreVector GetDirectionalLightDirection();
    CoreVector GetDirectionalLightColour();
    CoreVector GetDirectionalLightPosition();
    float GetDirectionalLightSpecularIntensity();
    bool HasValidSkeleton();
    bool UpdateState(float fTime);
    void SetStateChanged();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreVector GetObjectPelvisUpVector();
    CoreVector GetObjectPelvisForwardVector();
    bool DoesBoneExist(CoreHash oBoneHash);
    CoreMatrix mtGetBone2ObjectMatrix();
    CoreEulerAngle GetBoneObjectOrientation();
    CoreVector GetBoneObjectPosition();
    CoreVector GetBoneObjectScale();
    CoreEulerAngle GetBoneLocalOrientation();
    CoreMatrix mtGetBone2WorldMatrix(uint32_t uiBoneHash);
    bool IsBoneVisible();
    CoreMatrix mtGetLocal2WorldMatrix();
    CorePhysicsArticulate* GetPhysicsArticulate();
    char* GetPhysicsMaterial();
    bool HasPhysics();
    bool AddPhysicsImpulse();
    bool PhysicsBlast();
    bool ActivatePhysics(CoreVector& velocity);
    bool IsPhysicsActive();
    bool DeactivatePhysics();
    void ClearPhysicsAcc();
    void AddPhysicsAcc();
    bool SetPhysicsBlendScaleMode(float blendScale, int32_t blendMode);
    bool SetPhysicsAnimVelocityScale(float animVelScale);
    float GetPhysicsBlendScale();
    float GetPhysicsBlendMode();
    bool HasRemotePhysicsState();
    CoreModelSkeleton* GetModelSkeletonPtr();
    bool SetBoneControlCallback(CoreHash i_boneHash, void* i_callbackFunction, void* i_data);
    void GetSkeletonWorldMatrices();
    void GetSkeletonWorldPositions(CoreVector* o_bonePos);
    CoreMatrix& GetObjectMatrixByIndex();
    void SetObjectMatrixByIndex();
    CoreScripted::CommandReturn eFnSetPhysicsRagdoll(CoreCommand* lpoCommand);
    CoreModelCompiled* GetModelCompiledPtr();
    CoreModelGeometry* GetModelGeometryPtr();
    void CreateSkeletonOverrideValues();
    void UpdateJointsState();
    void UpdateBlendShapeTargetAlphaValues();
    void UpdateMarkersState();
    int32_t iComputeSkeletonBlendShapeTargetByHash();
    int32_t iComputeSkeletonBlendShapeTargetByIndex();
    int32_t GetJointIndex(CoreHash oJointHash);
    void AssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType, void* lpUsrData1, void* lpUsrData2);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
    void AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
    void AttachTextureSet(CoreTextureSet* i_textureSet, uint32_t i_textureSetFile, uint32_t i_index);
    void ComputeTextureOffsets();
    void RemoveGeometryFiles();
    void SetHasPhysics();
    void RecordLocalPhysicsState(CoreObject::CoreObjectNetworkUpdate* io_Data);
    void CalculateDeltaPhysicsState(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& io_DataRead, float* o_boneDelta, float i_blend);
    void ApplyDeltaPhysicsState(float* i_boneDelta);
    void ApplyRemotePhysicsState();
    bool PhysicsPreUpdate(CoreMatrix* lpoMatrixList, CoreMatrix& mtObject2World);
    bool PhysicsUpdateState(CoreMatrix* lpoMatrixList, CoreMatrix& mtObject2World, CoreVector& vNewPos, CoreEulerAngle& eaNewOrient, CoreVector& vScale);
    bool PhysicsPostUpdate(CoreMatrix* lpoMatrixList, CoreMatrix& mtObject2World);
    void PhysicsUpdateModelSkeletonPtr(CoreModelSkeleton* lpoModelSkeleton);
    CoreModelInfo* GetModelInfo();
    bool GetNumBlindData();
    bool GetBlindData();
    bool GetBlindDataByIndex(CoreHash i_dataType, uint32_t i_index, void*& o_dataPtr);
    bool GetBlindDataByName();
    CoreScripted::CommandReturn eFnSetObjectTemplate(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn fnSetShadowTemplate(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn fnSetEngineTemplate(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetTextureTemplate(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn fnOverrideBaseTexture(CoreCommand* i_command);
    CoreScripted::CommandReturn eFnSetPhysicsControl(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetCutSceneObjectTemplate(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetCutSceneTextureTemplate(CoreCommand* lpoCommand);
    void ComputeAnimationMatrices(CoreMatrix* io_matrixList);
    void DebugRender(uint32_t ulDrawFlags, CoreGraphicsDevice* lpoDevice);
    void MakeLocal2WorldMatrix();
    void UpdateJointMatrices();
    void FakeUpdateJointMatrices();
    void UpdateMarkerMatrices();
    void RenderModelCompiled(float, uint32_t ulDrawFlags, CoreGraphicsDevice* lpoDevice, uint32_t uiMeshFlags, CoreModelCompiled* i_modelCompiled);
    void RenderNoModel(CoreGraphicsDevice* lpoDevice);
    int32_t iComputePhysicsType();
};

struct CoreAnimCommand
{
    enum
    {
        VERSION = 3,
    };

    enum ACType
    {
        AC_TIMER_START,
        AC_TIMER_STOP,
        AC_EVENT,
        AC_END_OF_ANIM,
        AC_AUDIO,
        AC_FX,
        AC_FLAG,
        AC_AUTOBLEND,
        AC_LAST_COMMAND,
    };

    float m_time;
    uint32_t m_type;
    uint32_t m_conditionIndex;
    uint32_t m_commandData;

    void CoreAnimCommand();
    void ~CoreAnimCommand();
    float GetTime();
    uint32_t GetType();
    uint32_t GetConditionIndex();
    bool IsInTimeRange();
    CoreAnimCommandTimerStart* GetAnimCommandTimerStart();
    CoreAnimCommandTimerStop* GetAnimCommandTimerStop();
    CoreAnimCommandEvent* GetAnimCommandEvent();
    CoreAnimCommandEndOfAnim* GetAnimCommandEndOfAnim();
    CoreAnimCommandAudio* GetAnimCommandAudio();
    CoreAnimCommandFX* GetAnimCommandFX();
    CoreAnimCommandFlag* GetAnimCommandFlag();
    CoreAnimCommandAutoBlend* GetAnimCommandAutoBlend();
};

struct CoreModelJoint
{
    enum
    {
        VERSION = 9,
    };

    uint32_t m_uiHash;
    uint32_t m_uiParentHash;
    int32_t m_sParentIndex;
    bool m_bParentedMesh;
    bool m_visible;
    float m_fJointOrientX;
    float m_fJointOrientY;
    float m_fJointOrientZ;
    float m_fJointOrientW;
    float m_fRotationAxisX;
    float m_fRotationAxisY;
    float m_fRotationAxisZ;
    float m_fRotationAxisW;
    float m_fTranslationX;
    float m_fTranslationY;
    float m_fTranslationZ;
    float m_fTranslationW;
    float m_fRotationX;
    float m_fRotationY;
    float m_fRotationZ;
    float m_fRotationW;
    float m_fScaleX;
    float m_fScaleY;
    float m_fScaleZ;
    float m_fScaleW;
    float m_rotationMinXLimit;
    float m_rotationMinYLimit;
    float m_rotationMinZLimit;
    float m_rotationMaxXLimit;
    float m_rotationMaxYLimit;
    float m_rotationMaxZLimit;
    uint32_t m_flags;
    float m_fBBoxMinX;
    float m_fBBoxMinY;
    float m_fBBoxMinZ;
    float m_fBBoxMinW;
    float m_fBBoxMaxX;
    float m_fBBoxMaxY;
    float m_fBBoxMaxZ;
    float m_fBBoxMaxW;

    void CoreModelJoint();
    void ~CoreModelJoint();
    uint32_t GetHash();
    uint32_t GetParentHash();
    int32_t GetParentIndex();
    CoreQuat GetJointOrient();
    CoreQuat GetRotationAxis();
    CoreVector GetTranslation();
    CoreQuat GetRotation();
    CoreVector GetScale();
    CoreVector GetBBoxMin();
    CoreVector GetBBoxMax();
    CoreVector GetBBoxPos();
    CoreVector GetBBoxScale();
    CoreVector GetRotationMinLimit();
    CoreVector GetRotationMaxLimit();
    bool IsRotationMinXLimitEnabled();
    bool IsRotationMinYLimitEnabled();
    bool IsRotationMinZLimitEnabled();
    bool IsRotationMaxXLimitEnabled();
    bool IsRotationMaxYLimitEnabled();
    bool IsRotationMaxZLimitEnabled();
    bool IsPureAnimation();
    bool IsPurePhysics();
    bool IsSwitchable();
    bool IgnoreAnimations();
    bool IsParentedMesh();
    bool IsVisible();
    void DrawParentToChildLine(CoreMatrix* lpoMatrixList, CoreMatrix* lpoJointMatrix, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
    void DrawJointBBox(CoreMatrix* lpoJointMatrix, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
    void DrawAxes(CoreMatrix* lpoJointMatrix, CoreMatrix& mtLocal2World, CoreGraphicsDevice* lpoDevice);
};

enum GAME_OBJECT_STATE
{
    GOS_NOT_ACTIVE,
    GOS_ACTIVE,
    GOS_DEACTIVATED,
    GOS_INVISIBLE,
};

struct FRWorld : CoreWorld
{
    struct TRPlayerDataEvent
    {
        uint32_t m_Type;
        uint32_t m_PlayerID;
        uint32_t m_EventID;
        int32_t m_nCharacter;
    };

    uint32_t m_nCurrentProfile;
    CoreHash m_messageText;
    int32_t m_noPanel;
    int32_t m_startRoom;
    REC_MODE m_recMode;
    REC_ENTRY* m_recBuffer;
    int32_t m_recNum;
    int32_t m_showGameComplete;
    int32_t m_showTrainingComplete;
    bool m_startTwoPlayerGame;
    bool m_noDamage;
    bool m_bLogo3DVisible;
    int32_t m_nLogo3DState;
    float m_fLogoPosDiffY;
    float m_fLogoMoveDir;
    int32_t m_numPlayers;
    bool m_bDontAllowPause;
    float m_loadTimer;
    float m_tipTimer;
    int32_t m_currentLoadingScreenID;
    int32_t m_currentTip;
    int32_t m_selectedZone;
    int32_t m_selectedLocation;
    int32_t m_selectedMission;
    int32_t m_InvOptionSelected;
    int32_t m_nGameType;
    bool m_platformPSP;
    bool m_platformPS2;
    bool m_isWideScreen;
    bool m_isDemo;
    bool m_ClientModelInfoSwapped;
    static uint32_t PLAYER_INVENTORY_EVENT_ID;
    static uint32_t PLAYER_DATA_EVENT;
    static uint32_t PLAYER_DATA_EVENT_ID;
    static uint32_t FRLEVEL_OBJECT_EVENT_ID;
    static uint32_t FRLEVEL_FLIP_EVENT_ID;

    void FRWorld();
    void Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams);
    void Init(CoreWorldUpdateStruct* lpoWorldUpdateStruct);
    void SetWorldPaused();
    void SetPaused(bool i_paused, bool bPauseAudio);
    bool CanPause();
    void ForcePaused(bool i_paused, bool bPauseAudio, bool i_dontLoadMenu, bool i_moveCamera);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreHash GetMessageText();
    void SetMessageText();
    void SetPlayerStartPos(int32_t i_index, float i_x, float i_y, float i_z, float i_rot);
    void ResetClientModelInfo();
    void RenderLoadingIcon(CoreGameRender* i_graphics, CoreTextureSet* i_textureSet, int32_t i_flags, float i_x0, float i_y0, CoreRGBA i_col, float i_scale);
    void RenderLoadingScreenElement();
    void UnpauseForMenu();
    void Update(CoreWorldUpdateStruct* lpoWorldUpdateStruct, float fTimeElapsed);
    void StartRecordPlayback();
    void UpdateRecordPlayback();
    uint32_t GetCurrentProfile();
    void SetCurrentProfile();
    void* LoadAIData();
    bool IsWideScreen();
    void SetDefaultCharacterClothing();
    void SetLoadingScreen(CoreHash i_loadingScreen);
    void RememberLevelName(char* i_level, char* i_area);
    CorePanel* CreatePanel(CoreMemory* io_memory);
    void RenderLoadingScreen(CoreGameRender* i_graphics, CoreTextureSet** i_textureSet);
    float GetNumDetectCaches();
    CoreLevel* CreateLevel(CoreMemory* io_memory);
    CoreAIController* CreateAIController(CoreMemory* io_memory);
    CoreScripted::CommandReturn FnMenuWaitForMemCard();
    CoreScripted::CommandReturn eFnLoadCharacter();
    CoreScripted::CommandReturn FnSetPaused(CoreCommand* io_command);
    CoreScripted::CommandReturn FnHandleCutScene();
    CoreScripted::CommandReturn FnLoadGameStartup();
    void ~FRWorld();
};

struct CoreTextureSet
{
    enum
    {
        VERSION = 9,
    };

    static uint32_t s_textureSetID;
    uint32_t m_version;
    uint32_t m_fileID;
    int32_t m_texturePageTableOffset;
    int32_t m_texturePageDataOffset;
    int32_t m_textureInfoTableOffset;
    int32_t m_textureInfoDataOffset;
    int32_t m_textureAnimationInfoTableOffset;
    int32_t m_textureAnimationInfoDataOffset;

    uint32_t GetVersion();
    bool CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
    void CoreTextureSet();
    void ~CoreTextureSet();
    uint32_t GetNumberOfTexturePages();
    CoreHash GetTexturePageHashByIndex();
    CoreTexturePage* GetTexturePageByHash();
    CoreTexturePage* GetTexturePageByIndex();
    CoreTexturePage* GetTexturePageByOffset();
    uint32_t GetNumberOfTextureInfos();
    CoreHash GetTextureInfoHashByIndex(uint32_t i_index);
    CoreTextureInfo* GetTextureInfoByHash(CoreHash i_hash);
    CoreTextureInfo* GetTextureInfoByIndex();
    uint32_t GetNumberOfAnimationInfos();
    CoreHash GetAnimationInfoHashByIndex();
    CoreTextureAnimationInfo* GetAnimationInfoByHash();
    CoreTextureAnimationInfo* GetAnimationInfoByIndex();
    bool CheckVersion();
    bool CheckID();
    uint32_t GetPlatformVersion();
    uint32_t GetID();
    CoreHashArray* GetTexturePageTable();
    char* GetTexturePageData();
    CoreHashArray* GetTextureInfoTable();
    CoreTextureInfo* GetTextureInfoData();
    CoreHashArray* GetAnimationInfoTable();
    CoreTextureAnimationInfo* GetAnimationInfoData();
};

struct CoreRGBA
{
    uint32_t m_storage;

    void CoreRGBA();
    uint32_t GetColour();
    void SetUI32();
    void SetRGBA(uint32_t i_red, uint32_t i_green, uint32_t i_blue, uint32_t i_alpha);
    void SetRed();
    void SetGreen();
    void SetBlue();
    void SetAlpha();
    uint32_t GetRed8();
    uint32_t GetGreen8();
    uint32_t GetBlue8();
    uint32_t GetAlpha8();
    float GetRed();
    float GetGreen();
    float GetBlue();
    float GetAlpha();
    void ToHSV();
    void FromHSV();
    void ToYCbCr();
    void FromYCbCr();
    void Average();
    CoreVector ToVector();
    void FromVector(CoreVector i_value);
    void ScaleAlpha(float i_scale);
    uint32_t GetRGBA();
};

enum REC_MODE
{
    REC_NONE,
    REC_START_RECORD,
    REC_START_PLAY,
    REC_START_PLAY_TGA,
    REC_RECORDING,
    REC_PLAYING,
};

struct REC_ENTRY
{
    float joyX;
    float joyY;
    uint32_t joyButts;
};

struct TRProfile
{
    int32_t m_flags;
    char m_profileName[49];
    _player_save_data m_sPlayer1;
    _player_save_data m_sPlayer2;
    _level_data m_sLevelData;
    float m_sfxVolume;
    float m_musicVolume;

    void TRProfile();
    void Clear();
    void SetSFXVolume();
    void SetMusicVolume();
    float GetSFXVolume();
    float GetMusicVolume();
    void ApplyOptions();
};

struct TRMenuSystem : CoreMenuSystem
{
    int32_t m_displayObjectNamesFlag;
    int32_t m_drawAllRoomsFlag;
    int32_t m_dampedCameraOn;
    int32_t m_menuFlipStatus;
    bool m_rumbleOn;
    bool m_invertXOn;
    bool m_invertYOn;
    bool m_followCamOn;
    bool m_splitscreenH;
    bool m_analogueOn;
    bool m_allowSave;
    bool m_bSaveCompleted;
    char m_nWantToSaveStatus;
    uint32_t m_checksum1;
    uint32_t m_checksum2;
    uint32_t m_lastChecksum1;
    uint32_t m_lastChecksum2;
    TRProfile m_profiles[5];
    uint32_t m_saveGameBuffer[27711];
    float m_defaultW;
    float m_defaultH;
    int32_t m_defaultAnchorX;
    int32_t m_defaultAnchorY;
    CoreHash m_defaultFont;
    int32_t m_defaultCentreScale;
    float m_defaultVisibility;
    int32_t m_defaultSelectable;
    int32_t m_defaultRequiresCallbacks;
    float m_defaultR;
    float m_defaultG;
    float m_defaultB;
    float m_defaultA;
    float m_inactiveTimer;
    bool m_cutsceneSetup;

    void TRMenuSystem();
    void Construct(CoreMemory* io_memory);
    void Update(CoreObjectUpdateStruct* io_updateStruct);
    void Render(CoreGameRender* io_graphics);
    void RenderComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
    void InitProfiles();
    void UpdateAutoSave();
    bool IsAutoSaveCurrent();
    bool HasAutoSaveBeenUpdated();
    void ActivateSaveCrystal();
    void SetRumbleOn();
    bool IsRumbleOn();
    void SetInvertXOn();
    bool IsInvertXOn();
    void SetInvertYOn();
    bool IsInvertYOn();
    void SetSplitscreenH();
    bool IsSplitscreenH();
    void SetAnalogueOn();
    bool IsAnalogueOn();
    void SetDampedCameraOn(bool i_onOff);
    bool IsDampedCameraOn();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    int32_t SetupSaveGameData();
    bool RestoreSaveGameData();
    void TransferToProfileSlot();
    uint32_t* GetSaveGameBuffer();
    int32_t GetSaveGameBufferSize();
    int32_t GetSaveDataLength();
    void RenderLevelName();
    void RenderLevelStats(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
    void RenderLeftRightJustifiedThing(CoreMenuComponent* i_component, CoreGameRender* io_graphics, float i_x, float i_y, char* str1, char* str2);
    void InitSKU();
    void ConstructSKU(CoreMemory* io_memory);
    void UpdateSKU();
    bool LoadGameStartup();
    bool LoadGame();
    bool AutoSaveGame();
    bool SaveGame();
    bool EnoughMemoryForMoviePlayer();
    void TransferProfileSlotToGame(int32_t nSlot);
    CoreScripted::CommandReturn FnMenuSetDefaultWH(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetDefaultAnchor(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetDefaultFont(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetDefaultCentreScale(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetDefaultVisibility(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetDefaultSelectable(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetDefaultRequireCallbacks(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetDefaultRGBA(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuAddDefaultComponent(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetViewerDirectFlag(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSendPlayerDetails(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn FnCanSwapInventory(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMessageBoxNoYes(CoreCommand* io_command);
    CoreScripted::CommandReturn FnTitleRingOn(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSaveGame();
    CoreScripted::CommandReturn FnLoadGameStartup(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuWaitForMemCard(CoreCommand* io_command);
    CoreScripted::CommandReturn FnStartSavedGame(CoreCommand* io_command);
    CoreScripted::CommandReturn FnAutosaveGame();
    CoreScripted::CommandReturn FnPlayMovie();
    CoreScripted::CommandReturn FnGetCheatStatus(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn FnToggleCheatStatus(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn FnIsSaveSlotAvailable(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn FnIsDampedCameraOn(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDampedCameraOn(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSaveCompleted();
    CoreScripted::CommandReturn FnWantToSave(CoreCommand* io_command);
    CoreScripted::CommandReturn FnLoadFrontendTextureSet(CoreCommand* io_command);
    void ~TRMenuSystem();
};

struct FRGameController : CoreGameController
{
    void FRGameController();
    int32_t GetVersion();
    char* GetBuildTime();
    CoreWorld* CreateWorld(CoreMemory* io_memory);
    void Init(CoreNet::DeviceInitialisationData* io_CoreNetInit);
    void OneCycle();
    void UpdateInput(float i_deltaTime);
    void ~FRGameController();
};

struct FRLevel : CoreLevel
{
    enum
    {
        MODEL_SHIFTER = 0,
        ENGINE_SHIFTER = 2,
        TEXTURE_SHIFTER = 4,
        ANIM_SHIFTER = 6,
    };

    CoreVector m_playerStartPos[2];
    int32_t m_levelComplete;
    int32_t m_levelNumber;
    int32_t m_pierreItem;
    int32_t m_flippedRoomLUT1[512];
    int32_t m_flippedRoomLUT2[512];
    int32_t levelItems;
    TRItem items[256];
    uint32_t m_fileExists[208];
    bool m_oldRoomsLoaded;
    bool m_gameObjectsInvisible;
    char m_restoreGameId;
    LEVEL_STATE m_levelState;
    int32_t m_restartFlag;
    int32_t m_preloadState;
    int32_t m_timerPaused;
    int32_t m_cheatCounter[4];
    CoreInputContext m_cheatContext;
    CoreInputMapping m_cheatMapping;
    int32_t m_nCutSceneMode;
    int32_t m_nCutSceneToPlay;
    bool m_bCutSceneSkipFlag;
    TRFoliageObject* m_pFoliage[64];

    void FRLevel();
    void Construct(CoreMemory* io_memory);
    void Init(CoreLevelUpdateStruct* io_LevelUpdateStruct);
    void Reset(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    bool InitLoad(CoreHash oLevelHash, char* lpcLevelName, char* lpcAreaName, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void Update(CoreLevelUpdateStruct* pUpdate);
    void Render(uint32_t ulDrawFlags);
    void PostRender();
    void LevelSpecialRender();
    void SetTimerPaused();
    void ActivatePlayers(bool i_activate);
    bool CanPause();
    void UpdateCheats(CoreLevelUpdateStruct* pUpdate);
    void LoadItemsFile();
    void InitFREffects();
    void UpdateFREffects();
    CoreScripted::CommandReturn eFnFXSpecific();
    bool WaitForDeadObjects();
    CoreScripted::CommandReturn FnSendRestartLevelEvent(CoreCommand* io_command);
    void UnLoad(CoreHash oNewLevelToLoad, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void UnloadGameData();
    void RestartLevel();
    void SetLevelState();
    LEVEL_STATE GetLevelState();
    void ItemNewRoom(TRGameObject* i_object, int32_t room_number);
    int32_t InitialiseLevel();
    void InitialiseGameFlags();
    void InitialiseLevelFlags();
    void LoadObjectDatabase(CoreStringBuffer<256> i_fileName, bool i_reset);
    void InitFlipRooms();
    void FlipMap();
    void SetupRoomFlags();
    void ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
    bool SendRemoveObjectItemToNetworkPlayer();
    void SendForceFlipStateToNetworkPlayer();
    TRItem* GetItemPtr();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreObjectController* CreateObjectController(CoreMemory* io_memory);
    CoreMenuSystem* CreateMenuSystem(CoreMemory* io_memory);
    CoreScripted::CommandReturn FnLoadAIPaths();
    CoreScripted::CommandReturn FnLoadNPCAIPaths();
    CoreScripted::CommandReturn FnInstanceObject();
    CoreScripted::CommandReturn FnResetFX(CoreCommand* io_command);
    CoreScripted::CommandReturn FnResetMiscLevelStuff();
    CoreScripted::CommandReturn FnInstanceObjectOnSpline(CoreCommand* io_command);
    CoreScripted::CommandReturn FnLoadObjectDatabase(CoreCommand* io_command);
    CoreScripted::CommandReturn FnPreLoadAllObjects(CoreCommand* io_command);
    CoreScripted::CommandReturn FnLoadItems(CoreCommand* io_command);
    CoreScripted::CommandReturn FnLoadOldRoomData();
    CoreScripted::CommandReturn FnLoadOldAnimData();
    CoreScripted::CommandReturn FnLoadOldBoxData();
    CoreScripted::CommandReturn FnLoadOldCameras();
    CoreScripted::CommandReturn FnSetObjectPos(CoreCommand* io_command);
    CoreScripted::CommandReturn FnWaitForAllObjects(CoreCommand* io_command);
    CoreScripted::CommandReturn FnObjectExists(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetObjectAlwaysVisible(CoreCommand* io_command);
    CoreScripted::CommandReturn FnResetPlayerToStart(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetViewerTarget(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetFogValues(CoreCommand* io_command);
    CoreScripted::CommandReturn FnAddCameraTarget();
    CoreScripted::CommandReturn FnSetCameraRail();
    CoreScripted::CommandReturn FnResetTriggerBoxes(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetTriggerBoxPos(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetTriggerBoxType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetTriggerBoxSize(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetTriggerBoxOrient();
    CoreScripted::CommandReturn eFnUnPauseForMenu(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnShowObject(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnLoadingScreen();
    CoreScripted::CommandReturn FnAddFoliage(CoreCommand* io_command);
    int32_t GetFoliageSlot();
    void ~FRLevel();
};

enum LEVEL_STATE
{
    LS_NULL,
    LS_START_LOADING,
    LS_LOADING,
    LS_LOADED,
    LS_RUNNING,
    LS_LEVEL_STATS_INIT,
    LS_LEVEL_STATS_DISPLAY,
    LS_GOTO_NEXT_LEVEL,
    LS_MAX,
};

struct CoreEvent
{
    struct CoreEventHeader
    {
        uint32_t m_Type;
        uint32_t m_To;
        uint32_t m_From;
        uint32_t m_Size;
    };

    static CoreHash EVENT_LOGGER;
    static uint32_t WORLD_EVENT;
    static uint32_t LEVEL_EVENT;
    static uint32_t OBJECT_BY_TYPE_EVENT;
    static uint32_t OBJECT_BY_NAME_EVENT;
    CoreEvent::CoreEventHeader m_Header;
    void* m_Data;

    bool CreateLogger();
    bool Create(uint32_t i_Type, uint32_t i_To, uint32_t i_From, void* i_Data, uint32_t i_Size);
    uint32_t Serialise(void* i_Buffer, uint32_t i_BufferSize);
    bool DeSerialise(void* i_SerialisedBuffer, void* i_DataBuffer, uint32_t i_DataBufferSize);
    bool StoreEvent(CoreEvent& i_TargetEvent, void* i_DataBuffer, uint32_t i_DataBufferSize);
    uint32_t GetSerialisedLength();
    uint32_t GetType();
    uint32_t GetOwner();
    uint32_t GetTarget();
    void* GetData();
    uint32_t GetDataLength();
};

enum TRRagDollMode
{
    RAGDOLLMODE_OFF,
    RAGDOLLMODE_ON,
    RAGDOLLMODE_TIMER,
    RAGDOLLMODE_WAIT_BLEND_FROM_ANIM,
    RAGDOLLMODE_WAIT_BLEND_TO_ANIM,
    RAGDOLLMODE_MAX,
};

struct TRRagdoll
{
    TRGameObject* m_object;
    bool m_ragDollOn;
    TRRagDollMode m_ragDollMode;
    CoreVector m_ragDollInitialVelocity;
    bool m_ragDollExplode;
    float m_ragDollTimer;
    float m_ragDollBlendInTimer;
    float m_ragDollBlendOutTimer;
    float m_ragDollTimerStart;
    float m_ragDollTimerLastUpdate;

    void TRRagdoll();
    void Setup(TRGameObject* i_object);
    bool SetRagDoll(CoreVector i_initialvel, TRRagDollMode i_mode, float i_seconds, float i_secondsIn, float i_secondsOut, float i_animVelocityScale);
    bool UpdateRagDoll();
};

struct OffsetBlend
{
    bool active;
    CoreVector vector;
    float orient;
    float time;
    float delay;

    void OffsetBlend();
};

struct TRGameObjectAIData
{
    TRGameObject* target;
    float angleToTarget;
    float distanceToTarget;
    int32_t mood;
};

struct TRCollision
{
    void TRCollision();
    int32_t TestCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject);
    int32_t TestLaraPosition(float* fBounds, TRGameObject* i_object, FRPlayerObject* i_laraObject);
    int32_t TestBoundsCollide(TRGameObject* i_object, FRPlayerObject* i_laraObject, int32_t radius);
};

enum CAMERA_TYPE
{
    CHASE_CAMERA,
    FIXED_CAMERA,
    LOOK_CAMERA,
    COMBAT_CAMERA,
    CINEMATIC_CAMERA,
    HEAVY_CAMERA,
};

enum CoreNodeType
{
    NODE_BASIC,
    NODE_OBJECT,
    NODE_CHARACTER__UNUSED,
    NODE_BGLIGHT,
    NODE_TRIGGER,
    NODE_FX,
    NODE_SCENERY,
    NODE_CAMERA,
    NODE_ED_ITEM,
    NODE_ED_TRIG,
    NODE_ED_CAMERA,
    NODE_MAX_NODES,
    NODE_MANIP,
    NODE_ROOM,
    NODE_TOTAL_NODES,
};

enum FRDetectionBones
{
    FRDB_HEAD,
    FRDB_HANDL,
    FRDB_HANDR,
    FRDB_PELVIS,
    FRDB_FOOTL,
    FRDB_FOOTR,
    FRDB_NUM_DETECTION_BONES,
};

enum PlayerFlags
{
    PF_SWIMCHEAT,
    PF_ONFIRE,
    PF_LANDED_ON_FLOOR,
    PF_MOVE_PLAYER_FLAG,
    PF_APPLY_EXTERNAL_VELOCITY,
    PF_IN_LAVA,
    PF_JUMP_WAITING,
    PF_NULL7,
    PF_NULL8,
    PF_ON_STAIRS,
    PF_SET_RAGDOLL,
    PF_NULL11,
    PF_RESET_AVERAGE_VELOCITY,
    PF_DISABLE_INPUT,
    PF_ON_SLOPE,
    PF_NULL15,
    PF_NULL16,
    PF_NO_DETECTION,
    PF_NULL18,
    PF_NULL19,
    PF_NULL20,
    PF_NULL21,
    PF_NULL22,
    PF_LOWER_EXTERNAL_VELOCITY,
    PF_JUST_RAGDOLLED,
    PF_CAMERA_NEEDS_RESETTING,
    PF_USE_IN_FRONTEND,
    PF_NULL27,
    PF_NULL28,
    PF_NULL29,
    PF_NULL30,
    PF_NULL31,
};

struct TRInventoryItem
{
    int32_t m_objectNum;
    int32_t m_invPos;
    int32_t m_quantity;
    int32_t m_objectIndex;
    CoreHash m_hashName;

    void TRInventoryItem();
    void Init();
    void Clear();
    void ~TRInventoryItem();
};

struct TRInvInit
{
    int32_t m_objectNum;
    int32_t m_invPos;
    CoreHash m_hashName;
    bool m_bReduceWhenChosen;

    void TRInvInit();
    void ~TRInvInit();
};

enum MOOD
{
    MOOD_BORED,
    MOOD_ATTACK,
    MOOD_ESCAPE,
    MOOD_STALK,
};

struct TRCreature
{
    enum DEATH_STATE
    {
        DEATH_STATE_ALIVE,
        DEATH_STATE_RAGDOLLING,
        DEATH_STATE_FINISHED,
    };

    int32_t objectIndex;
    float m_maximumTurn;
    float m_currentTurn;
    CoreHash m_boneRotationHashes[10];
    float m_boneRotationValues[10];
    float m_boneRotationTurnValues[10];
    TRNav m_nav;
    TRRagdoll m_ragdoll;
    TRGameObject* m_targetObject;
    float m_crossoverTargetTimer;
    float m_quickTurnTimer;
    float m_maxClimbHeight;
    TRCreature::DEATH_STATE m_deathState;
    MOOD m_mood;

    MOOD GetMood();
    void SetMood();
    void TRCreature();
    void ~TRCreature();
};

enum OBJ_RENDER
{
    OBJ_RENDER_NULL,
    OBJ_RENDER_NORMAL,
    OBJ_RENDER_MAX,
};

enum CREATURE_DEF
{
    CREATURE_DEF_GMIN_CMIN,
    CREATURE_DEF_G15_C10,
    CREATURE_DEF_G22_C15,
    CREATURE_DEF_G30_C20,
    CREATURE_DEF_GMAX_CMAX,
};

struct TRObjectInfo
{
    enum TRODB_BoneRotations
    {
        MAX_BONE_ROTATIONS = 10,
    };

    char folderName[32];
    char modelName[32];
    bool usesNewSystem;
    int32_t nmeshes;
    int32_t mesh_index;
    int32_t bone_index;
    int32_t* frame_base;
    void* initialise;
    void* control;
    void* ffloor;
    void* ceiling;
    OBJ_RENDER renderType;
    void* collision;
    void* m_initialise;
    void* m_control;
    void* m_collision;
    CoreHash m_boneRotationHashes[10];
    float m_maxClimbHeight;
    CREATURE_DEF m_creatureDef;
    CoreHash m_initialAnimState;
    bool m_flyingCreature;
    int32_t m_weight;
    int32_t anim_index;
    int32_t hit_points;
    float pivot_length;
    int32_t radius;
    int32_t smartness;
    int32_t shadow_size;
    uint32_t loaded : 1;
    uint32_t intelligent : 1;
    uint32_t save_position : 1;
    uint32_t save_hitpoints : 1;
    uint32_t save_flags : 1;
    uint32_t save_anim : 1;

    void TRObjectInfo();
    void ~TRObjectInfo();
};

struct TRAttractor
{
    enum
    {
        VERSION = 1,
    };

    float m_x1;
    float m_y1;
    float m_z1;
    float m_x2;
    float m_y2;
    float m_z2;
    float m_planeX;
    float m_planeY;
    float m_planeZ;
    float m_planeDistance;
    uint32_t m_typeHash;
    float m_widthOrRadius;

    CoreVector GetPoint0();
    CoreVector GetPoint1();
    CorePlaneEquation GetPlane();
    CoreHash GetTypeHash();
    float GetWidth();
    float GetRadius();
    bool IsAnEdge();
    bool IsAWaterEdge();
    bool IsAHangEdge();
    bool IsAnInWall();
    bool IsAHPole();
    bool IsAHangInWall();
    bool IsALastChanceGrabEdge();
    bool IsALastChanceGrabHangEdge();
    bool IsLastChanceGrabbable();
    bool IsHangFeetPlantable();
    bool IsHangFeetNotPlantable();
    bool IsClimbableWall();
    bool IsOverhangEdge();
};

struct _tr_weapon
{
    int32_t bullets;
    int32_t clips;
    int32_t max_bullets;
};

enum TRTB_Type
{
    TRTB_NONE = 255,
    TRTB_RESTART_IF_NOT_RAGDOLL = 0,
    TRTB_RESTART_ALWAYS = 1,
    TRTB_GROUNDZERO = 2,
    TRTB_SHALLOW_WATER = 3,
    TRTB_DEEP_WATER_DEADLY = 4,
    TRTB_TR1_TRIGGER = 5,
    TRTB_MAX = 6,
};

struct FRPlayerObjectData
{
    enum collisionSetBitflagEnum
    {
        CF_NONE,
        CF_POS = (1 << 0),
        CF_CONTROL = (1 << 1),
        CF_FRONT = (1 << 2),
        CF_LEFT = (1 << 3),
        CF_RIGHT = (1 << 4),
        CF_FLOOR_UNDERNEATH = (1 << 5),
        CF_FRONT_HEIGHT = (1 << 6),
        CF_POSITION_HEIGHT = (1 << 7),
        CF_CEILING_HEIGHT = (1 << 8),
        CF_ATTRACTORS = (1 << 9),
        CF_BACK = (1 << 10),
    };

    float time;
    float debug[4];
    uint32_t networkOutAnimCount;
    NetworkAnimData networkOutAnimData[4];
    uint32_t networkInAnimCount;
    NetworkAnimData networkInAnimData[4];
    float networkInAnimTime;
    CoreVector networkPosition;
    CoreVector networkPositionDelta;
    CoreEulerAngle networkOrientation;
    CoreEulerAngle networkOrientationDelta;
    bool networkAbsolute;
    uint32_t networkUpdateFrequency;
    float networkTime;
    char networkName[64];
    float networkBoneDelta[77];
    float controlMagnitude;
    float controlAngle;
    float absControlAngle;
    float lStickAngle;
    float wallFacing;
    bool noAnimPosOrientChangeThisFrame;
    CoreVector waterCurrent;
    CoreVector transmitVelocity;
    uint32_t jumpType;
    float jumpDistance;
    CoreVector jumpVelocity;
    float jumpTime;
    CoreHash jumpAttractorType;
    CoreVector jumpDestination;
    float jumpFacing;
    CoreVector jumpAngleVector;
    float jumpAngleTolerance;
    float angleTurn;
    float railSpeed;
    TRTB_Type triggerBoxType;
    float triggerBoxYPos;
    int32_t triggerEventIndex;
    uint32_t triggerEventHash;
    CoreHash lastAnimContext;
    float lastAnimTime;
    int32_t playerControlScript;
    CoreHash playerControlScriptSlot;
    CoreHash currentAnimSlotState[3];
    CoreHash goalAnimSlotState[3];
    CoreHash lastAnimSlotState[3];
    float maxButtonDelay;
    int32_t numActions;
    float wallSlideCount;
    float runningCount;
    float leaningCount;
    float noGrabbingTimer;
    CoreEulerAngle railOrient;
    float lookXVel;
    float lookYVel;
    float lookX;
    float lookY;
    CoreVector oldPos;
    CoreVector newPos;
    CoreVector bonePos[6];
    CoreVector controlDirectionVector;
    CoreVector playerDirectionVector;
    CoreVector playerLeftVector;
    CoreVector playerRightVector;
    CoreVector playerLastCheckpointPos;
    CoreQuat playerLastCheckpointOrient;
    CoreEulerAngle presetOrient;
    FRActionStatus actions[64];
    CoreMap<bool __cdecl(FRPlayerObject * const,int)> functions;
    CoreMap<CoreHash const > animStateScriptOffsets[3];
    CoreMap<FRActionStatus> actionStates;
    CoreVector lastJoy;
    CoreVector currentJoy;
    float zeroJoyCount;
    FRPlayerObjectData::__unnamed m_fxGunSmoke[2];
    uint32_t m_fxWaterTime;
    float fxBreathTime;
    float onFireTimer;
    float m_inLavaTime;
    float defaultFOV;
    float defaultYOff;
    float defaultPitch;
    float defaultCameraDistance;
    float cam_fov;
    float cam_yOff;
    float cam_mBlur;
    float cam_fogAlpha;
    float cam_pitch;
    float cam_timeScale;
    float cam_distance;
    int32_t playerID;
    uint32_t flags;
    int32_t numAttractors;
    CoreInputContext gameContext;
    CoreInputMapping gameMapping;
    CoreInputContext debugContext;
    CoreInputMapping debugMapping;
    int32_t whichPlayer;
    bool playerFellOffWorld;
    FRTrickTable trickTable;
    int32_t currentViewerIndex;
    bool updatePlayerFX;
    bool playerPosSetup;
    CoreVector playerStartPos;
    int32_t currentViewerID;
    CoreVector lastSlopeNormal;
    float leanAngle;
    CoreDetectPoly floorPoly;
    float fallOrigin;
    float lastYVel;
    bool resetPlayerToLastCheckPointAfterRagdoll;
    float idleAnimTime;
    int32_t lastIdleDecision;
    float timeSinceStance;
    uint32_t collisionSetFlag;
    float justBeenPausedTimer;
    TRCollInfo coll;
    TRInventory inventory;
    float air;
    _tr_weapon weaponInfo[4];
    int32_t selectedWeapon;
    bool pressedL1;
    CoreEulerAngle swimOrient;
    float swimSpeed;
    float joyXAxis;
    float joyYAxis;
    float maxSwimSpeed;
    HairStruct hair[7];
    TRWeaponAimControl weaponAimLeft;
    TRWeaponAimControl weaponAimRight;
    TRWeaponAimControl weaponAimTorso1;
    TRWeaponAimControl weaponAimTorso2;
    TRWeaponAimControl weaponAimNeck;
    TRWeaponAimControl weaponAimHead;
    bool weaponForceDraw;
    bool weaponForceHolster;
    bool weaponSuspended;
    TRGameObject* leftPistolObject;
    TRGameObject* rightPistolObject;
    CoreParticleFXPrimitive* weaponReticule[4];
    TRGameObject* crystalObject;
    uint32_t crystalsAvailable;
    bool updateCrystalDisplay;
    bool bLaraCrystalSeqEnd;
    bool bLaraGrabGreenCrystal;
    AttractorToPlayerData attractorToPlayer;
    float floorUnderneath;
    float frontHeight;
    float posHeight;
    float ceilingHeight;
    AttractorTable attractorHead;
    AttractorTable attractors[64];
    AttractorTable* handsAttractorFront;
    AttractorTable* handsAttractorLeft;
    AttractorTable* handsAttractorRight;
    TRAttractor* climbWallAttractorCurrent;
    TRAttractor* shimmyJumpTargetAttractor;
    CoreDetectResult posDetectResultData;
    CoreDetectResult frontDetectResultData;
    CoreDetectResult controlDetectResultData;
    CoreDetectResult leftDetectResultData;
    CoreDetectResult rightDetectResultData;
    CoreDetectResult backDetectResultData;

    void FRPlayerObjectData();
    CoreDetectResult* GetPosDetectResultData();
    CoreDetectResult* GetControlDetectResultData();
    CoreDetectResult* GetFrontDetectResultData();
    CoreDetectResult* GetLeftDetectResultData();
    CoreDetectResult* GetRightDetectResultData();
    CoreDetectResult* GetBackDetectResultData();
    float GetFloorUnderneath();
    float GetFrontHeight();
    float GetPositionHeight();
    float GetCeilingHeight();
    int32_t GetAttractorInfo();
    AttractorTable* GetAttractorHead();
    AttractorTable* GetAttractorTable();
    AttractorTable* GetHandsAttractorFront();
    AttractorTable* GetHandsAttractorLeft();
    AttractorTable* GetHandsAttractorRight();
    void SetPosDetectResultData(CoreDetectResult* i_detectPtr);
    void SetControlDetectResultData(CoreDetectResult* i_detectPtr);
    void SetFrontDetectResultData();
    void SetLeftDetectResultData();
    void SetRightDetectResultData();
    void SetBackDetectResultData();
    void SetFloorUnderneath();
    void SetFrontHeight();
    void SetPositionHeight();
    void SetCeilingHeight();
    void SetAttractorInfo();
    void SetFrontLeftRightHands(CoreVector i_pos);
    void SetHandsAttractorFront();
    void SetHandsAttractorLeft();
    void SetHandsAttractorRight();
    void SetClimbWallAttractorCurrent();
    TRAttractor* GetClimbWallAttractorCurrent();
    void SetShimmyJumpTargetAttractor();
    TRAttractor* GetShimmyJumpTargetAttractor();
    void ClearAllCollisionSetFlags();
    void ClearCollisionSetFlag();
    void SetCollisionSetFlag();
    void ~FRPlayerObjectData();
};

struct CoreDetectResult
{
    bool bError;
    CoreVector vResultPos;
    CoreDetectHit eWhatHit;
    uint32_t subType1;
    uint32_t subType2;
    CoreGeometryObject* objectFloorHit;
    uint32_t typeWallsHit[32];
    CorePlaneEquation vNormalsWallsHit[32];
    float fHeightsWallsHit[32];
    CoreGeometryObject* objectWallsHit[32];
    int32_t iNumWallsHit;
    CoreVector vNormalsObjectWallsHit[32];
    float fHeightsObjectWallsHit[32];
    CoreGeometryObject* objectObjectWallsHit[32];
    int32_t iNumObjectWallsHit;
    CorePlaneEquation peFloor;

    void CoreDetectResult();
};

struct FRActionStatus
{
    CoreHash name;
    uint32_t* basePtr;
    uint32_t* currentPtr;
    uint32_t currentIndex;
    float idleTime;
    float life;
    float holdTime;
    bool status;
    bool held;

    void FRActionStatus();
    void ~FRActionStatus();
};

struct CoreMap<bool __cdecl(FRPlayerObject * const,int)> : CoreMapBase
{
    void CoreMap<bool __cdecl(FRPlayerObject * const,int)>();
    bool AddKey();
    bool* FindKey(CoreHash i_key);
    bool UpdateKey();
    void ~CoreMap<bool __cdecl(FRPlayerObject * const,int)>();
    void __dflt_ctor_closure();
};

struct CoreMap<CoreHash const > : CoreMapBase
{
    void CoreMap<CoreHash const >(uint32_t i_maxItems, CoreMemory* i_itemMemory);
    bool AddKey();
    CoreHash* FindKey();
    bool UpdateKey();
    void ~CoreMap<CoreHash const >();
    void __dflt_ctor_closure();
};

struct CoreMap<FRActionStatus> : CoreMapBase
{
    void CoreMap<FRActionStatus>();
    bool AddKey();
    FRActionStatus* FindKey(CoreHash i_key);
    bool UpdateKey();
    void ~CoreMap<FRActionStatus>();
    void __dflt_ctor_closure();
};

struct FRTrickTable
{
    enum TRICKTYPE
    {
        TRICKTYPE_NULL,
        NULL1,
        NULL2,
        NULL3,
        TRICKTYPE_EFFECT,
        TRICKTYPE_PLAYFX,
        TRICKTYPE_RUMBLE,
        TRICKTYPE_HELP,
    };

    enum
    {
        MAX_TRICK_CHAINS = 16,
    };

    CoreMap<unsigned int> trickHashIndexTable;
    CoreMap<unsigned int> feedbackHashIndexTable;
    uint32_t trickTextCounts[48];
    uint32_t feedbackTextCounts[16];
    int32_t m_trickID;
    CoreMap<CoreHash const > trickTableScriptOffsets;
    CoreHash m_lastAnim;
    int32_t m_debounce;

    void FRTrickTable();
    void Init(CoreScriptStore* scriptPtr, CoreMemory* io_memory, FRPlayerObject* i_player);
    void Reset(FRPlayerObject* i_player);
    CoreHash* GetTrick(CoreHash i_currentAnim, FRPlayerObject* player);
    uint32_t RoundScore();
    void ~FRTrickTable();
};

struct CoreScriptStore
{
    // TODO vtable

    char* GetScriptObject();
    void CoreScriptStore();
};

struct TRCollInfo
{
    int32_t mid_floor;
    int32_t mid_ceiling;
    int32_t mid_type;
    int32_t front_floor;
    int32_t front_ceiling;
    int32_t front_type;
    int32_t left_floor;
    int32_t left_ceiling;
    int32_t left_type;
    int32_t right_floor;
    int32_t right_ceiling;
    int32_t right_type;
    int32_t radius;
    int32_t bad_pos;
    int32_t bad_neg;
    int32_t bad_ceiling;
    CoreVector shift;
    CoreVector old;
    int32_t facing;
    int32_t quadrant;
    int32_t coll_type;
    int32_t* trigger;
    char tilt_x;
    char tilt_z;
    char hit_by_baddie;
    char hit_static;
    uint32_t slopes_are_walls : 1;
    uint32_t slopes_are_pits : 1;
    uint32_t lava_is_pit : 1;
    uint32_t enable_baddie_push : 1;
    uint32_t enable_spaz : 1;

    void TRCollInfo();
};

struct TRInventory
{
    int32_t m_numMainObjects;
    int32_t m_mainCurrent;
    int32_t m_mainQuantityList[23];
    TRInventoryItem m_mainItemList[23];
    int32_t m_numKeysObjects;
    int32_t m_keysCurrent;
    int32_t m_keysQuantityList[23];
    TRInventoryItem m_keysItemList[23];
    int32_t m_numTitleObjects;
    int32_t m_titleCurrent;
    int32_t m_TitleQuantityList[23];
    TRInventoryItem m_TitleItemList[23];
    int32_t m_inventoryChosen;
    int32_t m_nInvItemToUse;
    bool m_bInventoryDirty;

    void InitNewGame();
    int32_t AddItem(int32_t i_objectNum);
    int32_t GetItemOption(int32_t i_objectNum);
    int32_t RequestItem(int32_t i_objectNum);
    void InsertItem(TRInvInit* i_invInit);
    int32_t RemoveItem(int32_t i_objectNum);
    void RemoveAllItems();
    void ClearAll();
    void TRInventory();
    void ~TRInventory();
};

struct HairStruct
{
    CoreVector pos;
    CoreVector vel;

    void HairStruct();
};

struct TRWeaponAimControl
{
    enum TRWeaponAimType
    {
        WA_ARM_LEFT,
        WA_ARM_RIGHT,
        WA_TARGET_OBJECT,
        WA_REMOVE_ROTATION,
    };

    uint32_t m_state;
    uint32_t m_boneHash;
    uint32_t m_flags;
    float m_aimBlendTime;
    float m_minYaw;
    float m_maxYaw;
    float m_minPitch;
    float m_maxPitch;
    CoreEulerAngle m_extraRotation;
    bool m_active;
    bool m_lock;
    bool m_armLock;
    bool m_targetBlend;
    float m_blendTime;
    CoreObject* m_target;
    float m_rotX;
    float m_rotY;
    bool m_targetChange;
    CoreEulerAngle m_facingRot;
    float m_aimTimeout;

    void Reset();
    void SetBoneHash();
    void SetBlendTime();
    void SetAimAngleRanges();
    void SetExtraRotation();
    void SetTargetObject();
    void SetRemoveRotation();
    void SetArmLeft();
    void SetArmRight();
    void SetArmNone();
    bool IsTargetObject();
    bool IsRemoveRotation();
    bool IsArmLeft();
    bool IsArmRight();
    void StartAiming(CoreObject* i_target);
    void StopAiming();
    bool HasTarget();
    bool HasTargetLock();
    bool HasTargetArmLock();
    bool TargetIsDead();
    void GetAimAngleLimits(WeaponInfoStruct* i_weapon, float& o_minYaw, float& o_maxYaw, float& o_minPitch, float& o_maxPitch);
    bool UpdateAngleOnTargetChange();
    void TRWeaponAimControl();
};

struct WeaponInfoStruct
{
    WeaponHandedness handedness;
    CoreHash animDraw;
    CoreHash animDrawn;
    CoreHash animAim;
    CoreHash animFire;
    CoreHash animHolster;
    float maxTargetRange;
    float minYawLock;
    float maxYawLock;
    float minPitchLock;
    float maxPitchLock;
    float minYawArmL;
    float maxYawArmL;
    float minPitchArmL;
    float maxPitchArmL;
    float minYawArmR;
    float maxYawArmR;
    float minPitchArmR;
    float maxPitchArmR;

    void WeaponInfoStruct();
    void ~WeaponInfoStruct();
};

struct AttractorTable
{
    AttractorTable* prev;
    AttractorTable* next;
    TRAttractor* ptr;
    bool isIntersected;
    bool isInFront;
    float pointDist3D;
    float pointDist2D;
    float distanceFromEdge;
    float perpDistanceFromEdge;
    float gradient;
    int32_t attractorNum;
    int32_t pointOnRight;
    CoreVector intersectPoint;
    CoreVector perpIntersectPoint;
    bool perpIntersected;
    bool isInFrontClose;
    JumpIntersections jumpIntersections[2];

    void AttractorTable();
};

struct AttractorToPlayerData
{
    AttractorTable* aPtr;
    CorePlaneEquation attractorPlane;
    float angleDiff;
    float wallHeight;
    float heightFromFloor;
    float ceilingHeight;
    float align2Plane;
    CoreVector offsetBlend;
    float maxScrambleHeight;

    void AttractorToPlayerData();
};

struct NetworkAnimData
{
    int32_t m_SlotNo;
    uint32_t m_AnimFlags;
    uint32_t m_AnimState;
    float m_AnimTimestamp;
};

enum LARA_GUN_STATUS
{
    LGS_ARMLESS,
    LGS_HANDSBUSY,
    LGS_DRAW,
    LGS_UNDRAW,
    LGS_READY,
};

enum LARA_WATER_STATE
{
    LWS_ABOVEWATER,
    LWS_UNDERWATER,
    LWS_SURFACE,
    LWS_CHEAT,
};

struct TRClimbData
{
    TRAttractor* m_atr;
    CoreVector m_point0;
    CoreVector m_point1;
    CoreVector m_centre;
    CoreVector m_normal;
    CoreVector m_normalX;
    CoreVector m_normalY;
    float m_width;
    float m_height;
    bool m_inside;
    bool m_overlap;
    CoreVector m_pos;

    void FlippertyJibbit(bool i_originAtHands, bool& o_insideHeight, float& o_distFromEdge);
    void TRClimbData();
};

enum ClimbWallDirectionType
{
    CLIMBWALL_UP,
    CLIMBWALL_DOWN,
    CLIMBWALL_LEFT,
    CLIMBWALL_RIGHT,
};

struct CorePlaneEquation : CoreVector
{
    void CorePlaneEquation();
    CoreVector GetNormal();
    float GetDistance();
    void SetPos();
    CoreVector GetPointOnPlane();
    float GetDistanceToPoint();
    void Invert();
    void MakePlane();
};

struct CoreMap<unsigned int> : CoreMapBase
{
    void CoreMap<unsigned int>();
    bool AddKey();
    uint32_t* FindKey();
    bool UpdateKey();
    void ~CoreMap<unsigned int>();
    void __dflt_ctor_closure();
};

enum WeaponHandedness
{
    WH_ONEHANDED,
    WH_TWOHANDED,
};

struct JumpIntersections
{
    CoreVector vec;
    float distance;
    bool intersected;

    void JumpIntersections();
};

struct TRNav
{
    enum TARGET_STATUS
    {
        TARGET_UNDEFINED,
        TARGET_UNREACHABLE,
        TARGET_IS_ACTUAL_TARGET,
        TARGET_IS_ON_SAME_MESH,
        TARGET_IS_ON_DIFFERENT_MESH,
    };

    CoreNavPos m_myPos;
    CoreNavPos m_destPos;
    CoreNavPos m_altPos;
    CoreVector m_targetPos;
    TRNav::TARGET_STATUS m_targetStatus;
    float m_climbToTarget;
    float m_jumpToTarget;
    float m_jumpAngle;
    int32_t m_lastNavMesh;
    CoreVector m_crossoverPos;

    void SetTarget(CoreVector i_target, uint32_t i_navMesh, uint32_t i_triangle);
    void SetAltTarget(CoreVector i_target, uint32_t i_navMesh, uint32_t i_triangle);
    void TRNav();
};

struct TRAIController : CoreAIController
{
    CoreVector m_debugStart;
    CoreVector m_debugEnd;
    CoreVector m_debugWaypoint;
    TRCreature m_creatureSlots[32];

    void TRAIController();
    void ~TRAIController();
    void DoDebug(CoreDebugInput* i_input);
    void GlobalInit();
    void LevelInit();
    void CreatureAIInfo(TRGameObject* object, TRNewAIInfo* info, TRCreature* i_creature);
    void CreatureMood(TRGameObject* object, TRNewAIInfo* info, int32_t violent);
    float CreatureTurn(TRGameObject* i_object, float i_maxTurn, TRNewAIInfo* i_aiInfo);
    void CreatureTilt(TRGameObject* i_object, float i_tilt);
    void CreatureBoneRotation(TRGameObject* object, int32_t i_bone, float i_turn, float i_maxTurn, TRCreature* i_creature);
    int32_t CreatureAnimation(TRGameObject* i_object, float angle, TRCreature* i_creature);
    int32_t CreatureCreature(TRGameObject* i_object, CoreVector* o_objectPos);
    bool EnableBaddieAI(TRGameObject* object);
    void DisableBaddieAI();
    void InitialiseSlot(TRGameObject* i_object, int32_t i_slot);
    int32_t GetRandomControl();
    TRCreature* GetCreaturePtr();
    bool GetNavTriangle(CREATURE_DEF i_creatureDef, CoreNavPos* io_navPos);
    bool PickBoredDestination(TRNav* io_nav);
    bool PickEscapeDestination(TRNav* io_nav);
    bool UpdateTarget(CREATURE_DEF i_creatureDef, TRNav* io_nav, CoreNavPos* i_dest, int32_t i_lookAhead);
    bool GetGibbysMagicTrianglePos(CREATURE_DEF i_creatureDef, CoreNavPos* i_srcNav, CoreNavPos* i_destNav, int32_t i_lookAhead, CoreVector* o_pos);
};

struct CoreDebugInput
{
    enum
    {
        MAX_NUM_PRESSED_KEYS = 8,
    };

    CoreHash m_pressedKeys[8];
    CoreHash m_lastPressedKeys[8];
    uint32_t m_lastASCIIKeyClicked;
    uint32_t m_numPressedKeys;

    void CoreDebugInput();
    void ~CoreDebugInput();
    bool IsKeyPressed(CoreHash i_key);
    bool IsKeyClicked(CoreHash i_key);
    uint32_t GetLastKeyClicked();
    void InitData();
    void SetKeyPressed(CoreHash i_pressedKey);
    void SetLastKeyClicked(uint32_t i_lastKeyClicked);
};

struct TRNewAIInfo
{
    float distance;
    float angle;
    float distanceFromOrigin;
    float angleFromOrigin;
    bool aheadOfOrigin;
    bool behindOrigin;
    float enemyFacing;
    float distToJumpClimb;
    float navArea;
    bool jumpClimbAhead;
    bool ahead;
    bool behind;
    bool bite;
    bool sameNavMesh;
};

struct PLAYER_EFFECT
{
    int32_t m_state;
    float m_time;
    float m_param1;
    float m_param2;
    float m_startVal;
    float m_endVal;
    float m_inTime;
    float m_outTime;
    float m_transTime;
};

struct jumpAttractor
{
    jumpAttractor* prev;
    jumpAttractor* next;
    float hVel;
    float vVel;
    float hOff;
    float vOff;
    AttractorTable* attractorPtr;
    float jumpFacing;
};

struct AttractorJumpStatics
{
    CoreVector playerPos;
    float playerVel;
    float minVJumpVel;
    float maxVJumpVel;
    bool ignoreAttractorsBelow;
    float heightFromLedge;
    float heightFromFloor;
    float floorPos;
    AttractorTable* aPtr;
    JumpIntersections* jiPtr;

    void AttractorJumpStatics();
};

struct TRWeaponTarget
{
    CoreObject* m_object;
    float m_distance;
    float m_angle;
};

struct TRNode : CoreNode
{
    enum nodeHdr
    {
        NODE_HDR_TYPE,
        NODE_HDR_VERSION,
        NODE_HDR_COUNT,
        NODE_HDR_CREATE_COUNT,
        NODE_HDR_SPARE1,
        NODE_HDR_SPARE2,
        NODE_HDR_SPARE3,
        NODE_HDR_SPARE4,
        NODE_HDR_NUM_ENTRIES,
        NODE_HDR_BYTE_SIZE = 32,
    };

    enum dataSizes
    {
        NODE_BASE_WRITE_SIZE = 88,
        NODE_FX_WRITE_SIZE = 100,
        NODE_SCENERY_WRITE_SIZE = 92,
        NODE_TRIGGER_WRITE_SIZE = 120,
        NODE_CAMERA_WRITE_SIZE = 120,
    };

    enum NodeCullType
    {
        NODE_CULL_NONE,
        NODE_CULL_POINT,
        NODE_CULL_SPHERE,
        NODE_CULL_BOX,
    };

    enum
    {
        MAX_NODE_STRINGS = 2048,
        NODE_STRING_LENGTH = 64,
        NODE_STRING_BUFFER_SIZE = 131072,
    };

    struct roomInfo
    {
        int32_t flipRoom;
        uint32_t flags;
        uint32_t fogRGBA;
        uint32_t logical;
        int32_t pad5;
        int32_t pad6;
        int32_t pad7;
        int32_t pad8;
        int32_t pad9;
        int32_t pad10;
        int32_t pad11;
        int32_t pad12;
        int32_t pad13;
        int32_t pad14;
        int32_t pad15;
        int32_t pad16;
    };

    struct stringInfo
    {
        char* m_stringBuffer;
        CoreHash* m_hashBuffer;
    };

    int32_t m_nameStringIndex;
    uint32_t m_codeFlags;
    CoreHash m_hashAssociate;
    static bool m_bUsingEditor;
    static uint32_t* m_pNodeHeader;
    static uint32_t m_nodeTotals[11];
    static bool m_nodeVisibility[11];
    static TRNode::stringInfo m_stringInfo;

    void Construct();
    uint32_t Read(uint32_t* iBuffer);
    CoreVector ReadVector(uint32_t*& iBuffer, uint32_t& iCount);
    void CleanupAllNodeArrays();
    void onChangeCodeBits();
    void BodgeCodeFlags();
    void CreateFromEditorNode(TRNode* pNode);
    uint32_t FindUnusedStrings();
    uint32_t Write(uint32_t* iBuffer);
    void Duplicate();
    uint32_t WriteVector();
    void WriteSceneNodes();
    uint32_t GetWriteSize();
    bool DoesNameExist(uint32_t iNameHash);
    void CreateNodeName(uint32_t);
    void CreateDuplicateNodeName();
    void CreateEditorScene();
    void OnBeginEdit();
    uint32_t CountNodesByType(CoreNodeType iType);
    void OnDelete();
    void LoadRoomData();
    uint32_t* LoadNodeFile(char* iFileName, uint32_t iNodeType, uint32_t& ioNumNodes, CoreHash& ioAssetHash);
    void UnloadNodeFile(CoreHash iAssetHash);
    void CreateSceneNodes();
    void UpdateNodes(bool bLimitedUpdate);
    void SetNodeVisibility(uint32_t iType, bool iVal);
    bool GetNodeVisibility(uint32_t iType);
    CoreNode* GetNodeChainByType(uint32_t iRoomNumber, uint32_t iNodeType);
    uint32_t GetNodeTotalByType(uint32_t iType);
    void SetNodeTotalByType();
    uint32_t AddString(char* iString);
    char* GetString(uint32_t iIndex);
    void SetString(uint32_t iIndex, char* iString);
    uint32_t GetStringIndexFromHash(CoreHash iHash);
    TRNode* GetNodeByCreateIndex(uint32_t iIndex, uint32_t iType);
    uint32_t GetNodeStringIndexUsageCount(uint32_t iStringIndex);
    void UpdateOnMove(bool iUpdateChain);
    void CreateNodeSceneFromEditor();
    uint32_t WriteNodeNames(char* iFileName);
    uint32_t WriteRoomData(char* iFileName);
    void InitStringBuffer();
    void DeInitStringBuffer();
    uint32_t RemoveDuplicateStrings();
    void TRNode();
    void ~TRNode();
};

struct TRWadFileManager
{
    enum
    {
        MAX_FILES = 256,
    };

    struct wadFileElement
    {
        CoreHash m_hashShortName;
        uint32_t m_fileOffset;
        uint32_t m_fileSize;
        uint32_t m_pad;

        void wadFileElement();
        void ~wadFileElement();
    };

    struct wadFileHeader
    {
        uint32_t m_numberOfFiles;
        uint32_t m_pad[3];
        TRWadFileManager::wadFileElement m_wadElements;

        void wadFileHeader();
        void ~wadFileHeader();
    };

    struct wadElementCreate
    {
        CoreStringBuffer<256> m_fullNameAndPath;
        CoreHash m_hashShortName;
        uint32_t m_fileSize;

        void wadElementCreate();
        void ~wadElementCreate();
    };

    static TRWadFileManager::wadElementCreate m_fileList[256];
    static uint32_t m_numFiles;
    static TRWadFileManager::wadFileHeader* m_fileBuffer;
    static CoreHash m_assetHash;
    static CoreStringBuffer<256> m_fileName;

    void BeginFile(char* iFileName);
    void AddFile(CoreStringBuffer<256> iFullName, CoreHash iShortName, uint32_t iFileSize);
    bool Write();
    bool Open(char* iFileName);
    void Close();
    uint32_t* GetFile(CoreHash iFileHash);
    int32_t GetFileSize(CoreHash iFileHash);
    char* GetWadName();
    bool IsValid();
};

struct TRObjectDB
{
    TRObjectInfo objects[208];

    void TRObjectDB();
    void InitialiseObjects();
    void InitBaddyObjects();
    void InitTrapObjects();
    void InitObjectObjects();
    void InitMoveBlock();
    void ~TRObjectDB();
};

struct TRAttractors
{
    void InsertAttractor(AttractorTable* o_atHead, AttractorTable* io_atNew);
    int32_t GetNearbyAttractors(CoreVector i_pos, CoreEulerAngle i_dir, float i_range, AttractorTable* o_attractorHead, AttractorTable* o_attractorTable);
};

struct TRTriggerBox
{
    int32_t m_type;
    int32_t m_room;
    CoreVector m_min;
    CoreVector m_max;
    int32_t m_eventIndex;
    bool m_active;

    void TRTriggerBox();
};

struct TRTriggerEvent
{
    int32_t m_length;
    int32_t* m_data;
};

struct TRTriggerController
{
    bool m_inited;
    TRTriggerBox m_triggerBoxes[256];
    int32_t m_numTriggerBoxes;
    TRTriggerEvent m_triggerEvents[256];
    int32_t m_numTriggerEvents;
    bool m_startingNewTriggerBox;
    CoreVector m_tmpPos;
    CoreVector m_tmpSize;
    TRTB_Type m_tmpType;
    uint32_t m_numLoadedTriggerBoxes;
    uint32_t m_numLoadedTriggerEvents;

    void TRTriggerController();
    void ClearAllTriggers();
    TRTriggerBox* GetFreeTriggerBox();
    void CreateScriptTriggerBox();
    void LoadTriggersFile();
    void SetupNodeArray();
    TRTriggerEvent* GetFreeTriggerEvent();
    TRTB_Type CheckTriggerBoxes(CoreVector i_pos, int32_t i_room, float* o_lowestY, int32_t* o_eventIndex, uint32_t* o_eventHash);
};

struct TRCameraNode : TRNode
{
    uint32_t m_camData;
    uint32_t m_oldCameraIndex;

    uint32_t CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
    void Construct();
    uint32_t Read(uint32_t* iBuffer);
    void CreateFromEditorNode(TRNode* pNode);
    void Update();
    void RenderDebug();
    void ForceUpdate();
    void CreateNodeName(uint32_t iNum);
    uint32_t LoadNodes(CoreLevelCompiled* iLevelCompiled);
    void TRCameraNode();
    void ~TRCameraNode();
};

struct CoreAngleAxis : CoreVector
{
    void CoreAngleAxis();
    CoreVector GetVector();
    float GetAngle();
    void SetVector();
    void SetAngle();
};

struct CoreQuat : CoreVector
{
    void CoreQuat();
    CoreVector GetVector();
    void SetVector();
    void Normalize();
    bool IsEqualTo();
    CoreAngleAxis ToAngleAxis();
    void FromAngleAxis(CoreAngleAxis& angleAxis);
    CoreEulerAngle ToEulerAngle();
    void FromEulerAngle(CoreEulerAngle& i_euler);
    CoreQuat Slerp(CoreQuat& i_target, float i_alpha);
    void MakeSquadABValues();
    CoreQuat Squad(float i_alpha, CoreQuat& i_n, CoreQuat& i_a, CoreQuat& i_quat, CoreQuat& i_nPlus1);
    void RotateX(float i_angleX);
    void RotateY(float i_angleY);
    void RotateZ(float i_angleZ);
    void RotateYXZ();
    void RotateZYX();
    void MayaZXY(float i_angleX, float i_angleY, float i_angleZ);
    void MayaXYZ(float i_angleX, float i_angleY, float i_angleZ);
    CoreEulerAngle ToMayaXYZAngles();
    CoreQuat operator*=(CoreQuat& i_quat);
    CoreQuat Inverse();
    CoreQuat NormInverse();
    CoreQuat NormLog();
    CoreQuat NormExp();
    void CompleteWFromSign(bool i_sign);
};

struct CoreMatrix
{
    CoreVector m_col0;
    CoreVector m_col1;
    CoreVector m_col2;
    CoreVector m_row3;

    void CoreMatrix();
    void Identity();
    void Zero();
    void Transpose();
    CoreMatrix Multiply(CoreMatrix& i_matrix);
    CoreVector VecTransform(CoreVector& i_vector);
    CoreVector NormalTransform(CoreVector& i_vector);
    CoreVector MultiplyByVector(CoreVector& i_vector);
    CoreVector MultiplyByNormal(CoreVector& i_vector);
    CoreVector GetScale();
    CoreVector GetScaleSlow();
    CoreVector GetTranslation();
    CoreEulerAngle GetAngles();
    void RemoveScale();
    void ScaleX();
    void ScaleY(float i_scaleY);
    void ScaleZ();
    void ScaleW();
    float GetScaleX();
    float GetScaleY();
    float GetScaleZ();
    float GetScaleW();
    void Scale();
    void ScaleXYZ(float i_scale);
    void SetTranslation();
    void TranslateAbsolute();
    void TranslateRelative(CoreVector& i_trans);
    void RotateX(float i_rotX);
    void RotateY(float i_rotY);
    void RotateZ(float i_rotZ);
    void RotateZYX();
    void RotateYXZ(float i_rotX, float i_rotY, float i_rotZ);
    CoreEulerAngle ToEulerAnglesZYX();
    CoreEulerAngle ToEulerAnglesYXZ();
    void Rotate(float i_angle, CoreVector& i_axis);
    bool IsEqualTo();
    CoreEulerAngle ToEulerAngle();
    void FromEulerAngle(CoreEulerAngle& i_euler);
    CoreQuat ToQuat();
    void FromQuat(CoreQuat& i_quat);
    CoreAngleAxis ToAngleAxis();
    void FromAngleAxis();
    void LookAt(CoreVector& i_origin, CoreVector& i_target, CoreVector& i_worldUp, float i_roll);
    void InverseTransScaleRot();
    CoreVector GetMemRow0();
    CoreVector GetMemRow1();
    CoreVector GetMemRow2();
    CoreVector GetMemRow3();
    CoreVector GetXAxis();
    CoreVector GetYAxis();
    CoreVector GetZAxis();
    CoreVector GetMemCol0();
    CoreVector GetMemCol1();
    CoreVector GetMemCol2();
    CoreVector GetMemCol3();
    float Get00();
    float Get01();
    float Get02();
    float Get03();
    float Get10();
    float Get11();
    float Get12();
    float Get13();
    float Get20();
    float Get21();
    float Get22();
    float Get23();
    float Get30();
    float Get31();
    float Get32();
    float Get33();
    void SetMemRow0();
    void SetMemRow1();
    void SetMemRow2();
    void SetMemRow3();
    void SetMemCol0();
    void SetMemCol1();
    void SetMemCol2();
    void SetMemCol3();
    void Set00();
    void Set01();
    void Set02();
    void Set03();
    void Set10();
    void Set11();
    void Set12();
    void Set13();
    void Set20();
    void Set21();
    void Set22();
    void Set23();
    void Set30();
    void Set31();
    void Set32();
    void Set33();
    void Set();
    CoreVector GetRotCol0();
    CoreVector GetRotCol1();
    CoreVector GetRotCol2();
    void SetRotCol0();
    void SetRotCol1();
    void SetRotCol2();
};

enum floor_types
{
    FLOOR_TYPE,
    DOOR_TYPE,
    TILT_TYPE,
    ROOF_TYPE,
    TRIGGER_TYPE,
    LAVA_TYPE,
};

enum trigger_types
{
    TRIGGER,
    PAD,
    SWITCH,
    KEY,
    PICKUP,
    HEAVY,
    ANTIPAD,
    COMBAT,
    DUMMY,
    HINT,
    LAVA,
};

enum trigobj_types
{
    TO_OBJECT,
    TO_CAMERA,
    TO_SINK,
    TO_FLIPMAP,
    TO_FLIPON,
    TO_FLIPOFF,
    TO_TARGET,
    TO_FINISH,
    TO_CD,
    TO_FLIPEFFECT,
    TO_SECRET,
    TO_FX,
    TO_NOTHING,
};

enum HintState
{
    HINT_INACTIVE,
    HINT_INIT,
    HINT_UPDATE,
    HINT_SHUTDOWN,
};

enum InventoryType
{
    INV_TYPE_MAIN,
    INV_TYPE_KEYS,
    INV_TYPE_MAX,
};

struct TRFXNode : TRNode
{
    static uint32_t m_createCount;
    CoreFXEmitter* m_pEmitter;
    CoreHash m_emitterItemGroup;
    uint32_t m_emitterShape;
    float m_emitterGlobalRate;
    uint32_t m_emitterCullType;
    uint32_t m_backupCodeFlags;

    uint32_t CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
    void ForceEmitterReallocate();
    void Construct();
    void SetEmitterItemGroup(CoreHash iHash);
    CoreHash GetEmitterItemGroup();
    uint32_t GetEmitterShape();
    void SetEmitterShape();
    uint32_t Write(uint32_t* iBuffer);
    uint32_t Read(uint32_t* iBuffer);
    void Duplicate();
    TRFXNode* CreateAndConnectNode(CoreVector pos);
    void OnBeginEdit(bool iBeginEdit);
    void Update();
    void RenderDebug();
    void ForceUpdate();
    void CreateNodeName(uint32_t iNum);
    void CreateEmitter(CoreHash itemTemplate, float iGlobalRate, CoreVector iBoxSize);
    void AddEmitterItems(CoreHash itemTemplate);
    void TRFXNode();
    void ~TRFXNode();
};

struct TRObjectNode : TRNode
{
    uint32_t m_itemIndex;
    TRGameObject* m_pTRObject;

    void TRObjectNode();
    uint32_t CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
    void CreateFromEditorScene();
    void CreateFromEditorNode(TRNode* pNode);
    void SetupFromCoreObject(CoreObject* iObject);
    void Construct();
    void CreateNodeName(uint32_t iNum);
    void RenderDebug();
    TRGameObject* GetTRObject();
    TRNode* GetNodeFromTRItem(TRItem* iItem);
    void Update();
    void ~TRObjectNode();
};

struct TRSceneryNode : TRNode
{
    struct vinePresets
    {
        uint32_t m_vineType;
        uint32_t m_vineLength;
        float m_vineWeight;
        float m_vineWidth;
        float m_vineRad;
    };

    static char* m_pVineTypeNames[0];
    static uint32_t m_createCount;
    static TRSceneryNode::vinePresets m_vinePresets[0];
    static uint32_t m_numVinePresets;
    int32_t m_vineIndex;
    uint32_t m_vinePreset;

    uint32_t CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
    TRSceneryNode* CreateAndConnectNode(CoreVector iPos, uint32_t iType);
    void Construct();
    void UpdateVineType(uint32_t iIndex);
    uint32_t getVinePreset();
    uint32_t Write(uint32_t* iBuffer);
    uint32_t Read(uint32_t* iBuffer);
    void Update();
    void RenderDebug();
    void ForceUpdate();
    void Duplicate();
    void TRSceneryNode();
    void ~TRSceneryNode();
};

struct TRTriggerNode : TRNode
{
    enum trigEventGroupTypes
    {
        TT_REGULAR,
        TT_SWITCH,
        TT_KEY,
        TT_PICKUP,
        TT_PAD,
        TT_ANTIPAD,
        TT_COMBAT,
        TT_DUMMY,
        TT_TRIGGER,
        TT_HEAVY,
        TT_HINT,
        TT_LAVA,
        TT_MAX,
    };

    enum trigEventTypes
    {
        TE_OBJECT,
        TE_CAMERA,
        TE_TARGET,
        TE_SINK,
        TE_FLIPMAP,
        TE_FLIPON,
        TE_FLIPOFF,
        TE_FLIPEFFECT,
        TE_FINISH,
        TE_CD,
        TE_SECRET,
        TE_FX,
        TE_HINT,
        TE_LIGHT,
        TE_MAX,
    };

    enum
    {
        MAX_TRIGGER_EVENT_GROUPS = 256,
        MAX_TRIGGER_EVENTS = 16,
    };

    struct trigEvent
    {
        uint32_t m_eventTargetHash;
        uint32_t m_eventValue;
        uint32_t m_eventType;
        uint32_t m_eventTargetTimer;
        uint32_t m_eventTimer;
        uint32_t m_eventData;
        uint32_t m_pad[3];
    };

    struct trigEventGroup
    {
        uint32_t m_hashID;
        uint32_t m_nameStringIndex;
        uint32_t m_trigFlags;
        uint32_t m_trigType;
        uint32_t m_trigTimer;
        uint32_t m_trigNumEvents;
        uint32_t m_pad;
        uint32_t m_trigHashReqItem;
        TRTriggerNode::trigEvent m_triggerEvents[16];
    };

    struct trigEventGroupList
    {
        uint32_t m_numEventGroups;
        uint32_t m_createIndex;
        uint32_t m_pad[2];
        TRTriggerNode::trigEventGroup m_eventGroups[256];
    };

    struct trigEventGroupUpdate
    {
        TRTriggerNode::trigEventGroup* m_pEventGroup;
        uint32_t m_currentEventIndex;
        float m_eventTimer;
        FRPlayerObject* m_pPlayer;
    };

    static TRTriggerNode::trigEventGroupList m_trigEventGroups;
    static TRTriggerNode::trigEventGroupUpdate m_trigEventGroupUpdateList[32];
    static uint32_t* m_pTriggerEventBufferStart;
    static uint32_t* m_pTriggerEventBufferCur;
    static uint32_t m_triggerEventBufferMaxSize;
    TRTriggerBox* m_pItem;
    CoreHash m_hashEventGroup;
    int32_t m_eventGroupIndex;

    void TRTriggerNode();
    uint32_t CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled, int32_t i_numTriggers);
    uint32_t LoadNodes(CoreLevelCompiled* iLevelCompiled);
    void CreateFromEditorNode(TRNode* pNode);
    void SetupFromTriggerBox(TRTriggerBox* i_trigBox);
    void Construct();
    bool CheckTrigger(CoreVector iPos, uint32_t iFlip);
    TRTriggerBox* GetItem();
    void CreateNodeName(uint32_t iNum);
    uint32_t Read(uint32_t* iBuffer);
    TRTriggerNode::trigEventGroup* GetEventGroup(uint32_t iIndex);
    uint32_t GetNumEventGroups();
    int32_t GetEventGroupIndexFromHash(CoreHash iHash);
    CoreHash GetEventGroupHashFromIndex(int32_t iIndex);
    CoreHash GetEventHash();
    int32_t GetEventIndex();
    void GlobalUpdate();
    void InitEventScheduleList();
    void UpdateEventScheduleList();
    void AddScheduledGroup(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, uint32_t iEventIndex);
    void TestTriggers(FRPlayerObject* iPlayer, int32_t iEventIndex, int32_t iHeavy);
    uint32_t TriggerSingleEvent(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pEventGroup, TRTriggerNode::trigEvent* pEvent);
    void TriggerEventGroup(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pEventGroup, uint32_t iEventIndex);
    void TriggerEventSink(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    void TriggerEventSecret();
    uint32_t TriggerEventFlipOff(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    uint32_t TriggerEventFlipOn(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    uint32_t TriggerEventFlipMap(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    void TriggerEventTarget(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    void TriggerEventObject(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    void TriggerEventCamera(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    void TriggerEventFX(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    void TriggerEventHint(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    void TriggerEventLight(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
    bool PickupTrigger(TRTriggerNode::trigEventGroup* pEventGroup);
    bool SwitchTrigger(TRTriggerNode::trigEventGroup* pEventGroup);
    bool KeyTrigger(TRTriggerNode::trigEventGroup* pEventGroup, FRPlayerObject* iPlayer);
    uint32_t GetTriggerRoomArray(CoreVector iMin, CoreVector iMax, uint32_t* oRoomArray);
    void ParseTRTriggerEvents();
    void MakeTriggerEventGroup(uint32_t* iData, uint32_t iGroupIndex);
    uint32_t FixTriggerConnections(CoreHash iNewGroup, CoreHash iOldGroup, TRTriggerNode** oFixedTriggers);
    uint32_t FixEventConnections(CoreHash iNewNodeName, CoreHash iOldNodeName, uint32_t iNodeType, TRTriggerNode::trigEventGroup** oFixedEventGroups);
    uint32_t WriteTriggerEvents(char* iFileName);
    void LoadTriggerEvents();
    void Update();
    void RenderDebug();
    void ForceUpdate();
    void ~TRTriggerNode();
};

struct TREdObject : CoreAnimatingObject
{
    CoreS128Aligned m_memoryPot[256];
    TREdObjectData* m_data;

    void TREdObject();
    void Construct(CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
    void Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
    void Reset();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void UpdateGameCycle();
    void Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
    void Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    void SetObjectNumber();
    int32_t GetObjectNumber();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
    void AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
    CoreScripted::CommandReturn FnSetDefaultObjectTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultTextureTemplate(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetDefaultAnimSet(CoreCommand* io_command);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    void ~TREdObject();
};

struct TREdObjectData
{
    int32_t objectNumber;
    char modelExists;
    char textureExists;
    char animExists;
    int32_t current_anim;
};

struct TREdItemNode : TRNode
{
    TRGameObject* m_pTRObject;
    static uint32_t m_createCount;

    void TREdItemNode();
    void CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
    TREdItemNode* CreateAndConnectNode(CoreVector iPos, uint32_t iModel);
    void SetupFromObjectNode(TRObjectNode* iNode);
    void Construct();
    uint32_t WriteItemsFile(char* iFileName);
    TRGameObject* GetTRObject();
    void CreateNodeName(uint32_t iNum);
    void OnDelete();
    void Update();
    void RenderDebug();
    void ForceUpdate();
    void ~TREdItemNode();
};

struct TRETriggerNode : TRNode
{
    static uint32_t m_createCount;
    TRTriggerBox* m_pItem;
    CoreHash m_hashEventGroup;
    int32_t m_eventGroupIndex;
    static bool m_bShowEventConnections;

    void TRETriggerNode();
    void CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
    TRETriggerNode* CreateAndConnectNode(CoreVector iPos);
    void SetupFromEditorItem();
    void SetupFromTriggerNode(TRTriggerNode* iNode);
    void Construct();
    TRTriggerBox* GetItem();
    void SetEventGroupHash(CoreHash iHash);
    void SetEventGroupIndex();
    uint32_t Write(uint32_t* iBuffer);
    void CreateNodeName(uint32_t iNum);
    void SetEventVisibility();
    void Update();
    void RenderDebug();
    void ForceUpdate();
    void ~TRETriggerNode();
};

struct TRETriggerBox
{
    int32_t m_trigBoxIndex;
    CoreVector m_min;
    CoreVector m_max;
    int32_t m_room;
    int32_t m_eventIndex;

    void TRETriggerBox();
};

struct TRBGLightNode : TRNode
{
    int32_t m_controllerIndex;

    void TRBGLightNode();
    void Construct();
    void onChangeCodeBits();
    uint32_t CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
    void ~TRBGLightNode();
};

enum InvObjectType
{
    INV_OBJTYPE_NONE,
    INV_OBJTYPE_WEAPON,
    INV_OBJTYPE_HEALTH,
    INV_OBJTYPE_FLARES,
    INV_OBJTYPE_AMMO,
    INV_OBJTYPE_SAVEGAME,
};

enum BarState
{
    BAR_INACTIVE,
    BAR_INIT,
    BAR_UPDATE,
};

enum InventoryState
{
    INV_INACTIVE,
    INV_INIT,
    INV_OPENING,
    INV_UPDATE,
    INV_SELECT_MOVE,
    INV_SELECTED,
    INV_CLOSING,
    INV_SHUTDOWN,
};

enum QuickInvState
{
    QUICKINV_INACTIVE,
    QUICKINV_INIT,
    QUICKINV_UPDATE,
    QUICKINV_SHUTDOWN,
};

enum WhiteOutState
{
    WHITEOUT_INACTIVE,
    WHITEOUT_INIT,
    WHITEOUT_FADEUP,
    WHITEOUT_UPDATE,
    WHITEOUT_FADEDOWN,
    WHITEOUT_SHUTDOWN,
};

struct TRPanel : CorePanel
{
    struct OnScreenText
    {
        uint32_t m_timeStamp;
        uint32_t m_textHash;
        char m_text[64];
    };

    TRPanelPolyGroup m_polyGroups[12];
    int32_t m_numPolyGroups;
    bool m_TimerHilightFlag;
    float m_updateTime;
    int32_t m_playerID;
    TRPanel::OnScreenText m_OnScreenText[3];
    bool m_doSound;
    float m_fAirBarAlpha;
    float m_fAirFadingDir;
    BarState m_stateAirBar;
    float m_fAirBarTimer;
    float m_fHealthBarAlpha;
    float m_fHealthFadingDir;
    BarState m_stateHealthBar;
    float m_fHealthBarTimer;
    DISPLAY_PU pickups[3];
    float m_fPickUpRot;
    float m_fAmmoAlpha;
    float m_fAmmoFadingDir;
    bool m_bExitInventory;
    bool m_bInventoryOn;
    INV_DISPLAY m_Inventory[2][23];
    int32_t m_nInventoryCount[2];
    InventoryState m_nInventoryState;
    CoreHash m_hashItemName;
    int32_t m_nItemAmount;
    CoreVector m_vInvAxis;
    float m_fInvObjRotation;
    int32_t m_nCurrentInvItem[2];
    float m_fCurrentRingRot[2];
    float m_fTargetRingRot[2];
    bool m_bRingMoving;
    float m_fInvMoveDir;
    float m_fRingMoveDistance;
    CoreVector m_vInvSelPosMod;
    float m_fSelectScale;
    float m_fSelectScaleDir;
    float m_fCarouselSize;
    InventoryType m_nInvType;
    QuickInvState m_nQuickInvState;
    int32_t m_nQuickInvCurrent;
    INV_DISPLAY m_QuickInvItem;
    float m_fQuickInvTimer;
    HintState m_nHintState;
    int32_t m_nHintId;
    float m_fHintTimer;
    float m_fHintFade;
    bool m_bHintPressAvailable;
    WhiteOutState m_nWhiteOutState;
    float m_fWhiteOutFade;

    void Construct(CoreMemory* io_memory);
    void InitForNewLevel();
    void Update(CoreObjectUpdateStruct* io_updateStruct, float fTimeElapsed);
    void Render(CoreGameRender* io_graphics);
    void RenderComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
    int32_t GetPlayerIndex();
    void RenderHealth();
    void RenderAir(CoreMenuComponent* i_component, CoreGameRender* io_graphics, CoreHash i_name, FRPlayerObject* i_player);
    void RenderAmmoClips(CoreMenuComponent* i_component, CoreGameRender* io_graphics, CoreHash i_name, FRPlayerObject* i_player);
    void RenderBullets(CoreMenuComponent* i_component, CoreGameRender* io_graphics, CoreHash i_name, FRPlayerObject* i_player);
    void AirBarOn();
    void AirBarOff();
    void HealthBarOn();
    void HealthBarOff();
    void HealthHit();
    void HealthBarUpdate(float fTimeElapsed);
    void AirHit();
    void AirBarUpdate(float fTimeElapsed);
    void AmmoOn();
    void AmmoOff();
    bool IsInventoryOn();
    void InventoryOn(InventoryType invType);
    void InventoryOff();
    void InitialisePickUpDisplay();
    void HandlePickups();
    void AddDisplayPickup(int32_t objnum);
    void SetupInventoryRingLayout();
    void ShowInventoryType(InventoryType nType);
    void InitialiseInventoryDisplay();
    void AddToInventoryDisplay(int32_t objnum, InventoryType invType, int32_t nAmount);
    void KillInventoryDisplay();
    void HandleInventoryDisplay(float fTimeElapsed);
    void PopulateInventoryDisplay();
    void ProcessRingMovement();
    void ProcessItemUse();
    uint32_t FindInventoryItemName(int32_t nItemNum);
    void ProcessItemSelection();
    void SetInvObjectPositions();
    void UpdateSelectionMovement();
    int32_t FindInventoryItemIndex(int32_t nItemNum);
    bool AreKeysAvailable();
    bool SendInvItemToNetworkPlayer();
    void QuickInvOn();
    void QuickInvOff();
    void InitialiseQuickInvDisplay();
    void HandleQuickInvDisplay(float fTimeElapsed);
    InvObjectType GetInvItemUseType();
    bool IsQuickInvOn();
    bool ArePlayersWithinGivenDistance(float fDistance);
    void ActivateInventoryMenuOptions();
    void CheckForRecievedItem();
    bool CanSwapItemType();
    void ShowHint(int32_t nHintId, float fTimer);
    void HintUpdate(float fTimeElapsed);
    bool IsHintShowing();
    void SetHintPressActive(bool bTF);
    bool IsHintPressAvailable();
    void StartWhiteOut();
    void EndWhiteOut();
    void DoDebug(CoreDebugInput* i_input);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreVector ConvertScreenCoords();
    void RenderComponentPosUV(CoreMenuComponent* i_component, CoreGameRender* io_graphics, float i_x0, float i_y0, float i_x1, float i_y1, float i_u0, float i_v0, float i_u1, float i_v1, CoreRGBA i_rgba);
    void RenderHint(CoreGameRender* io_graphics);
    void RenderMyComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
    CoreScripted::CommandReturn FnConvertCoordinateSpace();
    CoreScripted::CommandReturn FnResetPolylist(CoreCommand* io_command);
    CoreScripted::CommandReturn FnAddPolylist(CoreCommand* io_command);
    CoreScripted::CommandReturn FnAddPolylistPoint(CoreCommand* io_command);
    CoreScripted::CommandReturn FnAddPolylistPoly(CoreCommand* io_command);
    float ComponentSpaceToScreenSpace();
    void ResetPolyGroups();
    bool IsScreenSplitVertically();
    bool IsScreenSplitHorizontally();
    void ProcessBarFade(float& io_fFadeLevel, float& io_fFadeDir, float fTimeElapsed);
    void RenderWhiteOut(CoreGameRender* pGR);
    void WhiteOutUpdate(float fTimeElapsed);
    TRPanelPolyGroup* GetPolyGroupByHash();
    void TRPanel();
    void ~TRPanel();
};

struct TRPanelPoint
{
    float m_x;
    float m_y;
    uint32_t m_index;
};

struct TRPanelTriangle
{
    uint32_t m_pointIndices[3];
    uint32_t m_groupID;
};

struct TRPanelPolyGroup
{
    TRPanelPoint m_points[32];
    TRPanelTriangle m_tris[20];
    int32_t m_numPoints;
    int32_t m_numTris;
    CoreHash m_nameHash;
    int32_t m_numPolys;

    void CalculateNumPolys();
    void TRPanelPolyGroup();
    void ~TRPanelPolyGroup();
};

struct DISPLAY_PU
{
    float duration;
    TRInvObject* object;
};

struct INV_DISPLAY
{
    TRInvObject* object;
    int32_t objNum;
    float fRingPos;
    int32_t nAmount;
};

struct TREItem
{
    int32_t m_itemIndex;
    int32_t m_objNum;
    int32_t m_roomNum;
    CoreVector m_pos;
    int32_t m_shade;
    int32_t m_flags;
    TREdObject* m_object;

    void TREItem();
};

struct TREditItems
{
    bool m_inited;
    bool m_loaded;
    bool m_renderItemPositions;
    bool m_renderItemNames;
    int32_t m_numItems;
    TREItem m_items[256];

    void Init();
    void LoadData();
    void SaveData();
    char* GetNextToken();
    void DeleteItem();
    void Render();
    void TREditItems();
};

struct TRETriggerEvent
{
    int32_t m_length;
    int32_t* m_data;
};

struct TREditTriggers
{
    bool m_inited;
    bool m_loaded;
    bool m_renderBoxes;
    bool m_renderEvents;
    bool m_renderLinks;
    TRETriggerBox m_triggerBoxes[256];
    TRETriggerEvent m_triggerEvents[256];
    int32_t m_numTriggerBoxes;
    int32_t m_numTriggerEvents;

    void Init();
    void LoadData();
    void SaveData();
    TRETriggerEvent* GetFreeTriggerEvent();
    void Render();
    void RenderTriggerLinks(TRETriggerBox* box);
    void AddText(CoreVector* i_pos, char* i_str, CoreRGBA i_colour);
    void TREditTriggers();
};

struct TRECamera
{
    CoreVector m_pos;
    int32_t m_type;

    void TRECamera();
};

struct TREditCameras
{
    bool m_inited;
    bool m_loaded;
    bool m_renderCameras;
    TRECamera m_cameras[256];

    void Init();
    void LoadData();
    void SaveData();
    void Render();
    void TREditCameras();
};

struct TREditor
{
    HWND* m_gameHwnd;
    HINSTANCE__* m_gameHinst;
    HWND* m_generalDialog;
    HWND* m_itemsDialog;
    HWND* m_triggersDialog;
    HWND* m_hWndNodeDialog;
    HWND* m_hWndEventDialog;
    TREditItems m_editItems;
    TREditTriggers m_editTriggers;
    TREditCameras m_editCameras;
    bool m_inited;
    bool m_active;
    CoreInput* m_input;
    float m_mouseX;
    float m_mouseY;
    float m_mouseXDelta;
    float m_mouseYDelta;
    TREditor::__unnamed m_deviceMouse;
    int32_t m_selectedItemIndex;
    int32_t m_selectedTrigBoxIndex;
    bool m_forceCameraUpdate;
    CoreVector m_camPos;
    CoreVector m_camTargetPos;
    CoreEulerAngle m_camOrient;
    bool m_viewRoomCentric;
    bool m_viewRoomBounds;
    uint32_t m_roomNumber;
    int32_t m_previousRoom;
    bool m_nodeDisplayState[11];

    void GlobalInit();
    void LevelInit();
    void Update();
    void Render();
    void Load();
    void Save();
    void CreateMainDialog();
    void CreateItemsDialog();
    void CreateTriggersDialog();
    void CreateNodeDialog();
    void CreateEventDialog();
    void PopulateEventDialog();
    void PopulateNodeDialog(TRManipNode* iManip, bool iFullUpdate);
    void PopulateRoomDialog(TRManipNode* iManip, bool iFullUpdate);
    void SetActive(bool i_active);
    bool IsActive();
    void ReadMouse();
    void SetupCamera();
    void UpdateCamera();
    void RestartLevel();
    void TREditor();
};

struct CoreFile
{
    enum
    {
        VERSION = 13,
    };

    int32_t m_fileSize;
    int32_t m_virtualFilePos;
    int32_t m_actualFilePos;
    int32_t m_bufferPos;
    int32_t m_bufferData;
    int32_t m_bufferSize;
    char* m_buffer;
    bool m_enableCaching;
    bool m_readEndianConversion;
    bool m_writeEndianConversion;
    CoreFileHandle m_fileHandle;
    static CoreFileSystem* s_fileSystem;
    static CoreMemory* s_globalMemory;
    CoreMemory* m_memory;
    CoreStringBuffer<256> m_fileName;
    static CoreStringBuffer<256> m_downLoadContentGamePath;

    void CoreFile();
    void ~CoreFile();
    void Zero();
    void Clear();
    bool Save();
    void* Load();
    bool Open(char* i_name, char* i_attrib);
    bool Close();
    bool IsValid();
    bool Read();
    bool Write();
    bool Seek(int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin);
    int32_t Size();
    int32_t Peek();
    int32_t Tell();
    bool UpdateOffset();
    void AttachFileSystem(CoreFileSystem* i_fileSystem);
    CoreFileSystem* GetFileSystem();
    void SetGlobalMemoryPtr(CoreMemory* i_memory);
    CoreMemory* GetGlobalMemoryPtr();
    int32_t GetFileSize(char* i_fileName);
    bool GetFileTimes();
    bool SetFileTimes();
    bool DoesFileExist(char* i_fileName);
    bool IsReadOnly();
    bool ChangeReadOnly();
    int32_t LoadFileSection();
    CoreQWORD* LoadFile();
    bool CreateEmptyFile(char* i_fileName);
    bool CopyFileA();
    bool IsReading();
    bool IsWriting();
    void SetWriteEndianConversion();
    void SetReadEndianConversion();
    bool GetWriteEndianConversion();
    bool GetReadEndianConversion();
    char* GetFileName();
    bool PadToNBytes();
    void EnableCaching();
    bool IsCachingEnabled();
    void SetDownLoadContentGamePath(char* i_gamePath);
    bool CompleteDownLoadContentFileName();
    CoreU128 GetMD5Hash();
    void InitBuffer();
    int32_t iReadBuffer(void* i_dest, int32_t i_dataSize, int32_t i_count);
    int32_t iWriteBuffer(void* i_src, int32_t i_dataSize, int32_t i_count);
    void FillBuffer();
    void EmptyBuffer();
    void BufferTransfer(void* i_dest, int32_t i_sizeBytes);
    int32_t ReadFile(void* i_dest, int32_t i_dataSize, int32_t i_count);
    int32_t WriteFile(void* i_src, int32_t i_dataSize, int32_t i_count);
    bool SetPosFile(int32_t i_pos);
    CoreMemory* GetMemoryPtr();
    char* GetDownLoadContentRootPath();
};

struct CoreU128
{
    uint32_t ui64one;
    uint32_t ui64two;
};

struct CoreS128
{
    int32_t i64one;
    int32_t i64two;
};

struct CoreQWORD
{
    CoreU128 qwData;
    uint32_t ul64[2];
    uint32_t ui32[4];
};

struct CoreDateTime
{
    int32_t m_year;
    int32_t m_milliSeconds;
    int32_t m_month : 5;
    int32_t m_day : 6;
    int32_t m_hour : 6;
    int32_t m_minute : 7;
    int32_t m_second : 7;

    void CoreDateTime();
    void Reset();
    void Set();
    CoreDateTime& operator=();
    void SetToCurrent();
    CoreDateTime& GetCurrent();
    CoreDateTime& GetDummy();
    char* GetTimeString(char* o_timeStringBuffer, char dateSeperator, char timeSeperator);
    bool IsTimeValid();
    bool IsTimeInvalid();
    int32_t GetYear();
    int32_t GetMonth();
    int32_t GetDay();
    int32_t GetHour();
    int32_t GetMinute();
    int32_t GetSecond();
    int32_t GetMilliSeconds();
    int32_t GetCompareValue();
    bool IsSameTime();
    bool IsNotSameTime();
    bool operator==();
    bool operator!=();
    bool SetFromPS2();
    bool ConvertToPS2();
    bool SetFromPC(_FILETIME* i_fileTimePC);
    bool ConvertToPC(_FILETIME* o_fileTimePC);
    bool SetFromPSP();
    bool ConvertToPSP();
};

enum FXVines
{
    FXV_ROOT,
    FXV_VINE,
    FXV_COBWEB,
    FXV_NUM_VINE_TYPES,
};

struct TRRoomEffects
{
    uint32_t m_wibble1;
    uint32_t m_wibble2;
    uint32_t m_wibble3;
    uint32_t m_wibble4;
    uint32_t m_wibbleRandTable[64];
    int32_t m_waterGouraudWibbleTable[64];
    int32_t m_waterVertexWibbleTable[64];
    int32_t m_waterfallGouraudWibbleTable[64];
    int32_t m_waterfallVertexWibbleTable[64];
    int32_t m_numWaterMeshes;
    TRRoomEffectsMesh m_waterMeshes[16];
    int32_t m_numWaterfallMeshes;
    TRRoomEffectsMesh m_waterfallMeshes[32];
    TRRoomEffectPointers m_roomEffectPointers[512];
    TRVineStruct m_vines[256];
    CoreVector m_totalFogColour;
    float m_totalFogDivider;

    void TRRoomEffects();
    void InitialiseRoomEffects();
    void GetWaterMeshPointers();
    void GetWaterfallMeshPointers();
    void UpdateRoomEffects();
    void UpdateWaterGourauds(TRRoomEffectsMesh* i_meshPointers, int32_t i_numMeshes);
    void UpdateWaterfalls(TRRoomEffectsMesh* i_meshPointers, int32_t i_numMeshes);
    bool ProcessFogBulb(TRFogBulbStruct* i_fogBulb);
    void UpdateVines();
    int32_t SetupVine(int32_t i_index, CoreVector i_pos, int32_t i_numSpheres, float i_radius, float i_width, float i_weight, int32_t i_vineType);
    void RenderVines();
    void DrawVine();
    void SetVineActive();
    void SetVinePosition();
};

struct TRRoomEffectsMesh
{
    uint32_t numVerts;
    uint32_t* geomVerts;
    TRRoomEffectsMeshVertex* meshVerts;
};

struct TRFogBulbStruct
{
    CoreVector pos;
    CoreRGBA colour;
    float innerRad;
    float outerRad;
    bool particles;

    void TRFogBulbStruct();
};

struct TRVineDrawStruct
{
    int32_t numSpheres;
    float width;
    CoreVector* spheres;
    uint32_t blendType;
    int32_t fxMaterial;
    CoreRGBA* sphereColours;
};

struct TRRoomEffectsMeshVertexPos
{
    int32_t x;
    int32_t y;
    int32_t z;
};

struct TRRoomEffectsMeshVertex
{
    TRRoomEffectsMeshVertexPos origPos;
    uint32_t randIndex;
    CoreRGBA col;

    void TRRoomEffectsMeshVertex();
};

struct TRRoomEffectPointers
{
    int32_t numWaterMeshes;
    TRRoomEffectsMesh* waterMeshes;
    int32_t numWaterfallMeshes;
    TRRoomEffectsMesh* waterfallMeshes;
};

struct TRVineSphereStruct
{
    CoreVector pos;
    CoreVector vel;

    void TRVineSphereStruct();
};

struct TRVineStruct
{
    bool allocated;
    bool active;
    int32_t numSpheres;
    float sphereRadius;
    float weight;
    float width;
    uint32_t blendType;
    int32_t fxMaterial;
    TRVineSphereStruct spheres[16];
    CoreRGBA colours[16];
    bool hitLara;

    void TRVineStruct();
};

struct TRHitItem
{
    enum
    {
        HIF_ACTIVE = 1,
        HIF_UPDATEPOSX = 2,
        HIF_UPDATEPOSY = 4,
        HIF_UPDATEPOSZ = 8,
        HIF_UPDATEPOSITION = 14,
        HIF_UPDATEROTX = 16,
        HIF_UPDATEROTY = 32,
        HIF_UPDATEROTZ = 64,
        HIF_UPDATEROTATION = 112,
        HIF_UPDATESCLX = 128,
        HIF_UPDATESCLY = 256,
        HIF_UPDATESCLZ = 512,
        HIF_UPDATESCALE = 896,
        HIF_NODE = 1024,
        HIF_ROOM = 2048,
        HIF_MANIPHANDLE = 4096,
        HIF_PICKQUEUE = 8192,
        HIF_DUMMY = 16384,
    };

    enum itemShape
    {
        HISHAPE_CUBE,
        HISHAPE_SPHERE,
        HISHAPE_CONE,
    };

    uint32_t m_itemFlags;
    uint32_t m_itemIndex;
    uint32_t m_itemShape;
    uint32_t m_itemTick;
    CoreNode* m_itemNode;
    CoreSceneContainer* m_itemRoom;
    CoreVector m_posOffset;
    CoreEulerAngle m_rotation;
    static TRHitItem m_itemArray[1024];
    static uint32_t m_itemsInScope[1024];
    static bool m_processNodes[11];
    static uint32_t m_numItemsInScope;
    static int32_t m_pickedItem;
    static int32_t m_lastManipItem;

    void TRHitItem();
    void ~TRHitItem();
    void initHitItems();
    void processScene(uint32_t* iVisibleList, uint32_t iVisibleCount);
    void renderScene();
    void processNodeChain(CoreNodeRoot* pChainRoot);
    void createAndAttachItem();
    void createItemsFromChain(CoreNode* pFirstNode);
    int32_t getFreeItem();
    CoreNode* GetPickedItemNode();
    CoreSceneContainer* GetPickedItemRoom();
    TRHitItem* GetPickedItem();
    TRHitItem* GetItemAddress(int32_t iItem);
    void SetPickedItem();
    CoreVector GetItemPosition();
    CoreVector GetItemOrientation();
    CoreVector GetItemScale();
    void updateItemPosition(CoreVector iPos);
    void updateItemOrientation();
    void updateItemScale(CoreVector iScl);
    uint32_t GetItemNodeType();
    int32_t GetItemIndex();
    void renderHandle();
    uint32_t GetItemFlags(int32_t iIndex);
    void SetItemFlags(int32_t iIndex, uint32_t iFlags);
    void SetItemShape(int32_t iIndex, TRHitItem::itemShape iShape);
    void SetRotation(int32_t iIndex, float iX, float iY, float iZ);
    int32_t GetPickedItemIndex();
};

struct TRECameraNode : TRNode
{
    static uint32_t m_createCount;
    uint32_t m_oldCameraIndex;
    uint32_t m_camData;

    uint32_t CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
    void Construct();
    uint32_t Write(uint32_t* iBuffer);
    void SetupFromCameraNode(TRCameraNode* iNode);
    void CreateNodeName(uint32_t iNum);
    TRECameraNode* CreateAndConnectNode(CoreVector iPos);
    void Update();
    void RenderDebug();
    void ForceUpdate();
    void TRECameraNode();
    void ~TRECameraNode();
};

struct TRManipNode : TRNode
{
    enum
    {
        MANIP_TRANS,
        MANIP_ROT,
        MANIP_SCALE,
    };

    static TRManipNode m_manipNode;
    int32_t m_manipHitItem;
    int32_t m_localManipHitItem;
    uint32_t m_hitIndexCount;
    int32_t m_hitIndexArray[4];
    uint32_t m_manipType;
    CoreVector m_oldPos;

    void CreateAndConnectNodes();
    void Construct();
    void InitManipulator();
    TRManipNode* GetManipNode();
    void updateManipNode(TRHitItem* pHitItem);
    void captureHitItem(TRHitItem* pHitItem);
    void renderManip();
    void resetManipHandles();
    void releaseCapture();
    void duplicateSelection();
    void deleteSelection();
    void setManipType(uint32_t iType);
    void SetHitIndex(int32_t iIndex);
    int32_t GetHitIndex(uint32_t iUseIndex);
    void Update();
    void RenderDebug();
    void TRManipNode();
    void ~TRManipNode();
};

struct RegVal
{
    enum TYPE
    {
        REGVAL_S32,
        REGVAL_U32,
        REGVAL_STRING,
        REGVAL_B8,
        REGVAL_F32,
        REGVAL_SIZE,
        REGVAL_POINT,
        REGVAL_RECT,
    };

    RegVal::TYPE m_type;
    uint32_t* m_value;
    int32_t* m_intValue;
    uint32_t* m_uintValue;
    char* m_stringValue;
    uint32_t* m_boolValue;
    float* m_floatValue;
    tagSIZE* m_sizeValue;
    tagPOINT* m_pointValue;
    tagRECT* m_rectValue;
    static char* RegistryKey;
    static char m_registryBuffer[0];
    static char* m_subKeyBuffer;
    char* m_subKey;
    char* m_key;
    uint32_t m_size;

    // TODO vtable

    void RegVal();
    void ~RegVal();
    void Read();
    void Write();
};

struct PICKTYPE
{
    uint32_t m_nodeType;
    char* m_str;
};

struct tagRECT
{
    int32_t left;
    int32_t top;
    int32_t right;
    int32_t bottom;
};

struct tagCHOOSECOLORA
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HWND* hInstance;
    uint32_t rgbResult;
    uint32_t* lpCustColors;
    uint32_t Flags;
    int32_t lCustData;
    uint32_t* lpfnHook;
    char* lpTemplateName;
};

enum CoreMouseID
{
    CORE_MOUSE_LEFT = 0,
    CORE_MOUSE_RIGHT = 1,
    CORE_MOUSE_WHEELBUTTON = 2,
    CORE_MOUSE_LEFTSIDE = 3,
    CORE_MOUSE_RIGHTSIDE = 4,
    CORE_MOUSE_WHEEL_UP = 5,
    CORE_MOUSE_WHEEL_DOWN = 6,
    CORE_MOUSE_BUTTON_COUNT = 7,
    CORE_MOUSE_MOVE_UP = 7,
    CORE_MOUSE_MOVE_DOWN = 8,
    CORE_MOUSE_MOVE_LEFT = 9,
    CORE_MOUSE_MOVE_RIGHT = 10,
    CORE_MOUSE_ABSOLUTE_X = 11,
    CORE_MOUSE_ABSOLUTE_Y = 12,
    CORE_MOUSE_INPUT_COUNT = 13,
};

enum CoreKeyID
{
    CORE_KEY_INVALID,
    CORE_KEY_0,
    CORE_KEY_1,
    CORE_KEY_2,
    CORE_KEY_3,
    CORE_KEY_4,
    CORE_KEY_5,
    CORE_KEY_6,
    CORE_KEY_7,
    CORE_KEY_8,
    CORE_KEY_9,
    CORE_KEY_A,
    CORE_KEY_B,
    CORE_KEY_C,
    CORE_KEY_D,
    CORE_KEY_E,
    CORE_KEY_F,
    CORE_KEY_G,
    CORE_KEY_H,
    CORE_KEY_I,
    CORE_KEY_J,
    CORE_KEY_K,
    CORE_KEY_L,
    CORE_KEY_M,
    CORE_KEY_N,
    CORE_KEY_O,
    CORE_KEY_P,
    CORE_KEY_Q,
    CORE_KEY_R,
    CORE_KEY_S,
    CORE_KEY_T,
    CORE_KEY_U,
    CORE_KEY_V,
    CORE_KEY_W,
    CORE_KEY_X,
    CORE_KEY_Y,
    CORE_KEY_Z,
    CORE_KEY_BACK,
    CORE_KEY_RETURN,
    CORE_KEY_SPACE,
    CORE_KEY_MINUS,
    CORE_KEY_EQUALS,
    CORE_KEY_LBRACKET,
    CORE_KEY_RBRACKET,
    CORE_KEY_SEMICOLON,
    CORE_KEY_APOSTROPHE,
    CORE_KEY_SLASH,
    CORE_KEY_COMMA,
    CORE_KEY_PERIOD,
    CORE_KEY_BACKSLASH,
    CORE_KEY_TILDA,
    CORE_KEY_NUMPAD7,
    CORE_KEY_NUMPAD8,
    CORE_KEY_NUMPAD9,
    CORE_KEY_NUMPAD4,
    CORE_KEY_NUMPAD5,
    CORE_KEY_NUMPAD6,
    CORE_KEY_NUMPAD1,
    CORE_KEY_NUMPAD2,
    CORE_KEY_NUMPAD3,
    CORE_KEY_NUMPAD0,
    CORE_KEY_SUBTRACT,
    CORE_KEY_ADD,
    CORE_KEY_DECIMAL,
    CORE_KEY_NUMPADENTER,
    CORE_KEY_MULTIPLY,
    CORE_KEY_DIVIDE,
    CORE_KEY_GRAVE,
    CORE_KEY_ESCAPE,
    CORE_KEY_TAB,
    CORE_KEY_LCONTROL,
    CORE_KEY_LSHIFT,
    CORE_KEY_RSHIFT,
    CORE_KEY_LMENU,
    CORE_KEY_CAPITAL,
    CORE_KEY_F1,
    CORE_KEY_F2,
    CORE_KEY_F3,
    CORE_KEY_F4,
    CORE_KEY_F5,
    CORE_KEY_F6,
    CORE_KEY_F7,
    CORE_KEY_F8,
    CORE_KEY_F9,
    CORE_KEY_F10,
    CORE_KEY_NUMLOCK,
    CORE_KEY_SCROLL,
    CORE_KEY_F11,
    CORE_KEY_F12,
    CORE_KEY_RCONTROL,
    CORE_KEY_NUMPADCOMMA,
    CORE_KEY_SYSRQ,
    CORE_KEY_RMENU,
    CORE_KEY_PAUSE,
    CORE_KEY_HOME,
    CORE_KEY_UP,
    CORE_KEY_PRIOR,
    CORE_KEY_LEFT,
    CORE_KEY_RIGHT,
    CORE_KEY_END,
    CORE_KEY_DOWN,
    CORE_KEY_NEXT,
    CORE_KEY_INSERT,
    CORE_KEY_DELETE,
    CORE_KEY_LWIN,
    CORE_KEY_RWIN,
    CORE_KEY_APPS,
    CORE_KEY_POWER,
    CORE_KEY_SLEEP,
    CORE_KEY_INPUT_COUNT,
};

enum eMULTIPLAYER_MODE
{
    MM_MULTIPLAYER = (1 << 0),
    MM_NETWORKED = (1 << 1),
    MM_SERVER = (1 << 2),
    MM_IN_LOBBY = (1 << 3),
    MM_SPLIT_SCREEN = (1 << 4),
    MM_SPLIT_IS_HORIZONTAL = (1 << 4),
};

struct TRInvObjectData
{
    int32_t objectNumber;
    char modelExists;
    char textureExists;
    char animExists;
    int32_t current_anim;
};

enum inv_order
{
    MAP_POS,
    GUN_POS,
    SGN_POS,
    MAG_POS,
    UZI_POS,
    EXP_POS,
    BGM_POS,
    MED_POS,
    CRY_POS,
    FLR_POS,
};

enum inv_order2
{
    LBAR_POS = 100,
    KY1_POS,
    KY2_POS,
    KY3_POS,
    KY4_POS,
    PZ4_POS,
    PZ3_POS,
    PZ2_POS,
    PZ1_POS,
    SCN_POS,
    PK2_POS,
    PK1_POS,
};

enum inv_order3
{
    PASSPORT_POS = 200,
    SOUND_POS,
    CONTROL_POS,
    PHOTO_POS,
};

struct TRInvInitList
{
    int32_t m_quantity;
    TRInvInit* m_initItem;
};

enum InvMenuOption
{
    INV_MENU_OPTION_NOSELECTION = 255,
    INV_MENU_OPTION_CANCEL = 0,
    INV_MENU_OPTION_USE = 1,
    INV_MENU_OPTION_COMBINE = 2,
    INV_MENU_OPTION_GIVE = 3,
};

enum CorePadID
{
    CORE_PAD_TRIANGLE = 0,
    CORE_PAD_CIRCLE = 1,
    CORE_PAD_CROSS = 2,
    CORE_PAD_SQUARE = 3,
    CORE_PAD_L2 = 4,
    CORE_PAD_R2 = 5,
    CORE_PAD_L1 = 6,
    CORE_PAD_R1 = 7,
    CORE_PAD_SELECT = 8,
    CORE_PAD_L3 = 9,
    CORE_PAD_R3 = 10,
    CORE_PAD_START = 11,
    CORE_PAD_DPAD_UP = 12,
    CORE_PAD_DPAD_RIGHT = 13,
    CORE_PAD_DPAD_DOWN = 14,
    CORE_PAD_DPAD_LEFT = 15,
    CORE_PAD_BUTTON_COUNT = 16,
    CORE_PAD_LANALOG_UP = 16,
    CORE_PAD_LANALOG_DOWN = 17,
    CORE_PAD_LANALOG_LEFT = 18,
    CORE_PAD_LANALOG_RIGHT = 19,
    CORE_PAD_RANALOG_UP = 20,
    CORE_PAD_RANALOG_DOWN = 21,
    CORE_PAD_RANALOG_LEFT = 22,
    CORE_PAD_RANALOG_RIGHT = 23,
    CORE_PAD_INPUT_COUNT = 24,
};

struct _player_inventory_event
{
    uint32_t uType;
    int32_t nItem;
    uint32_t nEventId;
    uint32_t nPlayerId;
};

struct CoreCurveSetData
{
    enum
    {
        VERSION = 2,
    };

    float m_fOriginX;
    float m_fOriginY;
    float m_fOriginZ;
    float m_fSize;
    float m_fBBOXminX;
    float m_fBBOXminY;
    float m_fBBOXminZ;
    float m_fBBOXmaxX;
    float m_fBBOXmaxY;
    float m_fBBOXmaxZ;
    float m_fTotalLength;
    uint32_t m_uiHash;
    int32_t m_iSegmentDataOffset;
    int32_t m_sNumPoints;
    int32_t m_sNumSegments;
    uint32_t m_ucOrderOpen;
    uint32_t m_ucDimension;
    uint32_t m_pad;
    int32_t m_ControlPointData[1];

    void CoreCurveSetData();
    void ~CoreCurveSetData();
    CoreVector GetOrigin();
    float GetSize();
    CoreVector GetBBOXmin();
    CoreVector GetBBOXmax();
    float GetTotalLength();
    uint32_t GetHash();
    int32_t GetNumPoints();
    int32_t GetNumSegments();
    int32_t GetOrder();
    int32_t GetDimension();
    bool Is3D();
    bool Is2D();
    bool IsSpline();
    bool IsLine();
    bool IsOpen();
    bool IsClosed();
    bool IsVolume();
    CoreCurveDataSegment* GetSegmentPtr();
    CoreVector GetPoint(int32_t iPoint);
    float GetSegmentLength();
    CoreVector GetSegmentBBOXmin();
    CoreVector GetSegmentBBOXmax();
    CoreVector GetPosition(float fLength, int32_t& iSegment, float& fAlpha);
    CoreVector GetTangent(float fLength);
    float GetNearestPointSlow();
    float GetNearestPoint(CoreVector& vPoint, CoreVector& vNearestPoint, float& fDistance, int32_t& iBestSegment, float& fSegmentAlpha);
    float GetNearestPointFast(CoreVector& vPoint, CoreVector& vNearestPoint, float& fDistance, int32_t& iBestSegment, float& fSegmentAlpha);
    CoreVector GetSegmentPosition(int32_t iSegment, float fAlpha);
    CoreVector GetSegmentTangent(int32_t iSegment, float fAlpha);
    void GetControlPoints(int32_t iSegment, CoreVector& vPoint0, CoreVector& vPoint1, CoreVector& vPoint2, CoreVector& vPoint3);
    bool bWithinSegmentBBOX();
    float fMinDistanceToSegmentBBOX();
    bool IsWithinVolume(CoreVector& vPoint);
    bool bKeepWithinVolumeXZ();
    bool bKeepWithinVolumeAlongRayXZ();
    int32_t iLineIntersectsVolumeXZ(CoreVector& vStart, CoreVector& vEnd, int32_t iMaxNumCrossingPoints, CoreVector* lpvCrossingPoints, bool* lpbCrossingPointsEnteringVolume);
};

struct SplineControl
{
    int32_t objectType;
    float actualPos;
    float moveSpeed;
    float waitTime;
    CoreCurveSetData* curve;
    CoreHash curveName;

    void SplineControl();
    void ~SplineControl();
};

struct aiCharacterAnim
{
    CoreHash actionName;
    CoreHash animationName;

    void aiCharacterAnim();
    void ~aiCharacterAnim();
};

enum RouteMode
{
    NOT_ROUTING,
    TURNING,
    MOVING,
};

enum AnimMode
{
    NOT_ANIMATING,
    ANIMATE_FOREVER,
    ANIMATE_ONCE,
    ANIMATE_JUST_SET,
    ANIMATE_FOR_TIME,
};

struct CoreFXEffect
{
};

struct FRBackgroundObjectData
{
    SplineControl splineControl;
    RouteMode routeMode;
    AnimMode animMode;
    float targetHeading;
    CoreVector targetPos;
    float timer;
    float maxDisplayDistance;
    int32_t distanceFadeFlag;
    float distanceFadeValue;
    bool doDistanceFade;
    bool skyBox;
    bool isPlane;
    bool isArrow;
    bool isSweep;
    bool isCutSceneSweep;
    CoreVector vArrowTarget[2];
    CoreQuat qAtOld[2];
    uint32_t uArrowFlags[2];
    bool bArrowFirstTime[2];
    float triggerRadius;
    bool trigger;
    bool firstTrigger;
    bool interact;
    bool firstInteract;
    bool isNPC;
    bool aiFirstTime;
    char aiNode;
    float aiHeading;
    bool aiRunning;
    aiCharacterAnim aiAnims[4];
    char aiNumAnims;
    CoreHash aiAnimAction;
    CoreHash aiModeHash;
    float aiTimer;
    char aiState;
    bool aiStateFirstTime;
    float aiInteractionDistance;
    bool aiFacePlayer;
    CoreHash aiNearbyModeHash;
    CoreFXEffect* aiAttachedEffect;
    int32_t missionPointFlags;
    CoreVector soundVectors[8];
    CoreHash soundHashs[8];
    int32_t numSounds;
    bool bTopTexDone;
    bool bTrouserTexDone;
    bool bTrainerTexDone;
    bool playingSwoosh;
    uint32_t lastSurfaceType;

    void FRBackgroundObjectData();
    void ~FRBackgroundObjectData();
};

struct CoreFont
{
    enum
    {
        VERSION = 3,
    };

    static uint32_t s_fontCompiledID;
    uint32_t m_version;
    uint32_t m_fileID;
    uint32_t m_numRanges;
    uint32_t m_numGlyphs;
    uint32_t m_numTextures;
    char m_textureSetString[256];
    CoreHash m_neverUseThis;
    uint32_t m_screenWidth;
    uint32_t m_screenHeight;
    uint32_t m_offsetRanges;
    uint32_t m_offsetGlyphs;
    uint32_t m_offsetTextures;
    static CoreFontTextureInfo m_fontTextureInfo[4];
    static int32_t m_fontTextureInfoCount;
    static CoreHash m_textureSetHash;
    static CoreHash m_triangleButtonHash;
    static CoreHash m_circleButtonHash;
    static CoreHash m_crossButtonHash;
    static CoreHash m_squareButtonHash;
    static CoreHash m_leftShoulderButtonHash;
    static CoreHash m_rightShoulderButtonHash;

    bool CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
    void DrawStringID(CoreGameRender* io_graphics, CoreVector& i_pos, CoreHash i_stringID, float i_scaleX, float i_scaleY, CoreRGBA i_col, int32_t i_flags);
    CoreVector GetStringIDSize(CoreHash i_stringID, float i_scaleX, float i_scaleY);
    void DrawString(CoreGameRender* io_graphics, CoreVector& i_pos, char* i_string, float i_scaleX, float i_scaleY, CoreRGBA i_col, int32_t i_flags);
    void DrawStringSpecial();
    CoreVector GetStringSize(char* i_string, float i_scaleX, float i_scaleY);
    CoreFontGlyph* FindGlyph(uint32_t i_char);
    bool FindGlyphIndex();
    CoreHash* GetTextureIDs();
    CoreFontGlyph* GetGlyphs();
    CoreFontRange* GetRanges();
    uint32_t GetNumTextures();
    CoreHash GetTextureSetName();
    void GetCharacterUnscaledWidthAndHeight();
    bool AnyUnknownCharactersID();
    bool AnyUnknownCharacters();
    bool IsCharacterInFont(uint32_t i_unicode);
    void ResetCache();
    void SetButtonTextures(CoreHash i_textureSetHash, CoreHash i_triangleButtonHash, CoreHash i_circleButtonHash, CoreHash i_crossButtonHash, CoreHash i_squareButtonHash, CoreHash i_leftShoulderButtonHash, CoreHash i_rightShoulderButtonHash);
    bool CheckVersion();
    bool CheckID();
    float DrawChar(CoreGameRender* io_graphics, uint32_t i_unicode, CoreVector& i_pos, float i_xOffset, CoreTextureSet* i_texSet, CoreHash* i_textureHashes, float i_scaleX, float i_scaleY, CoreRGBA i_col, int32_t i_flags);
    float DrawCharSpecial();
    bool RenderStart(CoreTextureSet*& o_texSet, CoreHash*& o_textureHashes);
    void RenderEnd();
    float GetScreenWidth();
    float GetScreenHeight();
    bool OverrideChar(uint32_t i_unicode, CoreRGBA& io_colour);
    void CoreFont();
    void ~CoreFont();
};

struct CoreRenderText : CoreRenderTextSettings
{
    CoreFont* m_font;
    CoreGameRender* m_graphics;
    int32_t m_flags;
    char* m_textString;
    float m_screenWidth;
    float m_screenHeight;
    static CoreRenderTextSettings DefaultSettings;

    void __InitVariables();
    void __GetStringWH(cRT_StringWH& io_stringWH);
    void __Render(cRT_StringWH& io_stringWH, float i_x, float i_y, CoreRGBA& i_rgba);
    float iGetFixedWidthAndHeight(float* o_width, float* o_height, float i_scaleX, float i_scaleY);
    void iGetWidthAndHeight();
    float iRender(CoreTextureSet* i_texSet, CoreHash* i_textureHashes, CoreRGBA& i_rgba, float i_x, float i_y, int32_t i_char, float i_scaleX, float i_scaleY);
    void Construct(CoreFont* i_font);
    void CoreRenderText();
    void Render(float i_x, float i_y, float* o_width, float* o_height);
    void GetWidthAndHeight(float* o_width, float* o_height);
    bool ScaleToArea(float i_areaW, float i_areaH, float i_scaleX, float i_scaleY, float i_startMultiplier, float i_endMultiplier, int32_t i_multiplierSteps);
};

struct CoreUV
{
    float m_fU;
    float m_fV;

    void CoreUV();
    void ~CoreUV();
    float GetU();
    float GetV();
    void SetU();
    void SetV();
};

enum msOff
{
    m00,
    m01,
    m02,
    m03,
    m10,
    m11,
    m12,
    m13,
    m20,
    m21,
    m22,
    m23,
};

enum ContextFlags
{
    CF_IMMEDIATE_BLEND = (1 << 0),
    CF_INTERRUPT = (1 << 1),
    CF_CHECK_SECOND_ACTION = (1 << 2),
    CF_ANIM_FRAME_RANGE = (1 << 3),
    CF_END_OF_ANIM = (1 << 4),
    CF_IMMEDIATE_STATE_CHANGE = (1 << 5),
    CF_IF_ANIM_NOT_SET = (1 << 6),
    CF_UNUSED8 = (1 << 7),
    CF_UNUSED9 = (1 << 8),
    CF_UNUSED10 = (1 << 9),
    CF_UNUSED11 = (1 << 10),
    CF_UNUSED12 = (1 << 11),
    CF_UNUSED13 = (1 << 12),
    CF_LAST_CONTEXT_TRUE = (1 << 13),
    CF_UNUSED15 = (1 << 14),
    CF_UNUSED16 = (1 << 15),
    CF_SETPLAYERFLAG = (1 << 16),
    CF_IFPLAYERFLAGCLEAR = (1 << 17),
    CF_IFPLAYERFLAGSET = (1 << 18),
    CF_NOACTION = (1 << 19),
    CF_NOT = (1 << 20),
    CF_UNUSED22 = (1 << 21),
    CF_IF_ANIM_SET = (1 << 22),
    CF_RESET_TO_ANIM = (1 << 23),
    CF_SLOT_SUSPEND = (1 << 24),
    CF_SLOT_RESUME = (1 << 25),
    CF_UNUSED27 = (1 << 26),
    CF_UNUSED28 = (1 << 27),
    CF_UNUSED29 = (1 << 28),
    CF_UNUSED30 = (1 << 29),
    CF_UNUSED31 = (1 << 30),
    CF_FLYCHEAT = (1 << 31),
};

struct TRSoundSystem
{
    void TRSoundSystem();
    int32_t SoundEffect();
};

struct _new_audio_info
{
    int32_t nId;
    char* pszObject;
    char* pszEvent;
};

enum EnemyAnimSpecificFlags
{
    ASF_NOTURNONDETECTION = 6,
    ASF_NOPATHSEEKING,
    ASF_UNUSED3,
    ASF_UNUSED4,
    ASF_UNUSED5,
    ASF_UNUSED6,
    ASF_UNUSED7,
    ASF_UNUSED8,
};

struct CoreNavigationMesh
{
    enum
    {
        VERSION = 7,
    };

    char m_name[16];
    CoreVector m_min;
    CoreVector m_max;
    uint32_t m_nameHash;
    int32_t m_iVertexArrayOffset;
    int32_t m_iTriangleArrayOffset;
    int32_t m_iOppositeArrayOffset;
    int32_t m_iPortalArrayOffset;
    int32_t m_iExitArrayOffset;
    int32_t m_iNumVertices;
    int32_t m_iNumTriangles;
    int32_t m_iNumExits;

    void CoreNavigationMesh();
    void ~CoreNavigationMesh();
    int32_t GetNumVertices();
    int32_t GetNumTriangles();
    int32_t GetNumExits();
    CoreVector GetVertex(int32_t iIndex);
    int32_t GetTriangleVertexIndex(int32_t iTriangle, int32_t iVertex);
    uint32_t GetNextTriangle();
    CoreVector GetCentreOfTriangle(int32_t iTriangle);
    uint32_t GetPortal();
    bool GetLineOfSight();
    CoreNavDistance GetDistance();
    int32_t GetOppositeTriangle();
    int32_t GetTriangleFromPos(CoreVector& vPos, float fTolerance, int32_t iLastTriangle);
    char* GetName();
    CoreHash GetNameHash();
    CoreNavMeshExit* GetExitToMesh(int32_t i_destNM, CoreVector i_closestTo, int32_t i_creatureDef);
    CoreNavMeshExit* GetExit(int32_t i_exitNum);
    CoreVector GetMin();
    CoreVector GetMax();
    float fDistVeryClose();
    float fDistClose();
    float fDistMedium();
    CoreNavigationVertex* GetVertexArrayPtr();
    int32_t* GetTriangleArrayPtr();
    uint32_t* GetPortalArrayPtr();
    int32_t* GetOppositeArrayPtr();
    CoreNavMeshExit* GetExitArrayPtr();
};

struct CoreNavPos
{
    CoreVector m_pos;
    int32_t m_navMeshIndex;
    uint32_t m_navMeshTriangle;
    uint32_t m_pad;

    void CoreNavPos();
};

struct CorePlayAnimInfo
{
    float m_blendTime;
    bool m_looping;
    float m_weight;
    float m_playbackSpeed;
    float m_subPlaybackSpeed;
    uint32_t m_priority;
    bool m_killBlendOnZeroWeight;
    bool m_mirror;
    float m_startTime;
    float m_timeToGoalAnim;
    CoreVector m_offsetPos;
    CoreEulerAngle m_offsetRot;
    uint32_t m_blendFlags;
    CoreHash m_boneSetHash;

    void CorePlayAnimInfo();
    void ~CorePlayAnimInfo();
    void SetDefaults();
    float GetBlendTime();
    bool GetLooping();
    float GetWeight();
    float GetPlaybackSpeed();
    float GetSubPlaybackSpeed();
    uint32_t GetPriority();
    bool IsKillBlendOnZeroWeight();
    bool IsMirror();
    float GetStartTime();
    float GetTimeToGoalAnim();
    CoreVector GetOffsetBlendPos();
    CoreEulerAngle GetOffsetBlendRot();
    uint32_t GetBlendFlags();
    CoreHash GetBoneSetHash();
    void SetBlendTime();
    void SetLooping();
    void SetWeight();
    void SetPlaybackSpeed();
    void SetSubPlaybackSpeed();
    void SetPriority();
    void SetKillBlendOnZeroWeight();
    void SetMirror();
    void SetStartTime();
    void SetTimeToGoalAnim();
    void SetOffsetBlendPos();
    void SetOffsetBlendRot();
    void SetBlendFlags();
    void SetBoneSetHash();
};

enum WolfBoneRotations
{
    BR_HEAD,
    BR_NECK1,
    BR_NECK2,
    BR_SPINE1,
    BR_SPINE2,
};

enum WolfDefaultVars
{
    WOLF_ATTACK_TIMER,
};

struct TRBiteInfo
{
    int32_t x;
    int32_t y;
    int32_t z;
    int32_t mesh_num;
};

struct CoreCommand
{
    CoreHash m_function;
    bool m_functionIsInternal;
    bool m_returnValueSet;
    CoreScriptUpdate* m_update;
    int32_t m_numberOfParams;
    CoreVariable* m_assignmentVariable;
    CoreVariable m_returnValue;
    CoreVariable m_params[7];

    void CoreCommand();
    void ~CoreCommand();
    void Reset();
    void SetFunction();
    void SetScriptUpdate();
    void SetAssignment();
    void SetParameter();
    bool IsInternalFunction();
    CoreHash GetFunction();
    int32_t GetNumParams();
    CoreVariable* GetParameter(int32_t i_index);
    CoreScriptUpdate* GetScriptUpdate();
    CoreVariable* GetAssignment();
    void SetReturnValue(CoreVariable& i_returnValue);
    void DoAssignment();
};

struct CoreVariable
{
    enum
    {
        VAR_INT = 0,
        VAR_FLOAT = 1,
        VAR_BOOL = 2,
        VAR_CHAR_POINTER = 3,
        VAR_BASIC_TYPES = 3,
        VAR_POINTER = 4,
        VAR_LOGIC = 8,
        VAR_TEMP = 16,
    };

    CoreHash m_owner;
    CoreHash m_name;
    int32_t m_type;
    int32_t m_value;
    int32_t m_lastValue;

    void CoreVariable();
    void ~CoreVariable();
    void Init(CoreHash i_owner, CoreHash i_name, int32_t i_type, void* i_valuePointer);
    CoreHash GetOwner();
    CoreHash GetName();
    int32_t GetType();
    int32_t GetBasicType();
    bool IsPointer();
    bool IsLogic();
    bool IsTemp();
    int32_t GetIntValue();
    float GetFloatValue();
    bool GetBoolValue();
    char* GetCharPointerValue();
    CoreHash GetHashValue();
    bool HasChanged();
    void UpdateLastValue();
    bool operator==(CoreVariable& i_compare);
    bool operator<(CoreVariable& i_compare);
    bool operator>(CoreVariable& i_compare);
    void SetValue(CoreVariable& i_value);
    void SetValueAndType();
    void* GetRawValuePointer();
    void ReadValue(void* o_valuePointer);
    void ReadLastValue();
};

enum CoreDetectHit
{
    CORE_DETECTHIT_NOTHING,
    CORE_DETECTHIT_FLOOR = (1 << 0),
    CORE_DETECTHIT_CEILING = (1 << 1),
    CORE_DETECTHIT_OBJECT = (1 << 2),
    CORE_DETECTHIT_CHARACTER = (1 << 3),
    CORE_DETECTHIT_AGAINSTWALL = (1 << 4),
    CORE_DETECTHIT_AWAYFROMWALL = (1 << 5),
    CORE_DETECTHIT_LEVEL_COLLIDABLE = (1 << 6),
};

enum RaptorBoneRotations
{
    BR_HEAD,
    BR_SPINE,
    BR_TAIL1,
    BR_TAIL2,
    BR_TAIL3,
    BR_TAIL4,
    BR_TAIL5,
};

struct FRFXLibrary : CoreFXLibrary
{
    CoreFXEmitter* m_pSunEmitter;
    CoreFXEmitter* m_pGlareEmitter;
    uint32_t m_iOcclusionTime;
    uint32_t m_iOcclusionTimeMax;
    uint32_t m_playerWaterTime;
    float m_playerWaterRate;
    float m_playerWaterRateTot;

    void FRFXLibrary();
    void ~FRFXLibrary();
    void Update();
    void RegisterFXCommands();
    void UpdatePlayerWaterFX();
    void InitFREffects();
    void eFnSpecificFX();
    FRFXLibrary* GetInstance();
    void CreateDust(CoreVector pos);
    void PlayerDroppedIntoWater(float iMagVel);
    void PlayerUnderwaterFX();
    void TriggerPickupGlow(CoreVector i_pos);
    void UpdateFlameThrower(CoreFXEmitter* i_emitter);
    void UpdateGenericMist(CoreFXEmitter* i_emitter, int32_t* iUseParticle, bool iInteract);
    void UpdateGroundMist(CoreFXEmitter* iEmitter);
    void UpdateLavaMist(CoreFXEmitter* iEmitter);
    void UpdateCavesDoorBeam(CoreFXEmitter* iEmit);
    void UpdateCavesDoorSnow(CoreFXEmitter* iEmit);
    void UpdateFireLeap(CoreFXEmitter* i_emitter);
    void UpdatePlayerFireTorch(FRPlayerObject* iPlayer, CoreVector iPos);
};

enum headings
{
    NORTH,
    EAST,
    SOUTH,
    WEST,
};

struct lightning
{
    int32_t onstate;
    int32_t count;
    int32_t zapped;
    int32_t notarget;
    OLD_VECTOR target;
    OLD_VECTOR main[8];
    OLD_VECTOR wibble[8];
    int32_t start[2];
    OLD_VECTOR end[2];
    OLD_VECTOR shoot[2][8];
};

struct OLD_VECTOR
{
    int32_t x;
    int32_t y;
    int32_t z;
};

enum TRexBoneRotations
{
    BR_NECK1,
    BR_NECK2,
    BR_SPINE1,
    BR_SPINE2,
    BR_TAIL1,
    BR_TAIL2,
    BR_TAIL3,
    BR_TAIL4,
};

enum TRexDefaultVars
{
    ATTACK_TIMER,
};

enum BearBoneRotations
{
    BR_HEAD,
    BR_NECK1,
    BR_NECK2,
};

enum BearDefaultVars
{
    BEAR_ATTACK_TIMER,
};

enum BatDefaultVars
{
    BAT_ATTACK_TIMER,
    BAT_ATTACK_MAX_TIME,
};

enum LEVEL
{
    LEVEL_GYM,
    LEVEL_1,
    LEVEL_2,
    LEVEL_3A,
    LEVEL_3B,
    LEVEL_4,
    LEVEL_5,
    LEVEL_6,
    LEVEL_7A,
    LEVEL_7B,
    LEVEL_8A,
    LEVEL_8B,
    LEVEL_8C,
    LEVEL_10A,
    LEVEL_10B,
    LEVEL_10C,
    LEVEL_CUT1,
    LEVEL_CUT2,
    LEVEL_CUT3,
    LEVEL_CUT4,
    LEVEL_TITLE,
    LEVEL_CURRENT,
    LEVEL_X,
    LEVEL_Y,
    LEVEL_Z,
    LEVEL_MAX,
};

struct TRLevelDescription
{
    LEVEL m_number;
    CoreHash m_shortName;
    CoreHash m_nameHash;
    char* m_loadName;

    void TRLevelDescription();
    void ~TRLevelDescription();
};

struct VineDefinitions
{
    CoreFX::Blend blendType;
    int32_t fxMaterial;
};

struct CoreGraphicsDeviceLightData
{
    CoreVector vWorldPosition;
    CoreVector vAmbientColour;
    CoreMatrix mtDiffuseColours;
    CoreMatrix mtDiffuseWorldDirections;
    float fSpecularIntensities[4];
    CoreVector vPositions[4];
    uint32_t flags;

    void CoreGraphicsDeviceLightData();
};

struct CoreDetectorSpheres
{
    CoreVector vPosition[8];
    float fRadius[8];
    uint32_t exclusiveSubtype[8];
    uint32_t ucNumSpheres;
    uint32_t ucPadding;
    uint32_t usPadding;

    void CoreDetectorSpheres();
};

struct CoreFRGBA
{
    uint32_t m_time;
    float m_r;
    float m_dr;
    float m_g;
    float m_dg;
    float m_b;
    float m_db;
    float m_a;
    float m_da;
    CoreRGBA m_rgba;

    void CoreFRGBA();
    void ~CoreFRGBA();
    void Set(CoreRGBA rgba);
    void SetR();
    void SetG();
    void SetB();
    void SetA();
    void SetDelta(float dr, float dg, float db, float da, uint32_t l_time);
    void Scale(float val);
    bool Step();
    CoreRGBA& Get();
    uint32_t GetRGBOverBright();
    float GetRed();
    float GetGreen();
    float GetBlue();
};

enum AnimSpecificFlags
{
    ASF_TESTFORDEADZONE = 6,
    ASF_FLAG2,
    ASF_NOWEAPONS,
    ASF_FLAG4,
    ASF_IDLEANIM,
    ASF_APPLYAVERAGEVELOCITY,
    ASF_FLAG7,
    ASF_FLAG8,
};

enum WeaponControlState
{
    WEAPON_HOLSTERED,
    WEAPON_DRAW,
    WEAPON_DRAWN,
    WEAPON_AIM,
    WEAPON_FIRE,
    WEAPON_HOLSTER,
};

struct HairDetectionSpheres
{
    CoreVector pos;
    float radius;

    void HairDetectionSpheres();
};

struct CoreRumbleEnvelope
{
    float m_attackTime;
    float m_decayTime;
    float m_sustainTime;
    float m_releaseTime;
    float m_attackLevel;
    float m_sustainLevel;
    float m_smallMotorDelay;
    float m_smallMotorTime;

    void CoreRumbleEnvelope();
    float GetTotalEnvelopeTime();
};

enum TRJumpType
{
    JT_UP,
    JT_FORWARD,
    JT_LEFT,
    JT_RIGHT,
    JT_BACK,
    JT_RUN,
    JT_HPOLE,
    JT_SHIMMY_LEFT,
    JT_SHIMMY_RIGHT,
};

struct FRPlayerObject::Render::__l14::__unnamed
{
    CoreVector pos0;
    CoreVector pos1;
    float floorHeight;
};

enum playerBurnBonePairs
{
    PBP_LEFTTOE,
    PBP_LEFTFOOT,
    PBP_LEFTLEG,
    PBP_LEFTUPLEG,
    PBP_RIGHTTOE,
    PBP_RIGHTFOOT,
    PBP_RIGHTLEG,
    PBP_RIGHTUPLEG,
    PBP_LEFTHAND,
    PBP_LEFTFOREARM,
    PBP_LEFTSHOULDER,
    PBP_RIGHTHAND,
    PBP_RIGHTFOREARM,
    PBP_RIGHTSHOULDER,
    PBP_PELVIS,
    PBP_SPINE1,
    PBP_NECK,
    PBP_HEAD,
    PBP_D6,
    PBP_D1,
    PBP_NUMBONES,
};

struct CoreAnimCommandEvent
{
    uint32_t m_nameHash;

    CoreHash GetNameHash();
};

struct CoreAnimCommandAutoBlend
{
    uint32_t m_oldStateHash;
    uint32_t m_newStateHash;

    CoreHash GetOldStateHash();
    CoreHash GetNewStateHash();
    void SetOldStateHash(CoreHash i_value);
    void SetNewStateHash(CoreHash i_value);
};

struct CoreInputAction : CoreInputState
{
    float m_timeHeldPrev;
    float m_timeHeld;
    float m_timeReleased;
    CoreInputID m_mapping[4];

    void CoreInputAction();
    float TimeHeld();
    float TimeNotHeld();
    bool IsClickedRepeat(float i_repeatPeriod);
    void Update(float i_value, float i_frameTime);
};

struct CoreDetectPoly
{
    CoreVector vVerts[3];
    CorePlaneEquation pePlane;
    int32_t iTriangleNumber;
    CoreDetectPoly* lpNext;
    CoreGeometryObject* lpParentObject;
    float fSort;
    CoreDetectPolyType eType;
    uint32_t uiSubType1Hash;
    uint32_t uiSubType2Hash;
    uint32_t detectCycle;

    void CoreDetectPoly();
};

enum CoreDetectPolyType
{
    CORE_DETECT_POLYTYPE_FLOOR = 1,
    CORE_DETECT_POLYTYPE_WALL = 2,
    CORE_DETECT_POLYTYPE_SPECIAL_OBJECT = 4,
    CORE_DETECT_POLYTYPE_SPECIAL_LEVEL_COLLIDABLE = 8,
    CORE_DETECT_POLYTYPE_ANY_SPECIAL_MASK = 12,
    MAX_DETECT_POLY_TYPES = 2,
    CORE_DETECT_POLYTYPE_NO_SPECIALS_MASK = 1,
};

enum AnimScriptOffsets
{
    ASO_COMMAND = 0,
    ASO_ACTION = 1,
    ASO_CASE = 0,
    ASO_FUNCTIONTYPE = 0,
    ASO_CONTEXTFLAGS = 1,
    ASO_CONTEXTINFO = 2,
    ASO_CONTEXTNAME = 3,
    ASO_SECONDACTIONHASH = 3,
    ASO_FLAGHASH = 3,
    ASO_ANIM = 4,
};

struct FRFunctions
{
    CoreHash scriptName;
    bool* func;

    void FRFunctions();
    void ~FRFunctions();
};

struct CoreMapBase
{
    CoreMapNode* m_root;
    CoreMapNode* m_NULL;
    CoreMapNode m_sentinel;
    CoreMemoryArray m_nodePool;

    void CoreMapBase();
    void ~CoreMapBase();
    void Init(uint32_t i_maxItems, CoreMemory* i_itemMemory);
    uint32_t GetKeyCount();
    void* FindKey(CoreHash i_key);
    bool AddKey(CoreHash i_key, void* i_data);
    bool RemoveKey();
    bool UpdateKey();
    bool ValidateMap();
    CoreMapNode* FindNode(CoreHash i_key);
    void RotateLeft();
    void RotateRight();
    void InsertFixup(CoreMapNode* i_node);
    void DeleteFixup();
    void RecursiveDelete();
    uint32_t RecursiveCount();
    bool ValidateNode();
};

enum FRObjectTypes
{
    PLAYERS,
    CHASECAMERAS,
    FIXEDCAMERAS,
    BACKGROUNDS,
    TRGAMEOBJECTS,
    TRINVOBJECTS,
    TRMULTIMESHOBJECTS,
    TRFOLIAGEOBJECTS,
    TREDOBJECTS,
    NUM_OBJECT_TYPES,
};

enum BaddyWeights
{
    BAT_WEIGHT = 50,
    LARA_WEIGHT = 90,
    DEFAULT_BADDYWEIGHT = 100,
    DINOSAUR_WEIGHT = 200,
};

enum FOLIAGE_TYPE
{
    FOLIAGE_NULL,
    FOLIAGE_PLANT1,
    FOLIAGE_PLANT2,
    FOLIAGE_PLANT3,
    FOLIAGE_PLANT4,
    FOLIAGE_MAX,
};

struct _frlevel_object_event
{
    uint32_t uType;
    int32_t nItem;
    int32_t nFlipState;
    uint32_t nEventId;
    uint32_t nPlayerId;
};

struct CheatDescription
{
    int32_t numPresses;
    int32_t Presses[8];
    int32_t Action;
};

struct CoreScripted
{
    enum CommandReturn
    {
        COM_ERROR,
        COM_DONE,
        COM_REPEAT,
        COM_FINISH,
    };

    CoreProgramCounter m_PC;
    CoreHash m_objectName;
    CoreHash m_scriptName;
    CoreVariable* m_firstVariable;
    int32_t m_numberOfVariables;
    bool m_dead;
    bool m_sleep;
    static bool m_ScriptLoggerCreated;
    static CoreHash m_ScriptLoggerHash;
    CoreHash m_cachedCommand;
    bool m_cachedCommandInternal;

    // TODO vtable

    void CoreScripted();
    void ~CoreScripted();
    void Reset();
    void InitScript(CoreHash i_objectName, CoreHash i_scriptName, CoreScriptUpdate* io_update);
    void ResetScript(CoreScriptUpdate* io_update);
    void UpdateScript(CoreScriptUpdate* io_update);
    void DeleteScript(CoreScriptUpdate* io_update);
    bool IsScriptInited();
    CoreVariable* GetFirstVariable();
    int32_t GetNumVariables();
    CoreHash GetScriptName();
    CoreHash GetObjectName();
    int32_t FindVariableIndex(CoreHash i_varName);
    CoreVariable* FindVariable(CoreHash i_varName);
    void CalcFirstVariable(CoreVariableStore* io_variableStore);
    CoreVariable* AddDynamicVariable(CoreVariableStore* i_variableStore, CoreHash i_varName, int32_t i_varType, void* i_valuePtr);
    void SetDead(bool i_dead);
    bool IsDead();
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void* GetVariablePointer(CoreHash i_variableName);
    void Sleep();
    void Wake();
    bool IsSleeping();
    CoreScripted::CommandReturn RunInternalFunction(CoreCommand* io_command);
    CoreScripted::CommandReturn FnIf(CoreCommand* io_command);
    CoreScripted::CommandReturn FnWaitFor(CoreCommand* io_command);
    CoreScripted::CommandReturn FnDebug(CoreCommand* io_command);
};

struct CoreInputState
{
    float m_currValue;
    float m_prevValue;

    void CoreInputState();
    bool IsClicked();
    bool IsReleased();
    bool IsHeld();
    float GetValue();
    void UpdateValue();
};

enum FRLevel::FnPreLoadAllObjects::__l2::STATE
{
    STATE_NULL,
    STATE_DOES_IT_NEED_LOADING,
    STATE_LOAD_MODEL,
    STATE_LOAD_ENGINE,
    STATE_LOAD_TEXTURE_SET,
    STATE_LOAD_ANIM_SEQUENCER,
    STATE_LOAD_ANIM_SET,
    STATE_FIND_NEXT,
};

struct CoreMouseData
{
    bool m_available;
    float m_sensitivity;
    CoreInputState m_states[13];

    void CoreMouseData();
};

struct CoreInputDevice
{
    float m_updateTime;
    CoreInputMapping m_defaultMapping;
    CorePadData m_pads[4];
    CoreKeyboardData m_keyboard;
    CoreMouseData m_mouse;
    CoreInputState m_invalidState;
    CoreInputID m_buffer[16];
    uint32_t m_bufferIn;
    uint32_t m_bufferOut;
    CoreInputContext m_defaultContext;

    // TODO vtable

    CoreInputDevice* CreateDevice(CoreMemory* i_memory, CoreHash i_type);
    void CoreInputDevice();
    void ~CoreInputDevice();
    void Construct();
    void Destruct();
    void Init();
    void Reset();
    void Update();
    void Rumble(int32_t i_pad, CoreRumbleEnvelope* i_rumbleEnvelope);
    void EnableRumble();
    void DisableRumble();
    void StopRumble(int32_t i_pad);
    void InitGeneral(bool i_enableMouse);
    void UpdateGeneral(float i_frameTime, CoreInput* i_input);
    float GetUpdateTime();
    CoreInputState* GetState(CoreInputID i_id);
    void UpdateValue(CoreInputID i_id, float i_value);
    CoreInputID GetLastState();
    CoreInputAction* GetDefaultAction(CoreHash i_actionID);
    bool IsDeviceValid();
    bool IsPad1Valid();
    bool IsPad2Valid();
    void SetMouseSensitivity(float i_sensitivity);
    float GetMouseSensitivity();
    CoreInputDevice* CreateSpecificDevice(CoreMemory* i_memory, CoreHash i_type);
    void BufferInput();
};

struct CoreInput
{
    static CoreHash CORE_MENU_LEFT_0;
    static CoreHash CORE_MENU_RIGHT_0;
    static CoreHash CORE_MENU_UP_0;
    static CoreHash CORE_MENU_DOWN_0;
    static CoreHash CORE_MENU_SELECT_0;
    static CoreHash CORE_MENU_BACK_0;
    static CoreHash CORE_MENU_SQUARE_0;
    static CoreHash CORE_MENU_START_0;
    static CoreHash CORE_MENU_LEFT_1;
    static CoreHash CORE_MENU_RIGHT_1;
    static CoreHash CORE_MENU_UP_1;
    static CoreHash CORE_MENU_DOWN_1;
    static CoreHash CORE_MENU_SELECT_1;
    static CoreHash CORE_MENU_BACK_1;
    static CoreHash CORE_MENU_SQUARE_1;
    static CoreHash CORE_MENU_START_1;
    CoreInputDevice* m_device;

    void CoreInput();
    void Construct(CoreMemory* i_memory, CoreHash i_type, char* i_appName);
    void Destruct(CoreMemory* io_memory);
    void Init(bool i_enableMouse);
    void Update(float i_frameTime);
    float GetUpdateTime();
    bool IsDeviceValid();
    bool IsInputClicked(CoreInputID i_id);
    bool IsInputReleased(CoreInputID i_id);
    bool IsInputHeld(CoreInputID i_id);
    float GetInputValue(CoreInputID i_id);
    CoreInputID GetLastInput();
    CoreInputDevice* GetDevice();
    CoreInputAction* GetDefaultAction(CoreHash i_actionID);
    char GetLastKeyClicked();
    void SetMouseSensitivity();
    float GetMouseSensitivity();
    void Rumble(uint32_t i_pad, CoreRumbleEnvelope* i_rumbleEnvelope);
    void EnableRumble();
    void DisableRumble();
};

struct CoreInputID
{
    uint32_t m_id;
    uint32_t m_device;
    uint32_t m_number;

    void CoreInputID(CorePadID i_padInput, uint32_t i_padNumber);
    bool operator==();
    bool IsValid();
    bool IsKeyboardInput();
    bool IsMouseInput();
    bool IsPadInput();
    CoreInputDeviceID GetDeviceType();
    uint32_t GetDeviceNumber();
    uint32_t GetInputID();
    char* GetInputName();
    char GetInputChar(bool i_shifted);
};

enum CoreInputDeviceID
{
    CORE_ID_NONE,
    CORE_ID_PAD,
    CORE_ID_KEYBOARD,
    CORE_ID_MOUSE,
};

struct CoreKeyboardData
{
    bool m_available;
    CoreInputState m_states[109];

    void CoreKeyboardData();
};

struct CoreStickData
{
    float m_centreX;
    float m_centreY;
    float m_valueX;
    float m_valueY;
    float m_prevX;
    float m_prevY;

    void CoreStickData();
    void Update(float i_axisX, float i_axisY);
    float GetLeft();
    float GetRight();
    float GetUp();
    float GetDown();
};

struct CorePadData
{
    bool m_available;
    CoreInputState m_states[24];
    CoreStickData m_sticks[2];

    void CorePadData();
};

struct CoreTextureInfo
{
    enum
    {
        VERSION = 2,
    };

    uint32_t m_powerOfTwoWidth;
    uint32_t m_powerOfTwoHeight;
    uint32_t m_pageX;
    uint32_t m_pageY;
    uint32_t m_pageIndex;
    uint32_t m_flags;
    uint32_t m_hash;
    char m_debugName[16];
    uint32_t m_pageOffset;

    void CoreTextureInfo();
    void ~CoreTextureInfo();
    uint32_t sGetWidth();
    uint32_t sGetHeight();
    uint32_t GetWidth();
    uint32_t GetHeight();
    uint32_t GetPowerOfTwoWidth();
    uint32_t GetPowerOfTwoHeight();
    uint32_t GetFlags();
    uint32_t GetHash();
    void SetFlag();
    uint32_t GetPageIndex();
    uint32_t GetPageOffset();
    uint32_t GetPageX();
    uint32_t GetPageY();
    float GetSOffset();
    float GetTOffset();
    void SetSOffset();
    void SetTOffset();
    void EnableTextureOffsets();
    uint32_t HasTextureOffsets();
    bool Is32Bit();
    bool Is24Bit();
    bool Is8Bit();
    bool Is4Bit();
    bool HasAlpha();
    bool HasPalette();
    bool HasMipMaps();
    bool HasNoMipMaps();
    bool IsDoubleSided();
    bool IsDrawBuffer();
    void Construct(char* i_debugName, CoreHash i_hash, uint32_t i_pageIndex, uint32_t i_pageX, uint32_t i_pageY, uint32_t i_width, uint32_t i_height, uint32_t i_flags);
    char* GetDebugName();
    void SetHash();
};

enum tagOLEGETMONIKER
{
    OLEGETMONIKER_ONLYIFTHERE = 1,
    OLEGETMONIKER_FORCEASSIGN,
    OLEGETMONIKER_UNASSIGN,
    OLEGETMONIKER_TEMPFORUSER,
};

enum tagOLEWHICHMK
{
    OLEWHICHMK_CONTAINER = 1,
    OLEWHICHMK_OBJREL,
    OLEWHICHMK_OBJFULL,
};

enum tagUSERCLASSTYPE
{
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT,
    USERCLASSTYPE_APPNAME,
};

enum tagOLEMISC
{
    OLEMISC_RECOMPOSEONRESIZE = (1 << 0),
    OLEMISC_ONLYICONIC = (1 << 1),
    OLEMISC_INSERTNOTREPLACE = (1 << 2),
    OLEMISC_STATIC = (1 << 3),
    OLEMISC_CANTLINKINSIDE = (1 << 4),
    OLEMISC_CANLINKBYOLE1 = (1 << 5),
    OLEMISC_ISLINKOBJECT = (1 << 6),
    OLEMISC_INSIDEOUT = (1 << 7),
    OLEMISC_ACTIVATEWHENVISIBLE = (1 << 8),
    OLEMISC_RENDERINGISDEVICEINDEPENDENT = (1 << 9),
    OLEMISC_INVISIBLEATRUNTIME = (1 << 10),
    OLEMISC_ALWAYSRUN = (1 << 11),
    OLEMISC_ACTSLIKEBUTTON = (1 << 12),
    OLEMISC_ACTSLIKELABEL = (1 << 13),
    OLEMISC_NOUIACTIVATE = (1 << 14),
    OLEMISC_ALIGNABLE = (1 << 15),
    OLEMISC_SIMPLEFRAME = (1 << 16),
    OLEMISC_SETCLIENTSITEFIRST = (1 << 17),
    OLEMISC_IMEMODE = (1 << 18),
    OLEMISC_IGNOREACTIVATEWHENVISIBLE = (1 << 19),
    OLEMISC_WANTSTOMENUMERGE = (1 << 20),
    OLEMISC_SUPPORTSMULTILEVELUNDO = (1 << 21),
};

enum tagVARKIND
{
    VAR_PERINSTANCE,
    VAR_STATIC,
    VAR_CONST,
    VAR_DISPATCH,
};

enum tagURLZONE
{
    URLZONE_PREDEFINED_MIN = 0,
    URLZONE_LOCAL_MACHINE = 0,
    URLZONE_INTRANET = 1,
    URLZONE_TRUSTED = 2,
    URLZONE_INTERNET = 3,
    URLZONE_UNTRUSTED = 4,
    URLZONE_PREDEFINED_MAX = 999,
    URLZONE_USER_MIN = 1000,
    URLZONE_USER_MAX = 10000,
};

enum tagURLTEMPLATE
{
    URLTEMPLATE_CUSTOM = 0,
    URLTEMPLATE_PREDEFINED_MIN = 65536,
    URLTEMPLATE_LOW = 65536,
    URLTEMPLATE_MEDLOW = 66816,
    URLTEMPLATE_MEDIUM = 69632,
    URLTEMPLATE_HIGH = 73728,
    URLTEMPLATE_PREDEFINED_MAX = 131072,
};

enum STUB_PHASE
{
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT,
};

enum PIDMSI_STATUS_VALUE
{
    PIDMSI_STATUS_NORMAL,
    PIDMSI_STATUS_NEW,
    PIDMSI_STATUS_PRELIM,
    PIDMSI_STATUS_DRAFT,
    PIDMSI_STATUS_INPROGRESS,
    PIDMSI_STATUS_EDIT,
    PIDMSI_STATUS_REVIEW,
    PIDMSI_STATUS_PROOF,
    PIDMSI_STATUS_FINAL,
    PIDMSI_STATUS_OTHER = 32767,
};

enum PROXY_PHASE
{
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL,
};

enum __MIDL_IInternetZoneManager_0001
{
    MAX_ZONE_PATH = 260,
    MAX_ZONE_DESCRIPTION = 200,
};

enum tagOLECLOSE
{
    OLECLOSE_SAVEIFDIRTY,
    OLECLOSE_NOSAVE,
    OLECLOSE_PROMPTSAVE,
};

enum CORE_POWER_CALLBACK_TYPE_TAG
{
    CORE_POWER_CALLBACK_TYPE_BUTTON_PRESSED,
    CORE_POWER_CALLBACK_TYPE_BUTTON_RELEASED,
    CORE_POWER_CALLBACK_TYPE_ON,
    CORE_POWER_CALLBACK_TYPE_OFF,
};

enum __MIDL_IInternetZoneManager_0002
{
    ZAFLAGS_CUSTOM_EDIT = (1 << 0),
    ZAFLAGS_ADD_SITES = (1 << 1),
    ZAFLAGS_REQUIRE_VERIFICATION = (1 << 2),
    ZAFLAGS_INCLUDE_PROXY_OVERRIDE = (1 << 3),
    ZAFLAGS_INCLUDE_INTRANET_SITES = (1 << 4),
    ZAFLAGS_NO_UI = (1 << 5),
    ZAFLAGS_SUPPORTS_VERIFICATION = (1 << 6),
    ZAFLAGS_UNC_AS_INTRANET = (1 << 7),
};

enum tagTYPEFLAGS
{
    TYPEFLAG_FAPPOBJECT = (1 << 0),
    TYPEFLAG_FCANCREATE = (1 << 1),
    TYPEFLAG_FLICENSED = (1 << 2),
    TYPEFLAG_FPREDECLID = (1 << 3),
    TYPEFLAG_FHIDDEN = (1 << 4),
    TYPEFLAG_FCONTROL = (1 << 5),
    TYPEFLAG_FDUAL = (1 << 6),
    TYPEFLAG_FNONEXTENSIBLE = (1 << 7),
    TYPEFLAG_FOLEAUTOMATION = (1 << 8),
    TYPEFLAG_FRESTRICTED = (1 << 9),
    TYPEFLAG_FAGGREGATABLE = (1 << 10),
    TYPEFLAG_FREPLACEABLE = (1 << 11),
    TYPEFLAG_FDISPATCHABLE = (1 << 12),
    TYPEFLAG_FREVERSEBIND = (1 << 13),
    TYPEFLAG_FPROXY = (1 << 14),
};

enum tagFUNCFLAGS
{
    FUNCFLAG_FRESTRICTED = (1 << 0),
    FUNCFLAG_FSOURCE = (1 << 1),
    FUNCFLAG_FBINDABLE = (1 << 2),
    FUNCFLAG_FREQUESTEDIT = (1 << 3),
    FUNCFLAG_FDISPLAYBIND = (1 << 4),
    FUNCFLAG_FDEFAULTBIND = (1 << 5),
    FUNCFLAG_FHIDDEN = (1 << 6),
    FUNCFLAG_FUSESGETLASTERROR = (1 << 7),
    FUNCFLAG_FDEFAULTCOLLELEM = (1 << 8),
    FUNCFLAG_FUIDEFAULT = (1 << 9),
    FUNCFLAG_FNONBROWSABLE = (1 << 10),
    FUNCFLAG_FREPLACEABLE = (1 << 11),
    FUNCFLAG_FIMMEDIATEBIND = (1 << 12),
};

enum tagBINDSTRING
{
    BINDSTRING_HEADERS = 1,
    BINDSTRING_ACCEPT_MIMES,
    BINDSTRING_EXTRA_URL,
    BINDSTRING_LANGUAGE,
    BINDSTRING_USERNAME,
    BINDSTRING_PASSWORD,
    BINDSTRING_UA_PIXELS,
    BINDSTRING_UA_COLOR,
    BINDSTRING_OS,
    BINDSTRING_USER_AGENT,
    BINDSTRING_ACCEPT_ENCODINGS,
    BINDSTRING_POST_COOKIE,
    BINDSTRING_POST_DATA_MIME,
    BINDSTRING_URL,
    BINDSTRING_IID,
    BINDSTRING_FLAG_BIND_TO_OBJECT,
    BINDSTRING_PTR_BIND_CONTEXT,
};

enum _URLZONEREG
{
    URLZONEREG_DEFAULT,
    URLZONEREG_HKLM,
    URLZONEREG_HKCU,
};

enum tagVARFLAGS
{
    VARFLAG_FREADONLY = (1 << 0),
    VARFLAG_FSOURCE = (1 << 1),
    VARFLAG_FBINDABLE = (1 << 2),
    VARFLAG_FREQUESTEDIT = (1 << 3),
    VARFLAG_FDISPLAYBIND = (1 << 4),
    VARFLAG_FDEFAULTBIND = (1 << 5),
    VARFLAG_FHIDDEN = (1 << 6),
    VARFLAG_FRESTRICTED = (1 << 7),
    VARFLAG_FDEFAULTCOLLELEM = (1 << 8),
    VARFLAG_FUIDEFAULT = (1 << 9),
    VARFLAG_FNONBROWSABLE = (1 << 10),
    VARFLAG_FREPLACEABLE = (1 << 11),
    VARFLAG_FIMMEDIATEBIND = (1 << 12),
};

enum COREAUDIO_PLAYBACKPREFERENCE
{
    COREAUDIO_PLAYBACKPREFERENCE_HARDWARE,
    COREAUDIO_PLAYBACKPREFERENCE_SOFTWARE,
    COREAUDIO_PLAYBACKPREFERENCE_HARDWARE_ONLY,
    COREAUDIO_PLAYBACKPREFERENCE_SOFTWARE_ONLY,
};

enum COREAUDIO_PROCESSING_TYPE
{
    COREAUDIO_PROCESSING_TYPE_3D,
    COREAUDIO_PROCESSING_TYPE_2D,
    COREAUDIO_PROCESSING_TYPE_2D_DISTATTN,
};

enum tagMKSYS
{
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5,
    MKSYS_CLASSMONIKER = 7,
    MKSYS_OBJREFMONIKER = 8,
    MKSYS_SESSIONMONIKER = 9,
};

enum COREAUDIO_SOURCE_TYPE
{
    COREAUDIO_SOURCE_TYPE_CONE,
    COREAUDIO_SOURCE_TYPE_SPOT,
};

enum tagMKREDUCE
{
    MKRREDUCE_ONE = 196608,
    MKRREDUCE_TOUSER = 131072,
    MKRREDUCE_THROUGHUSER = 65536,
    MKRREDUCE_ALL = 0,
};

enum PlaybackDataType
{
    PlaybackDataType_None,
    PlaybackDataType_Sequencial,
    PlaybackDataType_Random,
    PlaybackDataType_Chain,
    PlaybackDataType_Delay,
};

enum _tagPI_FLAGS
{
    PI_PARSE_URL = (1 << 0),
    PI_FILTER_MODE = (1 << 1),
    PI_FORCE_ASYNC = (1 << 2),
    PI_USE_WORKERTHREAD = (1 << 3),
    PI_MIMEVERIFICATION = (1 << 4),
    PI_CLSIDLOOKUP = (1 << 5),
    PI_DATAPROGRESS = (1 << 6),
    PI_SYNCHRONOUS = (1 << 7),
    PI_APARTMENTTHREADED = (1 << 8),
    PI_CLASSINSTALL = (1 << 9),
    PI_PASSONBINDCTX = (1 << 13),
    PI_NOMIMEHANDLER = (1 << 15),
    PI_LOADAPPDIRECT = (1 << 14),
    PD_FORCE_SWITCH = (1 << 16),
    PI_PREFERDEFAULTHANDLER = (1 << 17),
};

enum _STORAGE_MEDIA_TYPE
{
    DDS_4mm = 32,
    MiniQic,
    Travan,
    QIC,
    MP_8mm,
    AME_8mm,
    AIT1_8mm,
    DLT,
    NCTP,
    IBM_3480,
    IBM_3490E,
    IBM_Magstar_3590,
    IBM_Magstar_MP,
    STK_DATA_D3,
    SONY_DTF,
    DV_6mm,
    DMI,
    SONY_D2,
    CLEANER_CARTRIDGE,
    CD_ROM,
    CD_R,
    CD_RW,
    DVD_ROM,
    DVD_R,
    DVD_RW,
    MO_3_RW,
    MO_5_WO,
    MO_5_RW,
    MO_5_LIMDOW,
    PC_5_WO,
    PC_5_RW,
    PD_5_RW,
    ABL_5_WO,
    PINNACLE_APEX_5_RW,
    SONY_12_WO,
    PHILIPS_12_WO,
    HITACHI_12_WO,
    CYGNET_12_WO,
    KODAK_14_WO,
    MO_NFR_525,
    NIKON_12_RW,
    IOMEGA_ZIP,
    IOMEGA_JAZ,
    SYQUEST_EZ135,
    SYQUEST_EZFLYER,
    SYQUEST_SYJET,
    AVATAR_F2,
    MP2_8mm,
    DST_S,
    DST_M,
    DST_L,
    VXATape_1,
    VXATape_2,
    STK_9840,
    LTO_Ultrium,
    LTO_Accelis,
    DVD_RAM,
    AIT_8mm,
    ADR_1,
    ADR_2,
    STK_9940,
};

enum COREAUDIO_MUSIC_STATE
{
    COREAUDIO_MUSIC_STATE_STOPPED,
    COREAUDIO_MUSIC_STATE_STARTING_WITH_FADE,
    COREAUDIO_MUSIC_STATE_STARTING_WITH_FADE_IN_PROGRESS,
    COREAUDIO_MUSIC_STATE_STARTING_NO_FADE,
    COREAUDIO_MUSIC_STATE_PLAYING,
    COREAUDIO_MUSIC_STATE_STOPPING_CURRENT_WITH_FADE,
    COREAUDIO_MUSIC_STATE_STOPPING_CURRENT_WITH_FADE_IN_PROGRESS,
    COREAUDIO_MUSIC_STATE_STOPPING_CURRENT_NO_FADE,
    COREAUDIO_MUSIC_STATE_STOPPING_CURRENT_WITH_FADE_THEN_START_NEXT,
    COREAUDIO_MUSIC_STATE_STOPPING_CURRENT_WITH_FADE_IN_PROGRESS_THEN_START_NEXT,
    COREAUDIO_MUSIC_STATE_STOPPING_CURRENT_NO_FADE_THEN_START_NEXT,
};

enum eSchemaLanguage
{
    kSLANG_English = 1,
    kSLANG_Japanese = 2,
    kSLANG_German = 3,
    kSLANG_French = 4,
    kSLANG_Spanish = 5,
    kSLANG_Italian = 6,
    kSLANG_Korean = 7,
    kSLANG_TradChinese = 8,
    kSLANG_Portugese = 9,
    kSLANG_MinValue = 1,
    kSLANG_MaxValue = 9,
    kSLANG_Default = 1,
    kSLANG_Current = 253,
    kSLANG_System = 254,
    kSLANG_All = 255,
};

enum _HEAP_INFORMATION_CLASS
{
    HeapCompatibilityInformation,
};

enum _GET_FILEEX_INFO_LEVELS
{
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel,
};

enum tagADVF
{
    ADVF_NODATA = (1 << 0),
    ADVF_PRIMEFIRST = (1 << 1),
    ADVF_ONLYONCE = (1 << 2),
    ADVF_DATAONSTOP = (1 << 6),
    ADVFCACHE_NOHANDLER = (1 << 3),
    ADVFCACHE_FORCEBUILTIN = (1 << 4),
    ADVFCACHE_ONSAVE = (1 << 5),
};

enum CORE_SAVEGAME_RESULT_TAG
{
    CORE_SAVEGAME_RESULT_FINISHED = 0,
    CORE_SAVEGAME_RESULT_CANCELED = 1,
    CORE_SAVEGAME_RESULT_FAILED = 255,
    CORE_SAVEGAME_RESULT_ABORTED = 254,
    CORE_SAVEGAME_RESULT_FAILED_LOAD_DATA_CORRUPTED = 253,
    CORE_SAVEGAME_RESULT_FAILED_LOAD_NO_DATA = 252,
    CORE_SAVEGAME_RESULT_FAILED_SAVE_NOT_ENOUGH_MEMORY = 251,
    CORE_SAVEGAME_RESULT_NOT_IMPLEMENTED = 250,
};

enum tagOLEVERBATTRIB
{
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU,
};

enum CA_ChannelStatus
{
    CA_ChannelStatus_Inactive,
    CA_ChannelStatus_Active,
};

enum CA_PBPref
{
    CA_PBPref_Hardware,
    CA_PBPref_Software,
    CA_PBPref_Hardware_Only,
    CA_PBPref_Software_Only,
};

enum _STORAGE_BUS_TYPE
{
    BusTypeUnknown,
    BusTypeScsi,
    BusTypeAtapi,
    BusTypeAta,
    BusType1394,
    BusTypeSsa,
    BusTypeFibre,
    BusTypeUsb,
    BusTypeRAID,
    BusTypeMaxReserved = 127,
};

enum _ACTIVATION_CONTEXT_INFO_CLASS
{
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    MaxActivationContextInfoClass = 5,
    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4,
};

enum CA_ExpFmt
{
    CA_ExpFmt_None,
    CA_ExpFmt_PC_PCM,
    CA_ExpFmt_PC_ADPCM,
    CA_ExpFmt_PS2_ADPCM,
    CA_ExpFmt_XBOX_PCM,
    CA_ExpFmt_XBOX_ADPCM,
    CA_ExpFmt_PSP_ATRAC3,
    CA_ExpFmt_PSP_ATRAC3Plus,
    CA_ExpFmt_NumEntries,
};

enum _RPC_NOTIFICATION_TYPES
{
    RpcNotificationTypeNone,
    RpcNotificationTypeEvent,
    RpcNotificationTypeApc,
    RpcNotificationTypeIoc,
    RpcNotificationTypeHwnd,
    RpcNotificationTypeCallback,
};

enum CAAudioError
{
    CAAudioError_NoError = 0,
    CAAudioError_AnError = 1,
    CAAudioError_CompleteFailure = 1,
    CAAudioError_PartialFailure = 2,
    CAAudioError_VariableOutOfRange = 3,
    CAAudioError_NullPointer = 4,
    CAAudioError_WaitTimedOut = 5,
    CAAudioError_DataFormatError = 6,
    CAAudioError_NotImplementedYet = 7,
    CAAudioError_IndexOutOfRange = 8,
    CAAudioError_UnableToFindFile = 9,
    CAAudioError_InvalidAudioItemType = 10,
    CAAudioError_IncorrectType = 11,
    CAAudioError_ListFull = 1000,
    CAAudioError_ListError = 1001,
    CAAudioError_IDNotFound = 1002,
    CAAudioError_IndexEntryDoesNotExist = 1003,
    CAAudioError_ItemNotFound = 1004,
    CAAudioError_IncorrectParameterType = 2000,
    CAAudioError_NoPlaybackAttachedToEvent = 3000,
    CAAudioError_NoAudioData = 4000,
    CAAudioError_ParameterNotFound = 4001,
    CAAudioError_NoSampleGroup = 5000,
    CAAudioError_SampleNotFound = 6000,
    CAAudioError_ConstructorOnly = 7000,
    CAAudioError_CouldNotAllocateChannel_AllChannelsBusyAndRequestedPriorityNotHighEnough = 8000,
    CAAudioError_FailedToCreateDirectSoundSecondaryBuffer = 9000,
    CAAudioError_FailedToQueryDirectSound = 9001,
    CAAudioError_NoChannelAllocated = 9002,
    CAAudioError_FailedToCreateDirectSoundInterface = 9003,
    CAAudioError_FailedToSetDirectSoundCooperativeLevel = 9004,
    CAAudioError_FailedToCreateDirectSoundPrimaryBuffer = 9005,
    CAAudioError_FailedToSetDirectSoundPrimaryBufferFormat = 9006,
    CAAudioError_FailedToLockBufferDown = 9007,
    CAAudioError_FailedToGetStatusOfSecondaryBuffer = 9008,
    CAAudioError_DirectSoundBufferNotAllocated = 9009,
    CAAudioError_SampleIsNot3D = 10000,
    CAAudioError_ModeNotAvailable = 10001,
    CAAudioError_ChannelIsAlreadyPaused = 10002,
    CAAudioError_ChannelIsNotPaused = 10003,
    CAAudioError_FailedToAllocateStreamToSample = 10004,
    CAAudioError_PointerIsBetweenChunks = 11000,
    CAAudioError_BlockNotFound = 11001,
    CAAudioError_NoMemoryLeftForOperation = 12000,
    CAAudioError_IncorrectDataFormat = 13000,
    CAAudioError_SampleIsNot8Or16Bit = 13001,
    CAAudioError_SceneNameIsTooLong = 14000,
    CAAudioError_IncorrectNumberOfChannels = 15000,
    CAAudioError_IncorrectVersion = 16000,
    CAAudioError_IncorrectLanguageMask = 17000,
    CAAudioError_IncorrectPlatformMask = 17001,
    CAAudioError_MissingScenePath = 17002,
    CAAudioError_MissingProjectPath = 17003,
    CAAudioError_MissingOutputPath = 17004,
    CAAudioError_MissingExportName = 17005,
    CAAudioError_ExportNameExceedsEightCharacters = 17006,
    CAAudioError_DuplicateHashError = 17007,
    CAAudioError_DUMMY = 17008,
};

enum _RPC_ASYNC_EVENT
{
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete,
};

enum IMAGE_AUX_SYMBOL_TYPE
{
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
};

enum _USER_MARSHAL_CB_TYPE
{
    USER_MARSHAL_CB_BUFFER_SIZE,
    USER_MARSHAL_CB_MARSHALL,
    USER_MARSHAL_CB_UNMARSHALL,
    USER_MARSHAL_CB_FREE,
};

enum CORE_LED_STATE_TAG
{
    CORE_LED_STATE_DEFAULT,
    inside_sceUtilitySavedataInitStart,
    inside_sceUtilitySavedataGetStatus,
    inside_sceUtilitySavedataUpdate,
    inside_sceUtilitySavedataShutdownStart,
    inside_waitUntilReady,
    inside_sceIoOpen,
    inside_sceIoClose,
    inside_sceIoRead,
    inside_sceIoWrite,
    inside_sceIoLseek,
    inside_sceIoOpenAsync,
    inside_sceIoChangeAsyncPriority,
    inside_sceIoCloseAsync,
    inside_sceIoReadAsync,
    inside_sceIoWriteAsync,
    inside_sceIoLseekAsync,
    inside_sceIoPollAsync,
    inside_sceIoWaitAsync,
    inside_sceIoGetstat,
    inside_sceIoChstat,
    inside_sceIoRemove,
    inside_sceIoDopen,
    inside_sceIoDread,
    inside_sceIoDclose,
    insideMovie_CoreMoviePSP_Play,
    insideMovie_playMovie,
    insideMovie_playMovie_while,
    insideMovie_ringbufferCallBack,
    insideMovie_dispbuf_dataSet,
    insideMovie_WaitDriveStat,
    insideMovie_WaitDriveStatCB,
    insideMovie_DvdUmdIoTerm,
    insideMovie_DvdUmdRetryWaitSema,
    insideMovie_DvdUmdRetryWaitSemaCB,
    insideMovie_CoreMoviePSP_ExitFunc,
    insideMovie_CoreMoviePSP_Play_sceKernelWaitThreadEnd,
    insideMovie_soundbuf_func_sceKernelWaitEventFlag,
    insideMovie_soundbuf_func_sceKernelWaitSema,
    insideMovie_soundbuf_setBuf,
    insideMovie_playMovie_while_startFlag0,
    insideMovie_playMovie_while_startCheck,
    insideMovie_readPspStream,
    insideMovie_readPspStream_sceMpegRingbufferAvailableSize,
    insideMovie_readPspStream_sceMpegRingbufferPut,
    insideMovie_powerLock,
    insideMovie_powerUnlock,
    CORE_LED_STATE_LAST,
};

enum tagTYMED
{
    TYMED_HGLOBAL = (1 << 0),
    TYMED_FILE = (1 << 1),
    TYMED_ISTREAM = (1 << 2),
    TYMED_ISTORAGE = (1 << 3),
    TYMED_GDI = (1 << 4),
    TYMED_MFPICT = (1 << 5),
    TYMED_ENHMF = (1 << 6),
    TYMED_NULL = 0,
};

enum __MIDL_IMonikerProp_0001
{
    MIMETYPEPROP,
    USE_SRC_URL,
};

enum tagCOINIT
{
    COINIT_APARTMENTTHREADED = 2,
};

enum tagOLERENDER
{
    OLERENDER_NONE,
    OLERENDER_DRAW,
    OLERENDER_FORMAT,
    OLERENDER_ASIS,
};

enum tagExtendedErrorParamTypes
{
    eeptAnsiString = 1,
    eeptUnicodeString,
    eeptLongVal,
    eeptShortVal,
    eeptPointerVal,
    eeptNone,
    eeptBinary,
};

enum _IDL_CS_CONVERT
{
    IDL_CS_NO_CONVERT,
    IDL_CS_IN_PLACE_CONVERT,
    IDL_CS_NEW_BUFFER_CONVERT,
};

enum _MEDIA_TYPE
{
    Unknown,
    F5_1Pt2_512,
    F3_1Pt44_512,
    F3_2Pt88_512,
    F3_20Pt8_512,
    F3_720_512,
    F5_360_512,
    F5_320_512,
    F5_320_1024,
    F5_180_512,
    F5_160_512,
    RemovableMedia,
    FixedMedia,
    F3_120M_512,
    F3_640_512,
    F5_640_512,
    F5_720_512,
    F3_1Pt2_512,
    F3_1Pt23_1024,
    F5_1Pt23_1024,
    F3_128Mb_512,
    F3_230Mb_512,
    F8_256_128,
    F3_200Mb_512,
    F3_240M_512,
    F3_32M_512,
};

enum CAL0_FILE_ACCESS
{
    CAL0_FILE_ACCESS_READ,
    CAL0_FILE_ACCESS_WRITE,
};

enum CAL0_FILE_SEEK
{
    CAL0_FILE_SEEK_CURRENT,
    CAL0_FILE_SEEK_END,
    CAL0_FILE_SEEK_SET,
};

enum CA_AI_Type
{
    CA_AI_Sample,
    CA_AI_SampleGroup,
    CA_AI_SampleGroupReplay,
    CA_AI_SampleGroupReplayHybrid,
    CA_AI_SampleGroupReplayHybridChain,
    CA_AI_SampleGroupReplayIndex,
    CA_AI_SampleGroupReplayRandom,
    CA_AI_SampleGroupReplaySequencial,
    CA_AI_SampleGroupReplayChain,
    CA_AI_SampleGroupReplayDelay,
    CA_AI_AudioPlayback,
    CA_AI_AudioParameter,
    CA_AI_AudioEvent,
    CA_AI_AudioObject,
    CA_AI_AudioEventLink,
    CA_AI_AudioItemFileLink,
    CA_AI_AudioScene,
    CA_AI_AudioLevel,
    CA_AI_SampleGroupPlayback,
    CA_AI_NumItems,
    CA_AI_AnyType,
};

enum _CM_SERVICE_NODE_TYPE
{
    DriverType = (1 << 0),
    FileSystemType = (1 << 1),
    Win32ServiceOwnProcess = (1 << 4),
    Win32ServiceShareProcess = (1 << 5),
    AdapterType = (1 << 2),
    RecognizerType = (1 << 3),
};

enum _CM_SERVICE_LOAD_TYPE
{
    BootLoad,
    SystemLoad,
    AutoLoad,
    DemandLoad,
    DisableLoad,
};

enum _CM_ERROR_CONTROL_TYPE
{
    IgnoreError,
    NormalError,
    SevereError,
    CriticalError,
};

enum tagOLEUPDATE
{
    OLEUPDATE_ALWAYS = 1,
    OLEUPDATE_ONCALL = 3,
};

enum tagOLELINKBIND
{
    OLELINKBIND_EVENIFCLASSDIFF = 1,
};

enum _JOBOBJECTINFOCLASS
{
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    MaxJobObjectInfoClass,
};

enum tagSTDMSHLFLAGS
{
    SMEXF_SERVER = 1,
    SMEXF_HANDLER,
};

enum tagSYSKIND
{
    SYS_WIN16,
    SYS_WIN32,
    SYS_MAC,
    SYS_WIN64,
};

enum tagLIBFLAGS
{
    LIBFLAG_FRESTRICTED = (1 << 0),
    LIBFLAG_FCONTROL = (1 << 1),
    LIBFLAG_FHIDDEN = (1 << 2),
    LIBFLAG_FHASDISKIMAGE = (1 << 3),
};

enum _LOGICAL_PROCESSOR_RELATIONSHIP
{
    RelationProcessorCore,
    RelationNumaNode,
};

enum __MIDL_IBindStatusCallback_0001
{
    BINDVERB_GET,
    BINDVERB_POST,
    BINDVERB_PUT,
    BINDVERB_CUSTOM,
};

enum _tagOIBDG_FLAGS
{
    OIBDG_APARTMENTTHREADED = 256,
    OIBDG_DATAONLY = 4096,
};

enum __MIDL_IBindStatusCallback_0002
{
    BINDINFOF_URLENCODESTGMEDDATA = 1,
    BINDINFOF_URLENCODEDEXTRAINFO,
};

enum __MIDL_IBindStatusCallback_0003
{
    BINDF_ASYNCHRONOUS = (1 << 0),
    BINDF_ASYNCSTORAGE = (1 << 1),
    BINDF_NOPROGRESSIVERENDERING = (1 << 2),
    BINDF_OFFLINEOPERATION = (1 << 3),
    BINDF_GETNEWESTVERSION = (1 << 4),
    BINDF_NOWRITECACHE = (1 << 5),
    BINDF_NEEDFILE = (1 << 6),
    BINDF_PULLDATA = (1 << 7),
    BINDF_IGNORESECURITYPROBLEM = (1 << 8),
    BINDF_RESYNCHRONIZE = (1 << 9),
    BINDF_HYPERLINK = (1 << 10),
    BINDF_NO_UI = (1 << 11),
    BINDF_SILENTOPERATION = (1 << 12),
    BINDF_PRAGMA_NO_CACHE = (1 << 13),
    BINDF_GETCLASSOBJECT = (1 << 14),
    BINDF_RESERVED_1 = (1 << 15),
    BINDF_FREE_THREADED = (1 << 16),
    BINDF_DIRECT_READ = (1 << 17),
    BINDF_FORMS_SUBMIT = (1 << 18),
    BINDF_GETFROMCACHE_IF_NET_FAIL = (1 << 19),
    BINDF_FROMURLMON = (1 << 20),
    BINDF_FWD_BACK = (1 << 21),
    BINDF_PREFERDEFAULTHANDLER = (1 << 22),
    BINDF_ENFORCERESTRICTED = (1 << 23),
};

enum tagMEMCTX
{
    MEMCTX_TASK = 1,
    MEMCTX_SHARED = 2,
    MEMCTX_MACSYSTEM = 3,
    MEMCTX_UNKNOWN = 255,
    MEMCTX_SAME = 254,
};

enum __MIDL_IBindStatusCallback_0004
{
    URL_ENCODING_NONE = 0,
    URL_ENCODING_ENABLE_UTF8 = 268435456,
    URL_ENCODING_DISABLE_UTF8 = 536870912,
};

enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER = (1 << 0),
    CLSCTX_INPROC_HANDLER = (1 << 1),
    CLSCTX_LOCAL_SERVER = (1 << 2),
    CLSCTX_INPROC_SERVER16 = (1 << 3),
    CLSCTX_REMOTE_SERVER = (1 << 4),
    CLSCTX_INPROC_HANDLER16 = (1 << 5),
    CLSCTX_RESERVED1 = (1 << 6),
    CLSCTX_RESERVED2 = (1 << 7),
    CLSCTX_RESERVED3 = (1 << 8),
    CLSCTX_RESERVED4 = (1 << 9),
    CLSCTX_NO_CODE_DOWNLOAD = (1 << 10),
    CLSCTX_RESERVED5 = (1 << 11),
    CLSCTX_NO_CUSTOM_MARSHAL = (1 << 12),
    CLSCTX_ENABLE_CODE_DOWNLOAD = (1 << 13),
    CLSCTX_NO_FAILURE_LOG = (1 << 14),
    CLSCTX_DISABLE_AAA = (1 << 15),
    CLSCTX_ENABLE_AAA = (1 << 16),
    CLSCTX_FROM_DEFAULT_CONTEXT = (1 << 17),
};

enum CORE_ND_RESULT_TAG
{
    CORE_ND_RESULT_FINISHED = 0,
    CORE_ND_RESULT_CANCELED = 1,
    CORE_ND_RESULT_FAILED = 255,
};

enum tagSTGTY
{
    STGTY_STORAGE = 1,
    STGTY_STREAM,
    STGTY_LOCKBYTES,
    STGTY_PROPERTY,
};

enum tagMSHLFLAGS
{
    MSHLFLAGS_NORMAL,
    MSHLFLAGS_TABLESTRONG = (1 << 0),
    MSHLFLAGS_TABLEWEAK = (1 << 1),
    MSHLFLAGS_NOPING = (1 << 2),
    MSHLFLAGS_RESERVED1 = (1 << 3),
    MSHLFLAGS_RESERVED2 = (1 << 4),
    MSHLFLAGS_RESERVED3 = (1 << 5),
    MSHLFLAGS_RESERVED4 = (1 << 6),
};

enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET,
    STREAM_SEEK_CUR,
    STREAM_SEEK_END,
};

enum tagLOCKTYPE
{
    LOCK_WRITE = 1,
    LOCK_EXCLUSIVE = 2,
    LOCK_ONLYONCE = 4,
};

enum tagMSHCTX
{
    MSHCTX_LOCAL,
    MSHCTX_NOSHAREDMEM,
    MSHCTX_DIFFERENTMACHINE,
    MSHCTX_INPROC,
    MSHCTX_CROSSCTX,
};

enum tagDVASPECT
{
    DVASPECT_CONTENT = (1 << 0),
    DVASPECT_THUMBNAIL = (1 << 1),
    DVASPECT_ICON = (1 << 2),
    DVASPECT_DOCPRINT = (1 << 3),
};

enum tagSTGC
{
    STGC_DEFAULT,
    STGC_OVERWRITE = (1 << 0),
    STGC_ONLYIFCURRENT = (1 << 1),
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = (1 << 2),
    STGC_CONSOLIDATE = (1 << 3),
};

enum XLAT_SIDE
{
    XLAT_SERVER = 1,
    XLAT_CLIENT,
};

enum tagSTGMOVE
{
    STGMOVE_MOVE,
    STGMOVE_COPY,
    STGMOVE_SHALLOWCOPY,
};

enum tagBINDSPEED
{
    BINDSPEED_INDEFINITE = 1,
    BINDSPEED_MODERATE,
    BINDSPEED_IMMEDIATE,
};

enum _TAPE_DRIVE_PROBLEM_TYPE
{
    TapeDriveProblemNone,
    TapeDriveReadWriteWarning,
    TapeDriveReadWriteError,
    TapeDriveReadWarning,
    TapeDriveWriteWarning,
    TapeDriveReadError,
    TapeDriveWriteError,
    TapeDriveHardwareError,
    TapeDriveUnsupportedMedia,
    TapeDriveScsiConnectionError,
    TapeDriveTimetoClean,
    TapeDriveCleanDriveNow,
    TapeDriveMediaLifeExpired,
    TapeDriveSnappedTape,
};

enum tagDOMNodeType
{
    NODE_INVALID,
    NODE_ELEMENT,
    NODE_ATTRIBUTE,
    NODE_TEXT,
    NODE_CDATA_SECTION,
    NODE_ENTITY_REFERENCE,
    NODE_ENTITY,
    NODE_PROCESSING_INSTRUCTION,
    NODE_COMMENT,
    NODE_DOCUMENT,
    NODE_DOCUMENT_TYPE,
    NODE_DOCUMENT_FRAGMENT,
    NODE_NOTATION,
};

enum tagSTATFLAG
{
    STATFLAG_DEFAULT,
    STATFLAG_NONAME,
    STATFLAG_NOOPEN,
};

enum tagOLECONTF
{
    OLECONTF_EMBEDDINGS = (1 << 0),
    OLECONTF_LINKS = (1 << 1),
    OLECONTF_OTHERS = (1 << 2),
    OLECONTF_ONLYUSER = (1 << 3),
    OLECONTF_ONLYIFRUNNING = (1 << 4),
};

enum tagXMLEMEM_TYPE
{
    XMLELEMTYPE_ELEMENT,
    XMLELEMTYPE_TEXT,
    XMLELEMTYPE_COMMENT,
    XMLELEMTYPE_DOCUMENT,
    XMLELEMTYPE_DTD,
    XMLELEMTYPE_PI,
    XMLELEMTYPE_OTHER,
};

enum _SID_NAME_USE
{
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
};

enum __MIDL_IBindStatusCallback_0005
{
    BINDINFO_OPTIONS_WININETFLAG = (1 << 16),
    BINDINFO_OPTIONS_ENABLE_UTF8 = (1 << 17),
    BINDINFO_OPTIONS_DISABLE_UTF8 = (1 << 18),
    BINDINFO_OPTIONS_USE_IE_ENCODING = (1 << 19),
    BINDINFO_OPTIONS_BINDTOOBJECT = (1 << 20),
};

enum __MIDL_IBindStatusCallback_0006
{
    BSCF_FIRSTDATANOTIFICATION = (1 << 0),
    BSCF_INTERMEDIATEDATANOTIFICATION = (1 << 1),
    BSCF_LASTDATANOTIFICATION = (1 << 2),
    BSCF_DATAFULLYAVAILABLE = (1 << 3),
    BSCF_AVAILABLEDATASIZEUNKNOWN = (1 << 4),
};

enum tagEXTCONN
{
    EXTCONN_STRONG = 1,
    EXTCONN_WEAK = 2,
    EXTCONN_CALLABLE = 4,
};

enum _BIN_TYPES
{
    RequestSize,
    RequestLocation,
};

enum tagBINDSTATUS
{
    BINDSTATUS_FINDINGRESOURCE = 1,
    BINDSTATUS_CONNECTING,
    BINDSTATUS_REDIRECTING,
    BINDSTATUS_BEGINDOWNLOADDATA,
    BINDSTATUS_DOWNLOADINGDATA,
    BINDSTATUS_ENDDOWNLOADDATA,
    BINDSTATUS_BEGINDOWNLOADCOMPONENTS,
    BINDSTATUS_INSTALLINGCOMPONENTS,
    BINDSTATUS_ENDDOWNLOADCOMPONENTS,
    BINDSTATUS_USINGCACHEDCOPY,
    BINDSTATUS_SENDINGREQUEST,
    BINDSTATUS_CLASSIDAVAILABLE,
    BINDSTATUS_MIMETYPEAVAILABLE,
    BINDSTATUS_CACHEFILENAMEAVAILABLE,
    BINDSTATUS_BEGINSYNCOPERATION,
    BINDSTATUS_ENDSYNCOPERATION,
    BINDSTATUS_BEGINUPLOADDATA,
    BINDSTATUS_UPLOADINGDATA,
    BINDSTATUS_ENDUPLOADDATA,
    BINDSTATUS_PROTOCOLCLASSID,
    BINDSTATUS_ENCODING,
    BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE,
    BINDSTATUS_CLASSINSTALLLOCATION,
    BINDSTATUS_DECODING,
    BINDSTATUS_LOADINGMIMEHANDLER,
    BINDSTATUS_CONTENTDISPOSITIONATTACH,
    BINDSTATUS_FILTERREPORTMIMETYPE,
    BINDSTATUS_CLSIDCANINSTANTIATE,
    BINDSTATUS_IUNKNOWNAVAILABLE,
    BINDSTATUS_DIRECTBIND,
    BINDSTATUS_RAWMIMETYPE,
    BINDSTATUS_PROXYDETECTING,
    BINDSTATUS_ACCEPTRANGES,
    BINDSTATUS_COOKIE_SENT,
    BINDSTATUS_COMPACT_POLICY_RECEIVED,
    BINDSTATUS_COOKIE_SUPPRESSED,
    BINDSTATUS_COOKIE_STATE_UNKNOWN,
    BINDSTATUS_COOKIE_STATE_ACCEPT,
    BINDSTATUS_COOKIE_STATE_REJECT,
    BINDSTATUS_COOKIE_STATE_PROMPT,
    BINDSTATUS_COOKIE_STATE_LEASH,
    BINDSTATUS_COOKIE_STATE_DOWNGRADE,
    BINDSTATUS_POLICY_HREF,
    BINDSTATUS_P3P_HEADER,
    BINDSTATUS_SESSION_COOKIE_RECEIVED,
    BINDSTATUS_PERSISTENT_COOKIE_RECEIVED,
    BINDSTATUS_SESSION_COOKIES_ALLOWED,
};

enum _SYSTEM_POWER_STATE
{
    PowerSystemUnspecified,
    PowerSystemWorking,
    PowerSystemSleeping1,
    PowerSystemSleeping2,
    PowerSystemSleeping3,
    PowerSystemHibernate,
    PowerSystemShutdown,
    PowerSystemMaximum,
};

enum WELL_KNOWN_SID_TYPE
{
    WinNullSid,
    WinWorldSid,
    WinLocalSid,
    WinCreatorOwnerSid,
    WinCreatorGroupSid,
    WinCreatorOwnerServerSid,
    WinCreatorGroupServerSid,
    WinNtAuthoritySid,
    WinDialupSid,
    WinNetworkSid,
    WinBatchSid,
    WinInteractiveSid,
    WinServiceSid,
    WinAnonymousSid,
    WinProxySid,
    WinEnterpriseControllersSid,
    WinSelfSid,
    WinAuthenticatedUserSid,
    WinRestrictedCodeSid,
    WinTerminalServerSid,
    WinRemoteLogonIdSid,
    WinLogonIdsSid,
    WinLocalSystemSid,
    WinLocalServiceSid,
    WinNetworkServiceSid,
    WinBuiltinDomainSid,
    WinBuiltinAdministratorsSid,
    WinBuiltinUsersSid,
    WinBuiltinGuestsSid,
    WinBuiltinPowerUsersSid,
    WinBuiltinAccountOperatorsSid,
    WinBuiltinSystemOperatorsSid,
    WinBuiltinPrintOperatorsSid,
    WinBuiltinBackupOperatorsSid,
    WinBuiltinReplicatorSid,
    WinBuiltinPreWindows2000CompatibleAccessSid,
    WinBuiltinRemoteDesktopUsersSid,
    WinBuiltinNetworkConfigurationOperatorsSid,
    WinAccountAdministratorSid,
    WinAccountGuestSid,
    WinAccountKrbtgtSid,
    WinAccountDomainAdminsSid,
    WinAccountDomainUsersSid,
    WinAccountDomainGuestsSid,
    WinAccountComputersSid,
    WinAccountControllersSid,
    WinAccountCertAdminsSid,
    WinAccountSchemaAdminsSid,
    WinAccountEnterpriseAdminsSid,
    WinAccountPolicyAdminsSid,
    WinAccountRasAndIasServersSid,
    WinNTLMAuthenticationSid,
    WinDigestAuthenticationSid,
    WinSChannelAuthenticationSid,
    WinThisOrganizationSid,
    WinOtherOrganizationSid,
    WinBuiltinIncomingForestTrustBuildersSid,
    WinBuiltinPerfMonitoringUsersSid,
    WinBuiltinPerfLoggingUsersSid,
};

enum POWER_ACTION
{
    PowerActionNone,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject,
};

enum _DEVICE_POWER_STATE
{
    PowerDeviceUnspecified,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum,
};

enum CoreNullInputID
{
    CORE_NULL_MAPPING,
};

enum LATENCY_TIME
{
    LT_DONT_CARE,
    LT_LOWEST_LATENCY,
};

enum _ELEMENT_TYPE
{
    AllElements,
    ChangerTransport,
    ChangerSlot,
    ChangerIEPort,
    ChangerDrive,
    ChangerDoor,
    ChangerKeypad,
    ChangerMaxElement,
};

enum POWER_INFORMATION_LEVEL
{
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,
    LastSleepTime,
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
};

enum tagApplicationType
{
    ServerApplication,
    LibraryApplication,
};

enum tagShutdownType
{
    IdleShutdown,
    ForcedShutdown,
};

enum _tagPARSEACTION
{
    PARSE_CANONICALIZE = 1,
    PARSE_FRIENDLY,
    PARSE_SECURITY_URL,
    PARSE_ROOTDOCUMENT,
    PARSE_DOCUMENT,
    PARSE_ANCHOR,
    PARSE_ENCODE,
    PARSE_DECODE,
    PARSE_PATH_FROM_URL,
    PARSE_URL_FROM_PATH,
    PARSE_MIME,
    PARSE_SERVER,
    PARSE_SCHEMA,
    PARSE_SITE,
    PARSE_DOMAIN,
    PARSE_LOCATION,
    PARSE_SECURITY_DOMAIN,
    PARSE_ESCAPE,
    PARSE_UNESCAPE,
};

enum AReverbStatus
{
    AReverbStatus_Off,
    AReverbStatus_RequestNewPreset,
    AReverbStatus_Changing,
    AReverbStatus_InUse,
};

enum tagSF_TYPE
{
    SF_ERROR = 10,
    SF_I1 = 16,
    SF_I2 = 2,
    SF_I4 = 3,
    SF_I8 = 20,
    SF_BSTR = 8,
    SF_UNKNOWN = 13,
    SF_DISPATCH = 9,
    SF_VARIANT = 12,
    SF_RECORD = 36,
    SF_HAVEIID = 32781,
};

enum tagCHANGEKIND
{
    CHANGEKIND_ADDMEMBER,
    CHANGEKIND_DELETEMEMBER,
    CHANGEKIND_SETNAMES,
    CHANGEKIND_SETDOCUMENTATION,
    CHANGEKIND_GENERAL,
    CHANGEKIND_INVALIDATE,
    CHANGEKIND_CHANGEFAILED,
    CHANGEKIND_MAX,
};

enum tagDATADIR
{
    DATADIR_GET = 1,
    DATADIR_SET,
};

enum _tagPSUACTION
{
    PSU_DEFAULT = 1,
    PSU_SECURITY_URL_ONLY,
};

enum _tagQUERYOPTION
{
    QUERY_EXPIRATION_DATE = 1,
    QUERY_TIME_OF_LAST_CHANGE,
    QUERY_CONTENT_ENCODING,
    QUERY_CONTENT_TYPE,
    QUERY_REFRESH,
    QUERY_RECOMBINE,
    QUERY_CAN_NAVIGATE,
    QUERY_USES_NETWORK,
    QUERY_IS_CACHED,
    QUERY_IS_INSTALLEDENTRY,
    QUERY_IS_CACHED_OR_MAPPED,
    QUERY_USES_CACHE,
    QUERY_IS_SECURE,
    QUERY_IS_SAFE,
};

enum BIDI_TYPE
{
    BIDI_NULL,
    BIDI_INT,
    BIDI_FLOAT,
    BIDI_BOOL,
    BIDI_STRING,
    BIDI_TEXT,
    BIDI_ENUM,
    BIDI_BLOB,
};

enum AAChannelStatus
{
    AAChannelStatus_Allocated,
    AAChannelStatus_Unallocated,
    AAChannelStatus_AllocatedStream,
};

enum RPC_ADDRESS_CHANGE_TYPE
{
    PROTOCOL_NOT_LOADED = 1,
    PROTOCOL_LOADED,
    PROTOCOL_ADDRESS_CHANGE,
};

enum _APTTYPE
{
    APTTYPE_CURRENT = 255,
    APTTYPE_STA = 0,
    APTTYPE_MTA = 1,
    APTTYPE_NA = 2,
    APTTYPE_MAINSTA = 3,
};

enum _THDTYPE
{
    THDTYPE_BLOCKMESSAGES,
    THDTYPE_PROCESSMESSAGES,
};

enum std::_Uninitialized
{
    _Noinit,
};

enum tagREGKIND
{
    REGKIND_DEFAULT,
    REGKIND_REGISTER,
    REGKIND_NONE,
};

enum tagBIND_FLAGS
{
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE,
};

enum CORE_XML_TYPE
{
    CORE_XML_UNKNOWN,
    CORE_XML_NULL,
    CORE_XML_STRING,
    CORE_XML_INT,
    CORE_XML_FLOAT,
    CORE_XML_BOOL,
    CORE_XML_HASH,
    CORE_XML_VECTOR3,
    CORE_XML_VECTOR4,
    CORE_XML_MATRIX,
    CORE_XML_END,
};

enum _EXCEPTION_DISPOSITION
{
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind,
};

enum CoreCollidableType
{
    COLLIDABLE_SPHERE = 1,
    COLLIDABLE_SAUSAGE = 2,
    COLLIDABLE_BOX = 4,
    COLLIDABLE_RAGDOLL_SPHERE = 8,
    COLLIDABLE_GEOMETRY_MASK = 15,
    COLLIDABLE_STAND_ON = 16,
};

enum _CHANGER_DEVICE_PROBLEM_TYPE
{
    DeviceProblemNone,
    DeviceProblemHardware,
    DeviceProblemCHMError,
    DeviceProblemDoorOpen,
    DeviceProblemCalibrationError,
    DeviceProblemTargetFailure,
    DeviceProblemCHMMoveError,
    DeviceProblemCHMZeroError,
    DeviceProblemCartridgeInsertError,
    DeviceProblemPositionError,
    DeviceProblemSensorError,
    DeviceProblemCartridgeEjectError,
    DeviceProblemGripperError,
    DeviceProblemDriveError,
};

enum tagCALLTYPE
{
    CALLTYPE_TOPLEVEL = 1,
    CALLTYPE_NESTED,
    CALLTYPE_ASYNC,
    CALLTYPE_TOPLEVEL_CALLPENDING,
    CALLTYPE_ASYNC_CALLPENDING,
};

enum tagSERVERCALL
{
    SERVERCALL_ISHANDLED,
    SERVERCALL_REJECTED,
    SERVERCALL_RETRYLATER,
};

enum tagDCOM_CALL_STATE
{
    DCOM_NONE,
    DCOM_CALL_COMPLETE,
    DCOM_CALL_CANCELED,
};

enum tagPENDINGTYPE
{
    PENDINGTYPE_TOPLEVEL = 1,
    PENDINGTYPE_NESTED,
};

enum __MIDL_ICodeInstall_0001
{
    CIP_DISK_FULL,
    CIP_ACCESS_DENIED,
    CIP_NEWER_VERSION_EXISTS,
    CIP_OLDER_VERSION_EXISTS,
    CIP_NAME_CONFLICT,
    CIP_TRUST_VERIFICATION_COMPONENT_MISSING,
    CIP_EXE_SELF_REGISTERATION_TIMEOUT,
    CIP_UNSAFE_TO_ABORT,
    CIP_NEED_REBOOT,
};

enum tagPENDINGMSG
{
    PENDINGMSG_CANCELCALL,
    PENDINGMSG_WAITNOPROCESS,
    PENDINGMSG_WAITDEFPROCESS,
};

enum __MIDL_IInternetSecurityManager_0001
{
    PUAF_DEFAULT,
    PUAF_NOUI = (1 << 0),
    PUAF_ISFILE = (1 << 1),
    PUAF_WARN_IF_DENIED = (1 << 2),
    PUAF_FORCEUI_FOREGROUND = (1 << 3),
    PUAF_CHECK_TIFS = (1 << 4),
    PUAF_DONTCHECKBOXINDIALOG = (1 << 5),
    PUAF_TRUSTED = (1 << 6),
    PUAF_ACCEPT_WILDCARD_SCHEME = (1 << 7),
    PUAF_ENFORCERESTRICTED = (1 << 8),
};

enum tagDISCARDCACHE
{
    DISCARDCACHE_SAVEIFDIRTY,
    DISCARDCACHE_NOSAVE,
};

enum __MIDL_IInternetSecurityManager_0002
{
    SZM_CREATE,
    SZM_DELETE,
};

enum _ACL_INFORMATION_CLASS
{
    AclRevisionInformation = 1,
    AclSizeInformation,
};

enum tagTYPEKIND
{
    TKIND_ENUM,
    TKIND_RECORD,
    TKIND_MODULE,
    TKIND_INTERFACE,
    TKIND_DISPATCH,
    TKIND_COCLASS,
    TKIND_ALIAS,
    TKIND_UNION,
    TKIND_MAX,
};

enum CoreCombatMarkerGeometryType
{
    SPHERE,
    SAUSAGE,
    CONE,
};

enum CoreWeaponMarkerType
{
    CLUBWEAPON,
    BULLET,
    EXPLOSION,
    KNIFE,
    FIST,
    FOOT,
    OTHERBODYPART,
    FIRE,
    UNKNOWN,
    NUM_WEAPON_MARKER_TYPES,
};

enum _SC_ACTION_TYPE
{
    SC_ACTION_NONE,
    SC_ACTION_RESTART,
    SC_ACTION_REBOOT,
    SC_ACTION_RUN_COMMAND,
};

enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE,
    IMPORT_OBJECT_DATA,
    IMPORT_OBJECT_CONST,
};

enum CoreNavDistance
{
    ND_VERY_CLOSE,
    ND_CLOSE,
    ND_MEDIUM,
    ND_FAR,
    ND_UNDEFINED = 255,
};

enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL,
    IMPORT_OBJECT_NAME,
    IMPORT_OBJECT_NAME_NO_PREFIX,
    IMPORT_OBJECT_NAME_UNDECORATE,
};

enum ReplacesCorHdrNumericDefines
{
    COMIMAGE_FLAGS_ILONLY = 1,
    COMIMAGE_FLAGS_32BITREQUIRED = 2,
    COMIMAGE_FLAGS_IL_LIBRARY = 4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 8,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536,
    COR_VERSION_MAJOR_V2 = 2,
    COR_VERSION_MAJOR = 2,
    COR_VERSION_MINOR = 0,
    COR_DELETED_NAME_LENGTH = 8,
    COR_VTABLEGAP_NAME_LENGTH = 8,
    NATIVE_TYPE_MAX_CB = 1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255,
    IMAGE_COR_MIH_METHODRVA = 1,
    IMAGE_COR_MIH_EHRVA = 2,
    IMAGE_COR_MIH_BASICBLOCK = 8,
    COR_VTABLE_32BIT = 1,
    COR_VTABLE_64BIT = 2,
    COR_VTABLE_FROM_UNMANAGED = 4,
    COR_VTABLE_CALL_MOST_DERIVED = 16,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
    MAX_PACKAGE_NAME = 1024,
};

enum tagDESCKIND
{
    DESCKIND_NONE,
    DESCKIND_FUNCDESC,
    DESCKIND_VARDESC,
    DESCKIND_TYPECOMP,
    DESCKIND_IMPLICITAPPOBJ,
    DESCKIND_MAX,
};

enum tagREGCLS
{
    REGCLS_SINGLEUSE,
    REGCLS_MULTIPLEUSE = (1 << 0),
    REGCLS_MULTI_SEPARATE = (1 << 1),
    REGCLS_SUSPENDED = (1 << 2),
    REGCLS_SURROGATE = (1 << 3),
};

enum CoreBodyMarkerType
{
    ALLBODY,
    UPPERBODY,
    LOWERBODY,
    LEFTARM,
    RIGHTARM,
    LEFTLEG,
    RIGHTLEG,
    HHEAD,
    NUM_BODY_MARKER_TYPES,
};

enum _AUDIT_EVENT_TYPE
{
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess,
};

enum VARENUM
{
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_RECORD = 36,
    VT_INT_PTR = 37,
    VT_UINT_PTR = 38,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VERSIONED_STREAM = 73,
    VT_BSTR_BLOB = 4095,
    VT_VECTOR = 4096,
    VT_ARRAY = 8192,
    VT_BYREF = 16384,
    VT_RESERVED = 32768,
    VT_ILLEGAL = 65535,
    VT_ILLEGALMASKED = 4095,
    VT_TYPEMASK = 4095,
};

enum _SC_STATUS_TYPE
{
    SC_STATUS_PROCESS_INFO,
};

enum _SC_ENUM_TYPE
{
    SC_ENUM_PROCESS_INFO,
};

enum SYSNLS_FUNCTION
{
    COMPARE_STRING = 1,
};

enum _SECURITY_IMPERSONATION_LEVEL
{
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation,
};

enum _TOKEN_TYPE
{
    TokenPrimary = 1,
    TokenImpersonation,
};

enum CORE_OSK_RESULT_TAG
{
    CORE_OSK_RESULT_EDITED = 0,
    CORE_OSK_RESULT_UNEDITED = 1,
    CORE_OSK_RESULT_CANCELED = 2,
    CORE_OSK_RESULT_FAILED = 255,
    CORE_OSK_RESULT_FAILED_NOT_IMPLEMENTED = 254,
};

enum _TOKEN_INFORMATION_CLASS
{
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    MaxTokenInfoClass,
};

enum SYSGEOTYPE
{
    GEO_NATION = 1,
    GEO_LATITUDE,
    GEO_LONGITUDE,
    GEO_ISO2,
    GEO_ISO3,
    GEO_RFC1766,
    GEO_LCID,
    GEO_FRIENDLYNAME,
    GEO_OFFICIALNAME,
    GEO_TIMEZONES,
    GEO_OFFICIALLANGUAGES,
};

enum CoreBodyQuadrant
{
    FRONT_QUADRANT,
    BACK_QUADRANT,
    RIGHT_QUADRANT,
    LEFT_QUADRANT,
};

enum SYSGEOCLASS
{
    GEOCLASS_NATION = 16,
    GEOCLASS_REGION = 14,
};

enum CoreDetectEventType
{
    CORE_EVENT_NONE,
    CORE_EVENT_TYPE1 = (1 << 0),
    CORE_EVENT_TYPE2 = (1 << 1),
    CORE_EVENT_TYPE3 = (1 << 2),
    CORE_EVENT_TYPE4 = (1 << 3),
};

enum CoreDetectLineType
{
    CORE_LINE_NONE,
    CORE_LINE_TYPE1 = (1 << 0),
    CORE_LINE_TYPE2 = (1 << 1),
    CORE_LINE_TYPE3 = (1 << 2),
    CORE_LINE_TYPE4 = (1 << 3),
};

enum tagCALLCONV
{
    CC_FASTCALL = 0,
    CC_CDECL = 1,
    CC_MSCPASCAL = 2,
    CC_PASCAL = 2,
    CC_MACPASCAL = 3,
    CC_STDCALL = 4,
    CC_FPFASTCALL = 5,
    CC_SYSCALL = 6,
    CC_MPWCDECL = 7,
    CC_MPWPASCAL = 8,
    CC_MAX = 9,
};

enum tagTYSPEC
{
    TYSPEC_CLSID,
    TYSPEC_FILEEXT,
    TYSPEC_MIMETYPE,
    TYSPEC_FILENAME,
    TYSPEC_PROGID,
    TYSPEC_PACKAGENAME,
    TYSPEC_OBJECTID,
};

enum CORE_MB_RESULT_TAG
{
    CORE_MB_RESULT_FINISHED = 0,
    CORE_MB_RESULT_CANCELED = 1,
    CORE_MB_RESULT_FAILED = 255,
    CORE_MB_RESULT_NOT_IMPLEMENTED = 254,
};

enum tagFUNCKIND
{
    FUNC_VIRTUAL,
    FUNC_PUREVIRTUAL,
    FUNC_NONVIRTUAL,
    FUNC_STATIC,
    FUNC_DISPATCH,
};

enum tagINVOKEKIND
{
    INVOKE_FUNC = (1 << 0),
    INVOKE_PROPERTYGET = (1 << 1),
    INVOKE_PROPERTYPUT = (1 << 2),
    INVOKE_PROPERTYPUTREF = (1 << 3),
};

struct tagEMRTRANSPARENTBLT
{
    tagEMR emr;
    _RECTL rclBounds;
    int32_t xDest;
    int32_t yDest;
    int32_t cxDest;
    int32_t cyDest;
    uint32_t dwRop;
    int32_t xSrc;
    int32_t ySrc;
    tagXFORM xformSrc;
    uint32_t crBkColorSrc;
    uint32_t iUsageSrc;
    uint32_t offBmiSrc;
    uint32_t cbBmiSrc;
    uint32_t offBitsSrc;
    uint32_t cbBitsSrc;
    int32_t cxSrc;
    int32_t cySrc;
};

struct tagMIDIINCAPS2W
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t dwSupport;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct _CLASS_MEDIA_CHANGE_CONTEXT
{
    uint32_t MediaChangeCount;
    uint32_t NewState;
};

struct tagIDLDESC
{
    uint32_t dwReserved;
    uint32_t wIDLFlags;
};

struct creative_adpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wRevision;
};

struct _TAPE_SET_DRIVE_PARAMETERS
{
    uint32_t ECC;
    uint32_t Compression;
    uint32_t DataPadding;
    uint32_t ReportSetmarks;
    uint32_t EOTWarningZoneSize;
};

struct tagCBTACTIVATESTRUCT
{
    int32_t fMouse;
    HWND* hWndActive;
};

struct _NETRESOURCEW
{
    uint32_t dwScope;
    uint32_t dwType;
    uint32_t dwDisplayType;
    uint32_t dwUsage;
    uint32_t* lpLocalName;
    uint32_t* lpRemoteName;
    uint32_t* lpComment;
    uint32_t* lpProvider;
};

struct tagRemHGLOBAL
{
    int32_t fNullHGlobal;
    uint32_t cbData;
    uint32_t data[1];
};

struct _DWORD_BLOB
{
    uint32_t clSize;
    uint32_t alData[1];
};

struct CorePrimitiveTypes
{
    enum CorePrimitiveTypesEnum
    {
        INVALID = 0,
        TRIANGLE = 0,
        TRIANGLESTRIP = 1,
        LINE = 2,
        LINESTRIP = 3,
        ALPHA_BLENDED = 4,
        FLAT_SHADED = 5,
        STATIC_MESH = 6,
        PARENTED_MESH = 7,
        HARDSKINNED_MESH = 8,
        SOFTSKINNED_MESH = 9,
        BLENDSHAPE_MESH = 10,
        SHADOW_MESH = 11,
        VOLUMES_MESH = 12,
        ENVMAP_MESH = 13,
    };

    // TODO vtable

    void YouCannotInstanceThisClass();
    void CorePrimitiveTypes();
};

struct _QUERY_SERVICE_CONFIGA
{
    uint32_t dwServiceType;
    uint32_t dwStartType;
    uint32_t dwErrorControl;
    char* lpBinaryPathName;
    char* lpLoadOrderGroup;
    uint32_t dwTagId;
    char* lpDependencies;
    char* lpServiceStartName;
    char* lpDisplayName;
};

struct CoreRTreeRecord
{
    float m_minX;
    float m_minY;
    float m_minZ;
    int32_t m_index;
    float m_maxX;
    float m_maxY;
    float m_maxZ;
    uint32_t m_siblingIndex;
    uint32_t m_firstChildIndex;

    void CoreRTreeRecord();
    void ~CoreRTreeRecord();
    CoreVector GetMin();
    CoreVector GetMax();
    int32_t GetIndex();
    uint32_t GetSiblingIndex();
    uint32_t GetFirstChildIndex();
};

struct CoreRTreeParams
{
    CoreVector m_min;
    CoreVector m_max;
    int32_t* m_indexList;
    int32_t m_indexMax;
    CoreRTreeRecord* m_records;
    int32_t m_stackLevel;
    int32_t m_stack[10];

    void CoreRTreeParams();
};

struct _PROCESS_HEAP_ENTRY
{
    void* lpData;
    uint32_t cbData;
    uint32_t cbOverhead;
    uint32_t iRegionIndex;
    uint32_t wFlags;
    _PROCESS_HEAP_ENTRY::__unnamed::__unnamed Block;
    _PROCESS_HEAP_ENTRY::__unnamed::__unnamed Region;
};

struct _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO
{
    _CERT_ID RecipientId;
    _CRYPTOAPI_BLOB EncryptedKey;
    _FILETIME Date;
    _CRYPT_ATTRIBUTE_TYPE_VALUE* pOtherAttr;
};

struct tagMETHODDATA
{
    uint32_t* szName;
    tagPARAMDATA* ppdata;
    int32_t dispid;
    uint32_t iMeth;
    tagCALLCONV cc;
    uint32_t cArgs;
    uint32_t wFlags;
    uint32_t vtReturn;
};

struct _DSFXEcho
{
    float fWetDryMix;
    float fFeedback;
    float fLeftDelay;
    float fRightDelay;
    int32_t lPanDelay;
};

struct _GUID
{
    uint32_t Data1;
    uint32_t Data2;
    uint32_t Data3;
    uint32_t Data4[8];
};

struct _SID_AND_ATTRIBUTES
{
    void* Sid;
    uint32_t Attributes;
};

struct _MEMORY_BASIC_INFORMATION64
{
    uint32_t BaseAddress;
    uint32_t AllocationBase;
    uint32_t AllocationProtect;
    uint32_t __alignment1;
    uint32_t RegionSize;
    uint32_t State;
    uint32_t Protect;
    uint32_t Type;
    uint32_t __alignment2;
};

struct gsm610waveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
};

struct tagRemHMETAFILEPICT
{
    int32_t mm;
    int32_t xExt;
    int32_t yExt;
    uint32_t cbData;
    uint32_t data[1];
};

struct _PROCESSOR_POWER_POLICY
{
    uint32_t Revision;
    uint32_t DynamicThrottle;
    uint32_t Spare[3];
    uint32_t DisableCStates : 1;
    uint32_t Reserved : 31;
    uint32_t PolicyCount;
    _PROCESSOR_POWER_POLICY_INFO Policy[3];
};

struct tagTOGGLEKEYS
{
    uint32_t cbSize;
    uint32_t dwFlags;
};

struct _FULL_PTR_XLAT_TABLES
{
    _FULL_PTR_XLAT_TABLES::__unnamed RefIdToPointer;
    _FULL_PTR_XLAT_TABLES::__unnamed PointerToRefId;
    uint32_t NextRefId;
    XLAT_SIDE XlatSide;
};

struct _DOC_INFO_2W
{
    uint32_t* pDocName;
    uint32_t* pOutputFile;
    uint32_t* pDatatype;
    uint32_t dwMode;
    uint32_t JobId;
};

struct _OFNOTIFYEXA
{
    tagNMHDR hdr;
    tagOFNA* lpOFN;
    void* psf;
    void* pidl;
};

struct _PSP
{
};

struct tagPDEXA
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    void* hDevMode;
    void* hDevNames;
    HDC__* hDC;
    uint32_t Flags;
    uint32_t Flags2;
    uint32_t ExclusionFlags;
    uint32_t nPageRanges;
    uint32_t nMaxPageRanges;
    tagPRINTPAGERANGE* lpPageRanges;
    uint32_t nMinPage;
    uint32_t nMaxPage;
    uint32_t nCopies;
    HINSTANCE__* hInstance;
    char* lpPrintTemplateName;
    IUnknown* lpCallback;
    uint32_t nPropertyPages;
    _PSP** lphPropertyPages;
    uint32_t nStartPage;
    uint32_t dwResultAction;
};

struct _EXCEPTION_RECORD
{
    uint32_t ExceptionCode;
    uint32_t ExceptionFlags;
    _EXCEPTION_RECORD* ExceptionRecord;
    void* ExceptionAddress;
    uint32_t NumberParameters;
    uint32_t ExceptionInformation[15];
};

struct DLGTEMPLATE
{
    uint32_t style;
    uint32_t dwExtendedStyle;
    uint32_t cdit;
    int32_t x;
    int32_t y;
    int32_t cx;
    int32_t cy;
};

struct _PROPSHEETPAGEA_V3
{
    uint32_t dwSize;
    uint32_t dwFlags;
    HINSTANCE__* hInstance;
    char* pszTemplate;
    DLGTEMPLATE* pResource;
    HICON__* hIcon;
    char* pszIcon;
    char* pszTitle;
    int32_t* pfnDlgProc;
    int32_t lParam;
    uint32_t* pfnCallback;
    uint32_t* pcRefParent;
    char* pszHeaderTitle;
    char* pszHeaderSubTitle;
    void* hActCtx;
};

struct _PRINTER_INFO_5A
{
    char* pPrinterName;
    char* pPortName;
    uint32_t Attributes;
    uint32_t DeviceNotSelectedTimeout;
    uint32_t TransmissionRetryTimeout;
};

struct CoreBGLightPatternFrame
{
    uint32_t m_flags;
    float m_red;
    float m_green;
    float m_blue;
    uint32_t m_src;
};

struct tagNMHDR
{
    HWND* hwndFrom;
    uint32_t idFrom;
    uint32_t code;
};

struct _currencyfmtA
{
    uint32_t NumDigits;
    uint32_t LeadingZero;
    uint32_t Grouping;
    char* lpDecimalSep;
    char* lpThousandSep;
    uint32_t NegativeOrder;
    uint32_t PositiveOrder;
    char* lpCurrencySymbol;
};

struct _CERT_CONTEXT
{
    uint32_t dwCertEncodingType;
    uint32_t* pbCertEncoded;
    uint32_t cbCertEncoded;
    _CERT_INFO* pCertInfo;
    void* hCertStore;
};

struct _CERT_CHAIN_ELEMENT
{
    uint32_t cbSize;
    _CERT_CONTEXT* pCertContext;
    _CERT_TRUST_STATUS TrustStatus;
    _CERT_REVOCATION_INFO* pRevocationInfo;
    _CTL_USAGE* pIssuanceUsage;
    _CTL_USAGE* pApplicationUsage;
    uint32_t* pwszExtendedErrorInfo;
};

struct _PRINTER_NOTIFY_INFO_DATA
{
    uint32_t Type;
    uint32_t Field;
    uint32_t Reserved;
    uint32_t Id;
    _PRINTER_NOTIFY_INFO_DATA::__unnamed NotifyData;
};

struct CoreLevelLightSet
{
    enum
    {
        VERSION = 28,
    };

    uint32_t m_numEngineDynamicLights;
    uint32_t m_engineDynamicLightPtr;
    int32_t m_iNumStaticLights;
    int32_t m_iNumDynamicLights;
    int32_t m_iNumStaticFlaps;
    int32_t m_iNumDynamicFlaps;
    int32_t m_iActiveDynamicLight;
    int32_t m_iActiveDynamicFlap;
    int32_t m_iLevelLightOffset;
    int32_t m_iLevelDynamicLightBaseOffset;
    int32_t m_iLevelDynamicLightCurrentOffset;
    int32_t m_iLevelFlapOffset;
    int32_t m_iLevelDynamicFlapBaseOffset;
    int32_t m_iLevelDynamicFlapCurrentOffset;
    CoreLevelDynamicLight m_oTempDynamicLight;
    CoreLevelDynamicFlap m_oTempDynamicFlap;

    void CoreLevelLightSet();
    void ~CoreLevelLightSet();
    int32_t GetNumberOfLights();
    int32_t GetNumberOfStaticLights();
    int32_t GetNumberOfDynamicLights();
    int32_t GetNumberOfFlaps();
    int32_t GetNumberOfStaticFlaps();
    int32_t GetNumberOfDynamicFlaps();
    CoreLevelLight* GetLevelLight();
    CoreLevelLight* GetStaticLevelLight();
    CoreLevelLight* GetDynamicLevelLight();
    CoreLevelDynamicLight* GetDynamicLevelLightBaseValues();
    CoreLevelDynamicLight* GetDynamicLevelLightCurrentValues();
    CoreLevelFlap* GetLevelFlap();
    CoreLevelFlap* GetStaticLevelFlap();
    CoreLevelFlap* GetDynamicLevelFlap();
    CoreLevelDynamicFlap* GetDynamicLevelFlapBaseValues();
    CoreLevelDynamicFlap* GetDynamicLevelFlapCurrentValues();
    void DoDebug(CoreDebugInput* i_input, CoreGraphicsDevice* lpoGraphicsDevice);
    void SelectLightsFromList(CoreLevelLight** iLightList, uint32_t iNumLights, CoreVector& vWorldPos, CoreGraphicsDeviceLightData* ioLightData);
    void SelectLights();
    void Reset();
    void SettleLights();
    void SetDynamicLight(uint32_t iIndex);
    int32_t FindDynamicLight(CoreHash oName);
    void ResetDynamicLights();
    bool StartEditingEngineDynamicLight();
    bool StartEditingDynamicLight(CoreHash oName);
    bool ResetDynamicLightToBaseValues();
    bool SetDynamicLightType(CoreLevelLight::CoreLevelLightTypeEnum eType);
    bool SetDynamicLightPosition(CoreVector& vPosition);
    bool SetDynamicLightColours(CoreVector& vInnerColour, CoreVector& vOuterColour);
    bool SetDynamicLightRadii(float fInnerRadius, float fOuterRadius);
    bool SetDynamicLightIntensity(float fIntensity);
    bool SetDynamicDirectionalLightDirection(CoreVector& vDirection);
    bool SetDynamicSpotLightDirection(CoreVector& vDirection);
    bool SetDynamicSpotLightConeAngles(float fInnerConeAngle, float fOuterConeAngle);
    bool SetDynamicAreaLightOrientation(CoreEulerAngle& eaOrient);
    bool SetDynamicAreaLightSize(float fXSize, float fYSize);
    bool SetDynamicAreaLightSoftness(float fSoftness);
    bool SetDynamicCylinderLightDirection(CoreVector& vDirection);
    bool SetDynamicCylinderLightLength(float fLength);
    bool EndEditingDynamicLight();
    int32_t FindDynamicFlap(CoreHash oName);
    void ResetDynamicFlaps();
    bool StartEditingDynamicFlap(CoreHash oName);
    bool ResetDynamicFlapToBaseValues();
    bool SetDynamicFlapPosition(CoreVector& vPosition);
    bool SetDynamicFlapOrientation(CoreEulerAngle& eaOrient);
    bool SetDynamicFlapSize(float fXSize, float fYSize);
    bool SetDynamicFlapEdges(bool bLeftOpen, bool bRightOpen, bool bTopOpen, bool bBottomOpen);
    bool SetDynamicFlapSoftness(float fSoftness);
    bool EndEditingDynamicFlap();
    void SetNumEngineDynamicLights(uint32_t i_num);
    void SetEngineDynamicLightPtr(CoreLevelDynamicLight* i_ptr);
    void SetEngineDynamicLevelLightPtr(CoreLevelLight* i_ptr);
    void BuildLightPartitions();
    uint32_t GetInfluenceLights(CoreVector iMin, CoreVector iMax, CoreLevelLight** oLightList, uint32_t iMaxLights);
    void RenderContainers();
    void RenderSingleContainer();
    CoreLevelDynamicLight* GetEngineDynamicLightBase();
    CoreLevelLight* GetEngineDynamicLevelLight();
    CoreLevelLight* GetLevelLight0Ptr();
    CoreLevelLight* GetStaticLevelLight0Ptr();
    CoreLevelLight* GetDynamicLevelLight0Ptr();
    CoreLevelDynamicLight* GetDynamicLevelLightBaseValues0Ptr();
    CoreLevelDynamicLight* GetDynamicLevelLightCurrentValues0Ptr();
    CoreLevelFlap* GetLevelFlap0Ptr();
    CoreLevelFlap* GetStaticLevelFlap0Ptr();
    CoreLevelFlap* GetDynamicLevelFlap0Ptr();
    CoreLevelDynamicFlap* GetDynamicLevelFlapBaseValues0Ptr();
    CoreLevelDynamicFlap* GetDynamicLevelFlapCurrentValues0Ptr();
    void DebugDrawLight(int32_t iLight, bool bDrawText, bool bDrawGraphics);
    void DebugDrawFlap(int32_t iFlap, bool bDrawText, bool bDrawGraphics, bool bFG, bool bActive);
};

struct CoreLevelLight
{
    enum
    {
        VERSION = 11,
    };

    enum CoreLevelLightTypeEnum
    {
        FIRST_TYPE = 0,
        AMBIENT = 0,
        AREA = 1,
        DIRECTIONAL = 2,
        POINT = 3,
        SPOT = 4,
        CYLINDER = 5,
        LAST_TYPE = 5,
        INACTIVE = 6,
    };

    enum CoreLevelLightFlagsEnum
    {
        OBJECT,
        CHARACTER,
    };

    char m_lpcName[16];
    uint32_t m_uiHash;
    int32_t m_type;
    int32_t m_flags;
    float m_fInnerMinusOuterRed;
    float m_fInnerMinusOuterGreen;
    float m_fInnerMinusOuterBlue;
    float m_fOuterRed;
    float m_fOuterGreen;
    float m_fOuterBlue;
    float m_fIntensity;
    float m_fPositionX;
    float m_fPositionY;
    float m_fPositionZ;
    float m_fPlaneX;
    float m_fPlaneY;
    float m_fPlaneZ;
    float m_fPlaneW;
    float m_fOuterMinusInnerRadius;
    float m_fOuterRadius;
    float m_fSpotCosInnerMinusCosOuterConeAngle;
    float m_fSpotCosOuterConeAngle;
    float m_fAreaXNormalX;
    float m_fAreaXNormalY;
    float m_fAreaXNormalZ;
    float m_fAreaYNormalX;
    float m_fAreaYNormalY;
    float m_fAreaYNormalZ;
    float m_fAreaDXMinus;
    float m_fAreaDXPlus;
    float m_fAreaDYMinus;
    float m_fAreaDYPlus;

    void CoreLevelLight();
    void ~CoreLevelLight();
    void Reset();
    char* GetName();
    uint32_t GetHash();
    float GetInnerMinusOuterRed();
    float GetInnerMinusOuterGreen();
    float GetInnerMinusOuterBlue();
    CoreVector GetInnerMinusOuterColourVector();
    CoreRGBA GetInnerMinusOuterColourRGBA();
    CoreRGBA GetInnerColour();
    float GetInnerRed();
    float GetInnerGreen();
    float GetInnerBlue();
    float GetOuterRed();
    float GetOuterGreen();
    float GetOuterBlue();
    CoreVector GetOuterColourVector();
    CoreRGBA GetOuterColourRGBA();
    CoreLevelLight::CoreLevelLightTypeEnum GetType();
    char* GetTypeName();
    bool IsAmbient();
    bool IsArea();
    bool IsDirectional();
    bool IsPoint();
    bool IsSpot();
    int32_t GetFlags();
    void SetFlags();
    bool IsObject();
    bool IsCharacter();
    float GetIntensity();
    CoreVector GetPosition();
    CoreVector GetPlane();
    float GetOuterMinusInnerRadius();
    float GetInnerRadius();
    float GetOuterRadius();
    float GetSpotCosInnerMinusCosOuterConeAngle();
    float GetSpotCosOuterConeAngle();
    float GetSpotInnerConeAngle();
    float GetSpotOuterConeAngle();
    CoreVector GetAreaXNormal();
    CoreVector GetAreaYNormal();
    float GetAreaDXMinus();
    float GetAreaDXPlus();
    float GetAreaDYMinus();
    float GetAreaDYPlus();
    float GetAreaXSize();
    float GetAreaYSize();
    CoreVector GetCylinderEndPoint1();
    CoreVector GetCylinderEndPoint2();
    float GetCylinderLength();
    bool bIsInfluenceBox(CoreVector iMin, CoreVector iMax);
    void SetName();
    void SetHash();
    void SetType();
    void SetInnerMinusOuterColour();
    void SetOuterColour();
    void SetIntensity();
    void SetPosition();
    void SetPlane();
    void SetOuterMinusInnerRadius();
    void SetOuterRadius();
    void SetSpotCosInnerMinusCosOuterConeAngle();
    void SetSpotCosOuterConeAngle();
    void SetAreaXSize();
    void SetAreaYSize();
    void SetAreaXNormal();
    void SetAreaYNormal();
    void SetAreaDXMinus();
    void SetAreaDXPlus();
    void SetAreaDYMinus();
    void SetAreaDYPlus();
    void SetCylinerLength();
    void SetCylinderEndPoint1();
    void SetCylinderEndPoint2();
};

struct CoreLevelDynamicLight
{
    enum
    {
        VERSION = 1,
    };

    char m_lpcName[16];
    uint32_t m_uiHash;
    int32_t m_iType;
    CoreVector m_vInnerColour;
    CoreVector m_vOuterColour;
    float m_fIntensity;
    CoreVector m_vPosition;
    CoreVector m_vOrigin;
    CoreEulerAngle m_eaOrient;
    CoreVector m_vScale;
    CoreVector m_vPlane;
    float m_fInnerRadius;
    float m_fOuterRadius;
    float m_fSpotInnerConeAngle;
    float m_fSpotOuterConeAngle;
    float m_fAreaXSize;
    float m_fAreaYSize;
    CoreVector m_vAreaXNormal;
    CoreVector m_vAreaYNormal;
    float m_fAreaSoftnessDistance;
    float m_fCylinderLength;

    void CoreLevelDynamicLight();
    void ~CoreLevelDynamicLight();
    void SetName();
    void SetHash();
    void SetType(CoreLevelLight::CoreLevelLightTypeEnum eType);
    void SetTransformation();
    void SetColours(CoreVector& vInnerColour, CoreVector& vOuterColour);
    void SetRadii(float fInnerRadius, float fOuterRadius);
    void SetIntensity(float fIntensity);
    void SetPosition(CoreVector& vPosition);
    void SetDirectionalDirection(CoreVector& vDirection);
    void SetSpotConeAngles(float fInnerConeAngle, float fOuterConeAngle);
    void SetSpotDirection(CoreVector& vDirection);
    void SetAreaOrientation(CoreEulerAngle& eaOrient);
    void SetAreaSize(float fXSize, float fYSize);
    void SetAreaSoftnessDistance(float fSoftnessDistance);
    void SetCylinderDirection(CoreVector& vDirection);
    void SetCylinderLength(float fLength);
    void Reset();
    void MakeLevelLight(CoreLevelLight* lpoLevelLight);
    char* GetName();
    uint32_t GetHash();
    int32_t GetType();
    char* GetTypeName();
    CoreVector GetInnerColour();
    CoreVector GetOuterColour();
    float GetIntensity();
    CoreVector GetPosition();
    CoreVector GetOrigin();
    CoreEulerAngle GetOrient();
    CoreVector GetScale();
    CoreVector GetPlane();
    float GetInnerRadius();
    float GetOuterRadius();
    float GetSpotInnerConeAngle();
    float GetSpotOuterConeAngle();
    float GetAreaXSize();
    float GetAreaYSize();
    CoreVector GetAreaXNormal();
    CoreVector GetAreaYNormal();
    float GetAreaSoftnessDistance();
    float GetCylinderLength();
};

struct CoreLevelFlap
{
    enum
    {
        VERSION = 3,
    };

    char m_lpcName[16];
    uint32_t m_uiHash;
    float m_fPositionX;
    float m_fPositionY;
    float m_fPositionZ;
    float m_fPlaneX;
    float m_fPlaneY;
    float m_fPlaneZ;
    float m_fPlaneW;
    float m_fXNormalX;
    float m_fXNormalY;
    float m_fXNormalZ;
    float m_fYNormalX;
    float m_fYNormalY;
    float m_fYNormalZ;
    float m_fDXPlus;
    float m_fDXMinus;
    float m_fDYPlus;
    float m_fDYMinus;
    float m_fXSize;
    float m_fYSize;

    void CoreLevelFlap();
    void ~CoreLevelFlap();
    char* GetName();
    uint32_t GetHash();
    CoreVector GetPosition();
    CoreVector GetPlane();
    CoreVector GetXNormal();
    CoreVector GetYNormal();
    float GetDXPlus();
    float GetDXMinus();
    float GetDYPlus();
    float GetDYMinus();
    float GetXSize();
    float GetYSize();
    void SetName();
    void SetHash();
    void SetPosition();
    void SetPlane();
    void SetSize();
    void SetXNormal();
    void SetYNormal();
    void SetDX();
    void SetDY();
};

struct CoreLevelDynamicFlap
{
    enum
    {
        VERSION = 1,
    };

    char m_lpcName[16];
    uint32_t m_uiHash;
    CoreVector m_vPosition;
    CoreEulerAngle m_eaOrient;
    CoreVector m_vScale;
    CoreVector m_vPlane;
    CoreVector m_vXNormal;
    CoreVector m_vYNormal;
    float m_fDXPlus;
    float m_fDXMinus;
    float m_fDYPlus;
    float m_fDYMinus;
    float m_fXSize;
    float m_fYSize;
    float m_fSoftnessDistance;
    bool m_bOpenLeft;
    bool m_bOpenRight;
    bool m_bOpenTop;
    bool m_bOpenBottom;

    void CoreLevelDynamicFlap();
    void ~CoreLevelDynamicFlap();
    void SetName();
    void SetHash();
    void SetTransformation();
    void SetPosition(CoreVector& vPosition);
    void SetOrientation(CoreEulerAngle& eaOrient);
    void SetSize(float fXSize, float fYSize);
    void SetSoftnessDistance(float fSoftnessDistance);
    void SetOpen(bool bLeft, bool bRight, bool bTop, bool bBottom);
    void MakeLevelFlap(CoreLevelFlap* lpoLevelFlap);
    char* GetName();
    uint32_t GetHash();
    CoreVector GetPosition();
    CoreEulerAngle GetOrient();
    CoreVector GetScale();
    CoreVector GetPlane();
    CoreVector GetXNormal();
    CoreVector GetYNormal();
    float GetXSize();
    float GetYSize();
    float GetDXPlus();
    float GetDXMinus();
    float GetDYPlus();
    float GetDYMinus();
    float GetSoftnessDistance();
    bool GetOpenLeft();
    bool GetOpenRight();
    bool GetOpenTop();
    bool GetOpenBottom();
};

struct CoreCurveSet
{
    enum
    {
        VERSION = 15,
    };

    int32_t m_iNumCurves;
    int32_t m_iNumKeyedObjects;
    int32_t m_iCurveOffsetTableOffset;
    int32_t m_iKeyedObjectsOffsetTableOffset;
    int32_t m_iKeyedObjectsTableOffset;
    CoreHashArray m_oCurveTable;

    void CoreCurveSet();
    void ~CoreCurveSet();
    int32_t GetNumCurves();
    CoreCurveSetData* GetCurveByIndex();
    CoreCurveSetData* GetCurveByName(uint32_t uiHash);
    CoreHashArray* GetCurveTablePtr();
    int32_t GetNumKeyedObjects();
    CoreKeyedObject* GetKeyedObjectByIndex();
    CoreKeyedObject* GetKeyedObjectByName(uint32_t uiHash);
    CoreHashArray* GetKeyedObjectsTablePtr();
    int32_t* GetCurveOffsetTablePtr();
    int32_t* GetKeyedObjectsOffsetTablePtr();
};

struct CoreKeyedObject : CoreJointData
{
    enum
    {
        VERSION = 9,
    };

    void CoreKeyedObject();
    void ~CoreKeyedObject();
    CoreVector GetTranslation();
    CoreEulerAngle GetRotationEuler();
    CoreQuat GetRotationQuat();
    CoreVector GetScale();
    bool GetVisible();
};

struct _ACTIVATION_CONTEXT_QUERY_INDEX
{
    uint32_t ulAssemblyIndex;
    uint32_t ulFileIndexInAssembly;
};

struct _CRYPT_ATTRIBUTES
{
    uint32_t cAttr;
    _CRYPT_ATTRIBUTE* rgAttr;
};

struct tagMIDIOUTCAPSA
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t wTechnology;
    uint32_t wVoices;
    uint32_t wNotes;
    uint32_t wChannelMask;
    uint32_t dwSupport;
};

struct _CRYPT_URL_ARRAY
{
    uint32_t cUrl;
    uint32_t** rgwszUrl;
};

struct _CHANGER_ELEMENT
{
    _ELEMENT_TYPE ElementType;
    uint32_t ElementAddress;
};

struct _COMMCONFIG
{
    uint32_t dwSize;
    uint32_t wVersion;
    uint32_t wReserved;
    _DCB dcb;
    uint32_t dwProviderSubType;
    uint32_t dwProviderOffset;
    uint32_t dwProviderSize;
    uint32_t wcProviderData[1];
};

struct tagEMREXTCREATEFONTINDIRECTW
{
    tagEMR emr;
    uint32_t ihFont;
    tagEXTLOGFONTW elfw;
};

struct tagRPC_CALL_ATTRIBUTES_V1_A
{
    uint32_t Version;
    uint32_t Flags;
    uint32_t ServerPrincipalNameBufferLength;
    uint32_t* ServerPrincipalName;
    uint32_t ClientPrincipalNameBufferLength;
    uint32_t* ClientPrincipalName;
    uint32_t AuthenticationLevel;
    uint32_t AuthenticationService;
    int32_t NullSession;
};

struct _CRL_CONTEXT
{
    uint32_t dwCertEncodingType;
    uint32_t* pbCrlEncoded;
    uint32_t cbCrlEncoded;
    _CRL_INFO* pCrlInfo;
    void* hCertStore;
};

struct _CRYPT_KEY_PROV_INFO
{
    uint32_t* pwszContainerName;
    uint32_t* pwszProvName;
    uint32_t dwProvType;
    uint32_t dwFlags;
    uint32_t cProvParam;
    _CRYPT_KEY_PROV_PARAM* rgProvParam;
    uint32_t dwKeySpec;
};

struct ima_adpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
};

struct tagEMROFFSETCLIPRGN
{
    tagEMR emr;
    _POINTL ptlOffset;
};

struct tagSCROLLINFO
{
    uint32_t cbSize;
    uint32_t fMask;
    int32_t nMin;
    int32_t nMax;
    uint32_t nPage;
    int32_t nPos;
    int32_t nTrackPos;
};

struct _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO
{
    uint32_t cbSize;
    _CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
    void* pvKeyEncryptionAuxInfo;
    uint32_t hCryptProv;
    uint32_t dwKeyChoice;
    uint32_t hKeyEncryptionKey;
    void* pvKeyEncryptionKey;
    _CRYPTOAPI_BLOB KeyId;
    _FILETIME Date;
    _CRYPT_ATTRIBUTE_TYPE_VALUE* pOtherAttr;
};

struct _PORT_INFO_1A
{
    char* pName;
};

struct ISynchronize : IUnknown
{
    HRESULT __stdcall Wait();
    HRESULT __stdcall Signal();
    HRESULT __stdcall Reset();
    void ISynchronize();
};

struct tagREGISTERWORDW
{
    uint32_t* lpReading;
    uint32_t* lpWord;
};

struct CoreModelSkeleton
{
    enum
    {
        VERSION = 13,
    };

    uint32_t m_usNumJoints;
    uint32_t m_usNumBlendShapes;
    int32_t m_iNumBlendShapeTargets;
    int32_t m_iJointIndexTableOffset;
    int32_t m_iJointOffsetTableOffset;
    int32_t m_iBlendShapeOffsetTableOffset;

    void CoreModelSkeleton();
    void ~CoreModelSkeleton();
    bool IsStatic();
    bool IsAnimating();
    bool bHasBlendShapes();
    void ComputeAnimationMatrices();
    void ComputeBindPoseMatrices();
    bool IsJointVisible();
    void DrawOrigin(CoreMatrix& mtLocal2World, CoreGraphicsDevice* lpoDevice);
    void DrawSkeleton(CoreMatrix* lpoMatrixList, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
    void DrawBBox(CoreMatrix* lpoMatrixList, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
    void DrawBoneNames(CoreMatrix* lpoMatrixList, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
    int32_t GetNumJoints();
    int32_t GetNumBlendShapes();
    uint32_t GetJointHash();
    int32_t GetJointIndex(uint32_t uiJointHash);
    uint32_t GetJointParentHash();
    int32_t GetJointParentIndex();
    int32_t GetJointParentIndexFromIndex();
    CoreHashArray* GetJointIndexTablePtr();
    int32_t iComputeBlendShapeTargetSkeletonIndexByName();
    int32_t iComputeBlendShapeTargetSkeletonIndexByIndex();
    int32_t GetNumBlendShapeTargets();
    CoreModelJoint* GetModelJointPtrByIndex();
    CoreModelJoint* GetModelJointPtrByHash();
    int32_t* GetJointOffsetTablePtr();
    CoreModelBlendShape* GetModelBlendShapePtr();
    int32_t* GetBlendShapeOffsetTablePtr();
};

struct CoreJointState
{
    enum CoreJointVisible
    {
        CORE_VISIBLE_UNKNOWN = 2,
        CORE_VISIBLE_FALSE = 0,
        CORE_VISIBLE_TRUE = 1,
    };

    CoreVector m_vPos;
    CoreQuat m_qOrient;
    CoreVector m_vScale;
    char m_cVisible;
    bool m_bUpdated;
    uint32_t m_tempBlendIndex;
    uint32_t m_tempBlendSubIndex;

    void CoreJointState();
};

struct CoreModelBlendShape
{
    enum
    {
        VERSION = 1,
    };

    uint32_t m_uiBaseHash;
    int32_t m_iNumTargets;
    uint32_t m_lpuiTargetHashes[1];

    void CoreModelBlendShape();
    void ~CoreModelBlendShape();
    int32_t GetNumTargets();
    uint32_t GetTargetHash();
    uint32_t GetBaseHash();
};

struct tagPOLYTEXTA
{
    int32_t x;
    int32_t y;
    uint32_t n;
    char* lpstr;
    uint32_t uiFlags;
    tagRECT rcl;
    int32_t* pdx;
};

struct _DISK_GEOMETRY
{
    _LARGE_INTEGER Cylinders;
    _MEDIA_TYPE MediaType;
    uint32_t TracksPerCylinder;
    uint32_t SectorsPerTrack;
    uint32_t BytesPerSector;
};

struct tagREGISTERWORDA
{
    char* lpReading;
    char* lpWord;
};

struct CoreRTreeData
{
    enum
    {
        INACTIVE_FLAG = 1,
        FLIP_FLAG,
    };

    uint32_t m_flags;
    uint32_t m_type;
    uint32_t m_rootIndex;
    uint32_t m_roomNumber;
    uint32_t m_padding;
    CoreRTreeRecord m_records;

    void CoreRTreeData();
    void ~CoreRTreeData();
    uint32_t GetType();
    uint32_t GetRoomNumber();
    uint32_t GetFlags();
    bool IsInActive();
    void SetInActive();
    void SetActive();
    void SetFlipped();
    void SetUnFlipped();
    void SetFlags();
    uint32_t GetRootIndex();
    CoreRTreeRecord* GetRecordsPtr();
};

struct tagMINMAXINFO
{
    tagPOINT ptReserved;
    tagPOINT ptMaxSize;
    tagPOINT ptMaxPosition;
    tagPOINT ptMinTrackSize;
    tagPOINT ptMaxTrackSize;
};

struct _PORT_INFO_2A
{
    char* pPortName;
    char* pMonitorName;
    char* pDescription;
    uint32_t fPortType;
    uint32_t Reserved;
};

struct _SERVICE_TABLE_ENTRYW
{
    uint32_t* lpServiceName;
    void* lpServiceProc;
};

struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION
{
    uint32_t EndOfJobTimeAction;
};

struct tagDEBUGHOOKINFO
{
    uint32_t idThread;
    uint32_t idThreadInstaller;
    int32_t lParam;
    uint32_t wParam;
    int32_t code;
};

struct IDropTarget : IUnknown
{
    HRESULT __stdcall DragEnter();
    HRESULT __stdcall DragOver();
    HRESULT __stdcall DragLeave();
    HRESULT __stdcall Drop();
    void IDropTarget();
};

struct CoreMayaCurve
{
    struct CP
    {
        float fX;
        float fY;
        float fTX;
        float fTY;
    };

    float GetValue();
    int32_t GetKey();
};

struct tagRGBTRIPLE
{
    uint32_t rgbtBlue;
    uint32_t rgbtGreen;
    uint32_t rgbtRed;
};

struct _CERT_CHAIN_FIND_BY_ISSUER_PARA
{
    uint32_t cbSize;
    char* pszUsageIdentifier;
    uint32_t dwKeySpec;
    uint32_t dwAcquirePrivateKeyFlags;
    uint32_t cIssuer;
    _CRYPTOAPI_BLOB* rgIssuer;
    int32_t* pfnFindCallback;
    void* pvFindArg;
};

struct _MONITOR_INFO_1W
{
    uint32_t* pName;
};

struct _HMAC_Info
{
    uint32_t HashAlgid;
    uint32_t* pbInnerString;
    uint32_t cbInnerString;
    uint32_t* pbOuterString;
    uint32_t cbOuterString;
};

struct _TOKEN_CONTROL
{
    _LUID TokenId;
    _LUID AuthenticationId;
    _LUID ModifiedId;
    _TOKEN_SOURCE TokenSource;
};

struct _FAT_STATISTICS
{
    uint32_t CreateHits;
    uint32_t SuccessfulCreates;
    uint32_t FailedCreates;
    uint32_t NonCachedReads;
    uint32_t NonCachedReadBytes;
    uint32_t NonCachedWrites;
    uint32_t NonCachedWriteBytes;
    uint32_t NonCachedDiskReads;
    uint32_t NonCachedDiskWrites;
};

struct CoreSystem
{
    // TODO vtable

    void* LockScratchPad(bool i_lock);
    void Sleep(uint32_t i_milliSeconds);
    void CriticalSectionInit();
    void CriticalSectionExit();
    void* CriticalSectionStart();
    void CriticalSectionEnd();
    void TimerFunction();
    int32_t GetNickName();
    void FlashScreen();
    void FlashScreenSKU();
    void SleepSKU(uint32_t i_milliSeconds);
    void TimerFunctionSKU();
    void CoreSystem();
    void YouCannotInstanceThisClass();
};

struct tagABORTPATH
{
    tagEMR emr;
};

struct _CRYPT_OID_FUNC_ENTRY
{
    char* pszOID;
    void* pvFuncAddr;
};

struct CoreSaveGameInterfaceSize
{
    int32_t m_size;
    int32_t m_maximumSize;
    char m_sizeString[8];
    char m_maximumSizeString[8];

    void CoreSaveGameInterfaceSize();
    void Reset();
    int32_t GetSize();
    int32_t GetMaximumSize();
    char* GetSizeString();
    char* GetMaximumSizeString();
    void Set();
};

struct tagCREATESTRUCTA
{
    void* lpCreateParams;
    HINSTANCE__* hInstance;
    HMENU__* hMenu;
    HWND* hwndParent;
    int32_t cy;
    int32_t cx;
    int32_t y;
    int32_t x;
    int32_t style;
    char* lpszName;
    char* lpszClass;
    uint32_t dwExStyle;
};

struct _NDR_CORRELATION_INFO
{
};

struct _s__CatchableType
{
    uint32_t properties;
    _TypeDescriptor* pType;
    _PMD thisDisplacement;
    int32_t sizeOrOffset;
    void* copyFunction;
};

struct _s__CatchableTypeArray
{
    int32_t nCatchableTypes;
    _s__CatchableType* arrayOfCatchableTypes[0];
};

struct _RECTL
{
    int32_t left;
    int32_t top;
    int32_t right;
    int32_t bottom;
};

struct tagMCI_SYSINFO_PARMSA
{
    uint32_t dwCallback;
    char* lpstrReturn;
    uint32_t dwRetSize;
    uint32_t dwNumber;
    uint32_t wDeviceType;
};

struct _CTL_CONTEXT
{
    uint32_t dwMsgAndCertEncodingType;
    uint32_t* pbCtlEncoded;
    uint32_t cbCtlEncoded;
    _CTL_INFO* pCtlInfo;
    void* hCertStore;
    void* hCryptMsg;
    uint32_t* pbCtlContent;
    uint32_t cbCtlContent;
};

struct _CTL_VERIFY_USAGE_STATUS
{
    uint32_t cbSize;
    uint32_t dwError;
    uint32_t dwFlags;
    _CTL_CONTEXT** ppCtl;
    uint32_t dwCtlEntryIndex;
    _CERT_CONTEXT** ppSigner;
    uint32_t dwSignerIndex;
};

struct _CERT_CHAIN_CONTEXT
{
    uint32_t cbSize;
    _CERT_TRUST_STATUS TrustStatus;
    uint32_t cChain;
    _CERT_SIMPLE_CHAIN** rgpChain;
    uint32_t cLowerQualityChainContext;
    _CERT_CHAIN_CONTEXT** rgpLowerQualityChainContext;
    int32_t fHasRevocationFreshnessTime;
    uint32_t dwRevocationFreshnessTime;
};

struct _PRINTPROCESSOR_INFO_1A
{
    char* pName;
};

struct IInternetThreadSwitch : IUnknown
{
    HRESULT __stdcall Prepare();
    HRESULT __stdcall Continue();
    void IInternetThreadSwitch();
};

struct tagCABSTR
{
    uint32_t cElems;
    uint32_t** pElems;
};

struct tagMULTIKEYHELPW
{
    uint32_t mkSize;
    uint32_t mkKeylist;
    uint32_t szKeyphrase[1];
};

struct tagRemHENHMETAFILE
{
    uint32_t cbData;
    uint32_t data[1];
};

struct CoreFileOpenAttributes
{
    enum CoreFileOpenAttribEnum
    {
        NONE,
        READ = (1 << 0),
        WRITE = (1 << 1),
        APPEND = (1 << 2),
        CREATE = (1 << 3),
        TRUNCATE = (1 << 4),
        ABSOLUTE_ACCESS_FROM_CLUSTER = (1 << 12),
    };

    char m_attrib[4];
    int32_t m_mask;

    void CoreFileOpenAttributes(CoreFileOpenAttributes& i_other);
    void ~CoreFileOpenAttributes();
    void Set(char* i_attrib);
    bool IsValid();
    bool bAscii(char* i_attrib);
    bool IsRead();
    bool IsWrite();
    bool IsAppend();
    bool IsCreate();
    bool IsTruncate();
    bool IsAbsoluteAccessFromCluster();
    void Clear();
    void SetRead();
    void SetWrite();
    void SetAppend();
    void SetCreate();
    void SetTruncate();
    void SetAbsoluteAccessFromCluster(bool i_set);
};

struct CoreFileHandle : CoreFileOpenAttributes
{
    _iobuf* m_fileHandle;

    void CoreFileHandle();
    void ~CoreFileHandle();
    CoreFileHandle& operator=();
    bool IsValid();
    void Clear();
    void SetHandle();
    _iobuf* GetHandle();
};

struct tagEMRFRAMERGN
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t cbRgnData;
    uint32_t ihBrush;
    tagSIZE szlStroke;
    uint32_t RgnData[1];
};

struct _wireSAFEARR_BRECORD
{
    uint32_t Size;
    _wireBRECORD** aRecord;
};

struct _CREATE_PROCESS_DEBUG_INFO
{
    void* hFile;
    void* hProcess;
    void* hThread;
    void* lpBaseOfImage;
    uint32_t dwDebugInfoFileOffset;
    uint32_t nDebugInfoSize;
    void* lpThreadLocalBase;
    uint32_t* lpStartAddress;
    void* lpImageName;
    uint32_t fUnicode;
};

struct _SMALL_RECT
{
    int32_t Left;
    int32_t Top;
    int32_t Right;
    int32_t Bottom;
};

struct tagMIXERLINECONTROLSW
{
    uint32_t cbStruct;
    uint32_t dwLineID;
    uint32_t dwControlID;
    uint32_t dwControlType;
    uint32_t cControls;
    uint32_t cbmxctrl;
    tagMIXERCONTROLW* pamxctrl;
};

struct _CERT_POLICY_QUALIFIER_USER_NOTICE
{
    _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE* pNoticeReference;
    uint32_t* pszDisplayText;
};

struct _ACE_HEADER
{
    uint32_t AceType;
    uint32_t AceFlags;
    uint32_t AceSize;
};

struct HGLRC__
{
    int32_t unused;
};

struct tagEMRPOLYPOLYLINE
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t nPolys;
    uint32_t cptl;
    uint32_t aPolyCounts[1];
    _POINTL aptl[1];
};

struct tagUSEROBJECTFLAGS
{
    int32_t fInherit;
    int32_t fReserved;
    uint32_t dwFlags;
};

struct midistrmbuffver_tag
{
    uint32_t dwVersion;
    uint32_t dwMid;
    uint32_t dwOEMVersion;
};

struct fd_set
{
    uint32_t fd_count;
    uint32_t fd_array[64];
};

struct _CHANGER_EXCHANGE_MEDIUM
{
    _CHANGER_ELEMENT Transport;
    _CHANGER_ELEMENT Source;
    _CHANGER_ELEMENT Destination1;
    _CHANGER_ELEMENT Destination2;
    uint32_t Flip1;
    uint32_t Flip2;
};

struct _NON_PAGED_DEBUG_INFO
{
    uint32_t Signature;
    uint32_t Flags;
    uint32_t Size;
    uint32_t Machine;
    uint32_t Characteristics;
    uint32_t TimeDateStamp;
    uint32_t CheckSum;
    uint32_t SizeOfImage;
    uint32_t ImageBase;
};

struct _CERT_ACCESS_DESCRIPTION
{
    char* pszAccessMethod;
    _CERT_ALT_NAME_ENTRY AccessLocation;
};

struct _CRL_INFO
{
    uint32_t dwVersion;
    _CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
    _CRYPTOAPI_BLOB Issuer;
    _FILETIME ThisUpdate;
    _FILETIME NextUpdate;
    uint32_t cCRLEntry;
    _CRL_ENTRY* rgCRLEntry;
    uint32_t cExtension;
    _CERT_EXTENSION* rgExtension;
};

struct _userHENHMETAFILE
{
    union __MIDL_IWinTypes_0006
    {
        int32_t hInproc;
        _BYTE_BLOB* hRemote;
        int32_t hInproc64;
    };

    int32_t fContext;
    _userHENHMETAFILE::__MIDL_IWinTypes_0006 u;
};

struct IXMLDOMDocumentFragment : IXMLDOMNode
{
    void IXMLDOMDocumentFragment();
};

struct _CERT_SIGNED_CONTENT_INFO
{
    _CRYPTOAPI_BLOB ToBeSigned;
    _CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
    _CRYPT_BIT_BLOB Signature;
};

struct _CMC_TAGGED_ATTRIBUTE
{
    uint32_t dwBodyPartID;
    _CRYPT_ATTRIBUTE Attribute;
};

struct _USER_MARSHAL_ROUTINE_QUADRUPLE
{
    uint32_t* pfnBufferSize;
    uint32_t** pfnMarshall;
    uint32_t** pfnUnmarshall;
    void* pfnFree;
};

struct tagOFN_NT4W
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HINSTANCE__* hInstance;
    uint32_t* lpstrFilter;
    uint32_t* lpstrCustomFilter;
    uint32_t nMaxCustFilter;
    uint32_t nFilterIndex;
    uint32_t* lpstrFile;
    uint32_t nMaxFile;
    uint32_t* lpstrFileTitle;
    uint32_t nMaxFileTitle;
    uint32_t* lpstrInitialDir;
    uint32_t* lpstrTitle;
    uint32_t Flags;
    uint32_t nFileOffset;
    uint32_t nFileExtension;
    uint32_t* lpstrDefExt;
    int32_t lCustData;
    uint32_t* lpfnHook;
    uint32_t* lpTemplateName;
};

struct CoreMemoryList
{
    CoreMemoryListEntry* m_First;
    CoreMemoryListEntry* m_ast;
    int32_t m_Size;

    void CoreMemoryList();
    void ~CoreMemoryList();
    void Clear();
    void PushBack();
    void PushFront();
    CoreMemoryListEntry* Begin();
    CoreMemoryListEntry* End();
    void* Front();
    void* Back();
    CoreMemoryListEntry* Find();
    void Insert();
    CoreMemoryListEntry* Pop();
    int32_t Remove();
    int32_t Erase();
    int32_t Size();
    bool Empty();
    void PopBack();
    void PopFront();
    CoreMemoryListEntry* Get();
    void* operator[]();
};

struct CoretGS_EXTWRITE
{
    uint32_t WRITE : 1;
    uint32_t p0 : 31;
    uint32_t p1;
};

struct _JOBOBJECT_JOBSET_INFORMATION
{
    uint32_t MemberLevel;
};

struct _CoreGifPackXyzf
{
    int32_t X;
    int32_t Y;
    uint32_t Z;
    uint32_t F : 12;
    uint32_t pad108 : 3;
    uint32_t ADC : 1;
    uint32_t pad112 : 16;
};

struct CM_Power_Data_s
{
    uint32_t PD_Size;
    _DEVICE_POWER_STATE PD_MostRecentPowerState;
    uint32_t PD_Capabilities;
    uint32_t PD_D1Latency;
    uint32_t PD_D2Latency;
    uint32_t PD_D3Latency;
    _DEVICE_POWER_STATE PD_PowerStateMapping[7];
    _SYSTEM_POWER_STATE PD_DeepestSystemWake;
};

struct tagANIMATIONINFO
{
    uint32_t cbSize;
    int32_t iMinAnimate;
};

struct tagWAVEOUTCAPSA
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t dwFormats;
    uint32_t wChannels;
    uint32_t wReserved1;
    uint32_t dwSupport;
};

struct _CTL_FIND_SUBJECT_PARA
{
    uint32_t cbSize;
    _CTL_FIND_USAGE_PARA* pUsagePara;
    uint32_t dwSubjectType;
    void* pvSubject;
};

struct CorePathFinder
{
    CoreMemoryList m_Nodes;
    CoreMemoryList m_Open;
    CoreMemoryList m_Closed;
    CorePathNode* m_StartFind;
    CorePathNode* m_Goal;
    int32_t m_Iteration;
    int32_t m_MaxIteration;

    void CorePathFinder();
    CorePathNode* GetLowestCost();
    int32_t BeginDijkstra();
    bool EvalDijkstra();
    void EndDijkstra();
    int32_t BeginAStar();
    bool EvalAStar();
    void EndAStar();
    int32_t AddNode();
    int32_t GetNumNodes();
    CorePathNode* GetNode();
    int32_t GetNumPathSteps();
    bool GetPath();
    bool GetPathRecursive();
    void ~CorePathFinder();
};

struct _VIDEOPARAMETERS
{
    _GUID Guid;
    uint32_t dwOffset;
    uint32_t dwCommand;
    uint32_t dwFlags;
    uint32_t dwMode;
    uint32_t dwTVStandard;
    uint32_t dwAvailableModes;
    uint32_t dwAvailableTVStandard;
    uint32_t dwFlickerFilter;
    uint32_t dwOverScanX;
    uint32_t dwOverScanY;
    uint32_t dwMaxUnscaledX;
    uint32_t dwMaxUnscaledY;
    uint32_t dwPositionX;
    uint32_t dwPositionY;
    uint32_t dwBrightness;
    uint32_t dwContrast;
    uint32_t dwCPType;
    uint32_t dwCPCommand;
    uint32_t dwCPStandard;
    uint32_t dwCPKey;
    uint32_t bCP_APSTriggerBits;
    uint32_t bOEMCopyProtection[256];
};

struct CoreVertexPacket
{
    uint32_t m_uiPrimitiveType;
    uint32_t m_uiVertexType;
    uint32_t m_uiMaxVerticesPerPacket;
    uint32_t m_uiNumVertices;
    uint32_t m_uiNumPackets;
    uint32_t m_uiNumBlendShapeTargets;
    uint32_t m_uiNonVertexDataSizeBeforeFirstPacket;
    uint32_t m_uiNonVertexDataSizePerPacket;
    uint32_t m_uiPacketHeaderDataSize;
    uint32_t m_uiDataSizePerXYZVertex;
    uint32_t m_uiDataSizePerBlendShapeVertex;
    uint32_t m_uiDataSizePerRGBAVertex;
    uint32_t m_uiDataSizePerUVVertex;
    uint32_t m_uiDataSizePerNORMALSVertex;
    uint32_t m_uiDataSizePerVertex;
    uint32_t m_uiMaxPacketSize;
    uint32_t m_uiDataSize;
    uint32_t* m_lpuiDmaData;
    uint32_t m_usDataFormat;
    uint32_t m_usCodeFlags;
    uint32_t m_usCycleCount;

    void ~CoreVertexPacket();
    void CoreVertexPacket();
    void Construct();
    void Destruct();
    void SetParentedMeshIndex();
    void SetADCBit();
    void SetStripFlipWindingBit();
    void SetHardSkinningIndex();
    void SetSoftSkinningIndex();
    void SetSoftSkinningWeight();
    void SetSoftSkinningXYZ();
    void SetXYZ();
    void SetRGBA();
    void SetUV();
    void SetNORMALS();
    void SetBlendShapeBaseXYZ();
    void SetBlendShapeTargetDeltaXYZ();
    void MakePS2DmaModel();
    uint32_t GetMaxVertsPerPacket();
    void SetDmaPtr();
    uint32_t GetRGBAByteIndex();
    CoreQWORD* lpqwGetDmaPtr();
    uint32_t usGetDmaQWORDSize();
    uint32_t usGetDataFormat();
    uint32_t usGetCodeFlags();
    uint32_t usGetCycleCount();
    uint32_t uiComputeMaxNumberVerts();
    uint32_t uiComputeNumberOfPackets();
    uint32_t uiComputeNonVertexDataSizePerPacket();
    uint32_t uiComputeDataSizePerXYZVertex();
    uint32_t uiComputeDataSizePerRGBAVertex();
    uint32_t uiComputeDataSizePerUVVertex();
    uint32_t uiComputeDataSizePerNORMALSVertex();
    uint32_t uiComputeDataSizePerBlendShapeVertex();
    void ComputeDataSizePerVertex();
    uint32_t uiComputeMemorySize();
    CoreQWORD qwMakeGIFTAG();
    CoreQWORD qwMakePACKET_INFO();
    void Zero();
    int32_t* lpsGetParentedMeshIndexPtr();
    int32_t* lpsGetNumBlendShapeTargetsPtr();
    uint32_t* GetPacketStart();
    uint32_t GetPacketStartByteOffset();
    uint32_t* GetUVStart();
    uint32_t GetUVStartByteOffset();
    uint32_t* GetADCBitStart();
    uint32_t* GetStripFlipWindingBitStart();
    uint32_t* GetHardSkinningIndexStart();
    uint32_t* GetSoftSkinningWeightIndexStart();
    uint32_t* GetBlendShapeTargetStart();
    uint32_t* GetXYZStart();
    uint32_t GetXYZStartByteOffset();
    uint32_t* GetRGBAStart();
    uint32_t GetRGBAStartByteOffset();
    uint32_t* GetNORMALSStart();
    uint32_t GetNORMALSStartByteOffset();
    uint32_t uiNumVertsInThisPacket();
};

struct tagBITMAPCOREINFO
{
    tagBITMAPCOREHEADER bmciHeader;
    tagRGBTRIPLE bmciColors[1];
};

struct tagPIXELFORMATDESCRIPTOR
{
    uint32_t nSize;
    uint32_t nVersion;
    uint32_t dwFlags;
    uint32_t iPixelType;
    uint32_t cColorBits;
    uint32_t cRedBits;
    uint32_t cRedShift;
    uint32_t cGreenBits;
    uint32_t cGreenShift;
    uint32_t cBlueBits;
    uint32_t cBlueShift;
    uint32_t cAlphaBits;
    uint32_t cAlphaShift;
    uint32_t cAccumBits;
    uint32_t cAccumRedBits;
    uint32_t cAccumGreenBits;
    uint32_t cAccumBlueBits;
    uint32_t cAccumAlphaBits;
    uint32_t cDepthBits;
    uint32_t cStencilBits;
    uint32_t cAuxBuffers;
    uint32_t iLayerType;
    uint32_t bReserved;
    uint32_t dwLayerMask;
    uint32_t dwVisibleMask;
    uint32_t dwDamageMask;
};

struct tagEMRFILLPATH
{
    tagEMR emr;
    _RECTL rclBounds;
};

struct _FLOAT128
{
    int32_t LowPart;
    int32_t HighPart;
};

struct _LDT_ENTRY
{
    uint32_t LimitLow;
    uint32_t BaseLow;
    _LDT_ENTRY::__unnamed HighWord;
};

struct tagEMRFILLRGN
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t cbRgnData;
    uint32_t ihBrush;
    uint32_t RgnData[1];
};

struct _CRYPT_SMIME_CAPABILITIES
{
    uint32_t cCapability;
    _CRYPT_SMIME_CAPABILITY* rgCapability;
};

struct HKL__
{
    int32_t unused;
};

struct HIMCC__
{
    int32_t unused;
};

struct _MEMORY_BASIC_INFORMATION32
{
    uint32_t BaseAddress;
    uint32_t AllocationBase;
    uint32_t AllocationProtect;
    uint32_t RegionSize;
    uint32_t State;
    uint32_t Protect;
    uint32_t Type;
};

struct tagTEXTMETRICA
{
    int32_t tmHeight;
    int32_t tmAscent;
    int32_t tmDescent;
    int32_t tmInternalLeading;
    int32_t tmExternalLeading;
    int32_t tmAveCharWidth;
    int32_t tmMaxCharWidth;
    int32_t tmWeight;
    int32_t tmOverhang;
    int32_t tmDigitizedAspectX;
    int32_t tmDigitizedAspectY;
    uint32_t tmFirstChar;
    uint32_t tmLastChar;
    uint32_t tmDefaultChar;
    uint32_t tmBreakChar;
    uint32_t tmItalic;
    uint32_t tmUnderlined;
    uint32_t tmStruckOut;
    uint32_t tmPitchAndFamily;
    uint32_t tmCharSet;
};

struct tagAUXCAPS2W
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t wTechnology;
    uint32_t wReserved1;
    uint32_t dwSupport;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct CoreKernel
{
    static float m_elapsedTimeInSeconds;
    static int32_t m_lastElapsedTimeInTimerCycles;
    static CoreStdFileSystem m_stdFileSystem;
    static CoreClusterFileSystem m_clusterFileSystem;
    static CoreFileSystem* m_fileSystem;
    static CoreFileDevice* m_fileDevice;
    static CoreKernelTimer m_timers[4];
    static char* m_platformExtension;
    static char* m_globalClusterName;
    static char* m_regionClusterName;
    static char m_currentLevelClusterName[256];
    static char m_secondLevelClusterName[256];
    static bool m_useClusters;
    static bool m_debugAudio;
    static bool m_debugAudioHeap;
    static bool m_debugAudioMemory;
    static bool m_toolPS2;
    static int32_t m_mainFrameRate;
    static char m_gameDirName[256];
    static CoreNet::DeviceInitialisationData m_networkParams;

    // TODO vtable

    void CoreKernel();
    void ~CoreKernel();
    void MainLoop();
    void SetGameDirName(char* i_gameDirName);
    char* GetGameDirName();
    void Exit(int32_t iErrCode);
    void SetTimer(int32_t iIndex, int32_t iIntervalInTimerCycles, int32_t iMaxCyclesToRun, void* Function, void* lpData);
    int32_t ClearTimer();
    void InitTimers();
    void UpdateTimer(int32_t i_index, int32_t i_intervalInTimerCycles);
    int32_t FindUnusedTimer();
    int32_t FindTimerFunction();
    float GetElapsedTimeInSeconds();
    int32_t GetElapsedTimeInCycles();
    int32_t GetCyclesPerSecond();
    int32_t GetMainFrameRate();
    int32_t ComputeGameMaxFrameRateInterval();
    void SetMainFrameRate();
    CoreFileSystem* GetFileSystemPtr();
    CoreFileDevice* GetFileDevicePtr();
    void SetFileDevicePtr();
    CoreClusterFileSystem* GetClusterFileSystemPtr();
    bool GetDebugAudioFlag();
    void SetDebugAudioFlag();
    bool GetDebugAudioMemoryFlag();
    void SetDebugAudioMemoryFlag();
    bool GetDebugAudioHeapFlag();
    void SetDebugAudioHeapFlag();
    char* GetPlatformExtension();
    void UseStdFileSystem();
    void UseClusterFileSystem();
    bool IsUsingClusters();
    bool OpenCluster(char* lpcClusterName);
    bool CloseCluster(char* lpcClusterName);
    bool OpenGlobalCluster();
    bool CloseGlobalCluster();
    void SetGlobalClusterName();
    bool OpenRegionCluster();
    bool CloseRegionCluster();
    void SetRegionClusterName();
    void SetCurrentLevelCluster(char* i_levelClusterName);
    bool OpenCurrentLevelCluster();
    bool CloseCurrentLevelCluster();
    void SetSecondLevelCluster(char* i_levelClusterName);
    bool OpenSecondLevelCluster();
    bool CloseSecondLevelCluster();
    void SetGameController(CoreGameController* io_gameController);
    void InitCommon(int32_t iNumParams, char** lplpcParams, uint32_t* lpucGlobalMem, int32_t iGlobalMemSize, CoreHash i_graphicsType, CoreHash i_inputType, CoreHash i_audioType, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize, CoreHash i_networkType, CoreNet::DeviceInitialisationData* io_CoreNetInit, int32_t iGameMaxFrameRate);
    void InitPC(char* i_BSIPipeName, char* i_localPath, char* i_commonPath, int32_t i_globalMemorySize, bool i_banNewDelete, bool i_banMallocFree, char* i_networkGameID, CoreGameController* io_gameController, int32_t i_maxFrameRate, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize, int32_t i_ignore);
    void RunTimerFunction(CoreKernelTimer* lpoTimer);
    int32_t GetTimeInTimerCycles();
};

struct CAL0_AudioWadManagerExp : CAL0_AudioWadManager
{
    char** m_FileNameTable;

    void CAL0_AudioWadManagerExp();
    void ~CAL0_AudioWadManagerExp();
    bool AddFileToWad();
    bool SaveWad();
    void ClearAllEntries();
};

struct _POINTL
{
    int32_t x;
    int32_t y;
};

struct _OFSTRUCT
{
    uint32_t cBytes;
    uint32_t fFixedDisk;
    uint32_t nErrCode;
    uint32_t Reserved1;
    uint32_t Reserved2;
    char szPathName[128];
};

struct _MAT2
{
    _FIXED eM11;
    _FIXED eM12;
    _FIXED eM21;
    _FIXED eM22;
};

struct CoreDirectoryEntry
{
    CoreStringBuffer<256> m_directory;
    CoreStringBuffer<256> m_name;
    int32_t m_size64;
    uint32_t m_userValue;
    void* m_structureSKU;
    bool m_isFile;
    bool m_isDirectory;
    CoreDateTime m_creationTime;
    CoreDateTime m_lastAccessTime;
    CoreDateTime m_lastWriteTime;

    void CoreDirectoryEntry();
    void Reset();
    char* GetDirectory();
    char* GetName();
    void GetFileTimes();
    int32_t GetSize();
    int32_t GetSize64();
    uint32_t GetUserValue();
    void* GetPlatformSpecificStructure();
    bool IsFile();
    bool IsDirectory();
};

struct tagEMRNAMEDESCAPE
{
    tagEMR emr;
    int32_t iEscape;
    int32_t cbDriver;
    int32_t cbEscData;
    uint32_t EscData[1];
};

struct _DS3DBUFFER
{
    uint32_t dwSize;
    _D3DVECTOR vPosition;
    _D3DVECTOR vVelocity;
    uint32_t dwInsideConeAngle;
    uint32_t dwOutsideConeAngle;
    _D3DVECTOR vConeOrientation;
    int32_t lConeOutsideVolume;
    float flMinDistance;
    float flMaxDistance;
    uint32_t dwMode;
};

struct _OUTPUT_DEBUG_STRING_INFO
{
    char* lpDebugStringData;
    uint32_t fUnicode;
    uint32_t nDebugStringLength;
};

struct IWaitMultiple : IUnknown
{
    HRESULT __stdcall WaitMultiple();
    HRESULT __stdcall AddSynchronize();
    void IWaitMultiple();
};

struct tagFUNCDESC
{
    int32_t memid;
    int32_t* lprgscode;
    tagELEMDESC* lprgelemdescParam;
    tagFUNCKIND funckind;
    tagINVOKEKIND invkind;
    tagCALLCONV callconv;
    int32_t cParams;
    int32_t cParamsOpt;
    int32_t oVft;
    int32_t cScodes;
    tagELEMDESC elemdescFunc;
    uint32_t wFuncFlags;
};

struct _UNIVERSAL_NAME_INFOA
{
    char* lpUniversalName;
};

struct _WORD_BLOB
{
    uint32_t clSize;
    uint32_t asData[1];
};

struct _IMAGE_OPTIONAL_HEADER64
{
    uint32_t Magic;
    uint32_t MajorLinkerVersion;
    uint32_t MinorLinkerVersion;
    uint32_t SizeOfCode;
    uint32_t SizeOfInitializedData;
    uint32_t SizeOfUninitializedData;
    uint32_t AddressOfEntryPoint;
    uint32_t BaseOfCode;
    uint32_t ImageBase;
    uint32_t SectionAlignment;
    uint32_t FileAlignment;
    uint32_t MajorOperatingSystemVersion;
    uint32_t MinorOperatingSystemVersion;
    uint32_t MajorImageVersion;
    uint32_t MinorImageVersion;
    uint32_t MajorSubsystemVersion;
    uint32_t MinorSubsystemVersion;
    uint32_t Win32VersionValue;
    uint32_t SizeOfImage;
    uint32_t SizeOfHeaders;
    uint32_t CheckSum;
    uint32_t Subsystem;
    uint32_t DllCharacteristics;
    uint32_t SizeOfStackReserve;
    uint32_t SizeOfStackCommit;
    uint32_t SizeOfHeapReserve;
    uint32_t SizeOfHeapCommit;
    uint32_t LoaderFlags;
    uint32_t NumberOfRvaAndSizes;
    _IMAGE_DATA_DIRECTORY DataDirectory[16];
};

struct tagEMRSETVIEWPORTEXTEX
{
    tagEMR emr;
    tagSIZE szlExtent;
};

struct tagCOMBOBOXINFO
{
    uint32_t cbSize;
    tagRECT rcItem;
    tagRECT rcButton;
    uint32_t stateButton;
    HWND* hwndCombo;
    HWND* hwndItem;
    HWND* hwndList;
};

struct _RPC_SECURITY_QOS_V2_A
{
    uint32_t Version;
    uint32_t Capabilities;
    uint32_t IdentityTracking;
    uint32_t ImpersonationType;
    uint32_t AdditionalSecurityInfoType;
    _RPC_SECURITY_QOS_V2_A::__unnamed u;
};

struct tagCHOOSEFONTA
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HDC__* hDC;
    tagLOGFONTA* lpLogFont;
    int32_t iPointSize;
    uint32_t Flags;
    uint32_t rgbColors;
    int32_t lCustData;
    uint32_t* lpfnHook;
    char* lpTemplateName;
    HINSTANCE__* hInstance;
    char* lpszStyle;
    uint32_t nFontType;
    uint32_t ___MISSING_ALIGNMENT__;
    int32_t nSizeMin;
    int32_t nSizeMax;
};

struct _s__RTTIClassHierarchyDescriptor
{
    uint32_t signature;
    uint32_t attributes;
    uint32_t numBaseClasses;
    _s__RTTIBaseClassArray* pBaseClassArray;
};

struct _s__RTTICompleteObjectLocator
{
    uint32_t signature;
    uint32_t offset;
    uint32_t cdOffset;
    _TypeDescriptor* pTypeDescriptor;
    _s__RTTIClassHierarchyDescriptor* pClassDescriptor;
};

union _IMAGE_AUX_SYMBOL
{
    _IMAGE_AUX_SYMBOL::__unnamed Sym;
    _IMAGE_AUX_SYMBOL::__unnamed File;
    _IMAGE_AUX_SYMBOL::__unnamed Section;
};

struct _BY_HANDLE_FILE_INFORMATION
{
    uint32_t dwFileAttributes;
    _FILETIME ftCreationTime;
    _FILETIME ftLastAccessTime;
    _FILETIME ftLastWriteTime;
    uint32_t dwVolumeSerialNumber;
    uint32_t nFileSizeHigh;
    uint32_t nFileSizeLow;
    uint32_t nNumberOfLinks;
    uint32_t nFileIndexHigh;
    uint32_t nFileIndexLow;
};

struct tagCACLSID
{
    uint32_t cElems;
    _GUID* pElems;
};

struct _EVENTLOGRECORD
{
    uint32_t Length;
    uint32_t Reserved;
    uint32_t RecordNumber;
    uint32_t TimeGenerated;
    uint32_t TimeWritten;
    uint32_t EventID;
    uint32_t EventType;
    uint32_t NumStrings;
    uint32_t EventCategory;
    uint32_t ReservedFlags;
    uint32_t ClosingRecordNumber;
    uint32_t StringOffset;
    uint32_t UserSidLength;
    uint32_t UserSidOffset;
    uint32_t DataLength;
    uint32_t DataOffset;
};

struct tagSTYLESTRUCT
{
    uint32_t styleOld;
    uint32_t styleNew;
};

struct _cpinfoexA
{
    uint32_t MaxCharSize;
    uint32_t DefaultChar[2];
    uint32_t LeadByte[12];
    uint32_t UnicodeDefaultChar;
    uint32_t CodePage;
    char CodePageName[260];
};

struct tagAUXCAPSW
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t wTechnology;
    uint32_t wReserved1;
    uint32_t dwSupport;
};

struct tagMCI_OVLY_SAVE_PARMSW
{
    uint32_t dwCallback;
    uint32_t* lpfilename;
    tagRECT rc;
};

struct tagCADBL
{
    uint32_t cElems;
    float* pElems;
};

struct tagMCI_STATUS_PARMS
{
    uint32_t dwCallback;
    uint32_t dwReturn;
    uint32_t dwItem;
    uint32_t dwTrack;
};

struct _tagSOFTDISTINFO
{
    uint32_t cbSize;
    uint32_t dwFlags;
    uint32_t dwAdState;
    uint32_t* szTitle;
    uint32_t* szAbstract;
    uint32_t* szHREF;
    uint32_t dwInstalledVersionMS;
    uint32_t dwInstalledVersionLS;
    uint32_t dwUpdateVersionMS;
    uint32_t dwUpdateVersionLS;
    uint32_t dwAdvertisedVersionMS;
    uint32_t dwAdvertisedVersionLS;
    uint32_t dwReserved;
};

struct CoreXMLDocumentData
{
};

struct CoreXMLDocument
{
    CoreXMLDocumentData* m_data;

    void CoreXMLDocument();
    void ~CoreXMLDocument();
    bool Load();
    bool Save();
    CoreXMLNode GetMainNode();
    bool LoadFromWriter();
    void GetNodeData();
};

struct tagEMRMODIFYWORLDTRANSFORM
{
    tagEMR emr;
    tagXFORM xform;
    uint32_t iMode;
};

struct tagEXTLOGFONTA
{
    tagLOGFONTA elfLogFont;
    uint32_t elfFullName[64];
    uint32_t elfStyle[32];
    uint32_t elfVersion;
    uint32_t elfStyleSize;
    uint32_t elfMatch;
    uint32_t elfReserved;
    uint32_t elfVendorId[4];
    uint32_t elfCulture;
    tagPANOSE elfPanose;
};

struct _tagPROTOCOLDATA
{
    uint32_t grfFlags;
    uint32_t dwState;
    void* pData;
    uint32_t cbData;
};

struct CoreAudioSequencer
{
    CoreAudioSequencerEntry m_Entry[64];
    uint32_t m_NextEntry;

    void CoreAudioSequencer();
    void ~CoreAudioSequencer();
    void Reset();
    uint32_t GetNumEntries();
    CoreAudioSequencerEntry* GetEntry();
    void Start();
    void Update();
    void Stop();
    void SkipTo();
    void PlayTo();
};

struct sockaddr
{
    uint32_t sa_family;
    char sa_data[14];
};

struct _CERT_ALT_NAME_INFO
{
    uint32_t cAltEntry;
    _CERT_ALT_NAME_ENTRY* rgAltEntry;
};

struct tagEMRCREATECOLORSPACEW
{
    tagEMR emr;
    uint32_t ihCS;
    tagLOGCOLORSPACEW lcs;
    uint32_t dwFlags;
    uint32_t cbData;
    uint32_t Data[1];
};

struct _currencyfmtW
{
    uint32_t NumDigits;
    uint32_t LeadingZero;
    uint32_t Grouping;
    uint32_t* lpDecimalSep;
    uint32_t* lpThousandSep;
    uint32_t NegativeOrder;
    uint32_t PositiveOrder;
    uint32_t* lpCurrencySymbol;
};

struct tagMCI_OPEN_PARMSW
{
    uint32_t dwCallback;
    uint32_t wDeviceID;
    uint32_t* lpstrDeviceType;
    uint32_t* lpstrElementName;
    uint32_t* lpstrAlias;
};

struct _CERT_BASIC_CONSTRAINTS2_INFO
{
    int32_t fCA;
    int32_t fPathLenConstraint;
    uint32_t dwPathLenConstraint;
};

struct _BIN_RESULTS
{
    uint32_t NumberOfBins;
    _BIN_COUNT BinCounts[1];
};

struct IDataAdviseHolder : IUnknown
{
    HRESULT __stdcall Advise();
    HRESULT __stdcall Unadvise();
    HRESULT __stdcall EnumAdvise();
    HRESULT __stdcall SendOnDataChange();
    void IDataAdviseHolder();
};

struct tagBIND_OPTS
{
    uint32_t cbStruct;
    uint32_t grfFlags;
    uint32_t grfMode;
    uint32_t dwTickCountDeadline;
};

struct IXMLDOMNode : IDispatch
{
    HRESULT __stdcall get_nodeName();
    HRESULT __stdcall get_nodeValue();
    HRESULT __stdcall put_nodeValue();
    HRESULT __stdcall get_nodeType();
    HRESULT __stdcall get_parentNode();
    HRESULT __stdcall get_childNodes();
    HRESULT __stdcall get_firstChild();
    HRESULT __stdcall get_lastChild();
    HRESULT __stdcall get_previousSibling();
    HRESULT __stdcall get_nextSibling();
    HRESULT __stdcall get_attributes();
    HRESULT __stdcall insertBefore();
    HRESULT __stdcall replaceChild();
    HRESULT __stdcall removeChild();
    HRESULT __stdcall appendChild();
    HRESULT __stdcall hasChildNodes();
    HRESULT __stdcall get_ownerDocument();
    HRESULT __stdcall cloneNode();
    HRESULT __stdcall get_nodeTypeString();
    HRESULT __stdcall get_text();
    HRESULT __stdcall put_text();
    HRESULT __stdcall get_specified();
    HRESULT __stdcall get_definition();
    HRESULT __stdcall get_nodeTypedValue();
    HRESULT __stdcall put_nodeTypedValue();
    HRESULT __stdcall get_dataType();
    HRESULT __stdcall put_dataType();
    HRESULT __stdcall get_xml();
    HRESULT __stdcall transformNode();
    HRESULT __stdcall selectNodes();
    HRESULT __stdcall selectSingleNode();
    HRESULT __stdcall get_parsed();
    HRESULT __stdcall get_namespaceURI();
    HRESULT __stdcall get_prefix();
    HRESULT __stdcall get_baseName();
    HRESULT __stdcall transformNodeToObject();
    void IXMLDOMNode();
};

struct adpcmewaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
};

struct CoreGsTrxdir
{
    uint32_t XDR : 2;
    uint32_t pad02 : 62;
};

struct CoreGsXyzf
{
    uint32_t X : 16;
    uint32_t Y : 16;
    uint32_t Z : 24;
    uint32_t F : 8;
};

struct tagEMRLINETO
{
    tagEMR emr;
    _POINTL ptl;
};

struct tagRemBRUSH
{
    uint32_t cbData;
    uint32_t data[1];
};

struct CoreNode : CoreNodeRoot
{
    enum
    {
        NODEFLAG_ACTIVE = (1 << 0),
        NODEFLAG_SLEEPING = (1 << 1),
        NODEFLAG_UNUSED = (1 << 2),
        NODEFLAG_ANCHOR = (1 << 3),
        NODEFLAG_REFERENCE = (1 << 4),
    };

    CoreVector m_pos;
    CoreVector m_orient;
    CoreVector m_scl;
    CoreHash m_hashID;
    uint32_t m_roomNumber;
    uint32_t m_pad;
    CoreNode* m_pReference;
    static CoreNode* m_nodeArray[11];
    static uint32_t m_nodeExtraCapacity[11];
    static uint32_t m_numAllocatedNodes[11];
    static uint32_t m_nodeSizes[11];
    static CoreNodeChainGroup m_nodeFreePool;
    static char* m_nodeTypeNames[0];
    static char m_textBuffer[32];

    void CoreNode();
    void ~CoreNode();
    void Construct();
    CoreNode* FindNodeByHash(uint32_t iHash);
    void RenderDebug();
    void ForceUpdate();
    void OnDelete();
    char* GetNodeTypeString();
    char* GetPositionString(uint32_t iAxis);
    char* GetRotationString(uint32_t iAxis);
    char* GetScaleString(uint32_t iAxis);
    CoreNode* CreateNode(CoreNodeType iType);
    void DeleteNode(CoreNode* pNode);
    void SetTransformFromText(uint32_t iTransType, uint32_t iTransAxis, char* iString);
    uint32_t GetNumAllocatedNodesByType();
    void ClearExtraCapacity();
    void SetExtraCapacity(CoreNodeType iNodeType, uint32_t iNum);
    uint32_t GetExtraCapacity(CoreNodeType iNodeType);
    void UpdateChain(CoreNode* pFirstNode);
    CoreNode* GetFreeNode(CoreNodeType iType);
    void AddNodeToFreePool(CoreNode* pNode);
    void SetupFromCoreObject(CoreObject* iObject);
    void Update();
    void AddToScene();
};

struct _IMAGE_RESOURCE_DIRECTORY_ENTRY
{
    uint32_t NameOffset : 31;
    uint32_t NameIsString : 1;
    uint32_t Name;
    uint32_t Id;
    uint32_t OffsetToData;
    uint32_t OffsetToDirectory : 31;
    uint32_t DataIsDirectory : 1;
};

struct tagEMRROUNDRECT
{
    tagEMR emr;
    _RECTL rclBox;
    tagSIZE szlCorner;
};

struct CoreSceneClip
{
    float m_clipBounds[4];
    uint32_t m_clipFlags;
    uint32_t m_clipNext;
};

struct _IMAGE_NT_HEADERS
{
    uint32_t Signature;
    _IMAGE_FILE_HEADER FileHeader;
    _IMAGE_OPTIONAL_HEADER OptionalHeader;
};

struct _UNLOAD_DLL_DEBUG_INFO
{
    void* lpBaseOfDll;
};

struct tagEMRPOLYLINE
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t cptl;
    _POINTL aptl[1];
};

struct tagMIDIOUTCAPS2W
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t wTechnology;
    uint32_t wVoices;
    uint32_t wNotes;
    uint32_t wChannelMask;
    uint32_t dwSupport;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct _PROPSHEETPAGEW
{
    uint32_t dwSize;
    uint32_t dwFlags;
    HINSTANCE__* hInstance;
    uint32_t* pszTemplate;
    DLGTEMPLATE* pResource;
    HICON__* hIcon;
    uint32_t* pszIcon;
    uint32_t* pszTitle;
    int32_t* pfnDlgProc;
    int32_t lParam;
    uint32_t* pfnCallback;
    uint32_t* pcRefParent;
    uint32_t* pszHeaderTitle;
    uint32_t* pszHeaderSubTitle;
};

struct _PROPSHEETHEADERW
{
    uint32_t dwSize;
    uint32_t dwFlags;
    HWND* hwndParent;
    HINSTANCE__* hInstance;
    HICON__* hIcon;
    uint32_t* pszIcon;
    uint32_t* pszCaption;
    uint32_t nPages;
    uint32_t nStartPage;
    uint32_t* pStartPage;
    _PROPSHEETPAGEW* ppsp;
    _PSP** phpage;
    int32_t* pfnCallback;
    HBITMAP__* hbmWatermark;
    uint32_t* pszbmWatermark;
    HPALETTE__* hplWatermark;
    HBITMAP__* hbmHeader;
    uint32_t* pszbmHeader;
};

struct _MONITOR_INFO_2A
{
    char* pName;
    char* pEnvironment;
    char* pDLLName;
};

struct creative_fastspeech10format_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wRevision;
};

struct CoreAnimBoneSet
{
    enum
    {
        VERSION = 1,
    };

    CoreHash m_boneSetName;
    uint32_t m_boneFlags[2];

    void CoreAnimBoneSet();
    void ~CoreAnimBoneSet();
    CoreHash GetBoneSetNameHash();
    uint32_t GetBoneSetFlags();
    void GetBonesUsed();
    void UpdateBonesUsed(bool* o_bonesUsed, bool* i_parentBones, int32_t i_numBones);
};

struct _RPC_HTTP_TRANSPORT_CREDENTIALS_A
{
    _SEC_WINNT_AUTH_IDENTITY_A* TransportCredentials;
    uint32_t Flags;
    uint32_t AuthenticationTarget;
    uint32_t NumberOfAuthnSchemes;
    uint32_t* AuthnSchemes;
    uint32_t* ServerCertificateSubject;
};

struct _CMSG_SIGNER_INFO
{
    uint32_t dwVersion;
    _CRYPTOAPI_BLOB Issuer;
    _CRYPTOAPI_BLOB SerialNumber;
    _CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    _CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    _CRYPTOAPI_BLOB EncryptedHash;
    _CRYPT_ATTRIBUTES AuthAttrs;
    _CRYPT_ATTRIBUTES UnauthAttrs;
};

struct _JOB_INFO_2A
{
    uint32_t JobId;
    char* pPrinterName;
    char* pMachineName;
    char* pUserName;
    char* pDocument;
    char* pNotifyName;
    char* pDatatype;
    char* pPrintProcessor;
    char* pParameters;
    char* pDriverName;
    _devicemodeA* pDevMode;
    char* pStatus;
    void* pSecurityDescriptor;
    uint32_t Status;
    uint32_t Priority;
    uint32_t Position;
    uint32_t StartTime;
    uint32_t UntilTime;
    uint32_t TotalPages;
    uint32_t Size;
    _SYSTEMTIME Submitted;
    uint32_t Time;
    uint32_t PagesPrinted;
};

struct _JOB_INFO_3
{
    uint32_t JobId;
    uint32_t NextJobId;
    uint32_t Reserved;
};

struct IObjContext : IContext
{
    void __stdcall Reserved1();
    void __stdcall Reserved2();
    void __stdcall Reserved3();
    void __stdcall Reserved4();
    void __stdcall Reserved5();
    void __stdcall Reserved6();
    void __stdcall Reserved7();
    void IObjContext();
};

struct CoreRecentFileName
{
    int32_t m_time64;
    CoreStringBuffer<256> m_fileName;
    CoreStringBuffer<256> m_userString;
    int32_t m_counter;
    int32_t m_index;

    void CoreRecentFileName();
    void Reset();
    int32_t GetTime64();
    void Set(char* i_fileName, char* i_userString);
    bool IsSame();
    bool IsUsed();
    bool IsUnused();
    bool HasTimedOut();
    char* GetFileName();
    char* GetUserString();
    void SetUserString();
    void IncrementCounter();
    void ResetCounter();
    int32_t GetCounter();
    int32_t GetIndex();
    void SetIndex();
};

struct _RIP_INFO
{
    uint32_t dwError;
    uint32_t dwType;
};

struct tagCWPRETSTRUCT
{
    int32_t lResult;
    int32_t lParam;
    uint32_t wParam;
    uint32_t message;
    HWND* hwnd;
};

struct contres_cr10waveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
};

struct _DSBUFFERDESC
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwBufferBytes;
    uint32_t dwReserved;
    tWAVEFORMATEX* lpwfxFormat;
    _GUID guid3DAlgorithm;
};

struct IDirectSound8 : IDirectSound
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall CreateSoundBuffer();
    HRESULT __stdcall GetCaps();
    HRESULT __stdcall DuplicateSoundBuffer();
    HRESULT __stdcall SetCooperativeLevel();
    HRESULT __stdcall Compact();
    HRESULT __stdcall GetSpeakerConfig();
    HRESULT __stdcall SetSpeakerConfig();
    HRESULT __stdcall Initialize();
    HRESULT __stdcall VerifyCertification();
    void IDirectSound8();
};

struct waveformat_tag
{
    uint32_t wFormatTag;
    uint32_t nChannels;
    uint32_t nSamplesPerSec;
    uint32_t nAvgBytesPerSec;
    uint32_t nBlockAlign;
};

struct tagJOYCAPSA
{
    uint32_t wMid;
    uint32_t wPid;
    char szPname[32];
    uint32_t wXmin;
    uint32_t wXmax;
    uint32_t wYmin;
    uint32_t wYmax;
    uint32_t wZmin;
    uint32_t wZmax;
    uint32_t wNumButtons;
    uint32_t wPeriodMin;
    uint32_t wPeriodMax;
    uint32_t wRmin;
    uint32_t wRmax;
    uint32_t wUmin;
    uint32_t wUmax;
    uint32_t wVmin;
    uint32_t wVmax;
    uint32_t wCaps;
    uint32_t wMaxAxes;
    uint32_t wNumAxes;
    uint32_t wMaxButtons;
    char szRegKey[32];
    char szOEMVxD[260];
};

struct tagJOYCAPSW
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t szPname[32];
    uint32_t wXmin;
    uint32_t wXmax;
    uint32_t wYmin;
    uint32_t wYmax;
    uint32_t wZmin;
    uint32_t wZmax;
    uint32_t wNumButtons;
    uint32_t wPeriodMin;
    uint32_t wPeriodMax;
    uint32_t wRmin;
    uint32_t wRmax;
    uint32_t wUmin;
    uint32_t wUmax;
    uint32_t wVmin;
    uint32_t wVmax;
    uint32_t wCaps;
    uint32_t wMaxAxes;
    uint32_t wNumAxes;
    uint32_t wMaxButtons;
    uint32_t szRegKey[32];
    uint32_t szOEMVxD[260];
};

struct tagMIXERCAPS2A
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t fdwSupport;
    uint32_t cDestinations;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct _PRINTER_INFO_1W
{
    uint32_t Flags;
    uint32_t* pDescription;
    uint32_t* pName;
    uint32_t* pComment;
};

struct CoreRegistryPC : CoreRegistryInterface
{
    enum RegistryValueType_TAG
    {
        VALUE_TYPE_UNKNOWN = 254,
        VALUE_TYPE_ERROR = 255,
        VALUE_TYPE_NUMBER = 0,
        VALUE_TYPE_STRING = 1,
        VALUE_TYPE_BINARY = 2,
        VALUE_TYPE_UNSUPPORTED = 3,
    };

    enum RegistryValueType
    {
        VALUE_TYPE_UNKNOWN = 254,
        VALUE_TYPE_ERROR = 255,
        VALUE_TYPE_NUMBER = 0,
        VALUE_TYPE_STRING = 1,
        VALUE_TYPE_BINARY = 2,
        VALUE_TYPE_UNSUPPORTED = 3,
    };

    static void* m_defaultMasterKeyHandle;
    CoreStringBuffer<256> m_tidiedSubKeyName;
    void* m_masterKeyHandle;
    void* m_subKeyHandle;
    bool m_subKeyOpen;
    bool m_createdSubKeyAlreadyExisted;
    uint32_t m_valueType;
    int32_t m_valueSize;
    CoreRegistryPC::RegistryValueType_TAG m_processedValueType;

    void CoreRegistryPC();
    void ~CoreRegistryPC();
    void* GetDefaultMasterKey();
    void SetDefaultMasterKey();
    void SetDefaultMasterKeyClassesRoot();
    void SetDefaultMasterKeyCurrentUser();
    void SetDefaultMasterKeyLocalMachine();
    void SetDefaultMasterKeyUsers();
    char* OverrideMasterKeyHandle(char* i_name);
    char* TidySubKeyName(char* i_subKey);
    char* AdjustSubKeyAndValueNames(char* i_subKey, char* i_valueName, CoreStringBuffer<256>& o_subKey);
    bool CloseSubKey();
    bool OpenSubKey(char* i_subKey);
    bool CreateSubKey(char* i_subKey);
    bool DeleteSubKey();
    bool DoesSubKeyExists();
    bool ReadNumberFromOpenSubKey(char* i_valueName, uint32_t* o_number);
    int32_t ReadStringFromOpenSubKey(char* i_valueName, char* o_stringBuffer, int32_t i_stringBufferSize);
    int32_t ReadBinaryFromOpenSubKey(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
    bool WriteNumberFromOpenSubKey();
    bool WriteNumberIfChangedFromOpenSubKey(char* i_valueName, uint32_t i_number);
    bool WriteStringFromOpenSubKey();
    bool WriteStringIfChangedFromOpenSubKey(char* i_valueName, char* i_string);
    bool WriteBinaryFromOpenSubKey();
    bool WriteBinaryIfChangedFromOpenSubKey(char* i_valueName, void* i_buffer, int32_t i_bufferSize);
    bool GetValueTypeAndSizeFromOpenSubKey(char* i_valueName);
    bool CheckProcessedValueTypeAndSizeFromOpenSubKey(char* i_valueName, CoreRegistryPC::RegistryValueType_TAG i_processedValueType, int32_t i_valueSize, bool i_reportSizeDifference);
    int32_t GetValueFromOpenSubKey(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
    bool SetValueFromOpenSubKey(char* i_valueName, void* i_data, int32_t i_dataSize, uint32_t i_valueType);
    bool DeleteValueFromOpenSubKey(char* i_valueName);
    int32_t GetStringSize();
    bool DoesValueExist();
    int32_t GetValueSize();
    CoreRegistryPC::RegistryValueType_TAG GetValueType();
    bool ReadNumber(char* i_valueName, uint32_t* o_number);
    int32_t ReadString(char* i_valueName, char* o_stringBuffer, int32_t i_stringBufferSize);
    int32_t ReadBinary(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
    bool WriteNumber(char* i_valueName, uint32_t i_number);
    bool WriteNumberIfChanged(char* i_subKey, char* i_valueName, uint32_t i_number);
    bool WriteString(char* i_valueName, char* i_string);
    bool WriteStringIfChanged(char* i_subKey, char* i_valueName, char* i_string);
    bool WriteBinary(char* i_valueName, void* i_buffer, int32_t i_bufferSize);
    bool WriteBinaryIfChanged(char* i_subKey, char* i_valueName, void* i_buffer, int32_t i_bufferSize);
    bool DeleteValue(char* i_valueName);
    void DeleteInstance();
};

struct CoreMemoryArray : CoreMemory
{
    struct ArrayBlock
    {
        CoreMemoryArray::ArrayBlock* next;
    };

    uint32_t* m_memoryArray;
    uint32_t m_blockSize;
    uint32_t m_memorySize;
    CoreMemoryArray::ArrayBlock* m_unusedBlock;

    void CoreMemoryArray();
    void Construct();
    void Destruct();
    void* Alloc(uint32_t i_bytes, uint32_t i_alignment, char* i_fileName, uint32_t i_lineNumber);
    void Free(void* i_memory, char* i_fileName, int32_t i_lineNumber);
    int32_t GetMemoryAvailable();
    int32_t GetMemoryUsed();
    char* GetDebugTypeName();
    bool Init(int32_t i_numBlocks, int32_t i_blockSize, CoreMemory* i_memory);
    void ~CoreMemoryArray();
};

struct CoreTimingSeconds
{
    int32_t m_start64;
    float m_timeOut64;

    void CoreTimingSeconds();
    float Get();
    void Start();
    float GetTaken();
    void StartTimeOut(float i_timeOut);
    bool HasTimedOut();
    void Sync();
    void Wait();
    float GetTimedValue(float i_timePeriod, float i_min, float i_max);
    float MicroSeconds64ToSeconds();
    int32_t SecondsToMicroSeconds64(float i_seconds);
};

struct _NETINFOSTRUCT
{
    uint32_t cbStructure;
    uint32_t dwProviderVersion;
    uint32_t dwStatus;
    uint32_t dwCharacteristics;
    uint32_t dwHandle;
    uint32_t wNetType;
    uint32_t dwPrinters;
    uint32_t dwDrives;
};

struct _MIDL_SYNTAX_INFO
{
    _RPC_SYNTAX_IDENTIFIER TransferSyntax;
    RPC_DISPATCH_TABLE* DispatchTable;
    uint32_t* ProcString;
    uint32_t* FmtStringOffset;
    uint32_t* TypeString;
    void* aUserMarshalQuadruple;
    uint32_t pReserved1;
    uint32_t pReserved2;
};

struct oligsmwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t Flags;
    _GUID ObjectType;
    _GUID InheritedObjectType;
    uint32_t SidStart;
};

struct IDirectSoundFXEcho : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    void IDirectSoundFXEcho();
};

struct tagEMRSELECTPALETTE
{
    tagEMR emr;
    uint32_t ihPal;
};

struct _PUBKEYVER3
{
    uint32_t magic;
    uint32_t bitlenP;
    uint32_t bitlenQ;
    uint32_t bitlenJ;
    _DSSSEED DSSSeed;
};

struct _CERT_REGISTRY_STORE_ROAMING_PARA
{
    HKEY__* hKey;
    uint32_t* pwszStoreDirectory;
};

struct _NDR_USER_MARSHAL_INFO_LEVEL1
{
    void* Buffer;
    uint32_t BufferSize;
    void** pfnAllocate;
    void* pfnFree;
    IRpcChannelBuffer* pRpcChannelBuffer;
    uint32_t Reserved[5];
};

struct _GDI_OBJECT
{
    union __MIDL_IAdviseSink_0002
    {
        _userHBITMAP* hBitmap;
        _userHPALETTE* hPalette;
        _userHGLOBAL* hGeneric;
    };

    uint32_t ObjectType;
    _GDI_OBJECT::__MIDL_IAdviseSink_0002 u;
};

struct _CONTEXT
{
    uint32_t ContextFlags;
    uint32_t Dr0;
    uint32_t Dr1;
    uint32_t Dr2;
    uint32_t Dr3;
    uint32_t Dr6;
    uint32_t Dr7;
    _FLOATING_SAVE_AREA FloatSave;
    uint32_t SegGs;
    uint32_t SegFs;
    uint32_t SegEs;
    uint32_t SegDs;
    uint32_t Edi;
    uint32_t Esi;
    uint32_t Ebx;
    uint32_t Edx;
    uint32_t Ecx;
    uint32_t Eax;
    uint32_t Ebp;
    uint32_t Eip;
    uint32_t SegCs;
    uint32_t EFlags;
    uint32_t Esp;
    uint32_t SegSs;
    uint32_t ExtendedRegisters[512];
};

struct _RPC_SECURITY_QOS_V3_A
{
    uint32_t Version;
    uint32_t Capabilities;
    uint32_t IdentityTracking;
    uint32_t ImpersonationType;
    uint32_t AdditionalSecurityInfoType;
    _RPC_SECURITY_QOS_V3_A::__unnamed u;
    void* Sid;
};

struct hostent
{
    char* h_name;
    char** h_aliases;
    int32_t h_addrtype;
    int32_t h_length;
    char** h_addr_list;
};

struct IComThreadingInfo : IUnknown
{
    HRESULT __stdcall GetCurrentApartmentType();
    HRESULT __stdcall GetCurrentThreadType();
    HRESULT __stdcall GetCurrentLogicalThreadId();
    HRESULT __stdcall SetCurrentLogicalThreadId();
    void IComThreadingInfo();
};

struct tagCAUB
{
    uint32_t cElems;
    uint32_t* pElems;
};

struct _OLESTREAMVTBL
{
    uint32_t* Get;
    uint32_t* Put;
};

struct _PROCESSOR_POWER_POLICY_INFO
{
    uint32_t TimeCheck;
    uint32_t DemoteLimit;
    uint32_t PromoteLimit;
    uint32_t DemotePercent;
    uint32_t PromotePercent;
    uint32_t Spare[2];
    uint32_t AllowDemotion : 1;
    uint32_t AllowPromotion : 1;
    uint32_t Reserved : 30;
};

struct tagDRAWTEXTPARAMS
{
    uint32_t cbSize;
    int32_t iTabLength;
    int32_t iLeftMargin;
    int32_t iRightMargin;
    uint32_t uiLengthDrawn;
};

struct CoreQuatCurveData
{
    int32_t m_sNumKeys;
    int32_t m_sPad;
    CoreQuatAnimKeyData m_oKeys[1];

    void CoreQuatCurveData();
    void ~CoreQuatCurveData();
    CoreQuat GetValue(float fTime, bool& bNoKeys);
    int32_t GetNumKeys();
    int32_t FindKey(float fTime);
    CoreQuatAnimKeyData* GetKeyPtr();
};

struct CoreQuatAnimKeyData
{
    float m_fTime;
    float m_fValue[4];
    float m_Tangent[4];
};

struct CAL1_ProgramLoader : CAL0_FileLoader
{
    CAL1_AudioDriver* m_AD;
    CAL1_AudioItemDatabase* m_AID;
    bool m_Editor;

    void CAL1_ProgramLoader();
    void ~CAL1_ProgramLoader();
    CAL1_AudioItemDatabase* GetAID();
    void SetEditor();
    CAAudioError LoadTheSection(char* type, uint32_t version, uint32_t dataSize);
    CAAudioError LoadCAL1(uint32_t version, uint32_t dataSize);
    CAAudioError ParseCAL1_V1_0(uint32_t* data, uint32_t dataSize);
    int32_t ReadItem(uint32_t* i_itemData);
    CAAudioError ReadSample(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
    CAAudioError ReadSampleGroup(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
    CAAudioError ReadSampleGroupPlayback(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
    CAAudioError ReadAudioItemFileLink(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
    CAAudioError ReadAudioEvent(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
    CAAudioError ReadAudioObject(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
};

struct tagMIXERLINEW
{
    uint32_t cbStruct;
    uint32_t dwDestination;
    uint32_t dwSource;
    uint32_t dwLineID;
    uint32_t fdwLine;
    uint32_t dwUser;
    uint32_t dwComponentType;
    uint32_t cChannels;
    uint32_t cConnections;
    uint32_t cControls;
    uint32_t szShortName[16];
    uint32_t szName[64];
    tagMIXERLINEW::__unnamed Target;
};

struct _PRINTER_INFO_8A
{
    _devicemodeA* pDevMode;
};

struct _SECURITY_ATTRIBUTES
{
    uint32_t nLength;
    void* lpSecurityDescriptor;
    int32_t bInheritHandle;
};

struct tagMCI_OPEN_PARMSA
{
    uint32_t dwCallback;
    uint32_t wDeviceID;
    char* lpstrDeviceType;
    char* lpstrElementName;
    char* lpstrAlias;
};

struct tagMCI_SAVE_PARMSW
{
    uint32_t dwCallback;
    uint32_t* lpfilename;
};

struct _GENERIC_BINDING_ROUTINE_PAIR
{
    void** pfnBind;
    void* pfnUnbind;
};

struct _XMIT_ROUTINE_QUINTUPLE
{
    void* pfnTranslateToXmit;
    void* pfnTranslateFromXmit;
    void* pfnFreeXmit;
    void* pfnFreeInst;
};

struct _COMM_FAULT_OFFSETS
{
    int32_t CommOffset;
    int32_t FaultOffset;
};

struct _NDR_CS_ROUTINES
{
    _NDR_CS_SIZE_CONVERT_ROUTINES* pSizeConvertRoutines;
    void** pTagGettingRoutines;
};

struct _MIDL_STUB_DESC
{
    void* RpcInterfaceInformation;
    void** pfnAllocate;
    void* pfnFree;
    _MIDL_STUB_DESC::__unnamed IMPLICIT_HANDLE_INFO;
    void** apfnNdrRundownRoutines;
    _GENERIC_BINDING_ROUTINE_PAIR* aGenericBindingRoutinePairs;
    void** apfnExprEval;
    _XMIT_ROUTINE_QUINTUPLE* aXmitQuintuple;
    uint32_t* pFormatTypes;
    int32_t fCheckBounds;
    uint32_t Version;
    _MALLOC_FREE_STRUCT* pMallocFreeStruct;
    int32_t MIDLVersion;
    _COMM_FAULT_OFFSETS* CommFaultOffsets;
    _USER_MARSHAL_ROUTINE_QUADRUPLE* aUserMarshalQuadruple;
    void** NotifyRoutineTable;
    uint32_t mFlags;
    _NDR_CS_ROUTINES* CsRoutineTables;
    void* Reserved4;
    uint32_t Reserved5;
};

struct _DSFXI3DL2Reverb
{
    int32_t lRoom;
    int32_t lRoomHF;
    float flRoomRolloffFactor;
    float flDecayTime;
    float flDecayHFRatio;
    int32_t lReflections;
    float flReflectionsDelay;
    int32_t lReverb;
    float flReverbDelay;
    float flDiffusion;
    float flDensity;
    float flHFReference;
};

struct _GLYPHMETRICSFLOAT
{
    float gmfBlackBoxX;
    float gmfBlackBoxY;
    _POINTFLOAT gmfptGlyphOrigin;
    float gmfCellIncX;
    float gmfCellIncY;
};

struct _CRYPT_OID_INFO
{
    uint32_t cbSize;
    char* pszOID;
    uint32_t* pwszName;
    uint32_t dwGroupId;
    uint32_t dwValue;
    uint32_t Algid;
    uint32_t dwLength;
    _CRYPTOAPI_BLOB ExtraInfo;
};

struct _CERT_LDAP_STORE_OPENED_PARA
{
    void* pvLdapSessionHandle;
    uint32_t* pwszLdapUrl;
};

struct _DSCBUFFERDESC
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwBufferBytes;
    uint32_t dwReserved;
    tWAVEFORMATEX* lpwfxFormat;
    uint32_t dwFXCount;
    _DSCEFFECTDESC* lpDSCFXDesc;
};

struct IDirectSoundCaptureBuffer8 : IDirectSoundCaptureBuffer
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetCaps();
    HRESULT __stdcall GetCurrentPosition();
    HRESULT __stdcall GetFormat();
    HRESULT __stdcall GetStatus();
    HRESULT __stdcall Initialize();
    HRESULT __stdcall Lock();
    HRESULT __stdcall Start();
    HRESULT __stdcall Stop();
    HRESULT __stdcall Unlock();
    HRESULT __stdcall GetObjectInPath();
    HRESULT __stdcall GetFXStatus();
    void IDirectSoundCaptureBuffer8();
};

struct _SYSTEM_ALARM_CALLBACK_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t SidStart;
};

struct _TOKEN_DEFAULT_DACL
{
    _ACL* DefaultDacl;
};

struct tagFONTSIGNATURE
{
    uint32_t fsUsb[4];
    uint32_t fsCsb[2];
};

struct wavefilter_volume_tag
{
    wavefilter_tag wfltr;
    uint32_t dwVolume;
};

struct CoreRenderableObject : CoreObject
{
    CoreRenderableObjectData* m_lpoData;

    void CoreRenderableObject();
    void ~CoreRenderableObject();
    void Construct(CoreMemory* lpoMemory);
    void Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Reset();
    void AddToRenderList(CoreGameRender* lpoGraphics);
    void SetScaledFrameTime(float);
    void Render();
    void RenderShadow();
    void SetNoZWrite(bool i_enable);
    void SetNoZTest(bool i_enable);
    void SetBeforeLevel(bool i_enable);
    void SetPanelObject(bool i_enable);
    void SetNoViewCulling(bool i_enable);
    void SetLastObject();
    void SetSingleViewObject();
    void SetNoViewOcclusion();
    bool GetNoZWrite();
    bool GetNoZTest();
    bool GetBeforeLevel();
    bool GetLastObject();
    bool GetPanelObject();
    bool GetNoViewCulling();
    bool GetSingleViewObject();
    bool GetNoViewOcclusion();
    void GetBoundingBox(CoreVector& o_bboxMin, CoreVector& o_bboxMax);
    void SetBoundingBox(CoreVector i_bboxMin, CoreVector i_bboxMax);
};

struct SYSTEM_POWER_LEVEL
{
    uint32_t Enable;
    uint32_t Spare[3];
    uint32_t BatteryLevel;
    POWER_ACTION_POLICY PowerPolicy;
    _SYSTEM_POWER_STATE MinSystemState;
};

struct _DRIVER_INFO_4A
{
    uint32_t cVersion;
    char* pName;
    char* pEnvironment;
    char* pDriverPath;
    char* pDataFile;
    char* pConfigFile;
    char* pHelpFile;
    char* pDependentFiles;
    char* pMonitorName;
    char* pDefaultDataType;
    char* pszzPreviousNames;
};

struct tagOBJECTDESCRIPTOR
{
    uint32_t cbSize;
    _GUID clsid;
    uint32_t dwDrawAspect;
    tagSIZE sizel;
    _POINTL pointl;
    uint32_t dwStatus;
    uint32_t dwFullUserTypeName;
    uint32_t dwSrcOfCopy;
};

struct _OFNOTIFYW
{
    tagNMHDR hdr;
    tagOFNW* lpOFN;
    uint32_t* pszFile;
};

struct _SYSTEM_INFO
{
    uint32_t dwOemId;
    uint32_t wProcessorArchitecture;
    uint32_t wReserved;
    uint32_t dwPageSize;
    void* lpMinimumApplicationAddress;
    void* lpMaximumApplicationAddress;
    uint32_t dwActiveProcessorMask;
    uint32_t dwNumberOfProcessors;
    uint32_t dwProcessorType;
    uint32_t dwAllocationGranularity;
    uint32_t wProcessorLevel;
    uint32_t wProcessorRevision;
};

struct tagMCI_PLAY_PARMS
{
    uint32_t dwCallback;
    uint32_t dwFrom;
    uint32_t dwTo;
};

struct std::_Init_locks
{
    void _Init_locks();
    void ~_Init_locks();
};

struct std::bad_exception : exception
{
    void bad_exception();
    void ~bad_exception();
    void __dflt_ctor_closure();
};

struct exception
{
    char* _m_what;
    int32_t _m_doFree;

    // TODO vtable

    void exception();
    void ~exception();
    char* what();
};

struct std::nothrow_t
{
};

struct std::_Lockit
{
    int32_t _Locktype;

    void _Lockit();
    void ~_Lockit();
};

struct std::_Mutex
{
    void* _Mtx;

    void _Mutex();
    void ~_Mutex();
    void _Lock();
    void _Unlock();
};

struct std::bad_alloc : exception
{
    void bad_alloc();
    void ~bad_alloc();
    void __dflt_ctor_closure();
};

struct _ACCESS_ALLOWED_OBJECT_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t Flags;
    _GUID ObjectType;
    _GUID InheritedObjectType;
    uint32_t SidStart;
};

struct val_context
{
    int32_t valuelen;
    void* value_context;
    void* val_buff_ptr;
};

union _CLIENT_CALL_RETURN
{
    void* Pointer;
    int32_t Simple;
};

struct tagCACY
{
    uint32_t cElems;
    tagCY* pElems;
};

struct CAL1_StreamSaver : CAL0_FileSaver
{
    CAL1_AudioDriver* m_AD;
    CAL1_AudioItemDatabase* m_AID;
    CAL0_File* m_STMMFile;
    CAL0_File* m_STMDFile;
    CA_ExpFmt m_ExportFormat;
    uint32_t m_LanguageMask;
    uint32_t m_PlatformIndex;

    void CAL1_StreamSaver();
    void ~CAL1_StreamSaver();
    void SetExportFormat();
    void SetLanguageMask();
    void SetPlatformIndex();
    CAAudioError AssembleSections();
    CAAudioError DestroySections();
    CAAudioError AssembleLanguageBlock();
    CAAudioError AssembleAll();
    CAAudioError DestroyAll();
};

struct CorePhysicsRod
{
    int32_t m_vIndex0;
    int32_t m_vIndex1;
    float m_restLength;
    float m_tmpLength;
};

struct tagMCI_WAVE_OPEN_PARMSA
{
    uint32_t dwCallback;
    uint32_t wDeviceID;
    char* lpstrDeviceType;
    char* lpstrElementName;
    char* lpstrAlias;
    uint32_t dwBufferSeconds;
};

struct _CERT_STORE_PROV_INFO
{
    uint32_t cbSize;
    uint32_t cStoreProvFunc;
    void** rgpvStoreProvFunc;
    void* hStoreProv;
    uint32_t dwStoreProvFlags;
    void* hStoreProvFuncAddr2;
};

struct IXMLDOMAttribute : IXMLDOMNode
{
    HRESULT __stdcall get_name();
    HRESULT __stdcall get_value();
    HRESULT __stdcall put_value();
    void IXMLDOMAttribute();
};

struct CoreMapFileFunctionsHeader
{
    enum
    {
        ParametersPlaceholder = 255,
        FirstPlaceholder = 254,
    };

    uint32_t m_header;
    uint32_t m_version;
    int32_t m_offsetToFunctions;
    int32_t m_functionCount;
    uint32_t m_firstAddress;
    uint32_t m_sizeScaler;
    int32_t m_offsetToStringTable;

    void CoreMapFileFunctionsHeader();
    void SetHeader();
    bool IsHeaderValid();
    int32_t GetPlaceholderForString();
    int32_t GetParametersPlaceholder();
    int32_t CountParametersPlaceholders();
    bool FindFunction();
    char* GetPlaceholderString();
    int32_t GetPlaceholderStringCount();
    int32_t ConvertPlaceholderIndexToPlaceholder();
    int32_t ConvertPlaceholderToPlaceholderIndex();
    char* GetString();
    void CopyString();
};

struct ITypeMarshal : IUnknown
{
    HRESULT __stdcall Size();
    HRESULT __stdcall Marshal();
    HRESULT __stdcall Unmarshal();
    HRESULT __stdcall Free();
    void ITypeMarshal();
};

struct tagEXBMINFOHEADER
{
    tagBITMAPINFOHEADER bmi;
    uint32_t biExtDataOffset;
};

struct LIST_ENTRY32
{
    uint32_t Flink;
    uint32_t Blink;
};

struct _IMAGE_FUNCTION_ENTRY64
{
    uint32_t StartingAddress;
    uint32_t EndingAddress;
    uint32_t EndOfPrologue;
    uint32_t UnwindInfoAddress;
};

struct _EXIT_THREAD_DEBUG_INFO
{
    uint32_t dwExitCode;
};

struct tagMCI_GENERIC_PARMS
{
    uint32_t dwCallback;
};

struct _ENUM_SERVICE_STATUS_PROCESSA
{
    char* lpServiceName;
    char* lpDisplayName;
    _SERVICE_STATUS_PROCESS ServiceStatusProcess;
};

struct IWindowForBindingUI : IUnknown
{
    HRESULT __stdcall GetWindow();
    void IWindowForBindingUI();
};

struct _SERVICE_STATUS_PROCESS
{
    uint32_t dwServiceType;
    uint32_t dwCurrentState;
    uint32_t dwControlsAccepted;
    uint32_t dwWin32ExitCode;
    uint32_t dwServiceSpecificExitCode;
    uint32_t dwCheckPoint;
    uint32_t dwWaitHint;
    uint32_t dwProcessId;
    uint32_t dwServiceFlags;
};

struct _DSFXCompressor
{
    float fGain;
    float fAttack;
    float fRelease;
    float fThreshold;
    float fRatio;
    float fPredelay;
};

struct CoreGameMessageBoxButtons
{
    int32_t m_buttonCount;
    int32_t m_selectedButtonIndex;
    float m_flashValue;
    CoreGameButtonText* m_buttons[4];

    void CoreGameMessageBoxButtons();
    int32_t Prepare(CoreMessageBoxInterface::CoreMessageBoxTypeTag i_type, int32_t i_selectedButtonIndex);
    int32_t GetButtonCount();
    bool GetWidthsAndHeights(CoreGameMessageBoxParameters* i_messageBoxParameters, CoreFont* i_font, float& o_width, float& o_height, float& o_totalWidth, float& o_nextOffsetX, int32_t i_renderFlags);
    void Render(CoreGameMessageBoxParameters* i_messageBoxParameters, CoreGameRender* io_graphics, CoreFont* i_font, float i_startX, float i_y, float i_buttonWidth, float i_buttonHeight, float i_nextOffsetX, bool i_shouldFlash, float i_alphaScaler, int32_t i_renderFlags);
    bool UpdateInput(CoreGameMessageBoxParameters* i_messageBoxParameters, CoreHash& o_soundHash, int32_t i_controllerInputIndex);
    int32_t GetSelectedButtonIndex();
    void Reset();
    bool Add(CoreGameButtonText* i_buttonText);
};

struct CoreGameMessageBoxParameters
{
    CoreGameFrame Frame;
    CoreRGBA ScreenBackGroundRGBA;
    CoreRGBA TextRGBA;
    CoreRGBA ButtonTextRGBA;
    CoreRGBA SelectedButtonTextRGBA;
    CoreRGBA ButtonBackGroundRGBA;
    static bool m_defaultsSet;
    float m_centreX;
    float m_centreY;
    float m_maximumWidth;
    bool m_fixedWidth;
    float m_maximumHeight;
    bool m_fixedHeight;
    float m_messageTextScaleX;
    float m_messageTextScaleY;
    float m_buttonsTextScaleX;
    float m_buttonsTextScaleY;
    float m_spaceBetweenTextAndFrameX;
    float m_spaceBetweenTextAndFrameY;
    float m_spaceBetweenButtons;
    float m_spaceBetweenTextAndButtons;
    float m_buttonSurroundX;
    float m_buttonSurroundY;
    float m_buttonSurroundOffsetX;
    float m_buttonSurroundOffsetY;
    float m_buttonMinimumWidth;
    CoreHash m_buttonTextureID;
    bool m_buttonInputWrap;
    float m_selectedButtonFlashRate;
    float m_selectedButtonFlashFrom;
    float m_selectedButtonFlashTo;
    float m_dialogFadeUpTime;
    float m_dialogFadeDownTime;
    CoreHash m_startSoundHash;
    CoreHash m_selectSoundHash;
    CoreHash m_leftSoundHash;
    CoreHash m_rightSoundHash;
    CoreHash m_fontHash;
    CoreHash m_textureSetHash;

    CoreGameMessageBoxParameters* GetDefaults();
    void CoreGameMessageBoxParameters();
    void SetDefaultsFromThis();
    void SetThisFromDefaults();
    void SetCentreXY();
    float GetCentreX();
    float GetCentreY();
    void SetMaximumWidth();
    float GetMaximumWidth();
    void SetFixedWidth();
    bool IsFixedWidth();
    void SetMaximumHeight();
    float GetMaximumHeight();
    void SetFixedHeight();
    bool IsFixedHeight();
    void SetMessageTextScales();
    float GetMessageTextScaleX();
    float GetMessageTextScaleY();
    void SetButtonsTextScales();
    float GetButtonsTextScaleX();
    float GetButtonsTextScaleY();
    void SetSpaceBetweenTextAndFrameX();
    float GetSpaceBetweenTextAndFrameX();
    void SetSpaceBetweenTextAndFrameY();
    float GetSpaceBetweenTextAndFrameY();
    void SetSpaceBetweenButtons();
    float GetSpaceBetweenButtons();
    void SetSpaceBetweenTextAndButtons();
    float GetSpaceBetweenTextAndButtons();
    void SetButtonSurroundX();
    float GetButtonSurroundX();
    void SetButtonSurroundY();
    float GetButtonSurroundY();
    void SetButtonSurroundOffsetX();
    float GetButtonSurroundOffsetX();
    void SetButtonSurroundOffsetY();
    float GetButtonSurroundOffsetY();
    void SetButtonMinimumWidth();
    float GetButtonMinimumWidth();
    void SetButtonTextureID(CoreHash i_textureID);
    CoreHash GetButtonTextureID();
    void SetButtonInputWrap();
    bool GetButtonInputWrap();
    void SetSelectedButtonFlash();
    float GetSelectedButtonFlashRate();
    float GetSelectedButtonFlashRangeFrom();
    float GetSelectedButtonFlashRangeTo();
    void SetDialogFadeTimes();
    float GetDialogFadeUpTime();
    float GetDialogFadeDownTime();
    void SetFontHash(CoreHash i_fontHash);
    CoreFont* GetFont();
    void SetTextureSetHash(CoreHash i_textureSetHash);
    CoreTextureSet* GetTextureSet();
    void SetStartSoundHash(CoreHash i_soundHash);
    CoreHash GetStartSoundHash();
    void SetSelectSoundHash(CoreHash i_soundHash);
    CoreHash GetSelectSoundHash();
    void SetLeftSoundHash(CoreHash i_soundHash);
    CoreHash GetLeftSoundHash();
    void SetRightSoundHash(CoreHash i_soundHash);
    CoreHash GetRightSoundHash();
    void SetDefaults();
    void ~CoreGameMessageBoxParameters();
};

struct CoreGameButtonText
{
    char* m_text;
    CoreHash m_textID;

    void CoreGameButtonText(char* i_text);
    void Set(CoreHash i_textID);
    char* Get();
    void ~CoreGameButtonText();
};

struct CoreAnimCommandCreate : CoreAnimCommand
{
    void CoreAnimCommandCreate();
    void Initialise();
    CoreAnimCommandAutoBlend* GetAnimCommandAutoBlendNC();
    void ~CoreAnimCommandCreate();
};

struct _QUOTA_LIMITS
{
    uint32_t PagedPoolLimit;
    uint32_t NonPagedPoolLimit;
    uint32_t MinimumWorkingSetSize;
    uint32_t MaximumWorkingSetSize;
    uint32_t PagefileLimit;
    _LARGE_INTEGER TimeLimit;
};

struct tagSERIALKEYSW
{
    uint32_t cbSize;
    uint32_t dwFlags;
    uint32_t* lpszActivePort;
    uint32_t* lpszPort;
    uint32_t iBaudRate;
    uint32_t iPortState;
    uint32_t iActive;
};

struct tagMCI_ANIM_OPEN_PARMSW
{
    uint32_t dwCallback;
    uint32_t wDeviceID;
    uint32_t* lpstrDeviceType;
    uint32_t* lpstrElementName;
    uint32_t* lpstrAlias;
    uint32_t dwStyle;
    HWND* hWndParent;
};

struct _ADDJOB_INFO_1W
{
    uint32_t* Path;
    uint32_t JobId;
};

struct IInternetZoneManager : IUnknown
{
    HRESULT __stdcall GetZoneAttributes();
    HRESULT __stdcall SetZoneAttributes();
    HRESULT __stdcall GetZoneCustomPolicy();
    HRESULT __stdcall SetZoneCustomPolicy();
    HRESULT __stdcall GetZoneActionPolicy();
    HRESULT __stdcall SetZoneActionPolicy();
    HRESULT __stdcall PromptAction();
    HRESULT __stdcall LogAction();
    HRESULT __stdcall CreateZoneEnumerator();
    HRESULT __stdcall GetZoneAt();
    HRESULT __stdcall DestroyZoneEnumerator();
    HRESULT __stdcall CopyTemplatePoliciesToZone();
    void IInternetZoneManager();
};

struct _PRINTER_DEFAULTSA
{
    char* pDatatype;
    _devicemodeA* pDevMode;
    uint32_t DesiredAccess;
};

struct _CMS_DH_KEY_INFO
{
    uint32_t dwVersion;
    uint32_t Algid;
    char* pszContentEncObjId;
    _CRYPTOAPI_BLOB PubInfo;
    void* pReserved;
};

struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
{
    uint32_t ulFlags;
    uint32_t ulEncodedAssemblyIdentityLength;
    uint32_t ulManifestPathType;
    uint32_t ulManifestPathLength;
    _LARGE_INTEGER liManifestLastWriteTime;
    uint32_t ulPolicyPathType;
    uint32_t ulPolicyPathLength;
    _LARGE_INTEGER liPolicyLastWriteTime;
    uint32_t ulMetadataSatelliteRosterIndex;
    uint32_t ulManifestVersionMajor;
    uint32_t ulManifestVersionMinor;
    uint32_t ulPolicyVersionMajor;
    uint32_t ulPolicyVersionMinor;
    uint32_t ulAssemblyDirectoryNameLength;
    uint32_t* lpAssemblyEncodedAssemblyIdentity;
    uint32_t* lpAssemblyManifestPath;
    uint32_t* lpAssemblyPolicyPath;
    uint32_t* lpAssemblyDirectoryName;
    uint32_t ulFileCount;
};

struct _CRYPTOAPI_BLOB
{
    uint32_t cbData;
    uint32_t* pbData;
};

struct _CMC_ADD_EXTENSIONS_INFO
{
    uint32_t dwCmcDataReference;
    uint32_t cCertReference;
    uint32_t* rgdwCertReference;
    uint32_t cExtension;
    _CERT_EXTENSION* rgExtension;
};

struct _FLAGGED_BYTE_BLOB
{
    uint32_t fFlags;
    uint32_t clSize;
    uint32_t abData[1];
};

struct aptxwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct tagDROPSTRUCT
{
    HWND* hwndSource;
    HWND* hwndSink;
    uint32_t wFmt;
    uint32_t dwData;
    tagPOINT ptDrop;
    uint32_t dwControlData;
};

struct tagCONVCONTEXT
{
    uint32_t cb;
    uint32_t wFlags;
    uint32_t wCountryID;
    int32_t iCodePage;
    uint32_t dwLangID;
    uint32_t dwSecurity;
    _SECURITY_QUALITY_OF_SERVICE qos;
};

struct _TOKEN_GROUPS_AND_PRIVILEGES
{
    uint32_t SidCount;
    uint32_t SidLength;
    _SID_AND_ATTRIBUTES* Sids;
    uint32_t RestrictedSidCount;
    uint32_t RestrictedSidLength;
    _SID_AND_ATTRIBUTES* RestrictedSids;
    uint32_t PrivilegeCount;
    uint32_t PrivilegeLength;
    _LUID_AND_ATTRIBUTES* Privileges;
    _LUID AuthenticationId;
};

struct tagMDICREATESTRUCTA
{
    char* szClass;
    char* szTitle;
    void* hOwner;
    int32_t x;
    int32_t y;
    int32_t cx;
    int32_t cy;
    uint32_t style;
    int32_t lParam;
};

struct _RPC_SECURITY_QOS_V2_W
{
    uint32_t Version;
    uint32_t Capabilities;
    uint32_t IdentityTracking;
    uint32_t ImpersonationType;
    uint32_t AdditionalSecurityInfoType;
    _RPC_SECURITY_QOS_V2_W::__unnamed u;
};

struct _STORAGE_PREDICT_FAILURE
{
    uint32_t PredictFailure;
    uint32_t VendorSpecific[512];
};

struct CoreFontGlyph
{
    CoreUV top;
    CoreUV bottom;
    float width;
    float height;
    float xOffset;
    float yOffset;
    float advance;
    float prespace;
    uint32_t textureNumber;

    void CoreFontGlyph();
    void ~CoreFontGlyph();
};

struct tagEXTLOGPEN
{
    uint32_t elpPenStyle;
    uint32_t elpWidth;
    uint32_t elpBrushStyle;
    uint32_t elpColor;
    uint32_t elpHatch;
    uint32_t elpNumEntries;
    uint32_t elpStyleEntry[1];
};

struct midievent_tag
{
    uint32_t dwDeltaTime;
    uint32_t dwStreamID;
    uint32_t dwEvent;
    uint32_t dwParms[1];
};

struct _CERT_TRUST_STATUS
{
    uint32_t dwErrorStatus;
    uint32_t dwInfoStatus;
};

struct CoreGsDispEnv
{
    CoretGS_PMODE pmode;
    CoretGS_SMODE2 smode2;
    CoretGS_DISPFB2 dispfb;
    CoretGS_DISPLAY2 display;
    CoretGS_BGCOLOR bgcolor;
};

struct CAL0_Util
{
    struct ca_MemoryBlockHeader
    {
        uint32_t m_size;
        void* m_fileName;
        uint32_t m_lineNumber;
        uint32_t m_AllocNumber;
    };

    static int32_t m_Tick[8];
    static int32_t m_Tock[8];
    static uint32_t m_MemoryAllocated;
    static uint32_t m_NumAllocs;
    static uint32_t m_NumDeAllocs;
    static bool m_BanSysAlloc;
    static bool m_BanNormalAlloc;
    static bool m_SendDbgLogToOutput;
    static bool m_UseSysAllocOnly;
    static CAL0_Heap m_Heap;
    static CAL0_Heap m_MiniHeap[3];
    static int32_t m_CurrentMiniHeap;
    static bool m_Initialised;
    static bool m_ShowMemoryLogging;
    static char m_WorkingPath[260];

    void CAL0_Util();
    uint32_t ca_mem_write_uint8(void* dest, uint32_t value);
    uint32_t ca_mem_write_int8();
    uint32_t ca_mem_write_uint16(void* dest, uint32_t value);
    uint32_t ca_mem_write_int16(void* dest, int32_t value);
    uint32_t ca_mem_write_uint32(void* dest, uint32_t value);
    uint32_t ca_mem_write_int32();
    uint32_t ca_mem_write_fixed();
    uint32_t ca_mem_write_fixedhp();
    uint32_t ca_mem_write_string();
    uint32_t ca_mem_write_data(void* dest, void* data, uint32_t length);
    uint32_t ca_mem_read_uint8(void* dest, uint32_t* value);
    uint32_t ca_mem_read_int8();
    uint32_t ca_mem_read_uint16(void* dest, uint32_t* value);
    uint32_t ca_mem_read_int16(void* dest, int32_t* value);
    uint32_t ca_mem_read_uint32(void* dest, uint32_t* value);
    uint32_t ca_mem_read_int32();
    uint32_t ca_mem_read_fixed();
    uint32_t ca_mem_read_fixedhp();
    void* ca_AllocSysMem(uint32_t size);
    void ca_DeallocSysMem(void* address);
    void* ca_AllocMemory();
    void ca_DeallocMemory();
    void* AllocateMemoryFromHeap(uint32_t size);
    void DeallocateMemoryFromHeap(void* address);
    CAAudioError ca_LockSystemHeap();
    CAAudioError ca_LockLevelHeap();
    CAAudioError ca_ResetLevelHeap();
    CAAudioError ca_ResetAreaHeap();
    CAAudioError ca_MarkAreaHeap();
    CAAudioError ca_UnMarkAreaHeap();
    CAAudioError ca_ResetAreaA();
    CAAudioError ca_ResetAreaB();
    void ca_logTime();
    void ca_showTime();
    void ca_dbgLog(bool is_valid, char* format);
    void ca_InitMemory();
    void ca_ReleaseMemory();
    bool IsMemoryInitialised();
    void ca_showMemoryLogging(bool show);
    void SetHeapLogging(bool set);
    void ca_SetBanSysAlloc();
    void ca_SetBanNormalAlloc();
    void ca_SetDbgLogToOutput();
    void* ca_memset(void* ptr, char value, uint32_t length);
    void* ca_memcpy(void* ptr_dest, void* ptr_src, uint32_t length);
    int32_t ca_memcmp(void* ptr_one, void* ptr_two, uint32_t length);
    int32_t ca_strcmp(char* str1, char* str2);
    int32_t ca_strlen(char* str1);
    char* ca_strcpy(char* str_dest, char* str_src);
    char* ca_strncpy(char* dest, char* src, uint32_t length);
    char* ca_strcat(char* dest, char* src);
    uint32_t ca_sprintf(char* stringBuffer, char* format);
    char* ca_strupr();
    char* ca_strlwr();
    char* ca_strchr();
    char* ca_strstr();
    uint32_t ca_GetPCMStreamOffset();
    CAAudioError strDeallocAllocAndCopy(char** destStr, char* sourceStr);
    char* ca_pathGetExtension();
    bool ca_pathGetFileName();
    void ca_splitPath();
    CAAudioError ca_createDirectoryMultiple();
    CAAudioError GetRemappedFileName();
    void GetFileNameFromPath();
    int32_t GetPathLanguageIndex();
    int32_t GetPathPlatformIndex();
    bool GetRootPath();
    bool ca_getLocPlatFile();
    bool ca_fileExists();
    CAAudioError InitialiseHeap(uint32_t heapSize, void* address, bool useSysMemory);
    CAAudioError ResetHeap();
    CAAudioError ReleaseHeap();
    uint32_t ca_Align(uint32_t value, uint32_t alignment);
    CAL0_File* CreateTempFile();
    void SetWorkingPath();
    char* GetWorkingPath();
    uint32_t GetHashValue(char* s);
    void GetHashString();
};

struct _OUTLINETEXTMETRICA
{
    uint32_t otmSize;
    tagTEXTMETRICA otmTextMetrics;
    uint32_t otmFiller;
    tagPANOSE otmPanoseNumber;
    uint32_t otmfsSelection;
    uint32_t otmfsType;
    int32_t otmsCharSlopeRise;
    int32_t otmsCharSlopeRun;
    int32_t otmItalicAngle;
    uint32_t otmEMSquare;
    int32_t otmAscent;
    int32_t otmDescent;
    uint32_t otmLineGap;
    uint32_t otmsCapEmHeight;
    uint32_t otmsXHeight;
    tagRECT otmrcFontBox;
    int32_t otmMacAscent;
    int32_t otmMacDescent;
    uint32_t otmMacLineGap;
    uint32_t otmusMinimumPPEM;
    tagPOINT otmptSubscriptSize;
    tagPOINT otmptSubscriptOffset;
    tagPOINT otmptSuperscriptSize;
    tagPOINT otmptSuperscriptOffset;
    uint32_t otmsStrikeoutSize;
    int32_t otmsStrikeoutPosition;
    int32_t otmsUnderscoreSize;
    int32_t otmsUnderscorePosition;
    char* otmpFamilyName;
    char* otmpFaceName;
    char* otmpStyleName;
    char* otmpFullName;
};

struct _userCLIPFORMAT
{
    union __MIDL_IWinTypes_0001
    {
        uint32_t dwValue;
        wchar_t* pwszName;
    };

    int32_t fContext;
    _userCLIPFORMAT::__MIDL_IWinTypes_0001 u;
};

struct CoreMapFileParseHelper
{
    char* m_parse;
    int32_t m_remaining;
    int32_t m_characterCount;
    int32_t m_lineCount;

    int32_t CheckNextChar();
    void SkipZeros();
    void Advance();
    void CoreMapFileParseHelper();
    void Init();
    int32_t GetNextChar();
    bool IsEOF();
    bool IsCRLF();
    void SkipCRLF();
    void FindCRLF();
    bool IsHexDigit();
    int32_t GetHexDigit();
    uint32_t GetHexNumber();
    int32_t GetLine();
};

struct _CRYPT_RC2_CBC_PARAMETERS
{
    uint32_t dwVersion;
    int32_t fIV;
    uint32_t rgbIV[8];
};

struct _PREVENT_MEDIA_REMOVAL
{
    uint32_t PreventMediaRemoval;
};

struct _RASTERIZER_STATUS
{
    int32_t nSize;
    int32_t wFlags;
    int32_t nLanguageID;
};

struct _PROPSHEETPAGEW_V3
{
    uint32_t dwSize;
    uint32_t dwFlags;
    HINSTANCE__* hInstance;
    uint32_t* pszTemplate;
    DLGTEMPLATE* pResource;
    HICON__* hIcon;
    uint32_t* pszIcon;
    uint32_t* pszTitle;
    int32_t* pfnDlgProc;
    int32_t lParam;
    uint32_t* pfnCallback;
    uint32_t* pcRefParent;
    uint32_t* pszHeaderTitle;
    uint32_t* pszHeaderSubTitle;
    void* hActCtx;
};

struct tagOFN_NT4A
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HINSTANCE__* hInstance;
    char* lpstrFilter;
    char* lpstrCustomFilter;
    uint32_t nMaxCustFilter;
    uint32_t nFilterIndex;
    char* lpstrFile;
    uint32_t nMaxFile;
    char* lpstrFileTitle;
    uint32_t nMaxFileTitle;
    char* lpstrInitialDir;
    char* lpstrTitle;
    uint32_t Flags;
    uint32_t nFileOffset;
    uint32_t nFileExtension;
    char* lpstrDefExt;
    int32_t lCustData;
    uint32_t* lpfnHook;
    char* lpTemplateName;
};

struct digistdwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct CoreGeometryCompiledPSPStaticLitMeshVertex
{
    uint32_t u16;
    uint32_t v16;
    uint32_t col8888;
    float x32;
    float y32;
    float z32;
};

struct CAL1_StreamLoader : CAL0_FileLoader
{
    uint32_t m_BlockAddr;
    CAL1_AudioDriver* m_AD;
    CAL1_AudioItemDatabase* m_AID;
    uint32_t m_LanguageMask;
    uint32_t m_StreamOffset;
    uint32_t m_StreamOffset_Common;
    uint32_t m_GlobalStreamOffset;
    uint32_t m_GlobalStreamOffset_Common;
    bool m_GlobalStream;

    void CAL1_StreamLoader();
    void ~CAL1_StreamLoader();
    void SetLanguageMask(uint32_t langMask);
    uint32_t GetLanguageMask();
    void SetGlobalStream(bool globalStream);
    bool GetGlobalStream();
    CAAudioError LoadTheSection(char* type, uint32_t version, uint32_t dataSize);
    CAAudioError LoadSTMM(uint32_t version, uint32_t dataSize);
    CAAudioError ParseSTMM_V1_0(uint32_t* data, uint32_t dataSize);
    CAAudioError ReadSMAP(uint32_t* data, uint32_t language, uint32_t dataFormat);
    CAAudioError ReadSMAP_V1_0(uint32_t* data, uint32_t language, uint32_t dataFormat);
    CAAudioError LoadSTMD(uint32_t version, uint32_t dataSize);
};

struct _CERT_FORTEZZA_DATA_PROP
{
    uint32_t SerialNumber[8];
    int32_t CertIndex;
    uint32_t CertLabel[36];
};

struct _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA
{
    uint32_t cbSize;
    uint32_t dwSignerIndex;
    uint32_t dwUnauthAttrIndex;
};

struct _PRINTER_INFO_8W
{
    _devicemodeW* pDevMode;
};

struct tagEMRPOLYTEXTOUTA
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t iGraphicsMode;
    float exScale;
    float eyScale;
    int32_t cStrings;
    tagEMRTEXT aemrtext[1];
};

struct SCARD_T1_REQUEST
{
    _SCARD_IO_REQUEST ioRequest;
};

struct _MESSAGE_RESOURCE_BLOCK
{
    uint32_t LowId;
    uint32_t HighId;
    uint32_t OffsetToEntries;
};

struct tagBITMAPINFOHEADER
{
    uint32_t biSize;
    int32_t biWidth;
    int32_t biHeight;
    uint32_t biPlanes;
    uint32_t biBitCount;
    uint32_t biCompression;
    uint32_t biSizeImage;
    int32_t biXPelsPerMeter;
    int32_t biYPelsPerMeter;
    uint32_t biClrUsed;
    uint32_t biClrImportant;
};

struct IInternet : IUnknown
{
    void IInternet();
};

struct tagEMRSTRETCHDIBITS
{
    tagEMR emr;
    _RECTL rclBounds;
    int32_t xDest;
    int32_t yDest;
    int32_t xSrc;
    int32_t ySrc;
    int32_t cxSrc;
    int32_t cySrc;
    uint32_t offBmiSrc;
    uint32_t cbBmiSrc;
    uint32_t offBitsSrc;
    uint32_t cbBitsSrc;
    uint32_t iUsageSrc;
    uint32_t dwRop;
    int32_t cxDest;
    int32_t cyDest;
};

struct __GENERIC_BINDING_INFO
{
    void* pObj;
    uint32_t Size;
    void** pfnBind;
    void* pfnUnbind;
};

struct IBindCtx : IUnknown
{
    HRESULT __stdcall RegisterObjectBound();
    HRESULT __stdcall RevokeObjectBound();
    HRESULT __stdcall ReleaseBoundObjects();
    HRESULT __stdcall SetBindOptions();
    HRESULT __stdcall GetBindOptions();
    HRESULT __stdcall GetRunningObjectTable();
    HRESULT __stdcall RegisterObjectParam();
    HRESULT __stdcall GetObjectParam();
    HRESULT __stdcall EnumObjectParam();
    HRESULT __stdcall RevokeObjectParam();
    void IBindCtx();
};

struct _STORAGE_HOTPLUG_INFO
{
    uint32_t Size;
    uint32_t MediaRemovable;
    uint32_t MediaHotplug;
    uint32_t DeviceHotplug;
    uint32_t WriteCacheEnableOverride;
};

struct tagPROPSPEC
{
    uint32_t ulKind;
    uint32_t propid;
    uint32_t* lpwstr;
};

struct tagPROPVARIANT
{
    uint32_t vt;
    uint32_t wReserved1;
    uint32_t wReserved2;
    uint32_t wReserved3;
    char cVal;
    uint32_t bVal;
    int32_t iVal;
    uint32_t uiVal;
    int32_t lVal;
    uint32_t ulVal;
    int32_t intVal;
    uint32_t uintVal;
    _LARGE_INTEGER hVal;
    _ULARGE_INTEGER uhVal;
    float fltVal;
    float dblVal;
    int32_t boolVal;
    int32_t scode;
    tagCY cyVal;
    float date;
    _FILETIME filetime;
    _GUID* puuid;
    tagCLIPDATA* pclipdata;
    uint32_t* bstrVal;
    tagBSTRBLOB bstrblobVal;
    tagBLOB blob;
    char* pszVal;
    uint32_t* pwszVal;
    IUnknown* punkVal;
    IDispatch* pdispVal;
    IStream* pStream;
    IStorage* pStorage;
    tagVersionedStream* pVersionedStream;
    tagSAFEARRAY* parray;
    tagCAC cac;
    tagCAUB caub;
    tagCAI cai;
    tagCAUI caui;
    tagCAL cal;
    tagCAUL caul;
    tagCAH cah;
    tagCAUH cauh;
    tagCAFLT caflt;
    tagCADBL cadbl;
    tagCABOOL cabool;
    tagCASCODE cascode;
    tagCACY cacy;
    tagCADATE cadate;
    tagCAFILETIME cafiletime;
    tagCACLSID cauuid;
    tagCACLIPDATA caclipdata;
    tagCABSTR cabstr;
    tagCABSTRBLOB cabstrblob;
    tagCALPSTR calpstr;
    tagCALPWSTR calpwstr;
    tagCAPROPVARIANT capropvar;
    char* pcVal;
    uint32_t* pbVal;
    int32_t* piVal;
    uint32_t* puiVal;
    int32_t* plVal;
    uint32_t* pulVal;
    int32_t* pintVal;
    uint32_t* puintVal;
    float* pfltVal;
    float* pdblVal;
    int32_t* pboolVal;
    tagDEC* pdecVal;
    int32_t* pscode;
    tagCY* pcyVal;
    float* pdate;
    uint32_t** pbstrVal;
    IUnknown** ppunkVal;
    IDispatch** ppdispVal;
    tagSAFEARRAY** pparray;
    tagPROPVARIANT* pvarVal;
    tagDEC decVal;
};

struct _FILETIME
{
    uint32_t dwLowDateTime;
    uint32_t dwHighDateTime;
};

struct IPropertyStorage : IUnknown
{
    HRESULT __stdcall ReadMultiple();
    HRESULT __stdcall WriteMultiple();
    HRESULT __stdcall DeleteMultiple();
    HRESULT __stdcall ReadPropertyNames();
    HRESULT __stdcall WritePropertyNames();
    HRESULT __stdcall DeletePropertyNames();
    HRESULT __stdcall Commit();
    HRESULT __stdcall Revert();
    HRESULT __stdcall Enum();
    HRESULT __stdcall SetTimes();
    HRESULT __stdcall SetClass();
    HRESULT __stdcall Stat();
    void IPropertyStorage();
};

struct tagPDW
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    void* hDevMode;
    void* hDevNames;
    HDC__* hDC;
    uint32_t Flags;
    uint32_t nFromPage;
    uint32_t nToPage;
    uint32_t nMinPage;
    uint32_t nMaxPage;
    uint32_t nCopies;
    HINSTANCE__* hInstance;
    int32_t lCustData;
    uint32_t* lpfnPrintHook;
    uint32_t* lpfnSetupHook;
    uint32_t* lpPrintTemplateName;
    uint32_t* lpSetupTemplateName;
    void* hPrintTemplate;
    void* hSetupTemplate;
};

struct _TRIVERTEX
{
    int32_t x;
    int32_t y;
    uint32_t Red;
    uint32_t Green;
    uint32_t Blue;
    uint32_t Alpha;
};

struct _DSFXWavesReverb
{
    float fInGain;
    float fReverbMix;
    float fReverbTime;
    float fHighFreqRTRatio;
};

struct _MEMORY_BASIC_INFORMATION
{
    void* BaseAddress;
    void* AllocationBase;
    uint32_t AllocationProtect;
    uint32_t RegionSize;
    uint32_t State;
    uint32_t Protect;
    uint32_t Type;
};

struct _OUTLINETEXTMETRICW
{
    uint32_t otmSize;
    tagTEXTMETRICW otmTextMetrics;
    uint32_t otmFiller;
    tagPANOSE otmPanoseNumber;
    uint32_t otmfsSelection;
    uint32_t otmfsType;
    int32_t otmsCharSlopeRise;
    int32_t otmsCharSlopeRun;
    int32_t otmItalicAngle;
    uint32_t otmEMSquare;
    int32_t otmAscent;
    int32_t otmDescent;
    uint32_t otmLineGap;
    uint32_t otmsCapEmHeight;
    uint32_t otmsXHeight;
    tagRECT otmrcFontBox;
    int32_t otmMacAscent;
    int32_t otmMacDescent;
    uint32_t otmMacLineGap;
    uint32_t otmusMinimumPPEM;
    tagPOINT otmptSubscriptSize;
    tagPOINT otmptSubscriptOffset;
    tagPOINT otmptSuperscriptSize;
    tagPOINT otmptSuperscriptOffset;
    uint32_t otmsStrikeoutSize;
    int32_t otmsStrikeoutPosition;
    int32_t otmsUnderscoreSize;
    int32_t otmsUnderscorePosition;
    char* otmpFamilyName;
    char* otmpFaceName;
    char* otmpStyleName;
    char* otmpFullName;
};

struct sockaddr_in
{
    int32_t sin_family;
    uint32_t sin_port;
    in_addr sin_addr;
    char sin_zero[8];
};

struct tagRemHPALETTE
{
    uint32_t cbData;
    uint32_t data[1];
};

struct CoreAnimCommandTimerStop
{
    uint32_t m_nameHash;

    CoreHash GetNameHash();
};

struct _DOCINFOA
{
    int32_t cbSize;
    char* lpszDocName;
    char* lpszOutput;
    char* lpszDatatype;
    uint32_t fwType;
};

struct tagEMRSELECTCLIPPATH
{
    tagEMR emr;
    uint32_t iMode;
};

struct MENUITEMTEMPLATEHEADER
{
    uint32_t versionNumber;
    uint32_t offset;
};

struct _CERT_ISSUER_SERIAL_NUMBER
{
    _CRYPTOAPI_BLOB Issuer;
    _CRYPTOAPI_BLOB SerialNumber;
};

struct _SYSTEM_AUDIT_CALLBACK_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t SidStart;
};

struct tagICEXYZTRIPLE
{
    tagCIEXYZ ciexyzRed;
    tagCIEXYZ ciexyzGreen;
    tagCIEXYZ ciexyzBlue;
};

struct _CMC_TAGGED_CONTENT_INFO
{
    uint32_t dwBodyPartID;
    _CRYPTOAPI_BLOB EncodedContentInfo;
};

struct _PRINTER_INFO_4A
{
    char* pPrinterName;
    char* pServerName;
    uint32_t Attributes;
};

struct ca_fixedhp
{
    int32_t value;

    void ca_fixedhp();
    ca_fixedhp& operator=();
    ca_fixedhp operator+();
    ca_fixedhp operator-();
    ca_fixedhp operator*();
    ca_fixedhp operator/();
    ca_fixedhp& operator+=();
    ca_fixedhp& operator-=();
    ca_fixedhp& operator*=();
    ca_fixedhp& operator/=();
    bool operator==();
    bool operator>=();
    bool operator>();
    bool operator<=();
    bool operator<();
    bool operator!=();
    float GetFloat();
    ca_fixedhp& SetFixed();
    uint32_t GetUInt16();
    uint32_t GetUInt32();
    ca_fixed GetFixed();
    uint32_t GetValue();
};

struct ca_fixed
{
    int32_t value;

    void ca_fixed();
    ca_fixed& operator=();
    ca_fixed operator+();
    ca_fixed operator-();
    ca_fixed operator*();
    ca_fixed operator/();
    ca_fixed& operator+=();
    ca_fixed& operator-=();
    ca_fixed& operator*=();
    ca_fixed& operator/=();
    bool operator==();
    bool operator>=();
    bool operator>();
    bool operator<=();
    bool operator<();
    bool operator!=();
    float GetFloat();
    ca_fixed& SetFixed();
    uint32_t GetUInt16();
    uint32_t GetUInt32();
    uint32_t GetValue();
};

struct _TOKEN_SOURCE
{
    char SourceName[8];
    _LUID SourceIdentifier;
};

struct IUrlMon : IUnknown
{
    HRESULT __stdcall AsyncGetClassBits();
    void IUrlMon();
};

struct CoreAnimCommandFlag
{
    enum FSFlags
    {
        FS_FLAG_SET,
    };

    uint32_t m_nameHash;
    uint32_t m_flags;

    CoreHash GetNameHash();
    uint32_t GetFlags();
    bool IsFlagSet();
};

struct _BLENDFUNCTION
{
    uint32_t BlendOp;
    uint32_t BlendFlags;
    uint32_t SourceConstantAlpha;
    uint32_t AlphaFormat;
};

struct _RPC_PROTSEQ_VECTORW
{
    uint32_t Count;
    uint32_t* Protseq[1];
};

struct _PUBKEY
{
    uint32_t magic;
    uint32_t bitlen;
};

struct _CMSG_CONTENT_ENCRYPT_INFO
{
    uint32_t cbSize;
    uint32_t hCryptProv;
    _CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
    void* pvEncryptionAuxInfo;
    uint32_t cRecipients;
    _CMSG_RECIPIENT_ENCODE_INFO* rgCmsRecipients;
    void** pfnAlloc;
    void* pfnFree;
    uint32_t dwEncryptFlags;
    uint32_t hContentEncryptKey;
    uint32_t dwFlags;
};

struct IPSFactoryBuffer : IUnknown
{
    HRESULT __stdcall CreateProxy();
    HRESULT __stdcall CreateStub();
    void IPSFactoryBuffer();
};

struct IInternetProtocolSink : IUnknown
{
    HRESULT __stdcall Switch();
    HRESULT __stdcall ReportProgress();
    HRESULT __stdcall ReportData();
    HRESULT __stdcall ReportResult();
    void IInternetProtocolSink();
};

struct IXMLElement2 : IDispatch
{
    HRESULT __stdcall get_tagName();
    HRESULT __stdcall put_tagName();
    HRESULT __stdcall get_parent();
    HRESULT __stdcall setAttribute();
    HRESULT __stdcall getAttribute();
    HRESULT __stdcall removeAttribute();
    HRESULT __stdcall get_children();
    HRESULT __stdcall get_type();
    HRESULT __stdcall get_text();
    HRESULT __stdcall put_text();
    HRESULT __stdcall addChild();
    HRESULT __stdcall removeChild();
    HRESULT __stdcall get_attributes();
    void IXMLElement2();
};

struct HUMPD__
{
    int32_t unused;
};

struct _CERT_PRIVATE_KEY_VALIDITY
{
    _FILETIME NotBefore;
    _FILETIME NotAfter;
};

struct IRpcChannelBuffer : IUnknown
{
    HRESULT __stdcall GetBuffer();
    HRESULT __stdcall SendReceive();
    HRESULT __stdcall FreeBuffer();
    HRESULT __stdcall GetDestCtx();
    HRESULT __stdcall IsConnected();
    void IRpcChannelBuffer();
};

struct _PROVIDOR_INFO_2W
{
    uint32_t* pOrder;
};

struct midiproptempo_tag
{
    uint32_t cbStruct;
    uint32_t dwTempo;
};

struct _KEY_TYPE_SUBTYPE
{
    uint32_t dwKeySpec;
    _GUID Type;
    _GUID Subtype;
};

struct _ASSEMBLY_FILE_DETAILED_INFORMATION
{
    uint32_t ulFlags;
    uint32_t ulFilenameLength;
    uint32_t ulPathLength;
    uint32_t* lpFileName;
    uint32_t* lpFilePath;
};

struct IProcessInitControl : IUnknown
{
    HRESULT __stdcall ResetInitializerTimeout();
    void IProcessInitControl();
};

struct CoreAIController
{
    // TODO vtable

    void CoreAIController();
    void ~CoreAIController();
    void Construct(CoreMemory*);
    void Destruct(CoreMemory*);
    void Init(CoreObjectUpdateStruct*);
    void Reset();
    void UnLoad();
    void Update(CoreObjectUpdateStruct*);
    void DoDebug(CoreDebugInput*);
};

struct CoreViewObject : CoreCameraObject
{
    enum CameraTransitionType
    {
        CameraTransitionTypeNull,
        CameraTransitionTypeLinear,
        CameraTransitionTypeSmooth,
    };

    enum CoreViewObjectBlendMode
    {
        CoreViewObjectBlendModeLinear,
        CoreViewObjectBlendModeCatchUp,
        CoreViewObjectBlendModePolar,
    };

    CoreCameraObject* m_internalCopy;
    CoreCameraObject* m_defaultCamera;
    CoreCameraObject* m_camera;
    CoreCameraObject* m_fromCamera;
    float m_blendTimer;
    float m_blendTimerMax;
    bool m_debugSwitch;
    bool m_disableAllCameraSwitches;
    CoreCameraEffect m_cameraEffect;
    CoreVector m_blendFromPos;
    CoreHash m_newCameraHash;
    bool m_popCameraFlag;
    float m_cameraTransitionTime;
    CoreViewObject::CameraTransitionType m_cameraTransitionType;
    bool m_firstUpdateInBlend;
    int32_t m_numCamerasAttached;
    CoreCameraObject* m_cameraAttachedList[64];
    CoreVector m_initialBlendPosFrom;
    CoreVector m_initialBlendPosTo;
    bool m_lookAtCatchupFlag;
    CoreViewObject::CoreViewObjectBlendMode m_blendMode;
    bool m_cameraDirectFlag;
    CoreS128Aligned m_memoryPot[512];

    void CoreViewObject();
    void ~CoreViewObject();
    void Construct();
    void Init();
    void DoDebug();
    void SetDefaultCamera();
    CoreCameraObject* GetDefaultCamera();
    void SetCamera();
    CoreCameraObject* GetCamera();
    CoreCameraObject* GetFromCamera();
    bool IsDebugModeSet();
    CoreObject* Create();
    CoreHash GetTypeID();
    void SetLookAtCatchupMode();
    bool GetLookAtCatchupMode();
    void SetDisableAllCameraSwitches();
    bool GetDisableAllCameraSwitches();
    void* GetVariablePointer();
    CoreScripted::CommandReturn RunFunction();
    void DebugUpdate();
    CoreScripted::CommandReturn FnDefaultCameraLogic();
    CoreScripted::CommandReturn FnSetCamera();
    CoreScripted::CommandReturn FnPopCamera();
    void ApplyCameraEffect();
    CoreScripted::CommandReturn FnSetTransition();
    void AddCamera();
    void SetBlendMode();
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
};

struct CoreS64Union
{
    int32_t long_data;
    uint32_t int_data[2];
};

struct CoreFileDevice
{
    enum CoreFileDeviceAsyncState
    {
        ASYNC_AFTER_CLOSE,
        ASYNC_IDLE,
        ASYNC_BEFORE_OPEN,
        ASYNC_IN_OPEN,
        ASYNC_OPEN_DONE,
        ASYNC_IN_SEEK,
        ASYNC_SEEK_DONE,
        ASYNC_IN_READ,
        ASYNC_READ_DONE,
        ASYNC_IN_CLOSE,
        ASYNC_CLOSE_DONE,
        ASYNC_ERROR,
        ASYNC_ERROR_FILENAME_TOO_LONG,
        ASYNC_ERROR_SYNC_ACTIVE,
        ASYNC_ERROR_NOT_IDLE,
        ASYNC_ERROR_FILEHANDLE,
        ASYNC_ERROR_NUMREADBYTES,
        ASYNC_ERROR_READDEST,
        ASYNC_ERROR_FILENAMEHASH,
        ASYNC_ERROR_FILENAME,
        ASYNC_ERROR_WRONG_FILENAME,
        ASYNC_ERROR_DURING_OPEN,
        ASYNC_ERROR_DURING_SEEK,
        ASYNC_ERROR_DURING_READ,
        ASYNC_ERROR_DURING_CLOSE,
    };

    enum CoreFileSeekOrigin
    {
        CURRENT_POS,
        START_OF_FILE,
        END_OF_FILE,
    };

    enum CoreFileDeviceFlagsBits
    {
        COREFILEDEVICE_ASYNC,
    };

    CoreFileHandle m_asyncFileHandle;
    CoreStringBuffer<256> m_asyncFileName;
    CoreHash m_asyncFileNameHash;
    int32_t m_asyncNumberOfBytesToRead;
    float m_asyncTime;
    int32_t m_asyncStartByteOffsetToRead;
    void* m_asyncReadDestination;
    CoreFileDevice::CoreFileDeviceAsyncState m_asyncState;
    CoreStringBuffer<256> m_asyncLastFileName;
    int32_t m_asyncLastNumberOfBytesRead;
    float m_asyncLastByteTransferRate;
    float m_asyncLastReadTime;
    static float* s_GetElapsedTimeFunc;

    // TODO vtable

    void CoreFileDevice();
    void ~CoreFileDevice();
    void Construct();
    void Destruct();
    void Init();
    CoreFileHandle Open();
    bool Close();
    int32_t Read();
    bool Seek();
    bool AsyncFinished();
    int32_t Write();
    int32_t FileSize();
    bool GetFileTimes();
    bool SetFileTimes();
    bool DoesFileExist();
    bool IsReadOnly();
    bool ChangeReadOnly();
    CoreFileDevice::CoreFileDeviceAsyncState GetAsyncState();
    bool IsErrorAsyncState(CoreFileDevice::CoreFileDeviceAsyncState i_state);
    CoreFileDevice::CoreFileDeviceAsyncState AsyncUpdate();
    CoreFileDevice::CoreFileDeviceAsyncState AsyncStartLoadFile(char* i_name, int32_t iStartOffset, int32_t i_size, void* i_dest);
    CoreFileDevice::CoreFileDeviceAsyncState AsyncEndLoadFile(char* i_name);
    void SetAsyncState();
    void ResetAsyncError();
    char* GetCurrentAsyncState();
    CoreHash GetAsyncFileNameHash();
    char* GetAsyncFileName();
    int32_t GetLastAsyncTransferRateKB();
    char* GetLastAsyncFileName();
    int32_t GetLastAsyncFileSizeKB();
    int32_t GetLastAsyncReadTimeMS();
    void SetGetElapsedTimeFunc();
    float GetElapsedTime();
    void* GetAsyncReadDestination();
    int32_t GetAsyncNumberOfBytesToRead();
    int32_t GetAsyncStartByteOffsetToRead();
    void SetAsyncFileNameHash(CoreHash i_hash);
    void SetAsyncFileName(char* i_fileName);
    void ClearAsyncFileName();
};

struct tagEMR
{
    uint32_t iType;
    uint32_t nSize;
};

struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    tagEMR emr;
    uint32_t ihBrush;
    uint32_t iUsage;
    uint32_t offBmi;
    uint32_t cbBmi;
    uint32_t offBits;
    uint32_t cbBits;
};

struct _CHANGER_ELEMENT_STATUS_EX
{
    _CHANGER_ELEMENT Element;
    _CHANGER_ELEMENT SrcElementAddress;
    uint32_t Flags;
    uint32_t ExceptionCode;
    uint32_t TargetId;
    uint32_t Lun;
    uint32_t Reserved;
    uint32_t PrimaryVolumeID[36];
    uint32_t AlternateVolumeID[36];
    uint32_t VendorIdentification[8];
    uint32_t ProductIdentification[16];
    uint32_t SerialNumber[32];
};

struct tagRemSTGMEDIUM
{
    uint32_t tymed;
    uint32_t dwHandleType;
    uint32_t pData;
    uint32_t pUnkForRelease;
    uint32_t cbData;
    uint32_t data[1];
};

struct SC_HANDLE__
{
    int32_t unused;
};

struct _DSBPOSITIONNOTIFY
{
    uint32_t dwOffset;
    void* hEventNotify;
};

struct IDirectSoundNotify : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetNotificationPositions();
    void IDirectSoundNotify();
};

struct CoreMeshGroupPSP
{
    uint32_t m_uiNumMeshes;
    int32_t m_iModelMeshIndexTable[1];

    void CoreMeshGroupPSP();
    void ~CoreMeshGroupPSP();
    CoreModelMesh* GetModelMeshPtr();
    uint32_t GetNumMeshes();
    int32_t* GetModelMeshIndexTable();
};

struct CoreModelMesh
{
    int32_t m_iGeometryOffset;
    int32_t m_sType;
    int32_t m_sJointIndex;
    int32_t m_sMatrixPaletteIndex;
    int32_t m_sNumBlendShapeBaseTriangles;
    int32_t m_sNumBlendShapeTargets;
    int32_t m_sBlendShapeSkeletonIndex;

    void CoreModelMesh();
    void ~CoreModelMesh();
    CoreGeometryTypes::CoreGeometryTypeEnum GetType();
    int32_t GetMatrixPaletteIndex();
    int32_t GetJointIndex();
    int32_t GetNumBlendShapeBaseTriangles();
    int32_t GetNumBlendShapeTargets();
    int32_t GetBlendShapeSkeletonIndex();
    CoreGeometryCompiled* GetGeometryCompiledPtr();
    CoreGeometryCompiledPC* GetGeometryCompiledPCPtr();
    CoreGeometryCompiledPS* GetGeometryCompiledPSPtr();
};

struct tagPOINTS
{
    int32_t x;
    int32_t y;
};

struct _DRIVER_INFO_5W
{
    uint32_t cVersion;
    uint32_t* pName;
    uint32_t* pEnvironment;
    uint32_t* pDriverPath;
    uint32_t* pDataFile;
    uint32_t* pConfigFile;
    uint32_t dwDriverAttributes;
    uint32_t dwConfigVersion;
    uint32_t dwDriverVersion;
};

struct _DSFXParamEq
{
    float fCenter;
    float fBandwidth;
    float fGain;
};

struct dolbyac2waveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t nAuxBitsCode;
};

struct tagPOINTFX
{
    _FIXED x;
    _FIXED y;
};

struct _PROV_ENUMALGS_EX
{
    uint32_t aiAlgid;
    uint32_t dwDefaultLen;
    uint32_t dwMinLen;
    uint32_t dwMaxLen;
    uint32_t dwProtocols;
    uint32_t dwNameLen;
    char szName[20];
    uint32_t dwLongNameLen;
    char szLongName[40];
};

struct _CERT_X942_DH_PARAMETERS
{
    _CRYPTOAPI_BLOB p;
    _CRYPTOAPI_BLOB g;
    _CRYPTOAPI_BLOB q;
    _CRYPTOAPI_BLOB j;
    _CERT_X942_DH_VALIDATION_PARAMS* pValidationParams;
};

struct _SET_PARTITION_INFORMATION
{
    uint32_t PartitionType;
};

struct IOleInPlaceActiveObject : IOleWindow
{
    HRESULT __stdcall TranslateAcceleratorA();
    HRESULT __stdcall OnFrameWindowActivate();
    HRESULT __stdcall OnDocWindowActivate();
    HRESULT __stdcall ResizeBorder();
    HRESULT __stdcall EnableModeless();
    void IOleInPlaceActiveObject();
};

struct CoreArray<CoreArg>
{
    CoreArg* m_lpoContents;
    int32_t m_iAllocSize;
    int32_t m_iArraySize;
    bool m_allowResize;
    int32_t m_startAllocSize;

    void CoreArray<CoreArg>();
    void SetAllowResize();
    void ~CoreArray<CoreArg>();
    int32_t GetSize();
    void Insert();
    void Remove();
    void operator+=();
    bool CanFit();
    void Reset();
    void SetSize();
    void Resize();
    CoreArg* operator const struct CoreArg *();
    CoreArg* operator struct CoreArg *();
    CoreArg& GetElement();
    CoreArg* GetArray();
    bool operator==();
    bool operator!=();
    CoreArg& operator[]();
};

struct CoreArg
{
    CoreString oName;
    CoreString oDesc;
    CoreString oParam;
    bool IsSet;
    bool bRequiresParam;

    void CoreArg();
    void ~CoreArg();
};

struct _COMMPROP
{
    uint32_t wPacketLength;
    uint32_t wPacketVersion;
    uint32_t dwServiceMask;
    uint32_t dwReserved1;
    uint32_t dwMaxTxQueue;
    uint32_t dwMaxRxQueue;
    uint32_t dwMaxBaud;
    uint32_t dwProvSubType;
    uint32_t dwProvCapabilities;
    uint32_t dwSettableParams;
    uint32_t dwSettableBaud;
    uint32_t wSettableData;
    uint32_t wSettableStopParity;
    uint32_t dwCurrentTxQueue;
    uint32_t dwCurrentRxQueue;
    uint32_t dwProvSpec1;
    uint32_t dwProvSpec2;
    uint32_t wcProvChar[1];
};

struct CoreTimingMilliSeconds
{
    int32_t m_start64;
    int32_t m_timeOut64;

    void CoreTimingMilliSeconds();
    int32_t Get64();
    uint32_t Get();
    void Start();
    int32_t GetTaken64();
    uint32_t GetTaken();
    void StartTimeOut64();
    void StartTimeOut();
    bool HasTimedOut();
    void Sync();
    void Wait64();
    void Wait();
};

struct tagPAINTSTRUCT
{
    HDC__* hdc;
    int32_t fErase;
    tagRECT rcPaint;
    int32_t fRestore;
    int32_t fIncUpdate;
    uint32_t rgbReserved[32];
};

struct _DISCDLGSTRUCTA
{
    uint32_t cbStructure;
    HWND* hwndOwner;
    char* lpLocalName;
    char* lpRemoteName;
    uint32_t dwFlags;
};

struct CorePS2BuildSystemFileDevice : CoreBuildSystemInterfaceUsingNamedPipe
{
    bool CompleteTheFileName();
    void CorePS2BuildSystemFileDevice();
    void ~CorePS2BuildSystemFileDevice();
};

struct _DCB
{
    uint32_t DCBlength;
    uint32_t BaudRate;
    uint32_t fBinary : 1;
    uint32_t fParity : 1;
    uint32_t fOutxCtsFlow : 1;
    uint32_t fOutxDsrFlow : 1;
    uint32_t fDtrControl : 2;
    uint32_t fDsrSensitivity : 1;
    uint32_t fTXContinueOnXoff : 1;
    uint32_t fOutX : 1;
    uint32_t fInX : 1;
    uint32_t fErrorChar : 1;
    uint32_t fNull : 1;
    uint32_t fRtsControl : 2;
    uint32_t fAbortOnError : 1;
    uint32_t fDummy2 : 17;
    uint32_t wReserved;
    uint32_t XonLim;
    uint32_t XoffLim;
    uint32_t ByteSize;
    uint32_t Parity;
    uint32_t StopBits;
    char XonChar;
    char XoffChar;
    char ErrorChar;
    char EofChar;
    char EvtChar;
    uint32_t wReserved1;
};

struct yamaha_adpmcwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct _SINGLE_LIST_ENTRY
{
    _SINGLE_LIST_ENTRY* Next;
};

struct _SYSTEM_ALARM_OBJECT_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t Flags;
    _GUID ObjectType;
    _GUID InheritedObjectType;
    uint32_t SidStart;
};

struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t Flags;
    _GUID ObjectType;
    _GUID InheritedObjectType;
    uint32_t SidStart;
};

struct tagEMREXCLUDECLIPRECT
{
    tagEMR emr;
    _RECTL rclClip;
};

struct _CRYPT_ASYNC_RETRIEVAL_COMPLETION
{
    void* pfnCompletion;
    void* pvCompletion;
};

struct WAVEFORMATEXTENSIBLE
{
    tWAVEFORMATEX Format;
    WAVEFORMATEXTENSIBLE::__unnamed Samples;
    uint32_t dwChannelMask;
    _GUID SubFormat;
};

struct CAL1_LevelManager
{
    CAL0_AudioWadManager m_LevelWad;
    CAL1_AudioDriver* m_AD;
    CAL1_AudioItemDatabase* m_AID;
    char* m_LevelPath;
    uint32_t m_LevelFileOffset;
    uint32_t m_LanguageMask;
    char* m_GlobalSceneName;
    CAL1_SceneData** m_SceneTable;
    int32_t m_MaxScenes;
    bool m_GlobalLevel;
    uint32_t m_LevelSRAMPtr;

    void CAL1_LevelManager();
    void ~CAL1_LevelManager();
    CAAudioError LoadLevel(char* levelPath, char* globalSceneName, uint32_t fileOffset, uint32_t languageMask);
    CAAudioError UnloadLevel();
    CAAudioError LoadScene(char* sceneName, uint32_t languageMask, char* levelPath, uint32_t offset);
    CAAudioError UnloadScene(int32_t sceneIndex);
    CAAudioError Destroy();
    CAAudioError Initialise();
};

struct tagEMRSETDIBITSTODEVICE
{
    tagEMR emr;
    _RECTL rclBounds;
    int32_t xDest;
    int32_t yDest;
    int32_t xSrc;
    int32_t ySrc;
    int32_t cxSrc;
    int32_t cySrc;
    uint32_t offBmiSrc;
    uint32_t cbBmiSrc;
    uint32_t offBitsSrc;
    uint32_t cbBitsSrc;
    uint32_t iUsageSrc;
    uint32_t iStartScan;
    uint32_t cScans;
};

struct _NAME_BUFFER
{
    uint32_t name[16];
    uint32_t name_num;
    uint32_t name_flags;
};

struct _SCHANNEL_ALG
{
    uint32_t dwUse;
    uint32_t Algid;
    uint32_t cBits;
    uint32_t dwFlags;
    uint32_t dwReserved;
};

struct _RPC_SECURITY_QOS_V3_W
{
    uint32_t Version;
    uint32_t Capabilities;
    uint32_t IdentityTracking;
    uint32_t ImpersonationType;
    uint32_t AdditionalSecurityInfoType;
    _RPC_SECURITY_QOS_V3_W::__unnamed u;
    void* Sid;
};

struct _CMSG_ENCRYPTED_ENCODE_INFO
{
    uint32_t cbSize;
    _CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
    void* pvEncryptionAuxInfo;
};

struct _PARTITION_INFORMATION
{
    _LARGE_INTEGER StartingOffset;
    _LARGE_INTEGER PartitionLength;
    uint32_t HiddenSectors;
    uint32_t PartitionNumber;
    uint32_t PartitionType;
    uint32_t BootIndicator;
    uint32_t RecognizedPartition;
    uint32_t RewritePartition;
};

struct tagEXCEPINFO
{
    uint32_t wCode;
    uint32_t wReserved;
    uint32_t* bstrSource;
    uint32_t* bstrDescription;
    uint32_t* bstrHelpFile;
    uint32_t dwHelpContext;
    void* pvReserved;
    HRESULT* pfnDeferredFillIn;
    int32_t scode;
};

struct _WIN32_FIND_DATAW
{
    uint32_t dwFileAttributes;
    _FILETIME ftCreationTime;
    _FILETIME ftLastAccessTime;
    _FILETIME ftLastWriteTime;
    uint32_t nFileSizeHigh;
    uint32_t nFileSizeLow;
    uint32_t dwReserved0;
    uint32_t dwReserved1;
    uint32_t cFileName[260];
    uint32_t cAlternateFileName[14];
};

struct _RTL_VERIFIER_DLL_DESCRIPTOR
{
    uint32_t* DllName;
    uint32_t DllFlags;
    void* DllAddress;
    _RTL_VERIFIER_THUNK_DESCRIPTOR* DllThunks;
};

struct _GRADIENT_TRIANGLE
{
    uint32_t Vertex1;
    uint32_t Vertex2;
    uint32_t Vertex3;
};

struct tagMCI_VD_ESCAPE_PARMSW
{
    uint32_t dwCallback;
    uint32_t* lpstrCommand;
};

struct _MODEMSETTINGS
{
    uint32_t dwActualSize;
    uint32_t dwRequiredSize;
    uint32_t dwDevSpecificOffset;
    uint32_t dwDevSpecificSize;
    uint32_t dwCallSetupFailTimer;
    uint32_t dwInactivityTimeout;
    uint32_t dwSpeakerVolume;
    uint32_t dwSpeakerMode;
    uint32_t dwPreferredModemOptions;
    uint32_t dwNegotiatedModemOptions;
    uint32_t dwNegotiatedDCERate;
    uint32_t abVariablePortion[1];
};

struct CoreCollidables
{
    uint32_t ucNumCollidables;
    uint32_t ucPadding;
    uint32_t usPadding;
    CoreSingleCollidable* lpoCollidableArray;
};

struct _DRIVER_INFO_4W
{
    uint32_t cVersion;
    uint32_t* pName;
    uint32_t* pEnvironment;
    uint32_t* pDriverPath;
    uint32_t* pDataFile;
    uint32_t* pConfigFile;
    uint32_t* pHelpFile;
    uint32_t* pDependentFiles;
    uint32_t* pMonitorName;
    uint32_t* pDefaultDataType;
    uint32_t* pszzPreviousNames;
};

struct CoreMemorySkipList
{
    static float fGoodProbability;
    CoreMemorySkipListElement* m_First;
    CoreMemorySkipListElement* m_Last;
    int32_t m_Size;
    int32_t m_MaxLevel;
    int32_t m_Level;
    float m_Probability;

    void CoreMemorySkipList();
    void ~CoreMemorySkipList();
    void Clear();
    CoreMemorySkipListElement* Begin();
    CoreMemorySkipListElement* End();
    CoreMemorySkipListElement* Find();
    void Insert();
    void Remove();
    int32_t Size();
    bool Empty();
    void Init();
    int32_t GenerateRandomLevel();
};

struct CoreClusterFileSystem : CoreFileSystem
{
    CoreCluster* m_currentCluster;
    int32_t m_currentClusterNumber;
    char m_currentClusterName[256];
    uint32_t m_currentClusterHash;
    bool m_loadingRawFile;
    bool m_asyncLoadingRawFile;
    uint32_t m_currentFileHash;
    CoreCluster m_clusters[8];
    static CoreQWORD m_memoryBuffer[4608];

    void CoreClusterFileSystem();
    void ~CoreClusterFileSystem();
    void Construct(CoreMemory*);
    void Destruct(CoreMemory*);
    void Init(int32_t i_maxNumberOfOpenFiles);
    CoreFileHandle Open(char* i_name, CoreFileOpenAttributes& i_attrib);
    bool Close(CoreFileHandle& i_handle);
    int32_t Read(CoreFileHandle& i_handle, void* i_dest, int32_t i_size);
    int32_t Write(CoreFileHandle& i_handle, void* i_src, int32_t i_size);
    bool Seek(CoreFileHandle& i_handle, int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin);
    int32_t FileSize(char* i_name);
    int32_t FileOffset(char* i_name);
    bool GetFileTimes(char* i_fileName, CoreDateTime* o_creationTime, CoreDateTime* o_lastAccessTime, CoreDateTime* o_lastWriteTime);
    bool SetFileTimes(char* i_fileName, CoreDateTime* i_creationTime, CoreDateTime* i_lastAccessTime, CoreDateTime* i_lastWriteTime);
    bool DoesFileExist(char* i_fileName);
    bool IsReadOnly(char* i_fileName);
    bool ChangeReadOnly(char* i_fileName, bool i_readOnly, bool* o_changed);
    CoreFileSystem::CoreFileSystemAsyncState AsyncStartLoadFile(char* i_name, int32_t i_startOffset, int32_t i_size, void* i_dest);
    CoreFileSystem::CoreFileSystemAsyncState AsyncUpdate();
    CoreFileSystem::CoreFileSystemAsyncState AsyncEndLoadFile(char* i_name);
    void SetFileDevice(CoreFileDevice* i_fileDevice);
    bool OpenCluster(char* i_clusterName, uint32_t i_flags);
    bool CloseCluster(int32_t i_number, uint32_t);
    void SetLoadingRawFile();
    char* GetCurrentClusterName();
    void ComputeMemoryUsage(uint32_t& o_minUsedMemory, uint32_t& o_maxUsedMemory);
    CoreCluster* FindCluster();
    CoreCluster* SetCurrentCluster(char* i_clusterName);
    CoreCluster* FindFirstActiveCluster();
    CoreCluster* FindFirstFreeCluster();
    bool GenericOpen(char* i_name, CoreFileOpenAttributes& i_attrib);
    bool GenericClose(CoreFileHandle& i_handle);
    bool GenericFileCheck(uint32_t i_fileHash);
};

struct CAL1_API
{
    bool m_Initialised;
    uint32_t m_NumChannels;
    uint32_t m_NumEffects;
    uint32_t m_NumStreams;
    uint32_t m_MasterVolume;
    uint32_t m_HeapSize;
    uint32_t m_NumDBItems;
    uint32_t m_CreationFlags;
    uint32_t m_MaxInstances;
    bool m_UseSysMemory;
    void* m_Address;
    CAL1_AudioDriver* m_AD;
    CAL1_AudioItemDatabase* m_AID;
    CAL1_LevelManager* m_LevelManager;
    CAL1_LevelManager* m_GlobalLevelManager;
    CAL1_InstanceTable* m_InstanceTable;
    CAL1_AudioData m_AudioData;
    CAL1_AudioListener m_Listener;
    uint32_t m_GlobalReverbID;
    CAL0_API* m_CAL0API;

    // TODO vtable

    void CAL1_API();
    void ~CAL1_API();
    CAAudioError Reset();
    CAAudioError Destroy();
    CAAudioError StartAudioItem(uint32_t audioID, uint32_t instance);
    CAAudioError StartAudioItemParam(uint32_t audioID, uint32_t instance, uint32_t param);
    CAAudioError UpdateAudioItem(uint32_t audioID, uint32_t instance);
    CAAudioError TriggerAudioItem(uint32_t audioID, uint32_t instance);
    CAAudioError StopAudioItem(uint32_t audioID, uint32_t instance);
    bool IsAudioItemPlaying(uint32_t audioID, uint32_t instance);
    CAAudioError StartObjectEvent(uint32_t objectID, uint32_t instance, uint32_t eventID);
    CAAudioError StartObjectEventParam(uint32_t objectID, uint32_t instance, uint32_t eventID, uint32_t param);
    CAAudioError UpdateObjectEvent(uint32_t objectID, uint32_t instance, uint32_t eventID);
    CAAudioError TriggerObjectEvent(uint32_t objectID, uint32_t instance, uint32_t eventID);
    CAAudioError StopObjectEvent(uint32_t objectID, uint32_t instance, uint32_t eventID);
    bool IsObjectEventPlaying(uint32_t objectID, uint32_t instance, uint32_t eventID);
    CAAudioError UpdateObject(uint32_t objectID, uint32_t instance);
    CAAudioError SetAudioData(CAL1_AudioData* audioData);
    void ResetAudioData();
    void SetAudioData_DataMask(uint32_t dataMask);
    void SetAudioData_3D(bool is3D);
    void SetAudioData_CameraRelative();
    void SetAudioData_FrequencyOffset();
    void SetAudiOData_FRPan();
    void SetAudioData_GroupMask(uint32_t groupMask);
    void SetAudioData_ListenerIndex();
    void SetAudioData_LRPan();
    void SetAudioData_MaxDist();
    void SetAudioData_MinDist();
    void SetAudioData_Occlusion();
    void SetAudioData_PlaybackPreference();
    void SetAudioData_Point(ca_3DPoint point);
    void SetAudioData_Velocity(ca_3DVelocity velocity);
    void SetAudioData_VolumeOffset(uint32_t volumeOffset);
    void SetListener();
    void SetListenerPosition();
    void SetListenerOrientation();
    void SetListenerVelocity();
    void SetMasterVolume();
    CAAudioError FrameEnd();
    void StopAll();
    void Pause();
    void UnPause();
    void DisconnectHardware();
    void ReconnectHardware();
    bool IsHardwareConnected();
    CAAudioError LoadProgram(char* filename, uint32_t offset);
    CAAudioError LoadSRAM(char* filename, uint32_t offset);
    CAAudioError LoadStream(char* filename, uint32_t offset, uint32_t languageMask);
    CAAudioError LoadAudioWad(char* filename, uint32_t offset, char* levelName, uint32_t languageMask);
    CAAudioError LoadLevel(char* globalFileName, uint32_t globalOffset, char* globalLevelName, uint32_t globalLanguageMask, char* filename, uint32_t offset, char* levelName, uint32_t languageMask);
    CAAudioError LoadLevelScene(char* sceneName, uint32_t languageMask);
    CAAudioError MarkCurrentArea();
    CAAudioError ResetCurrentArea();
    CAAudioError UnloadLevelScene(char* sceneName);
    CAAudioError UnloadLevel();
    void SetHeapLogging();
    void SetMemoryLogging();
    CAL1_AudioDriver* GetAD();
    CAL1_AudioItemDatabase* GetAID();
    CAL1_LevelManager* GetLM();
    CAL1_LevelManager* GetGlobalLM();
    CAL1_InstanceTable* GetInstanceTable();
    CAL1_AudioItem* GetAudioItemFromDB();
    CAL1_AudioPlayback* GetPlaybackItemFromDB();
    void SetGlobalReverb(uint32_t reverbID);
    uint32_t GetVersionNumber();
    CAAudioError CreateInstance(uint32_t itemID, uint32_t& instance);
    uint32_t GetNumInstances();
    void DebugShowStats();
    void SetGroupVolume(uint32_t iGroupIndex, uint32_t iVolume);
    uint32_t GetGroupVolume(uint32_t iGroupIndex);
    CAAudioError Initialise(uint32_t i_heapSize, void* i_address, bool i_useSysMemory, uint32_t i_numChannels, uint32_t i_numStreams, uint32_t i_numEffects, uint32_t i_numDBItems, uint32_t i_creationFlags, uint32_t i_maxInstances);
    CAAudioError CreatePlatformObjects();
    CAAudioError DestroyPlatformObjects();
    CAAudioError ResetPlatformObjects();
    CAAudioError CreateNonPlatformObjects();
    CAAudioError DestroyNonPlatformObjects();
    CAAudioError ResetNonPlatformObjects();
};

struct _BIDI_RESPONSE_DATA
{
    uint32_t dwResult;
    uint32_t dwReqNumber;
    uint32_t* pSchema;
    _BIDI_DATA data;
};

struct tagMIDIOUTCAPS2A
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t wTechnology;
    uint32_t wVoices;
    uint32_t wNotes;
    uint32_t wChannelMask;
    uint32_t dwSupport;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct _CERT_REVOCATION_PARA
{
    uint32_t cbSize;
    _CERT_CONTEXT* pIssuerCert;
    uint32_t cCertStore;
    void** rgCertStore;
    void* hCrlStore;
    _FILETIME* pftTimeToUse;
};

struct _NDR_CS_SIZE_CONVERT_ROUTINES
{
    void* pfnNetSize;
    void* pfnToNetCs;
    void* pfnLocalSize;
    void* pfnFromNetCs;
};

struct _DISK_RECORD
{
    _LARGE_INTEGER ByteOffset;
    _LARGE_INTEGER StartTime;
    _LARGE_INTEGER EndTime;
    void* VirtualAddress;
    uint32_t NumberOfBytes;
    uint32_t DeviceNumber;
    uint32_t ReadRequest;
};

struct _CMSG_CTRL_DECRYPT_PARA
{
    uint32_t cbSize;
    uint32_t hCryptProv;
    uint32_t dwKeySpec;
    uint32_t dwRecipientIndex;
};

struct CorePacketTypes
{
    enum CorePacketTypesEnum
    {
        PACKET_NO_UVS = 262144,
        PACKET_NO_NORMALS = 524288,
        PACKET_NO_VERTEXCOLOURS = 131072,
        TRIANGLE = 1,
        TRIANGLESTRIP = 2,
        LINESTRIP = 8,
        ALPHA_BLENDED = 16,
        FLAT_SHADED = 32,
        STATIC_MESH = 64,
        PARENTED_MESH = 128,
        HARDSKINNED_MESH = 256,
        SOFTSKINNED_MESH = 512,
        BLENDSHAPE_MESH = 1024,
        SHADOW_MESH = 2048,
        VOLUMES_MESH = 4096,
        ENVMAP_MESH = 8192,
        PACKET_NOT_HARDSKINNED = 1048576,
        PACKET_NOT_SOFTSKINNED = 2097152,
        PACKET_NOT_BLENDSHAPE = 4194304,
        XYZ32 = 8257537,
        XYZ32RGBA8 = 8126497,
        XYZ32UV16 = 7995521,
        XYZ32UV16RGBA8 = 7864481,
        XYZ32UV16NXYZ8RGBA8 = 7342241,
        HSI8XYZ32 = 7217153,
        HSI8XYZ32UV16 = 6955137,
        HSI8XYZ32RGBA8 = 7086113,
        HSI8XYZ32UV16RGBA8 = 6824097,
        SSW20I12XYZ32 = 6176769,
        SSW20I12XYZ32RGBA8 = 6045729,
        SSW20I12XYZ32UV16 = 5914753,
        SSW20I12XYZ32UV16RGBA8 = 5783713,
        BST16XYZ32 = 4067329,
        BST16XYZ32RGBA8 = 3936289,
        BST16XYZ32UV16 = 3805313,
        BST16XYZ32UV16RGBA8 = 3674273,
        XYZ32NXYZ8 = 7735297,
        XYZ32NXYZ8RGBA8 = 7604257,
        XYZ32UV16NXYZ8 = 7473281,
        HSI8XYZ32NXYZ8 = 6694913,
        HSI8XYZ32UV16NXYZ8 = 6432897,
        SSW20I12XYZ32NXYZ8 = 5654529,
        SSW20I12XYZ32UV16NXYZ8 = 5392513,
        BST16XYZ32NXYZ8 = 3545089,
        BST16XYZ32UV16NXYZ8 = 3283073,
        SDWXYZ32NXYZ8 = 7735313,
        SDWHSI8XYZ32NXYZ8 = 6694929,
        VOLXYZ32 = 8257545,
    };

    // TODO vtable

    void YouCannotInstanceThisClass();
    void CorePacketTypes();
};

struct _IMAGE_ROM_HEADERS
{
    _IMAGE_FILE_HEADER FileHeader;
    _IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
};

struct tagSCROLLBARINFO
{
    uint32_t cbSize;
    tagRECT rcScrollBar;
    int32_t dxyLineButton;
    int32_t xyThumbTop;
    int32_t xyThumbBottom;
    int32_t reserved;
    uint32_t rgstate[6];
};

struct tagMCI_WAVE_SET_PARMS
{
    uint32_t dwCallback;
    uint32_t dwTimeFormat;
    uint32_t dwAudio;
    uint32_t wInput;
    uint32_t wOutput;
    uint32_t wFormatTag;
    uint32_t wReserved2;
    uint32_t nChannels;
    uint32_t wReserved3;
    uint32_t nSamplesPerSec;
    uint32_t nAvgBytesPerSec;
    uint32_t nBlockAlign;
    uint32_t wReserved4;
    uint32_t wBitsPerSample;
    uint32_t wReserved5;
};

struct _HISTOGRAM_BUCKET
{
    uint32_t Reads;
    uint32_t Writes;
};

struct _IMAGE_DEBUG_DIRECTORY
{
    uint32_t Characteristics;
    uint32_t TimeDateStamp;
    uint32_t MajorVersion;
    uint32_t MinorVersion;
    uint32_t Type;
    uint32_t SizeOfData;
    uint32_t AddressOfRawData;
    uint32_t PointerToRawData;
};

struct tagLOGFONTA
{
    int32_t lfHeight;
    int32_t lfWidth;
    int32_t lfEscapement;
    int32_t lfOrientation;
    int32_t lfWeight;
    uint32_t lfItalic;
    uint32_t lfUnderline;
    uint32_t lfStrikeOut;
    uint32_t lfCharSet;
    uint32_t lfOutPrecision;
    uint32_t lfClipPrecision;
    uint32_t lfQuality;
    uint32_t lfPitchAndFamily;
    char lfFaceName[32];
};

struct HMIDIIN__
{
    int32_t unused;
};

struct _CRYPT_ATTRIBUTE_TYPE_VALUE
{
    char* pszObjId;
    _CRYPTOAPI_BLOB Value;
};

struct _STORAGE_BUS_RESET_REQUEST
{
    uint32_t PathId;
};

struct g723_adpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t cbExtraSize;
    uint32_t nAuxBlockSize;
};

struct _TOKEN_USER
{
    _SID_AND_ATTRIBUTES User;
};

struct _CMSG_RECIPIENT_ENCODE_INFO
{
    uint32_t dwRecipientChoice;
    _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO* pKeyTrans;
    _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO* pKeyAgree;
    _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO* pMailList;
};

struct tagVARDESC
{
    int32_t memid;
    uint32_t* lpstrSchema;
    uint32_t oInst;
    tagVARIANT* lpvarValue;
    tagELEMDESC elemdescVar;
    uint32_t wVarFlags;
    tagVARKIND varkind;
};

struct CoreDetectionData
{
    enum
    {
        VERSION = 18,
        ALL_COLLISION = 0,
        ROOM_BBOX = 1,
        ZONES = 2,
    };

    static CoreRTreeParams m_rtreeParams;
    int32_t m_iCollidablesBoundingSpheresOffset;
    int32_t m_iCollidablesOffset;
    int32_t m_engineDatasOffset;
    int32_t m_engineDatasBoundingSpheresOffset;
    int32_t m_rtreeOffsetTableOffset;
    int32_t m_detectionMeshOffset;
    uint32_t m_numCollidables;
    uint32_t m_numEngineDatas;
    uint32_t m_numRTrees;

    void CoreDetectionData();
    void ~CoreDetectionData();
    int32_t GetNumCollidables();
    uint32_t GetNumEngineDatas();
    CoreVector* lpGetCollidablesBoundingSpherePtr();
    CoreVector GetCollidableBoundingSphere();
    CoreModelCollidable* GetCollidablePtr();
    CoreDetectionMesh* GetDetectionMesh();
    CoreDetectionEngineData* GetEngineDatasPtr();
    CoreVector* GetEngineDatasBoundingSpherePtr();
    int32_t* GetIndexListFromRTree(CoreVector& tMin, CoreVector& tMax, int32_t type, int32_t* buffer, int32_t buffMax);
    int32_t GetIndexListFromRTreeByRoom(CoreVector& tMin, CoreVector& tMax, int32_t type, uint32_t i_room, int32_t* buffer, int32_t buffMax);
    int32_t GetIntersectingRecords();
    int32_t GetLeafRecords();
    int32_t* GetInViewAndNonOccludedIndexListFromRTree();
    int32_t GetInViewAndNonOccludedRecords();
    void ComputeBBox(CoreVector& o_bboxMin, CoreVector& o_bboxMax);
    int32_t GetNumRTrees();
    int32_t* GetRTreeOffsetTable();
    CoreRTreeData* GetRTreeDataPtr();
    int32_t GetRTreeRecordRootIndex();
    CoreRTreeRecord* GetRTreeRecordPtr();
    CoreRTreeData* GetRTreeData(uint32_t i_type, uint32_t i_roomNumber);
    bool RTreeBBoxesIntersect();
};

struct CoreModelCollidable
{
    enum
    {
        VERSION = 2,
    };

    int32_t m_iGeometryType;
    uint32_t m_objectType;
    float m_fMinPointX;
    float m_fMinPointY;
    float m_fMinPointZ;
    float m_fMaxPointX;
    float m_fMaxPointY;
    float m_fMaxPointZ;
    float m_fRotateX;
    float m_fRotateY;
    float m_fRotateZ;
    float m_fRadius;
    uint32_t m_uiParentHash;

    void CoreModelCollidable();
    void ~CoreModelCollidable();
    float GetRadius();
    CoreVector GetMinPoint();
    CoreVector GetMaxPoint();
    CoreEulerAngle GetRotation();
    CoreCollidableType GetGeometryType();
    uint32_t GetObjectType();
    uint32_t GetParentHash();
};

struct CoreDetectionMesh
{
    enum
    {
        VERSION = 4,
    };

    int32_t m_iTrianglesOffset;
    int32_t m_triangleBoundingSpheresOffset;
    int32_t m_iVerticesOffset;
    int32_t m_iSubTypeHashesOffset;
    int32_t m_iSubTypeDebugNamesOffset;
    int32_t m_iNumTriangles;
    int32_t m_iNumVertices;
    int32_t m_iNumSubTypes;

    void CoreDetectionMesh();
    void ~CoreDetectionMesh();
    int32_t GetNumTriangles();
    int32_t GetNumVertices();
    int32_t GetNumSubTypes();
    CoreVector* lpGetTrianglesBoundingSpherePtr();
    CoreVector GetTriangleBoundingSphere();
    CoreDetectionTriangle* GetTrianglePtr();
    CoreDetectionVertex* GetVertexPtr();
    uint32_t* GetSubTypeHashes();
    uint32_t GetSubTypeHash();
    char* GetSubTypeDebugName();
};

struct CoreDetectionEngineData
{
    uint32_t m_instanceTypeHash;
    uint32_t m_instanceIndex;
};

struct CoreXMLWriterData
{
};

struct CoreXMLWriter
{
    CoreXMLWriterData* m_data;

    void CoreXMLWriter();
    void ~CoreXMLWriter();
    bool StartDocument();
    bool EndDocument();
    bool StartElement();
    bool EndElement();
    bool Text();
};

struct CoreNodeRoot
{
    struct nodeRGB
    {
        CoreRGBA rgb0;
        CoreRGBA rgb1;

        void nodeRGB();
    };

    int32_t m_typeCreateIndex;
    uint32_t m_nodeFlags;
    CoreNodeType m_nodeType;
    static CoreNodeRoot::nodeRGB m_nodeRGB[14];
    int32_t m_hitIndex;
    CoreNodeRoot* m_pPrev;
    CoreNodeRoot* m_pNext;

    // TODO vtable

    void CoreNodeRoot();
    void ~CoreNodeRoot();
    CoreNodeRoot* GetPrevious();
    CoreNodeRoot* GetNext();
    void SetPrevious();
    void SetNext();
    void SetHitIndex(int32_t iIndex);
    int32_t GetHitIndex();
    void GetNodeColourID(uint32_t iType, CoreRGBA& iRGB0, CoreRGBA& iRGB1);
    uint32_t GetNodeType();
    uint32_t GetFlags();
};

struct tagCONVINFO
{
    uint32_t cb;
    uint32_t hUser;
    HCONV__* hConvPartner;
    HSZ__* hszSvcPartner;
    HSZ__* hszServiceReq;
    HSZ__* hszTopic;
    HSZ__* hszItem;
    uint32_t wFmt;
    uint32_t wType;
    uint32_t wStatus;
    uint32_t wConvst;
    uint32_t wLastError;
    HCONVLIST__* hConvList;
    tagCONVCONTEXT ConvCtxt;
    HWND* hwnd;
    HWND* hwndPartner;
};

struct _CHANGER_ELEMENT_LIST
{
    _CHANGER_ELEMENT Element;
    uint32_t NumberOfElements;
};

struct CoreGeometryCompiledPSPDynamicLitMeshVertexWeights
{
    uint32_t wa8;
    uint32_t wb8;
    uint32_t wc8;
    uint32_t wd8;
    uint32_t we8;
    uint32_t wf8;
    uint32_t wg8;
    uint32_t wh8;
    uint32_t u16;
    uint32_t v16;
    float nx32;
    float ny32;
    float nz32;
    float x32;
    float y32;
    float z32;
};

struct tagEMRANGLEARC
{
    tagEMR emr;
    _POINTL ptlCenter;
    uint32_t nRadius;
    float eStartAngle;
    float eSweepAngle;
};

struct CoreModelGeometry
{
    enum
    {
        VERSION = 46,
    };

    enum CoreGeometryFlagsBitsEnum
    {
        GEOMETRY_HAS_ALPHA_MATERIALS,
        GEOMETRY_HAS_OPAQUE_MATERIALS,
        GEOMETRY_HAS_SHADOW_MATERIALS,
    };

    enum CoreMeshFlagsBitsEnum
    {
        MESH_OPAQUE_GEOMETRY_BIT = 0,
        MESH_ALPHA_GEOMETRY_BIT = 1,
        MESH_SHADOW_GEOMETRY_BIT = 2,
        MESH_MASK_GEOMETRY_BIT = 3,
        MESH_DRAW_SHADOW_VOLUMES_BIT = 4,
        MESH_ADD_ALPHA_TO_LIST_BIT = 5,
        MESH_ADD_MASKS_TO_LIST_BIT = 6,
        STATIC_MATERIAL_BBOX_CULL_BIT = 7,
        OVERRIDE_AUTO_LOD_CALCULATION_BIT = 8,
        OVERRIDE_LOD_LEVEL_NUM_BITS = 3,
        OVERRIDE_LOD_LEVEL_BIT0 = 9,
        MESH_SORT_ALPHAS_BIT = 12,
    };

    float m_fObjectBBOXPosX;
    float m_fObjectBBOXPosY;
    float m_fObjectBBOXPosZ;
    float m_fObjectBBOXMinX;
    float m_fObjectBBOXMinY;
    float m_fObjectBBOXMinZ;
    float m_fObjectBBOXMaxX;
    float m_fObjectBBOXMaxY;
    float m_fObjectBBOXMaxZ;
    float m_fObjectBBOXRadius;
    uint32_t m_uiGeometryFlags;
    uint32_t m_iNumMaterials;
    uint32_t m_numInstances;
    int32_t m_materialHashIndexTableOffset;
    int32_t m_instanceMeshIndexTableOffset;
    int32_t m_iModelMaterialIndexTable[1];

    void CoreModelGeometry();
    void ~CoreModelGeometry();
    int32_t Render(CoreTextureSet* lpoTextureSet, CoreGraphicsDevice* lpoGraphicsDevice, CoreVector i_eyePos, CoreGraphicsDeviceModelCompiledInfo* lpoModelCompiledInfo, int32_t i_materialIndexToDraw, uint32_t uiMeshFlags, uint32_t i_materialNameToDraw, bool i_setMaterial);
    int32_t RenderLevelMesh();
    uint32_t GetGeometryFlags();
    bool bHasAlphaMaterials();
    bool bHasOpaqueMaterials();
    bool bHasShadowMaterials();
    uint32_t GetNumMaterials();
    CoreModelMaterial* GetModelMaterialPtr();
    int32_t FindMaterialIndexByHash(uint32_t i_materialHash);
    uint32_t GetNumInstances();
    CoreModelMesh* GetInstanceMesh();
    float GetObjectBBOXRadius();
    CoreVector GetObjectBBOXPos();
    CoreVector GetObjectBBOXMin();
    CoreVector GetObjectBBOXMax();
    int32_t* GetInstanceMeshIndexTable();
};

struct CoreGraphicsDeviceModelCompiledInfo
{
    enum CoreDrawFlagsBitsEnum
    {
        DRAW_SKELETON_BIT = 0,
        DRAW_BONE_BBOX_BIT = 1,
        DRAW_GEOMETRY_BIT = 2,
        DRAW_UNTEXTURED_BIT = 3,
        DRAW_UNLIT_BIT = 4,
        DRAW_BLENDSHAPE_OVERRIDE_BIT = 5,
        DRAW_BLENDSHAPE_OVERRIDE_BASE_BIT = 6,
        DRAW_BLENDSHAPE_OVERRIDE_TARGET_NUM_BITS = 3,
        DRAW_BLENDSHAPE_OVERRIDE_TARGET_BIT0 = 7,
        DRAW_STATIC_GEOMETRY_BIT = 10,
        DRAW_PARENTED_GEOMETRY_BIT = 11,
        DRAW_SOFTSKINNED_GEOMETRY_BIT = 12,
        DRAW_HARDSKINNED_GEOMETRY_BIT = 13,
        DRAW_BLENDSHAPE_GEOMETRY_BIT = 14,
        DRAW_OUTLINED_BIT = 15,
        DRAW_BONE_NAMES_BIT = 16,
    };

    CoreModelGeometry* m_lpoModelGeometry;
    CoreModelSkeleton* m_lpoModelSkeleton;
    CoreTextureSet* m_lpoTextureSet;
    CoreMatrix* m_lpoMatrixList;
    char* m_lpcVisibleList;
    float* m_lpfBlendShapeTargetAlphaValues;
    uint32_t* m_textureOffsets;
    CoreGraphicsDeviceLightData* m_lpoLightData;
    CoreRGBA m_oColour;
    uint32_t m_uiDrawFlags;
    uint32_t m_uiMeshFlags;
    CoreMatrix m_mtLocal2World;
    uint32_t m_uiObjectHash;
    CoreStringBuffer<16> m_debugModelName;
    uint32_t m_frameCounter;
    float m_elapsedTime;
    int32_t m_textureOffsetIndex;
    CoreTextureOverride* textureOverrides;
    uint32_t numTextureOverrides;

    void CoreGraphicsDeviceModelCompiledInfo();
};

struct CoreModelMaterial
{
    enum
    {
        VERSION = 23,
    };

    enum CoreTextureLayerBlendModes
    {
        BLEND_NONE,
        BLEND_ADD,
        BLEND_SUBTRACT,
        BLEND_ALPHA,
        BLEND_FIXED_ALPHA,
    };

    enum SpecialFlags
    {
        MMF_MASK = 1,
        MMF_ALPHA = 2,
        MMF_OPAQUE = 4,
        MMF_IGNORE = 8,
        MMF_ANIMATED = 16,
        MMF_ANIM_PASS0 = 32,
        MMF_ANIM_PASS1 = 64,
        MMF_DEPTH_OFFSET = 128,
        MMF_ANIMATED_MASK = 96,
    };

    uint32_t m_uFlags;
    uint32_t m_spare1;
    uint32_t m_spare2;
    uint32_t m_spare3;
    uint32_t m_meshTypeHash;
    uint32_t m_meshInfoTypeHash;
    uint32_t m_materialOriginalNameHash;
    uint32_t m_newPad[3];
    uint32_t m_uiMaterialHash;
    int32_t m_numMeshesToDraw;
    int32_t m_iBBOXBoneIndex;
    uint32_t m_uiBBOXBoneHash;
    float m_fBBOXPosX;
    float m_fBBOXPosY;
    float m_fBBOXPosZ;
    float m_fBBOXMinX;
    float m_fBBOXMinY;
    float m_fBBOXMinZ;
    float m_fBBOXMaxX;
    float m_fBBOXMaxY;
    float m_fBBOXMaxZ;
    float m_fBBOXRadius;
    uint32_t m_numTextureLayers;
    uint32_t m_layerFlags[3];
    int32_t m_numMeshesToSkip;
    int32_t m_iMaterialBlendMode;
    uint32_t m_uiTextureLayerTextureHash[3];
    uint32_t m_uiTextureLayerTextureOffset[3];
    char m_textureLayerTextureName[3][16];
    float m_fTextureLayerBlendAlpha[3];
    int32_t m_iTextureLayerBlendMode[3];
    float m_fMaterialColourRed;
    float m_fMaterialColourGreen;
    float m_fMaterialColourBlue;
    float m_fIncandescenceColourRed;
    float m_fIncandescenceColourGreen;
    float m_fIncandescenceColourBlue;
    float m_fDiffuseIntensity;
    float m_fSpecularCosinePower;
    float m_fSpecularColourRed;
    float m_fSpecularColourGreen;
    float m_fSpecularColourBlue;
    bool m_bVertexColours;
    bool m_bShadowMesh;
    bool m_bAlphaBlended;
    uint32_t m_ucFixedAlpha;
    uint32_t m_LODhash;
    int32_t m_LODindex;
    uint32_t m_LODnumber;
    float m_LODPrevMaxSquared;
    float m_LODMaxSquared;
    float m_LODBboxMinX;
    float m_LODBboxMinY;
    float m_LODBboxMinZ;
    float m_LODBboxMaxX;
    float m_LODBboxMaxY;
    float m_LODBboxMaxZ;
    uint32_t m_numMatrixPalettes;
    uint32_t m_specialFlags;
    uint32_t m_numInstancedMeshes;
    int32_t m_iModelMatrixPaletteMeshIndexTable[1];

    void CoreModelMaterial();
    void ~CoreModelMaterial();
    CoreModelMaterial::CoreTextureLayerBlendModes GetMaterialBlendMode();
    uint32_t GetFlags();
    int32_t GetNumTextureLayers();
    uint32_t GetTextureLayerTextureHash();
    CoreTextureInfo* GetTextureLayerTexturePtr();
    char* GetTextureLayerTextureName();
    float GetTextureLayerBlendAlpha();
    CoreModelMaterial::CoreTextureLayerBlendModes GetTextureLayerBlendMode();
    void SetAnimTextureLayer();
    CoreVector GetIncandescenceColour();
    CoreVector GetMaterialColour();
    bool HasTextureOffsets();
    void EnableTextureOffsets();
    float GetSOffset();
    float GetTOffset();
    void SetSOffset();
    void SetTOffset();
    float GetDeltaSOffset();
    float GetDeltaTOffset();
    void SetDeltaSOffset();
    void SetDeltaTOffset();
    float GetDiffuseIntensity();
    float GetSpecularCosinePower();
    CoreVector GetSpecularColour();
    bool HasVertexColours();
    bool IsShadowMesh();
    bool IsAlphaBlended();
    bool IsOpaque();
    bool IsEnvMapped();
    bool IsAnimated();
    float GetFixedAlphaValue();
    uint32_t GetFixedAlphaValue8();
    uint32_t GetNumMatrixPalettes();
    CoreModelMatrixPalette* GetModelMatrixPalette();
    CoreModelMesh* GetStaticModelMesh();
    CoreMeshInstanceInfo* GetMeshInstanceInfo();
    uint32_t GetNumInstancedMeshes();
    uint32_t GetMeshTypeHash();
    uint32_t GetMeshInfoTypeHash();
    char* GetMeshInfoTypeName();
    uint32_t GetHash();
    uint32_t GetBBOXBoneHash();
    int32_t GetBBOXBoneIndex();
    float GetBBOXRadius();
    CoreVector GetBBOXPos();
    CoreVector GetBBOXMin();
    CoreVector GetBBOXMax();
    uint32_t GetLODHash();
    int32_t GetLODIndex();
    uint32_t GetLODNumber();
    CoreVector GetLODBboxPos();
    CoreVector GetLODBboxSize();
    CoreVector GetLODBboxMin();
    CoreVector GetLODBboxMax();
    float GetLODMax();
    float GetLODMaxSquared();
    float GetLODPrevMax();
    float GetLODPrevMaxSquared();
    uint32_t GetNumMeshesToDraw();
    uint32_t GetNumMeshesToSkip();
    uint32_t GetSpecialFlags();
    void SetSpecialFlags();
    void CreateSpecialFlags();
    void SetNoZWrite();
    void SetAdditive();
    bool GetNoZWrite();
    bool GetAdditive();
    void SetAnimName();
    uint32_t GetAnimName();
    void SetSpecialFlag();
    void CreateMinimalSet();
    uint32_t GetOriginalMaterialNameHash();
};

struct CoreGsSetTexEnv
{
    int32_t ulTEX0_1;
    int32_t ulTEX0_1RegNumber;
    int32_t ulTEX1_1;
    int32_t ulTEX1_1RegNumber;
    int32_t ulMIPTBP1_1;
    int32_t ulMIPTBP1_1RegNumber;
    int32_t ulMIPTBP2_1;
    int32_t ulMIPTBP2_1RegNumber;
    int32_t ulTEX0_2;
    int32_t ulTEX0_2RegNumber;
    int32_t ulTEX1_2;
    int32_t ulTEX1_2RegNumber;
    int32_t ulMIPTBP1_2;
    int32_t ulMIPTBP1_2RegNumber;
    int32_t ulMIPTBP2_2;
    int32_t ulMIPTBP2_2RegNumber;
    int32_t ulTEXFLUSH;
    int32_t ulTEXFLUSHRegNumber;
};

struct tagEMRSETARCDIRECTION
{
    tagEMR emr;
    uint32_t iArcDirection;
};

struct midihdr_tag
{
    char* lpData;
    uint32_t dwBufferLength;
    uint32_t dwBytesRecorded;
    uint32_t dwUser;
    uint32_t dwFlags;
    midihdr_tag* lpNext;
    uint32_t reserved;
    uint32_t dwOffset;
    uint32_t dwReserved[8];
};

struct tagMCI_WAVE_DELETE_PARMS
{
    uint32_t dwCallback;
    uint32_t dwFrom;
    uint32_t dwTo;
};

struct _TAPE_SET_POSITION
{
    uint32_t Method;
    uint32_t Partition;
    _LARGE_INTEGER Offset;
    uint32_t Immediate;
};

struct _CONNECTDLGSTRUCTA
{
    uint32_t cbStructure;
    HWND* hwndOwner;
    _NETRESOURCEA* lpConnRes;
    uint32_t dwFlags;
    uint32_t dwDevNum;
};

struct _CTL_ENTRY
{
    _CRYPTOAPI_BLOB SubjectIdentifier;
    uint32_t cAttribute;
    _CRYPT_ATTRIBUTE* rgAttribute;
};

struct IParseDisplayName : IUnknown
{
    HRESULT __stdcall ParseDisplayName();
    void IParseDisplayName();
};

struct CAL1_AudioStreamerPC : CAL1_AudioStreamer_Standard
{
    CAL0_AudioCodecADPCM m_ADPCMCodec;
    uint32_t* m_ADPCMTemp;

    void CAL1_AudioStreamerPC();
    void ~CAL1_AudioStreamerPC();
    CAAudioError TransferStartBlockToMemory(uint32_t channel, uint32_t startOffset, uint32_t source, uint32_t length);
    CAAudioError TransferSectorToMemory(uint32_t sector, uint32_t channel, uint32_t startOffset, uint32_t source, uint32_t length);
    uint32_t ReadData(uint32_t fileID, void* dataBuffer, uint32_t length, uint32_t* bufferDataRead);
    void ResetStreamer();
};

struct _ACCESS_DENIED_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t SidStart;
};

struct _DSFXChorus
{
    float fWetDryMix;
    float fDepth;
    float fFeedback;
    float fFrequency;
    int32_t lWaveform;
    float fDelay;
    int32_t lPhase;
};

struct _CERT_REQUEST_INFO
{
    uint32_t dwVersion;
    _CRYPTOAPI_BLOB Subject;
    _CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
    uint32_t cAttribute;
    _CRYPT_ATTRIBUTE* rgAttribute;
};

struct _PORT_INFO_3A
{
    uint32_t dwStatus;
    char* pszStatus;
    uint32_t dwSeverity;
};

struct _IMAGE_LINENUMBER
{
    _IMAGE_LINENUMBER::__unnamed Type;
    uint32_t Linenumber;
};

struct tagMIXERLINEA
{
    uint32_t cbStruct;
    uint32_t dwDestination;
    uint32_t dwSource;
    uint32_t dwLineID;
    uint32_t fdwLine;
    uint32_t dwUser;
    uint32_t dwComponentType;
    uint32_t cChannels;
    uint32_t cConnections;
    uint32_t cControls;
    char szShortName[16];
    char szName[64];
    tagMIXERLINEA::__unnamed Target;
};

struct CoreGsXyz
{
    uint32_t X : 16;
    uint32_t Y : 16;
    uint32_t Z : 32;
};

struct CAL1_SampleGroupPlayback : CAL1_AudioPlayback
{
    struct SamplePlaybackData
    {
        uint32_t m_Attn;
        ca_fixed m_Freq;
        uint32_t m_RandomAttn;
        uint32_t m_RandomDelay;
        uint32_t m_RandomPitchLow;
        uint32_t m_RandomPitchHigh;

        void SamplePlaybackData();
        uint32_t SaveItemData(uint32_t* i_Data);
        uint32_t LoadItemData(uint32_t* i_Data);
    };

    struct PlaybackData
    {
        PlaybackDataType m_Type;
        uint32_t m_NumItems;
        CAL1_SampleGroupPlayback::SamplePlaybackData** m_PlaybackArray;

        // TODO vtable

        void PlaybackData();
        void ~PlaybackData();
        PlaybackDataType GetPlaybackType();
        uint32_t GetPlayIndex();
        void Step();
        void Reset();
        CAL1_SampleGroupPlayback::SamplePlaybackData* GetSamplePlaybackData();
        uint32_t GetNumItems();
        CAAudioError SetCommonData(CAL1_SampleGroupPlayback::PlaybackData* oldPBData);
        uint32_t SaveItemData(uint32_t* i_Data);
        uint32_t LoadItemData(uint32_t* i_Data);
    };

    struct PlaybackData_Sequencial : CAL1_SampleGroupPlayback::PlaybackData
    {
        uint32_t m_Index;

        void PlaybackData_Sequencial();
        uint32_t GetPlayIndex();
        void Step();
        void Reset();
        void ~PlaybackData_Sequencial();
    };

    struct PlaybackData_Random : CAL1_SampleGroupPlayback::PlaybackData
    {
        uint32_t m_Index;
        uint32_t* m_ShuffleTable;
        uint32_t m_HitProbability;
        uint32_t* m_HitProbTable;
        bool m_ValidSelection;

        void PlaybackData_Random();
        void ~PlaybackData_Random();
        uint32_t GetPlayIndex();
        bool GetValidSelection();
        void Step();
        void Reset();
        void SetHitProbability();
        uint32_t GetHitProbability();
        void SetHitProb();
        uint32_t GetHitProb();
        uint32_t SaveItemData(uint32_t* i_Data);
        uint32_t LoadItemData(uint32_t* i_Data);
    };

    struct PlaybackData_Delay : CAL1_SampleGroupPlayback::PlaybackData
    {
        uint32_t* m_DelayTable;

        void PlaybackData_Delay();
        void ~PlaybackData_Delay();
        uint32_t GetEntryDelay();
        void SetEntryDelay();
        uint32_t SaveItemData(uint32_t* i_Data);
        uint32_t LoadItemData(uint32_t* i_Data);
    };

    struct PlaybackData_Chain : CAL1_SampleGroupPlayback::PlaybackData
    {
        uint32_t m_Index;
        bool m_Active;

        void PlaybackData_Chain();
        uint32_t GetPlayIndex();
        bool GetActive();
        void Step();
        void Reset();
        void ~PlaybackData_Chain();
    };

    CAL1_SampleGroupPlayback::PlaybackData* m_PlaybackData;
    CAL1_AudioItem* m_AudioItem;

    void CAL1_SampleGroupPlayback();
    void ~CAL1_SampleGroupPlayback();
    CAAudioError SetSampleGroup();
    CAAudioError Update();
    CAAudioError End();
    CAAudioError Start();
    CAAudioError DoTimer();
    CAAudioError StartChain();
    CAAudioError StartDelay();
    CAAudioError StartRandom();
    CAAudioError StartSequence();
    void StartSample(uint32_t index, uint32_t additionalDelay, bool setCompletion);
    void StopSample(uint32_t index);
    CAAudioError DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* aid);
    CAAudioError DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
    CAAudioError LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
    CAAudioError SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
    PlaybackDataType GetPlaybackType();
    CAAudioError SetPlaybackType(PlaybackDataType type, uint32_t numItems);
    uint32_t GetNumEntries();
    CAL1_SampleGroupPlayback::SamplePlaybackData* GetSamplePlaybackData();
    CAL1_SampleGroupPlayback::PlaybackData* GetPlaybackData();
    CAL1_AudioItem* GetAudioItem();
    CAAudioError Trigger();
    CAAudioError Tick();
    CAAudioError CompletionTrigger(CAL1_AudioPlayback* from);
    CAAudioError AlmostCompleteTrigger(CAL1_AudioPlayback* from);
};

struct _EXCEPTION_DEBUG_INFO
{
    _EXCEPTION_RECORD ExceptionRecord;
    uint32_t dwFirstChance;
};

struct _CERT_POLICIES_INFO
{
    uint32_t cPolicyInfo;
    _CERT_POLICY_INFO* rgPolicyInfo;
};

struct _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA
{
    uint32_t cbSize;
    uint32_t hCryptProv;
    uint32_t dwKeySpec;
    _CMSG_KEY_TRANS_RECIPIENT_INFO* pKeyTrans;
    uint32_t dwRecipientIndex;
};

struct _MONITOR_INFO_1A
{
    char* pName;
};

struct _DSCFXNoiseSuppress
{
    int32_t fEnable;
};

struct CoreGroupRailCamera : CoreCameraObject
{
    enum
    {
        MAX_TARGETS = 4,
    };

    CoreObject* m_target[4];
    uint32_t m_numTargets;
    CoreVector m_offset;
    float m_idealDistance;
    float m_distance;
    CoreCurveSetData* m_rail;
    CoreS128Aligned m_memoryPot[256];

    void CoreGroupRailCamera();
    void ~CoreGroupRailCamera();
    void Construct(CoreMemory* io_memory);
    void AddTarget();
    void RemoveTarget();
    void SetIdealDistance();
    void SetOffset();
    void SetRail();
    float GetActualDistance();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    int32_t FindTarget();
    CoreScripted::CommandReturn FnDefaultCameraLogic();
    CoreScripted::CommandReturn DefaultCameraLogic(CoreCommand* i_command);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
};

struct tagNEWTEXTMETRICEXA
{
    tagNEWTEXTMETRICA ntmTm;
    tagFONTSIGNATURE ntmFontSig;
};

struct IUnknown
{
    // TODO vtable

    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    void IUnknown();
};

struct AsyncIPipeDouble : IUnknown
{
    HRESULT __stdcall Begin_Pull();
    HRESULT __stdcall Finish_Pull();
    HRESULT __stdcall Begin_Push();
    HRESULT __stdcall Finish_Push();
    void AsyncIPipeDouble();
};

struct _OFNOTIFYEXW
{
    tagNMHDR hdr;
    tagOFNW* lpOFN;
    void* psf;
    void* pidl;
};

struct CoreDetectLine
{
    CoreDetectLineType eType;
};

struct CoreFader
{
    float m_level;
    float m_start;
    float m_end;
    float m_duration;
    float m_startTime;

    void CoreFader();
    void StartFadeOn();
    void StartFadeOff();
    float Update();
    float GetLevel();
    bool IsFading();
    bool IsOn();
    bool IsOff();
};

struct tagACCEL
{
    uint32_t fVirt;
    uint32_t key;
    uint32_t cmd;
};

struct tagMCI_BREAK_PARMS
{
    uint32_t dwCallback;
    int32_t nVirtKey;
    HWND* hwndBreak;
};

struct _CERT_PHYSICAL_STORE_INFO
{
    uint32_t cbSize;
    char* pszOpenStoreProvider;
    uint32_t dwOpenEncodingType;
    uint32_t dwOpenFlags;
    _CRYPTOAPI_BLOB OpenParameters;
    uint32_t dwFlags;
    uint32_t dwPriority;
};

struct _FILESYSTEM_STATISTICS
{
    uint32_t FileSystemType;
    uint32_t Version;
    uint32_t SizeOfCompleteStructure;
    uint32_t UserFileReads;
    uint32_t UserFileReadBytes;
    uint32_t UserDiskReads;
    uint32_t UserFileWrites;
    uint32_t UserFileWriteBytes;
    uint32_t UserDiskWrites;
    uint32_t MetaDataReads;
    uint32_t MetaDataReadBytes;
    uint32_t MetaDataDiskReads;
    uint32_t MetaDataWrites;
    uint32_t MetaDataWriteBytes;
    uint32_t MetaDataDiskWrites;
};

struct HENHMETAFILE__
{
    int32_t unused;
};

struct tagLOGFONTW
{
    int32_t lfHeight;
    int32_t lfWidth;
    int32_t lfEscapement;
    int32_t lfOrientation;
    int32_t lfWeight;
    uint32_t lfItalic;
    uint32_t lfUnderline;
    uint32_t lfStrikeOut;
    uint32_t lfCharSet;
    uint32_t lfOutPrecision;
    uint32_t lfClipPrecision;
    uint32_t lfQuality;
    uint32_t lfPitchAndFamily;
    uint32_t lfFaceName[32];
};

struct tagEMRARC
{
    tagEMR emr;
    _RECTL rclBox;
    _POINTL ptlStart;
    _POINTL ptlEnd;
};

struct tagCOPYDATASTRUCT
{
    uint32_t dwData;
    uint32_t cbData;
    void* lpData;
};

struct tagMINIMIZEDMETRICS
{
    uint32_t cbSize;
    int32_t iWidth;
    int32_t iHorzGap;
    int32_t iVertGap;
    int32_t iArrange;
};

struct tagMCI_ANIM_WINDOW_PARMSW
{
    uint32_t dwCallback;
    HWND* hWnd;
    uint32_t nCmdShow;
    uint32_t* lpstrText;
};

struct _CERT_KEYGEN_REQUEST_INFO
{
    uint32_t dwVersion;
    _CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
    uint32_t* pwszChallengeString;
};

struct echosc1waveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct CoreBlindDataSection
{
    enum
    {
        VERSION = 4,
    };

    uint32_t m_numTypes;
    uint32_t m_blindDataGroupOffsetsTableOffset;
    uint32_t m_blindDataGroupIndexTableOffset;

    void CoreBlindDataSection();
    void ~CoreBlindDataSection();
    uint32_t GetNumTypes();
    CoreBlindDataGroup* GetBlindDataGroupPtr(CoreHash i_type);
    CoreBlindDataGroup* GetBlindDataGroupPtrByIndex();
    CoreHashArray* GetBlindDataGroupIndexTable();
    uint32_t* GetBlindDataGroupOffsetsTable();
};

struct CoreBlindDataGroup
{
    enum
    {
        VERSION = 3,
    };

    uint32_t m_typeHash;
    uint32_t m_version;
    uint32_t m_numInstances;
    uint32_t m_instanceOffsetTableOffset;
    uint32_t m_instanceNameTableOffset;
    uint32_t m_instanceNameIndexTableOffset;
    char m_name[16];

    void CoreBlindDataGroup();
    void ~CoreBlindDataGroup();
    uint32_t GetTypeHash();
    uint32_t GetVersion();
    uint32_t GetNumInstances();
    char* GetName();
    void* GetInstance();
    void* GetInstanceByName();
    CoreHash GetNameByIndex();
    uint32_t* GetInstanceOffsetTable();
    CoreHashArray* GetInstanceNameIndexTablePtr();
    uint32_t* GetInstanceNameTablePtr();
};

struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
{
    uint32_t BeginAddress;
    uint32_t EndAddress;
    uint32_t ExceptionHandler;
    uint32_t HandlerData;
    uint32_t PrologEndAddress;
};

struct tagHELPWININFOA
{
    int32_t wStructSize;
    int32_t x;
    int32_t y;
    int32_t dx;
    int32_t dy;
    int32_t wMax;
    char rgchMember[2];
};

struct __MIDL___MIDL_itf_wtypes_0003_0001
{
    union __MIDL___MIDL_itf_wtypes_0003_0005
    {
        _GUID clsid;
        uint32_t* pFileExt;
        uint32_t* pMimeType;
        uint32_t* pProgId;
        uint32_t* pFileName;
        __MIDL___MIDL_itf_wtypes_0003_0001::__MIDL___MIDL_itf_wtypes_0003_0005::__unnamed ByName;
        __MIDL___MIDL_itf_wtypes_0003_0001::__MIDL___MIDL_itf_wtypes_0003_0005::__unnamed ByObjectId;
    };

    uint32_t tyspec;
    __MIDL___MIDL_itf_wtypes_0003_0001::__MIDL___MIDL_itf_wtypes_0003_0005 tagged_union;
};

struct _DSCCAPS
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwFormats;
    uint32_t dwChannels;
};

struct IMoniker : IPersistStream
{
    HRESULT __stdcall BindToObject();
    HRESULT __stdcall BindToStorage();
    HRESULT __stdcall Reduce();
    HRESULT __stdcall ComposeWith();
    HRESULT __stdcall Enum();
    HRESULT __stdcall IsEqual();
    HRESULT __stdcall Hash();
    HRESULT __stdcall IsRunning();
    HRESULT __stdcall GetTimeOfLastChange();
    HRESULT __stdcall Inverse();
    HRESULT __stdcall CommonPrefixWith();
    HRESULT __stdcall RelativePathTo();
    HRESULT __stdcall GetDisplayName();
    HRESULT __stdcall ParseDisplayName();
    HRESULT __stdcall IsSystemMoniker();
    void IMoniker();
};

struct tagARRAYDESC
{
    tagTYPEDESC tdescElem;
    uint32_t cDims;
    tagSAFEARRAYBOUND rgbounds[1];
};

struct tagJPEGINFOHEADER
{
    uint32_t JPEGSize;
    uint32_t JPEGProcess;
    uint32_t JPEGColorSpaceID;
    uint32_t JPEGBitsPerSample;
    uint32_t JPEGHSubSampling;
    uint32_t JPEGVSubSampling;
};

struct CoreRagdollCollidables
{
    uint32_t ucNumRagdollCollidables;
    uint32_t ucPadding;
    uint32_t usPadding;
    CoreSingleRagdollCollidable* lpoRagdollCollidableArray;
};

struct CoreLevelAsyncData
{
    enum CoreLevelAsyncState
    {
        CORE_ASYNC_INACTIVE,
        CORE_ASYNC_LOADING_SCRIPTS,
        CORE_ASYNC_LOADING_LEVEL,
        CORE_ASYNC_START_LOADING,
        CORE_ASYNC_DONE_LOADING,
    };

    char lpcSecondLevelName[32];
    char lpcSecondAreaName[32];
    char lpcSecondLevelCluster[16];
    CoreHash oSecondLevelHash;
    char lpcSecondLevelLinkedScripts[256];
    char lpcSecondLevelLevelCompiled[256];
    CoreLevelCompiled* lpoSecondLevelCompiled;
    uint32_t uiSecondScriptStoreAssetID;
    uint32_t uiSecondLevelCompiledAssetID;
    CoreLevelAsyncData::CoreLevelAsyncState eSecondAreaAsyncState;

    char* GetAsyncState();
    void CoreLevelAsyncData();
    void ~CoreLevelAsyncData();
};

struct _SHFILEINFOW
{
    HICON__* hIcon;
    int32_t iIcon;
    uint32_t dwAttributes;
    uint32_t szDisplayName[260];
    uint32_t szTypeName[80];
};

struct tagTEXTMETRICW
{
    int32_t tmHeight;
    int32_t tmAscent;
    int32_t tmDescent;
    int32_t tmInternalLeading;
    int32_t tmExternalLeading;
    int32_t tmAveCharWidth;
    int32_t tmMaxCharWidth;
    int32_t tmWeight;
    int32_t tmOverhang;
    int32_t tmDigitizedAspectX;
    int32_t tmDigitizedAspectY;
    uint32_t tmFirstChar;
    uint32_t tmLastChar;
    uint32_t tmDefaultChar;
    uint32_t tmBreakChar;
    uint32_t tmItalic;
    uint32_t tmUnderlined;
    uint32_t tmStruckOut;
    uint32_t tmPitchAndFamily;
    uint32_t tmCharSet;
};

struct _CHANGER_INITIALIZE_ELEMENT_STATUS
{
    _CHANGER_ELEMENT_LIST ElementList;
    uint32_t BarCodeScan;
};

struct _OSVERSIONINFOW
{
    uint32_t dwOSVersionInfoSize;
    uint32_t dwMajorVersion;
    uint32_t dwMinorVersion;
    uint32_t dwBuildNumber;
    uint32_t dwPlatformId;
    uint32_t szCSDVersion[128];
};

struct CoreXMLNodeIt
{
    enum WALKTYPE
    {
        WALKTYPE_DEPTHFIRST,
        WALKTYPE_ALONGFIRST,
    };

    int32_t m_currStack;
    int32_t m_StackLen;
    CoreXMLNode_** m_Stack;
    CoreXMLNode_* m_pcurrNode;
    uint32_t m_Flags;
    uint32_t m_WalkType;
    char* m_szFilterName;
    uint32_t m_FilterTypes;
    CoreXMLDoc* m_pDoc;

    void CoreXMLNodeIt();
    void ~CoreXMLNodeIt();
    void Assign();
    void SetWalkType();
    void SetFilter();
    CoreXMLNode_* Next();
    CoreXMLNode_* Prev();
    void Construct();
    void AddToStack();
    void ExpandStack();
    bool FilterIgnore();
    void FilterSetName();
};

struct _CRYPT_ENCODE_PARA
{
    uint32_t cbSize;
    void** pfnAlloc;
    void* pfnFree;
};

struct tagAUXCAPS2A
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t wTechnology;
    uint32_t wReserved1;
    uint32_t dwSupport;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct IPrintDialogServices : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetCurrentDevMode();
    HRESULT __stdcall GetCurrentPrinterName();
    HRESULT __stdcall GetCurrentPortName();
    void IPrintDialogServices();
};

struct _CERT_TEMPLATE_EXT
{
    char* pszObjId;
    uint32_t dwMajorVersion;
    int32_t fMinorVersion;
    uint32_t dwMinorVersion;
};

struct CoreMapFileFunctionFileName
{
    uint32_t m_fileName_STLU;
};

struct CAL1_AudioDriver
{
    uint32_t m_LastStreamedChannel;
    uint32_t m_DefaultFileID;
    char* m_DefaultStreamFile;
    uint32_t m_DefaultStreamFileOffset;
    uint32_t m_DefaultFileID_Common;
    char* m_DefaultStreamFile_Common;
    uint32_t m_DefaultStreamFileOffset_Common;
    uint32_t m_GlobalFileID;
    char* m_GlobalStreamFile;
    uint32_t m_GlobalStreamFileOffset;
    uint32_t m_GlobalFileID_Common;
    char* m_GlobalStreamFile_Common;
    uint32_t m_GlobalStreamFileOffset_Common;
    uint32_t m_MasterAttenuation;
    uint32_t m_TimerUpdateFrequency;
    ca_fixed m_DopplerFactor;
    ca_fixed m_DistanceFactor;
    CAL1_AudioListener m_LastListener;
    CAL1_AudioListener m_NextListener;
    uint32_t m_3DMode;
    uint32_t m_DopplerMode;
    uint32_t m_HRTFMode;
    ca_fixed m_viewMatrix[16];
    uint32_t m_numChannels;
    uint32_t m_numStreams;
    uint32_t m_SoloMuteMask;
    CAL1_AudioStreamer** m_StreamerTable;
    CAL1_Sample** m_SampleTable;
    CAL1_StreamData** m_StreamList;
    CAL0_List* m_ActiveAudioItemList;
    uint32_t* m_VolumeTable;
    uint32_t* m_OcclusionTable;
    int32_t* m_PanTable;
    int32_t* m_FRPanTable;
    uint32_t* m_FrequencyTable;
    ca_3DPoint* m_PositionTable;
    ca_3DVelocity* m_VelocityTable;
    ca_fixed* m_MinDistTable;
    ca_fixed* m_MaxDistTable;
    bool* m_Paused;
    bool* m_DeferredList;
    uint32_t* m_CreationFlags;
    CAL0_MemoryManagerSoundRAM* m_MemoryManager;
    CAL1_ReverbManager* m_ReverbManager;
    bool m_Deferred;
    bool m_DriverPaused;
    uint32_t m_StreamOutputCount;
    int32_t m_streamPath[280];
    CAL1_ChannelManager* m_ChannelManager;
    bool m_HW3DAcceleration;
    bool m_HWNon3DAcceleration;
    bool m_UseEAX;
    bool m_EAXReverb;
    bool m_EAXReverbMorphing;
    bool m_EAXReverbPanning;
    bool m_EAXOcclusion;
    CAL1_DelayEntry m_DelayTable[128];
    uint32_t m_GroupAttenuationTable[32];
    bool m_HardwareConnected;

    // TODO vtable

    void CAL1_AudioDriver();
    void ~CAL1_AudioDriver();
    uint32_t GetNumberOfMatchingChannels();
    uint32_t GetNumberOfCreatedChannels();
    uint32_t GetChannelPlayCursor(uint32_t channel);
    CAAudioError UpdateChannelPan(uint32_t channel);
    CAAudioError UpdateChannelVolume(uint32_t channel);
    CAAudioError UpdateChannelFrequency(uint32_t channel);
    CAAudioError UpdateChannel3D(uint32_t channel);
    CAAudioError UpdateChannelOcclusion(uint32_t channel);
    CAAudioError SetChannelPan(uint32_t channel, int32_t pan, int32_t panFR);
    CAAudioError SetChannelVolume(uint32_t channel, uint32_t volume);
    CAAudioError SetChannelFrequency(uint32_t channel, uint32_t frequency);
    CAAudioError SetChannelOcclusion(uint32_t channel, uint32_t occlusion);
    CAAudioError SetChannel3D();
    CAAudioError GetChannelPan();
    CAAudioError GetChannelVolume();
    CAAudioError WriteChannelBufferData(uint32_t channel, uint32_t offset, uint32_t length, void* data);
    CAAudioError StopChannel(uint32_t channel);
    bool IsChannelPlaying(uint32_t channel, bool ignoreDeferred);
    CAAudioError PauseChannel(uint32_t channel);
    CAAudioError ResumeChannel(uint32_t channel);
    void ShowSamplePlayCursorDiff(CAL1_Sample* sample1, CAL1_Sample* sample2);
    CAAudioError StartSample(CAL1_Sample* sample);
    CAAudioError StopSample(CAL1_Sample* sample);
    void SetTimerUpdateFrequency();
    uint32_t GetTimerUpdateFrequency();
    CAAudioError Create();
    void Reset();
    void Close();
    void Tick();
    CAAudioError Stream();
    CAAudioError FrameEnd();
    CAAudioError SetMasterAttenuation(uint32_t masterAtten);
    CAAudioError UpdateMasterAttenuation();
    uint32_t GetMasterAttenuation();
    void SetSoloMuteMask(uint32_t soloMuteMask);
    void PauseAll();
    void UnpauseAll();
    void StopAllChannels();
    void DisconnectHardware();
    void ReconnectHardware();
    bool IsHardwareConnected();
    CAAudioError Update3DListener();
    CAL1_AudioListener* GetLastListener();
    CAAudioError SetNextListener(CAL1_AudioListener* listener);
    CAL1_AudioListener* GetNextListener();
    void SetDeferred(bool deferred);
    CAAudioError Set3DAndDopplerMode(uint32_t threeDMode, uint32_t dopplerMode);
    CAAudioError SetHRTFMode(uint32_t hrtfMode);
    CAAudioError EnableAllHWAcceleration(bool enable);
    CAAudioError EnableNon3DHWAcceleration(bool enable);
    CAAudioError Enable3DHWAcceleration(bool enable);
    CAAudioError EnableEAX(bool enable);
    CAAudioError EnableEAXReverb(bool enable);
    CAAudioError EnableEAXReverbMorphing(bool enable);
    CAAudioError EnableEAXReverbPanning(bool enable);
    CAAudioError EnableEAXOcclusion(bool enable);
    CAAudioError DeallocateStreamer(CAL1_AudioStreamer* streamer);
    CAAudioError DeallocateAllStreams();
    CAL1_AudioStreamer* AllocateStreamer();
    CAAudioError AllocateChannelForStreamingSample(CAL1_Sample* iStreamingSample);
    CAAudioError DeallocateChannelForStreamingSample(CAL1_Sample* iStreamingSample);
    CAAudioError SetDefaultStreamFileName(char* fileName, uint32_t fileOffset);
    CAAudioError SetDefaultStreamFileID(uint32_t fileID);
    CAAudioError SetDefaultStreamFileName_Common(char* fileName, uint32_t fileOffset);
    CAAudioError SetDefaultStreamFileID_Common(uint32_t fileID);
    CAAudioError SetGlobalStreamFileName(char* fileName, uint32_t fileOffset);
    CAAudioError SetGlobalStreamFileID(uint32_t fileID);
    CAAudioError SetGlobalStreamFileName_Common(char* fileName, uint32_t fileOffset);
    CAAudioError SetGlobalStreamFileID_Common(uint32_t fileID);
    uint32_t GetDefaultStreamFileID();
    char* GetDefaultStreamFileName();
    uint32_t GetDefaultStreamFileOffset();
    uint32_t GetDefaultStreamFileID_Common();
    char* GetDefaultStreamFileName_Common();
    uint32_t GetDefaultStreamFileOffset_Common();
    uint32_t GetGlobalStreamFileID();
    char* GetGlobalStreamFileName();
    uint32_t GetGlobalStreamFileOffset();
    uint32_t GetGlobalStreamFileID_Common();
    char* GetGlobalStreamFileName_Common();
    uint32_t GetGlobalStreamFileOffset_Common();
    CAAudioError TickAudioPlaybackList();
    CAAudioError EndAudioItem(CAL1_AudioPlayback* item);
    CAAudioError StartAudioItem(CAL1_AudioPlayback* item);
    CAAudioError StartAudioItemDelay(CAL1_AudioPlayback* item, uint32_t delay);
    CAAudioError UpdateAudioItem(CAL1_AudioPlayback* item);
    CAAudioError TriggerAudioItem(CAL1_AudioPlayback* item);
    CAAudioError AddToPlaybackList(CAL1_AudioPlayback* item);
    void SetStreamPath();
    void TickDelayTable();
    void ClearDelayTable();
    uint32_t GetAccelCaps();
    uint32_t GetDopplerCaps();
    uint32_t Get3DCaps();
    uint32_t GetReverbCaps();
    uint32_t GetNumberOfChannels();
    CAL1_Sample* GetSampleOnChannel(uint32_t channel);
    CAL1_ChannelManager* GetChannelManager();
    CAL1_ReverbManager* GetReverbManager();
    bool IsChannelDeferred(uint32_t channel);
    uint32_t GetChannelFrequency(uint32_t channel);
    bool IsEAXReverbMorphingEnabled();
    bool IsEAXEnabled();
    bool IsEAXReverbEnabled();
    bool IsChannelPaused(uint32_t channel);
    bool IsDriverPaused();
    CAL0_MemoryManagerSoundRAM* GetMemoryManager();
    uint32_t GetOcclusionVolumeOffset();
    uint32_t GetSoloMuteMask();
    uint32_t SetGroupVolume(uint32_t iGroupIndex, uint32_t iVolume);
    uint32_t GetGroupVolume(uint32_t iGroupIndex);
    uint32_t GetScaledOcclusion();
    CAAudioError Recalculate3DBasic();
    CAAudioError Recalculate3DDolbySurround();
    CAAudioError Recalculate3DFull();
    CAAudioError Calculate3DAndDoppler(CAL1_Sample* sample);
    ca_fixed CalculateDoppler();
    bool CalculateViewTransform();
    bool CalculateLRFRAndDistance();
    void BeginStreamThread();
};

struct tagSTICKYKEYS
{
    uint32_t cbSize;
    uint32_t dwFlags;
};

struct tagTITLEBARINFO
{
    uint32_t cbSize;
    tagRECT rcTitleBar;
    uint32_t rgstate[6];
};

struct tagMCI_SEQ_SET_PARMS
{
    uint32_t dwCallback;
    uint32_t dwTimeFormat;
    uint32_t dwAudio;
    uint32_t dwTempo;
    uint32_t dwPort;
    uint32_t dwSlave;
    uint32_t dwMaster;
    uint32_t dwOffset;
};

struct _RPC_IF_ID
{
    _GUID Uuid;
    uint32_t VersMajor;
    uint32_t VersMinor;
};

struct _DRIVER_INFO_2W
{
    uint32_t cVersion;
    uint32_t* pName;
    uint32_t* pEnvironment;
    uint32_t* pDriverPath;
    uint32_t* pDataFile;
    uint32_t* pConfigFile;
};

struct tagBIND_OPTS2 : tagBIND_OPTS
{
    uint32_t dwTrackFlags;
    uint32_t dwClassContext;
    uint32_t locale;
    _COSERVERINFO* pServerInfo;
};

struct _userHMETAFILE
{
    union __MIDL_IWinTypes_0004
    {
        int32_t hInproc;
        _BYTE_BLOB* hRemote;
        int32_t hInproc64;
    };

    int32_t fContext;
    _userHMETAFILE::__MIDL_IWinTypes_0004 u;
};

struct _DOC_INFO_3A
{
    char* pDocName;
    char* pOutputFile;
    char* pDatatype;
    uint32_t dwFlags;
};

struct _PORT_INFO_2W
{
    uint32_t* pPortName;
    uint32_t* pMonitorName;
    uint32_t* pDescription;
    uint32_t fPortType;
    uint32_t Reserved;
};

struct tagRemFORMATETC
{
    uint32_t cfFormat;
    uint32_t ptd;
    uint32_t dwAspect;
    int32_t lindex;
    uint32_t tymed;
};

struct CoreWorld : CoreScripted
{
    bool m_force30frames;
    CoreWorldInternalData* m_lpoData;
    static CoreWorld* m_instance;
    static CoreHash m_animationSetAssetTypeHash;
    static CoreHash m_animSequencerAssetTypeHash;
    static CoreHash m_modelCompiledAssetTypeHash;
    static CoreHash m_textureSetAssetTypeHash;
    static CoreHash m_fontAssetTypeHash;
    static CoreHash m_FXAssetTypeHash;
    static CoreHash m_scriptStoreAssetTypeHash;
    static CoreHash m_levelAssetTypeHash;
    static CoreHash m_genericFileAssetTypeHash;
    static CoreHash m_clusterAssetTypeHash;
    bool m_isLocalMultiplayer;
    bool m_isMultiplayerGame;

    void CoreWorld();
    void ~CoreWorld();
    void Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams);
    void Destruct(CoreMemory* lpoMemory);
    void Init(CoreWorldUpdateStruct* lpoWorldUpdateStruct);
    void Reset(CoreWorldUpdateStruct* lpoWorldUpdateStruct);
    void Update(CoreWorldUpdateStruct* lpoWorldUpdateStruct, float fTimeElapsed);
    void ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
    void RememberLevelName(char* i_level, char* i_area);
    void AddToRenderList(CoreGameRender* lpoGraphics);
    void Render(CoreGameRender* lpoGraphics);
    void RenderPanel(CoreGameRender* lpoGraphics);
    CoreWorld* GetInstance();
    bool IsLevelLoaded();
    bool IsWorldLoaded();
    CoreLevel* GetLevel();
    CoreDetect* GetDetect();
    CoreAIController* GetAIController();
    CorePhysicsWorld* GetPhysicsWorld();
    void SetPhysicsGravity();
    void SetPhysicsFriction();
    void SetPhysicsRestitution();
    void SetPhysicsVelocityDamping();
    uint32_t GetCurrentLevelHash();
    bool GetIsLocalMultiplayer();
    void SetIsLocalMultiplayer();
    void SetLoadLevel(CoreHash newLevel);
    CorePanel* GetPanel();
    CoreAssetManager* GetAssetManager();
    CoreHash GetAnimationSetAssetType();
    CoreHash GetAnimSequencerAssetType();
    CoreHash GetModelCompiledAssetType();
    CoreHash GetTextureSetAssetType();
    CoreHash GetFontAssetType();
    CoreHash GetFXAssetType();
    CoreHash GetScriptStoreAssetType();
    CoreHash GetLevelAssetType();
    CoreHash GetGenericFileAssetType();
    CoreHash GetClusterAssetType();
    uint32_t GetClientID();
    CoreAnimationSet* LoadAnimationSet(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreAnimSequencer* LoadAnimSequencer(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreModelCompiled* LoadModelCompiled(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreTextureSet* LoadTextureSet(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreFont* LoadFont(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    uint32_t* LoadLevelScript(uint32_t i_clientID, char* i_levelName, char* i_areaName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreClusterData* LoadLevelCluster(uint32_t i_clientID, char* i_levelName, char* i_areaName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    void* LoadSpecificFile(uint32_t i_clientID, char* i_assetName, CoreHash i_assetType, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    void* LoadDataFile(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreAnimSequencer* PreLoadAnimSequencer(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreAnimationSet* PreLoadAnimationSet(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreModelCompiled* PreLoadModelCompiled(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreModelCompiled* PreLoadEngine(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreTextureSet* PreLoadTextureSet(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    CoreFont* PreLoadFont(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
    bool LoadCluster(char* i_clusterName, bool i_allocateAssets, bool i_asyncLoad, bool& o_clusterExists);
    bool LoadFontFiles(char* i_name, bool i_asyncLoad, bool& o_exists);
    bool UnLoadScritpStore(CoreHash i_assetHash);
    bool UnLoadAnimationSet(CoreHash i_assetHash);
    bool UnLoadAnimSequencer(CoreHash i_assetHash);
    bool UnLoadModelCompiled(CoreHash i_assetHash);
    bool UnLoadTextureSet(CoreHash i_assetHash);
    bool UnLoadFont();
    bool UnLoadFX();
    bool UnLoadSpecificFile(CoreHash i_assetHash, CoreHash i_assetType);
    bool UnLoadDataFile(CoreHash i_assetHash);
    CoreHash GetAnimationSetAssetHash(char* i_assetName);
    CoreHash GetAnimSequencerAssetHash();
    CoreHash GetModelCompiledAssetHash(char* i_assetName);
    CoreHash GetTextureSetAssetHash(char* i_assetName);
    CoreHash GetFontAssetHash(char* i_assetName);
    CoreHash GetFXAssetHash();
    uint32_t* GetScriptStore(CoreHash i_scriptStoreName);
    CoreAnimationSet* GetAnimationSet();
    CoreAnimSequencer* GetAnimSequencer();
    CoreModelCompiled* GetModelCompiled();
    CoreTextureSet* GetTextureSet(char* i_textureSet, CoreHash& o_assetHash);
    CoreFont* GetFont(char* i_font, CoreHash& o_assetHash);
    void* GetSpecificFile(CoreHash i_assetHash, CoreHash i_assetType);
    void* GetDataFile(CoreHash i_assetHash);
    bool DoesAnimationSetExist();
    bool DoesAnimSequencerExist();
    bool DoesModelCompiledExist();
    bool DoesTextureSetExist();
    bool DoesFontExist();
    bool DoesFXExist();
    bool DoesLevelScriptExist(char* i_levelName, char* i_areaName);
    bool DoesLevelClusterExist(char* i_levelName, char* i_areaName);
    bool DoesDataFileExist(char* i_assetName);
    bool IsPaused();
    bool IsRemoteMachinePaused();
    void ResetRemoteMachinePaused();
    void SetPaused(bool bPaused, bool bPauseAudio);
    uint32_t GetActivePadIDForMenu();
    void SetActivePadIDForMenu();
    float GetTimeScale();
    void SetTimeScale(float fTimeScale);
    bool IsViewBackgroundLevel();
    bool IsSimulatingPSP();
    void SetSimulatePSP(bool i_simulatePSP);
    void SetSoakTest(bool i_enable);
    bool GetSoakTest();
    void ToggleSoakTest();
    bool NoNetworking();
    uint32_t GetNetworkAdapter();
    void ProcessGameSpecificNetworkPreInit(uint32_t i_GameSpecificData);
    void RoutePackets(CoreWorldUpdateStruct* lpoUpdateStruct);
    void SetWhiteFade(bool i_whiteFade);
    void SetFadeDown();
    void SetFadeUp();
    void SetFadeTime(float iFadeTime);
    void SetAudioFadeFactor(float iFadeFactor);
    float GetFadeTarget();
    float GetFadeValue();
    float GetFadeTime();
    bool bHasFinishedFadeDown();
    bool bHasFinishedFadeUp();
    void SetFadeValue(float fFadeVal);
    bool GetLevelName(CoreHash oNewLevel, char* lpcLevelName, char* lpcAreaName);
    bool CanPause();
    char* GetCurrentProfileName();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void ReLoadCurrentLevel();
    void EnableLoadingScreenDisplay();
    CoreScripted::CommandReturn eFnLoadingScreen(CoreCommand* lpoCommand);
    void SetOSKDefaultText();
    CoreScripted::CommandReturn DoOSK();
    char* GetOSKResult();
    CoreFont* GetFontFromCommand();
    CoreScripted::CommandReturn HandleMessageBox(CoreCommand* io_command, CoreMessageBoxInterface::CoreMessageBoxTypeTag i_type);
    bool IsMultiplayerGame();
    CoreScripted::CommandReturn eFnWorldUpdate();
    CoreScripted::CommandReturn eFnWorldUpdateWhileFade(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnWorldUpdateUntilLevelReady();
    CoreScripted::CommandReturn eFnLoadModel(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnLoadTextureSet(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnLoadAnimSet(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnLoadAnimSequencer();
    CoreScripted::CommandReturn eFnLoadFont(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnFXFont(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnLoadWorld();
    CoreScripted::CommandReturn eFnLoadLevel(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn fnLoadCluster(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnPauseFrames(CoreCommand*);
    CoreScripted::CommandReturn eFnNetStartup();
    CoreScripted::CommandReturn eFnSelectMenu();
    CoreScripted::CommandReturn eFnUpdateMenu();
    CoreScripted::CommandReturn FnSetFontButtonTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnIsQuickStart(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFont(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxTextureSet(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxOkButtonText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxNoButtonText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxYesButtonText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxRetryButtonText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxCancelButtonText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxCentre(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxMaximumWidth(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxMaximumHeight(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxMessageTextScales(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxButtonsTextScales(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxSpaceBetweenTextAndFrame(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxSpaceBetweenTextAndButtons(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxSpaceBetweenTextButtons(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxButtonSurround(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxButtonMinimumWidth(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxButtonTexture(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxButtonInputWrap(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxSelectedButtonFlash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFadeTimes(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxScreenBackGroundColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxTextColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxButtonTextColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxSelectedButtonTextColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxButtonBackGroundColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFrameCornerTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFrameEdgeTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFrameBackGroundTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFrameEdgeSizes(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFrameBackGroundOffsets(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFrameBackGroundColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFrameEdgeColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxFrameTextureColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxStartSoundHash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxSelectSoundHash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxLeftSoundHash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMessageBoxRightSoundHash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMessageBoxSaveSettings(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMessageBox();
    CoreScripted::CommandReturn FnMessageBoxYesNo();
    CoreScripted::CommandReturn FnMessageBoxNoYes();
    CoreScripted::CommandReturn FnMessageBoxRetry();
    CoreScripted::CommandReturn FnMessageBoxCancel();
    CoreScripted::CommandReturn FnMessageBoxRetryCancel();
    CoreScripted::CommandReturn FnMessageBoxCancelRetry();
    CoreScripted::CommandReturn FnMessageBoxOkCancel();
    CoreScripted::CommandReturn FnMessageBoxCancelOk();
    CoreScripted::CommandReturn FnSetOSKFont(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKTextureSet(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKSpaceButtonText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKDeleteButtonText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKCancelButtonText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKDoneButtonText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKCentre(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKSize(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKTitleTextScales(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKButtonsTextScales(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKEditedTextScales(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKSpacesBetweenTextAndFrame(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKSpaceBetweenTitleAndButtons(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKSpaceBetweenButtonsAndEditedText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKHighLightFlash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKFadeTimes(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKStartSoundHash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKSelectSoundHash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKCancelSoundHash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKMoveSoundHash(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKScreenBackGroundColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKTitleTextColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKTitleAreaBackGroundColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKButtonsTextColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKButtonsHighLightedTextColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKButtonsAreaBackGroundColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKEditedTextColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKEditedTextAreaBackGroundColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKFrameCornerTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKFrameEdgeTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKFrameBackGroundTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKFrameEdgeSizes(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKFrameBackGroundOffsets(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKFrameBackGroundColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKFrameEdgeColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetOSKFrameTextureColour(CoreCommand* io_command);
    CoreScripted::CommandReturn FnOSKSaveSettings(CoreCommand* io_command);
    CoreScripted::CommandReturn FnOSK(CoreCommand* io_command);
    CoreHash HandleFont(CoreCommand* io_command);
    CoreHash HandleTextureSet(CoreCommand* io_command);
    CoreHash HandleSoundHash(CoreCommand* io_command);
    void HandleColour(CoreRGBA& o_colour, CoreCommand* io_command);
    void HandleButtonText(CoreGameButtonText& o_buttonText, CoreCommand* io_command);
    void HandleFrameCornerTextures(CoreGameFrame& o_frame, CoreCommand* io_command);
    void HandleFrameEdgeTextures(CoreGameFrame& o_frame, CoreCommand* io_command);
    void HandleFrameBackGroundTextures(CoreGameFrame& o_frame, CoreCommand* io_command);
    void HandleFrameEdgeSizes(CoreGameFrame& o_frame, CoreCommand* io_command);
    void HandleFrameBackGroundOffsets(CoreGameFrame& o_frame, CoreCommand* io_command);
    void StartANewLevelGoing();
    void WorldCycle(CoreWorldUpdateStruct* lpoUpdateStruct);
    void* LoadAsset(uint32_t i_clientID, char* i_assetName, CoreHash i_assetHash, CoreHash i_assetType, bool i_asyncLoad, bool& o_fileExists, bool i_allocAsset);
    void* GetAsset(CoreHash i_assetHash, CoreHash i_assetType);
    bool UnLoadAsset(CoreHash i_assetHash, CoreHash i_assetType);
    void CancelAssetLoading();
    void UpdateAssetLoading();
    void WaitForAssetToLoad();
    void SetLoadingScreenTexSet(char* i_fileName, int32_t i_index);
    void RenderLoadingScreen(CoreGameRender* i_graphics, CoreTextureSet** i_textureSet);
    void SetLoadingScreen(CoreHash i_loadingScreen);
    void UpdateFade(float fTimeInput);
    void UpdateLevelSelect(CoreWorldUpdateStruct* lpoUpdateStruct);
    int32_t iCountLevels();
    void RenderLevelSelect(CoreGameRender* lpoGraphics);
    CoreLevel* CreateLevel();
    CoreAIController* CreateAIController(CoreMemory* io_memory);
    CoreDetect* CreateDetect(CoreMemory* io_memory);
    CorePanel* CreatePanel(CoreMemory* io_memory);
    CorePhysicsWorld* CreatePhysicsWorld(CoreMemory* io_memory);
    void DoDebugCallback(CoreDebugInput* i_input, CoreWorldUpdateStruct* lpoWorldUpdateStruct, int32_t iLevel, void* lpUserData);
    void AssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType, void* lpUsrData1, void* lpUsrData2);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType);
    float GetNumDetectCaches();
    bool CanICreateAsset(char* lpcFileName, CoreHash i_assetID, CoreHash assetType, void* lpUserData);
    bool CreateAsset(char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType, void* lpAssetPtr, void* lpUserData, CoreAssetManager* lpoAssetManager, bool bAsync);
    bool DeleteAsset(CoreHash i_assetID, CoreHash i_assetType, void* lpAssetPtr, void* lpUserData);
    bool MoveAsset(CoreHash i_assetID, CoreHash i_assetType, void* lpAssetPtr, void* lpUserData);
};

struct tagENUMLOGFONTA
{
    tagLOGFONTA elfLogFont;
    uint32_t elfFullName[64];
    uint32_t elfStyle[32];
};

struct tagMOUSEHOOKSTRUCT
{
    tagPOINT pt;
    HWND* hwnd;
    uint32_t wHitTestCode;
    uint32_t dwExtraInfo;
};

struct CAL1_AudioDriverConfigPC
{
    char* m_RegistryLocation;
    int32_t m_NumEnumDevices;
    CAL1_AudioRegistryEntry** m_DeviceTable;
    int32_t m_CurrentDeviceIndex;
    int32_t m_CurrentRegSelectedIndex;
    CAL1_AudioDriverPCTest* m_ADPCT;
    bool m_Initialised;
    bool m_UseWindowsDefaultDevice;
    bool m_EnableAudio;

    // TODO vtable

    void CAL1_AudioDriverConfigPC();
    void ~CAL1_AudioDriverConfigPC();
    void SelectNextQuality();
    void SelectPrevQuality();
    CAL1_AudioRegistryEntry* SelectNextDevice();
    CAL1_AudioRegistryEntry* SelectPrevDevice();
    int32_t GetCurrentDeviceIndex();
    CAL1_AudioRegistryEntry* GetSelectedRegistryEntry();
    void GetRegistrySettings();
    void Initialise();
    CAL1_AudioRegistryEntry* SelectDevice();
    void SaveSettings();
    int32_t GetNumItems();
    int32_t GetRegSelectedDevice();
    CAL1_AudioRegistryEntry* GetDefaultRegistryEntry();
    void SetUseWindowsDefaultDevice();
    bool GetUseWindowsDefaultDevice();
    void SetEnableAudio();
    bool GetEnableAudio();
    void CreateGUIDName();
    CAAudioError GetSettings_Reg();
    CAAudioError SetSettings_Reg();
    CAAudioError GetSettings();
    CAAudioError RegOpenKeyA();
    CAAudioError RegSetString();
    CAAudioError RegGetString();
    bool RegKeyExists();
};

struct CoreXMLNode_
{
    enum
    {
        CORE_XML_NODETYPE_TAG,
        CORE_XML_NODETYPE_COMMENT,
        CORE_XML_NODETYPE_SCHEMA,
        CORE_XML_NODETYPE_SCHEMAENTRY,
    };

    CoreXMLNode_* m_pParent;
    CoreXMLNode_* m_pChild;
    CoreXMLNode_* m_pNext;
    CoreXMLNode_* m_pPrev;
    uint32_t m_uValue;
    int32_t m_sValue;
    float m_fValue;
    uint32_t m_bValue;
    void* m_pValue;
    CoreXMLAttributeNode* m_pAttr;
    CoreXMLDocString* m_pName;
    CoreXMLDocString* m_pCData;
    CoreXMLDoc* m_pDoc;
    uint32_t m_Flags;
    uint32_t m_NodeType;
    uint32_t m_DataType;
    uint32_t m_lCData;
    uint32_t m_lCDataMem;

    void CoreXMLNode_();
    void ~CoreXMLNode_();
    CoreXMLNode_* AddChild();
    CoreXMLNode_* AddNewChild();
    CoreXMLNode_* AddSibling();
    CoreXMLNode_* AddNewSibling();
    CoreXMLNode_* GetFirstChild();
    CoreXMLNode_* GetLastChild();
    CoreXMLNode_* Next();
    CoreXMLNode_* Prev();
    CoreXMLNode_* Parent();
    CoreXMLNode_* Child();
    CoreXMLNode_* Prune();
    bool HasChild();
    bool HasParent();
    bool HasNext();
    bool HasPrev();
    void SetDoc();
    CoreXMLDoc* GetDoc();
    bool SetName();
    void SetNodeType();
    void SetFlags();
    void AddFlags();
    void RemoveFlags();
    bool CompareName();
    char* GetName();
    uint32_t GetNodeType();
    CoreXMLNode_* Find();
    CoreXMLNode_* FindOuter();
    CoreXMLNode_* FindInner();
    CoreXMLNode_* FindElement();
    CoreXMLNode_* GetNode();
    CoreXMLAttributeNode* AddAttribute();
    CoreXMLAttributeNode* AddAttributeAsFloat();
    CoreXMLAttributeNode* AddAttributeAsInt();
    CoreXMLAttributeNode* AddAttributeAsBool();
    CoreXMLAttributeNode* GetFirstAttribute();
    bool HasAttribute();
    CoreXMLAttributeNode* FindAttribute();
    char* GetAttributeValueAsString();
    int32_t GetAttributeValueAsInt();
    float GetAttributeValueAsFloat();
    bool GetAttributeValueAsBool();
    CoreHash GetAttributeValueAsHash();
    CoreXMLAttributeNode* FindAttributeInTag();
    char* GetAttributeInTagAsString();
    void* GetAttributeInTagAsVoid();
    int32_t GetAttributeInTagAsInt();
    float GetAttributeInTagAsFloat();
    bool GetAttributeInTagAsBool();
    CORE_XML_TYPE GetDataType();
    void SetDataType();
    uint32_t SetCData();
    uint32_t AppendCData();
    bool HasCData();
    uint32_t GetValue();
    char* GetValueAsString();
    void* GetValueAsVoid();
    int32_t GetValueAsInt();
    float GetValueAsFloat();
    bool GetValueAsBool();
    CoreHash GetValueAsHash();
    bool GetValueAsVector3();
    bool GetValueAsVector4();
    bool GetValueAsMatrix();
    void SetCDataAsString();
    void SetCDataAsInt();
    void SetCDataAsFloat();
    void SetCDataAsBool();
    void SetCDataAsVector3();
    void SetCDataAsVector4();
    void SetCDataAsMatrix();
    bool ConvertToType();
    void Initialize();
    bool StringToBool();
    int32_t StringToInt();
    float StringToFloat();
    void RemoveName();
    void RemoveCData();
};

struct CAL0_AudioCodecADPCM
{
    struct SOUND_CONVERT_PERSISTENT_ADPCM_DATA
    {
        int32_t start_left_sample;
        int32_t start_left_step;
        int32_t start_right_sample;
        int32_t start_right_step;

        void ResetState();
        void SOUND_CONVERT_PERSISTENT_ADPCM_DATA();
    };

    struct adpcm_state
    {
        int32_t valprev_l;
        char index_l;
        int32_t valprev_r;
        char index_r;
    };

    static int32_t indexTable[16];
    static int32_t stepsizeTable[89];
    CAL0_AudioCodecADPCM::SOUND_CONVERT_PERSISTENT_ADPCM_DATA m_PersistantState;

    // TODO vtable

    void CAL0_AudioCodecADPCM();
    void ~CAL0_AudioCodecADPCM();
    bool DecodeData(void* input, uint32_t encodedDataLength, uint32_t numChannels, void* output);
    bool EncodeData();
    uint32_t GetEncodedLength();
    uint32_t GetDecodedLength();
    void ResetCodec();
    void UpdateEncodeProgress();
    void UpdateDecodeProgress();
    int32_t Sound_Convert_DataSize_16Bit_To_ADPCM();
    int32_t Sound_Convert_DataSize_ADPCM_To_16Bit();
    void Sound_Convert_16BitMono_To_ADPCM();
    void Sound_Convert_16BitStereo_To_ADPCM();
    void Sound_Convert_ADPCM_To_16BitMono(char* indata, int32_t* outdata, int32_t sample_count, CAL0_AudioCodecADPCM::SOUND_CONVERT_PERSISTENT_ADPCM_DATA& persistent_data);
    void Sound_Convert_ADPCM_To_16BitStereo(char* indata, int32_t* outdata, int32_t sample_count, CAL0_AudioCodecADPCM::SOUND_CONVERT_PERSISTENT_ADPCM_DATA& persistent_data);
    void Sound_Convert_ADPCM_To_8BitMono();
    void Sound_Convert_ADPCM_To_8BitStereo();
    int32_t Sound_Convert_DataSize_16Bit_To_MPGAAC();
    int32_t Sound_Convert_DataSize_MPGAAC_To_16Bit();
    int32_t Sound_Convert_16Bit_To_MPGAAC();
    void Sound_Convert_MPGAAC_To_16Bit();
    bool encode16BitPCM_DLH();
    bool decode4BitADPCM_DLH(uint32_t* ADPCMData, uint32_t encodedDataLength, uint32_t numChannels, int32_t* decodedPCMDataPointer, CAL0_AudioCodecADPCM::SOUND_CONVERT_PERSISTENT_ADPCM_DATA* persistant);
};

struct CoreGameTextUnit
{
    uint32_t m_version;
    CoreHashArray m_array;

    char* GetString();
    bool CheckVersion();
    uint32_t GetPlatformVersion();
    uint32_t GetVersion();
    char* RetrieveString(CoreHash i_id);
    void CoreGameTextUnit();
    void ~CoreGameTextUnit();
};

struct tagMOUSEKEYS
{
    uint32_t cbSize;
    uint32_t dwFlags;
    uint32_t iMaxSpeed;
    uint32_t iTimeToMaxSpeed;
    uint32_t iCtrlSpeed;
    uint32_t dwReserved1;
    uint32_t dwReserved2;
};

struct tagMONMSGSTRUCT
{
    uint32_t cb;
    HWND* hwndTo;
    uint32_t dwTime;
    void* hTask;
    uint32_t wMsg;
    uint32_t wParam;
    int32_t lParam;
    tagDDEML_MSG_HOOK_DATA dmhd;
};

struct _PSHNOTIFY
{
    tagNMHDR hdr;
    int32_t lParam;
};

struct CoreString
{
    char* m_string;
    int32_t m_stringLength;
    int32_t m_sizeAllocated;

    void CoreString();
    CoreString& operator=();
    void ~CoreString();
    int32_t GetLength();
    bool IsEmpty();
    void operator+=();
    void AddN();
    void Reset();
    void Truncate();
    char* lpcPtr();
    char* operator const char *();
    int32_t VPrint();
    int32_t Print();
    bool operator==();
    bool operator!=();
    int32_t Find();
    int32_t ReverseFind();
    CoreString SubString();
    void ToLower();
    void ToUpper();
    CoreArray<CoreString> Split();
    void Free();
    void Construct();
    bool Resize();
    bool Extend();
    bool SetSize();
};

struct _RPC_POLICY
{
    uint32_t Length;
    uint32_t EndpointFlags;
    uint32_t NICFlags;
};

struct tagEMRSTRETCHBLT
{
    tagEMR emr;
    _RECTL rclBounds;
    int32_t xDest;
    int32_t yDest;
    int32_t cxDest;
    int32_t cyDest;
    uint32_t dwRop;
    int32_t xSrc;
    int32_t ySrc;
    tagXFORM xformSrc;
    uint32_t crBkColorSrc;
    uint32_t iUsageSrc;
    uint32_t offBmiSrc;
    uint32_t cbBmiSrc;
    uint32_t offBitsSrc;
    uint32_t cbBitsSrc;
    int32_t cxSrc;
    int32_t cySrc;
};

struct _ACCESS_DENIED_CALLBACK_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t SidStart;
};

struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION
{
    uint32_t SecurityLimitFlags;
    void* JobToken;
    _TOKEN_GROUPS* SidsToDisable;
    _TOKEN_PRIVILEGES* PrivilegesToDelete;
    _TOKEN_GROUPS* RestrictedSids;
};

struct _userSTGMEDIUM
{
    struct _STGMEDIUM_UNION
    {
        union __MIDL_IAdviseSink_0003
        {
            _userHMETAFILEPICT* hMetaFilePict;
            _userHENHMETAFILE* hHEnhMetaFile;
            _GDI_OBJECT* hGdiHandle;
            _userHGLOBAL* hGlobal;
            uint32_t* lpszFileName;
            _BYTE_BLOB* pstm;
            _BYTE_BLOB* pstg;
        };

        uint32_t tymed;
        _userSTGMEDIUM::_STGMEDIUM_UNION::__MIDL_IAdviseSink_0003 u;
    };

    IUnknown* pUnkForRelease;
};

struct CoreGsSt
{
    float S;
    float T;
};

struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY
{
    uint32_t FuncStart;
    uint32_t PrologLen : 8;
    uint32_t FuncLen : 22;
    uint32_t ThirtyTwoBit : 1;
    uint32_t ExceptionFlag : 1;
};

struct _REASSIGN_BLOCKS
{
    uint32_t Reserved;
    uint32_t Count;
    uint32_t BlockNumber[1];
};

struct tagSERIALKEYSA
{
    uint32_t cbSize;
    uint32_t dwFlags;
    char* lpszActivePort;
    char* lpszPort;
    uint32_t iBaudRate;
    uint32_t iPortState;
    uint32_t iActive;
};

union tagCY
{
    uint32_t Lo;
    int32_t Hi;
    int32_t int64;
};

struct _VOLUME_DISK_EXTENTS
{
    uint32_t NumberOfDiskExtents;
    _DISK_EXTENT Extents[1];
};

struct CoreArray<CoreString>
{
    CoreString* m_lpoContents;
    int32_t m_iAllocSize;
    int32_t m_iArraySize;
    bool m_allowResize;
    int32_t m_startAllocSize;

    void CoreArray<CoreString>();
    void SetAllowResize();
    void ~CoreArray<CoreString>();
    int32_t GetSize();
    void Insert();
    void Remove();
    void operator+=();
    bool CanFit();
    void Reset();
    void SetSize();
    void Resize();
    CoreString* operator const class CoreString *();
    CoreString* operator class CoreString *();
    CoreString& GetElement();
    CoreString* GetArray();
    bool operator==();
    bool operator!=();
    CoreString& operator[]();
};

struct CoreGroundVolume
{
    CoreVector boxMin;
    CoreVector boxMax;
    CoreVector2D* points;
    float bottomY;
    float topY;
    int32_t numPoints;

    void CoreGroundVolume();
};

struct CoreGeometry
{
    enum
    {
        VERSION = 14,
    };

    enum CoreInViewEnum
    {
        COMPLETELY_OUTSIDE,
        COMPLETELY_INSIDE,
        PARTIAL,
    };

    // TODO vtable

    uint32_t GetVersion();
    bool IsPointInFront();
    bool IsPointInFront2(CoreVector& i_origin, CoreEulerAngle& i_orient, CoreVector& i_target, float& o_dist);
    bool IsPointOnLeft(CoreVector& i_origin, CoreVector& i_reference, CoreVector& i_target);
    bool IsPointInPoly3D(CoreVector* i_verts, CorePlaneEquation& i_plane, CoreVector& i_point);
    bool IsPointInPoly2D(CoreVector* i_verts, CoreVector& i_point, float i_tolerance);
    bool IsPointInPoly3DVector();
    CoreVector LineToPlaneIntersect(CorePlaneEquation& i_plane, CoreVector& i_lineA, CoreVector& i_lineVector);
    bool SphereAABBIntersect(CoreVector iBoxMin, CoreVector iBoxMax, CoreVector iSpherePos, float iSphereRad);
    float SplineLength(float i_min, float i_max, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3);
    float SpeedOnSpline(float i_alpha, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3);
    CoreVector PointOnSpline(float i_alpha, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3);
    CoreVector TangentOnSpline(float i_alpha, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3);
    float DistanceFromPointToLine(CoreVector& i_point, CoreVector& i_lineA, CoreVector& i_lineB, CoreVector& o_pointOnLineClosest);
    float DistanceFromPointToSpline(CoreVector& i_point, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3, CoreVector& o_pointOnLineClosest, float& o_segmentDistance, float& o_segmentAlpha);
    CoreVector PointOnLineClosestToPoint(CoreVector& i_point, CoreVector& i_lineA, CoreVector& i_lineB);
    bool LineToSphereIntersection(CoreVector& i_sphereCentre, float i_detSphereCentre, CoreVector& i_lineOrigin, CoreVector& i_lineVector, float& o_intersection1, float& o_intersection2);
    void MakeTriangleBoundingSphere();
    void MakeTriangleBoundingBox(CoreVector& i_pos0, CoreVector& i_pos1, CoreVector& i_pos2, CoreVector& o_min, CoreVector& o_max);
    void MakeLineBoundingBox(CoreVector& i_start, CoreVector& i_end, CoreVector& o_min, CoreVector& o_max);
    bool SpheresIntersect(CoreVector& i_centre1, float i_radius1, CoreVector& i_centre2, float i_radius2);
    bool BBoxesIntersect(CoreVector& i_min1, CoreVector& i_max1, CoreVector& i_min2, CoreVector& i_max2, float i_tolerance);
    bool LineIntersectsBBox(CoreVector& i_lineStart, CoreVector& i_lineEnd, CoreVector& i_boxMin, CoreVector& i_boxMax);
    void MakeBoxBoundingSphere(CoreVector& i_posA, CoreVector& i_posB, CoreVector& o_centre, float& o_radius);
    bool WithinBBox(CoreVector& i_pos, CoreVector& i_min, CoreVector& i_max, float i_tolerance);
    bool WithinBBoxInclusive();
    float DistanceToBBox(CoreVector& i_point, CoreVector& i_min, CoreVector& i_max);
    bool IsWithinVolume();
    void ComputeVolumeBBox();
    void RemoveRedundantPoints();
    bool ShrinkVolume();
    bool LineToLineIntersect3D();
    bool LineToLineIntersect2D(CoreVector& i_line1Pos, CoreVector& i_line1Vect, CoreVector& i_line2Pos, CoreVector& i_line2Vect, float& o_howFar, CoreVector& o_pos);
    bool KeepPointOnLineWithinLineLimits(CoreVector& i_lineA, CoreVector& i_lineB, CoreVector& o_point);
    bool LineToCylinderIntersection(CoreVector& i_start, CoreVector& i_dir, CoreVector& i_cylBase, CoreVector& i_cylTop, float i_radius, float& o_pos1, float& o_pos2);
    bool LineToPolygonIntersection(CoreVector& o_intersection, CoreVector& i_start, CoreVector& i_end, CoreVector& i_dir, CoreVector* i_verts);
    bool SphereConeIntersect();
    bool SphereConeFindIntersect();
    bool SphereFiniteConeIntersect();
    bool LineConeIntersect();
    bool LineConeIntersectWithIntersectData();
    bool InfiniteLineInfiniteConeIntersection();
    bool LineConeEndIntersection();
    bool PointInFiniteCone();
    bool ClampPointWithinFiniteCone();
    bool CircleTangentLinePointsXZ();
    bool CircleTangentLinePointsXZClamped();
    CoreGeometry::CoreInViewEnum OverlapPlane();
    void ComputeAABB(CoreMatrix i_transform, CoreVector i_inputBboxMin, CoreVector i_inputBboxMax, CoreVector& o_bboxMin, CoreVector& o_bboxMax);
    float GetDeltaHeadingXZ();
    bool SphereClippingFustrum();
    bool BBoxClippingFustrum();
    bool SphereInViewFustrum(CoreVector* clipPlane, CoreVector* guardPlane, CoreVector& pos, float sqRadius);
    bool BBoxInViewFustrum(CoreVector* clipPlane, CoreVector* guardPlane, CoreVector& bbMin, CoreVector& bbMax);
    bool BBoxCompletelyInViewFustrum();
    void CoreGeometry();
    void ~CoreGeometry();
    void YouCannotInstanceThisClass();
};

struct _wireSAFEARR_HAVEIID
{
    uint32_t Size;
    IUnknown** apUnknown;
    _GUID iid;
};

struct ANON_OBJECT_HEADER
{
    uint32_t Sig1;
    uint32_t Sig2;
    uint32_t Version;
    uint32_t Machine;
    uint32_t TimeDateStamp;
    _GUID ClassID;
    uint32_t SizeOfData;
};

struct _RTL_CRITICAL_SECTION_DEBUG
{
    uint32_t Type;
    uint32_t CreatorBackTraceIndex;
    _RTL_CRITICAL_SECTION* CriticalSection;
    _LIST_ENTRY ProcessLocksList;
    uint32_t EntryCount;
    uint32_t ContentionCount;
    uint32_t Spare[2];
};

struct _BYTE_BLOB
{
    uint32_t clSize;
    uint32_t abData[1];
};

struct CoreAnimationSet
{
    enum
    {
        VERSION = 36,
    };

    static uint32_t s_animationSetID;
    uint32_t m_uiVersion;
    uint32_t m_oFileID;
    int32_t m_iNumAnims;
    int32_t m_iJointTableOffset;
    int32_t m_iAnimInfoTableOffset;
    int32_t m_iJointHashesOffset;
    int32_t m_iAnimTableOffset;

    uint32_t GetVersion();
    bool CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
    void CoreAnimationSet();
    void ~CoreAnimationSet();
    int32_t GetNumAnims();
    int32_t GetNumJoints();
    int32_t GetIndexByAnimID(CoreHash i_animID);
    float GetEndTime(CoreHash oAnimName);
    CoreEulerAngle GetOrientationChange(CoreHash oAnimName, float fStartTime, float fEndTime, bool mirror);
    CoreQuat GetOrientationChangeQuat();
    CoreVector GetPositionChange(CoreHash oAnimName, float fStartTime, float fEndTime, bool mirror);
    CoreVector GetVelocityPosition(CoreHash i_animName, float i_time, bool i_mirror);
    CoreEulerAngle GetVelocityOrientation();
    bool IsLooping();
    bool AnimHasVelocity();
    bool bDoesTimeMarkerExist();
    float GetTimeMarkerStartTime(CoreHash oAnimName, int32_t index);
    float GetTimeMarkerEndTime(CoreHash oAnimName, int32_t index);
    uint32_t GetTimeMarkerName(CoreHash oAnimName, int32_t index);
    int32_t GetNumTimeMarkers(CoreHash oAnimName);
    bool bDoesMarkerExist();
    CoreVector GetSubObjectMarkerPosition(CoreHash oAnimName, CoreHash oMarkerName, float fTime);
    CoreEulerAngle GetSubObjectMarkerOrientation(CoreHash oAnimName, CoreHash oMarkerName, float fTime);
    CoreVector GetSubObjectMarkerScale(CoreHash oAnimName, CoreHash oMarkerName, float fTime);
    CoreSubObjectMarkerData::eSubObjectMarkerStateEnum GetSubObjectMarkerState(CoreHash oAnimName, CoreHash oMarkerName, float fTime);
    float GetSubObjectMarkerStartTime();
    float GetSubObjectMarkerEndTime();
    int32_t GetNumSubObjectMarkers(CoreHash oAnimName);
    CoreHash GetSubObjectMarkerHash(CoreHash oAnimName, int32_t iSubObjectMarkerIndex);
    bool UpdateJointState(int32_t i_joint, CoreHash i_anim, float i_time, CoreHashArray* i_skeletonJointIndexTable, CoreJointState* o_jointState, bool i_mirror);
    void UpdateJointStates(CoreHash oAnim, float fTime, CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates, bool mirror);
    void UpdateJointStatesByBone(CoreHash oAnim, float fTime, CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates, bool mirror, bool* bones);
    void BlendJointStates();
    void UpdateBlendShapeTargetAlphaValues(CoreHash oAnim, float fTime, float* lpfBlendShapeAlphaValues, bool* lpbOverrideBlendShapeTarget);
    CoreAnimData* GetAnimPtr(CoreHash oAnimName);
    bool CheckVersion();
    bool CheckID();
    uint32_t GetPlatformVersion();
    uint32_t GetID();
    CoreHashArray* GetJointTable();
    CoreHashArray* GetAnimInfoTable();
    int32_t* GetAnimTable();
    uint32_t* GetJointHashTablePtr();
    CoreAnimData* GetAnimDataPtr();
    uint32_t GetJointHash();
};

struct CoreAnimData
{
    enum
    {
        VERSION = 10,
    };

    enum CoreAnimFlagsEnum
    {
        CORE_ANIMFLAGS_LOOPING_BIT,
    };

    int32_t m_iNumJoints;
    int32_t m_iNumBlendShapes;
    int32_t m_iNumSOMs;
    int32_t m_iNumTimeMarkers;
    float m_fEndTime;
    uint32_t m_uiFlags;
    int32_t m_iJointOffsetTableOffset;
    int32_t m_iSOMOffset;
    int32_t m_iTimeMarkersOffset;
    CoreJointData m_oVelocityData;

    void CoreAnimData();
    void ~CoreAnimData();
    float GetEndTime();
    bool IsLooping();
    bool HasVelocity(bool& o_posVel, bool& o_rotVel);
    CoreEulerAngle GetOrientationChange(float fStartTime, float fEndTime, bool mirror);
    CoreQuat GetOrientationChangeQuat(float fStartTime, float fEndTime, bool mirror);
    CoreVector GetPositionChange(float fStartTime, float fEndTime, bool mirror);
    bool UpdateJointState(int32_t i_joint, float i_time, CoreHashArray* i_skeletonJointIndexTable, CoreHashArray* i_animDataJointIndexTable, CoreJointState* o_jointState, bool i_mirror);
    void UpdateJointStates(float fTime, uint32_t* uiJointHashes, CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates, bool mirror);
    void UpdateJointStatesByBone(float fTime, uint32_t* uiJointHashes, CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates, bool mirror, bool* bones);
    void BlendJointStates();
    void UpdateBlendShapeTargetAlphaValues(float fTime, float* lpfBlendShapeAlphaValues, bool* lpbOverrideBlendShapeTarget);
    bool bDoesTimeMarkerExist();
    float GetTimeMarkerStartTime(int32_t index);
    float GetTimeMarkerEndTime(int32_t index);
    uint32_t GetTimeMarkerName(int32_t index);
    bool bDoesMarkerExist();
    CoreVector GetSOMPosition(CoreHash oMarkerName, float fTime);
    CoreEulerAngle GetSOMOrientation(CoreHash oMarkerName, float fTime);
    CoreVector GetSOMScale(CoreHash oMarkerName, float fTime);
    CoreSubObjectMarkerData::eSubObjectMarkerStateEnum GetSOMState(CoreHash oMarkerName, float fTime);
    float GetSOMStartTime(CoreHash oMarkerName);
    float GetSOMEndTime(CoreHash oMarkerName);
    int32_t GetNumSOMs();
    int32_t GetNumTimeMarkers();
    CoreHash GetSOMHash(int32_t iIndex);
    int32_t GetNumBlendShapes();
    CoreVector GetPosition(float fTime);
    CoreEulerAngle GetOrientation();
    CoreQuat GetOrientationAsQuat(float fTime);
    CoreVector GetVelocityPosition(float i_time, bool i_mirror);
    CoreEulerAngle GetVelocityOrientation(float i_time, bool i_mirror);
    int32_t* GetJointOffsetTable();
    CoreJointData* GetJointDataPtr();
    CoreJointData* GetVelocityDataPtr();
    CoreJointData* GetSOMJointDataPtr();
    CoreJointData* GetSOMJointDataByName(CoreHash oSOMName);
    CoreSubObjectMarkerData* GetSOMByName(CoreHash oSOMName);
    CoreSubObjectMarkerData* GetSOMPtr();
    CoreTimeMarker* GetTimeMarkerPtrByName();
    CoreTimeMarker* GetTimeMarkerPtr();
    CoreBlendShapeData* GetBlendShapeDataPtr();
    float GetCurveValue();
    bool GetCurveValueBool();
    CoreVector GetCurveValueVector();
    CoreQuat GetCurveValueQuat();
    int32_t GetNumJoints();
    uint32_t GetHashFromJointNumber(int32_t i_joint, CoreHashArray* i_jointIndexTable, bool& io_mirror);
    int32_t GetMirrorJoint();
};

struct tagEMREXTESCAPE
{
    tagEMR emr;
    int32_t iEscape;
    int32_t cbEscData;
    uint32_t EscData[1];
};

struct tagEVENTMSG
{
    uint32_t message;
    uint32_t paramL;
    uint32_t paramH;
    uint32_t time;
    HWND* hwnd;
};

struct CoreArray<enum CorePlatformVersion::CorePlatformVersionEnum>
{
    CorePlatformVersion::CorePlatformVersionEnum* m_lpoContents;
    int32_t m_iAllocSize;
    int32_t m_iArraySize;
    bool m_allowResize;
    int32_t m_startAllocSize;

    void CoreArray<enum CorePlatformVersion::CorePlatformVersionEnum>();
    void SetAllowResize();
    void ~CoreArray<enum CorePlatformVersion::CorePlatformVersionEnum>();
    int32_t GetSize();
    void Insert();
    void Remove();
    void operator+=();
    bool CanFit();
    void Reset();
    void SetSize();
    void Resize();
    CorePlatformVersion::CorePlatformVersionEnum* operator const enum CorePlatformVersion::CorePlatformVersionEnum *();
    CorePlatformVersion::CorePlatformVersionEnum* operator enum CorePlatformVersion::CorePlatformVersionEnum *();
    CorePlatformVersion::CorePlatformVersionEnum& GetElement();
    CorePlatformVersion::CorePlatformVersionEnum* GetArray();
    bool operator==();
    bool operator!=();
    CorePlatformVersion::CorePlatformVersionEnum& operator[]();
};

struct CoreGameMessageBox : CoreMessageBoxInterface
{
    static CoreGameButtonText OkButtonText;
    static CoreGameButtonText NoButtonText;
    static CoreGameButtonText YesButtonText;
    static CoreGameButtonText RetryButtonText;
    static CoreGameButtonText CancelButtonText;
    char* m_buffer;
    uint32_t m_bufferSize;
    CoreGameMessageBoxButtons m_buttons;
    void* m_finishedCallBack;
    void* m_callBackUserData;
    bool m_failed;
    bool m_canceled;
    bool m_finished;
    float m_timeStarted;
    float m_timeStopping;
    float m_alphaScaler;
    float m_fadeDownTimeScaler;
    static int32_t m_controllerInputIndex;
    static int32_t m_overrideControllerInputIndex;
    static bool m_overrideActive;
    static bool m_overrideStopping;
    static CoreHash m_overrideTextHash;
    static CoreGameMessageBoxButtons m_overrideButtons;
    static CoreFader m_overrideFader;
    static void* m_overrideRenderCallBack;
    static void* m_overrideRenderCallBackUserData;

    void CoreGameMessageBox();
    void DeleteInstance();
    bool Start(void* i_finishedCallBack, void* i_callBackUserData, char* i_fmtString);
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    bool IsReady();
    char* GetCommonDialogTitle();
    void Render(CoreGameRender* io_graphics, CoreFont* i_font, int32_t i_renderFlags, CoreGameMessageBoxButtons& i_buttons, char* i_text, bool i_shouldFlash, float i_alphaScaler, float i_offsetX, float i_offsetY);
    bool StartOverride();
    bool StopOverride();
    bool IsAnyOverrideActive();
    bool IsThisOverrideActive();
    void SetControllerInputIndex();
    void SetOverrideControllerInputIndex();
    void Finished();
};

struct tagMCI_SAVE_PARMSA
{
    uint32_t dwCallback;
    char* lpfilename;
};

struct _SID_IDENTIFIER_AUTHORITY
{
    uint32_t Value[6];
};

struct _SESSION_HEADER
{
    uint32_t sess_name;
    uint32_t num_sess;
    uint32_t rcv_dg_outstanding;
    uint32_t rcv_any_outstanding;
};

struct _PRINTER_INFO_1A
{
    uint32_t Flags;
    char* pDescription;
    char* pName;
    char* pComment;
};

struct IPropertyBag : IUnknown
{
    HRESULT __stdcall Read();
    HRESULT __stdcall Write();
    void IPropertyBag();
};

struct CoreGenericHeader
{
    uint32_t ID;
    uint32_t version;
    uint32_t length;
    uint32_t name;
};

struct IEnumString : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumString();
};

struct _CERT_POLICY_MAPPINGS_INFO
{
    uint32_t cPolicyMapping;
    _CERT_POLICY_MAPPING* rgPolicyMapping;
};

struct IRpcProxyBuffer : IUnknown
{
    HRESULT __stdcall Connect();
    void __stdcall Disconnect();
    void IRpcProxyBuffer();
};

struct ISynchronizeEvent : ISynchronizeHandle
{
    HRESULT __stdcall SetEventHandle();
    void ISynchronizeEvent();
};

struct _IMAGE_VXD_HEADER
{
    uint32_t e32_magic;
    uint32_t e32_border;
    uint32_t e32_worder;
    uint32_t e32_level;
    uint32_t e32_cpu;
    uint32_t e32_os;
    uint32_t e32_ver;
    uint32_t e32_mflags;
    uint32_t e32_mpages;
    uint32_t e32_startobj;
    uint32_t e32_eip;
    uint32_t e32_stackobj;
    uint32_t e32_esp;
    uint32_t e32_pagesize;
    uint32_t e32_lastpagesize;
    uint32_t e32_fixupsize;
    uint32_t e32_fixupsum;
    uint32_t e32_ldrsize;
    uint32_t e32_ldrsum;
    uint32_t e32_objtab;
    uint32_t e32_objcnt;
    uint32_t e32_objmap;
    uint32_t e32_itermap;
    uint32_t e32_rsrctab;
    uint32_t e32_rsrccnt;
    uint32_t e32_restab;
    uint32_t e32_enttab;
    uint32_t e32_dirtab;
    uint32_t e32_dircnt;
    uint32_t e32_fpagetab;
    uint32_t e32_frectab;
    uint32_t e32_impmod;
    uint32_t e32_impmodcnt;
    uint32_t e32_impproc;
    uint32_t e32_pagesum;
    uint32_t e32_datapage;
    uint32_t e32_preload;
    uint32_t e32_nrestab;
    uint32_t e32_cbnrestab;
    uint32_t e32_nressum;
    uint32_t e32_autodata;
    uint32_t e32_debuginfo;
    uint32_t e32_debuglen;
    uint32_t e32_instpreload;
    uint32_t e32_instdemand;
    uint32_t e32_heapsize;
    uint32_t e32_res3[12];
    uint32_t e32_winresoff;
    uint32_t e32_winreslen;
    uint32_t e32_devid;
    uint32_t e32_ddkver;
};

struct _SHCREATEPROCESSINFOW
{
    uint32_t cbSize;
    uint32_t fMask;
    HWND* hwnd;
    uint32_t* pszFile;
    uint32_t* pszParameters;
    uint32_t* pszCurrentDirectory;
    void* hUserToken;
    _SECURITY_ATTRIBUTES* lpProcessAttributes;
    _SECURITY_ATTRIBUTES* lpThreadAttributes;
    int32_t bInheritHandles;
    uint32_t dwCreationFlags;
    _STARTUPINFOW* lpStartupInfo;
    _PROCESS_INFORMATION* lpProcessInformation;
};

struct tagDEC
{
    uint32_t wReserved;
    uint32_t scale;
    uint32_t sign;
    uint32_t signscale;
    uint32_t Hi32;
    uint32_t Lo32;
    uint32_t Mid32;
    uint32_t Lo64;
};

struct CAL1_SRAMSaver : CAL0_FileSaver
{
    CAL1_AudioDriver* m_AD;
    CAL1_AudioItemDatabase* m_AID;
    uint32_t* m_SAMDData;
    uint32_t* m_SAMMData;
    CA_ExpFmt m_ExportFormat;
    int32_t m_LanguageIndex;
    int32_t m_PlatformIndex;

    void CAL1_SRAMSaver();
    void ~CAL1_SRAMSaver();
    void SetExportFormat();
    void SetLanguageIndex();
    void SetPlatformIndex();
    CAAudioError AssembleSections();
    CAAudioError DestroySections();
    CAAudioError AssembleSAMMAndSAMD();
    CAAudioError DestroySAMMAndSAMD();
};

struct _DSCFXAec
{
    int32_t fEnable;
    int32_t fNoiseFill;
    uint32_t dwMode;
};

struct _CERT_POLICY_CONSTRAINTS_INFO
{
    int32_t fRequireExplicitPolicy;
    uint32_t dwRequireExplicitPolicySkipCerts;
    int32_t fInhibitPolicyMapping;
    uint32_t dwInhibitPolicyMappingSkipCerts;
};

struct _MONITOR_INFO_2W
{
    uint32_t* pName;
    uint32_t* pEnvironment;
    uint32_t* pDLLName;
};

struct _WIN32_FILE_ATTRIBUTE_DATA
{
    uint32_t dwFileAttributes;
    _FILETIME ftCreationTime;
    _FILETIME ftLastAccessTime;
    _FILETIME ftLastWriteTime;
    uint32_t nFileSizeHigh;
    uint32_t nFileSizeLow;
};

struct _MMCKINFO
{
    uint32_t ckid;
    uint32_t cksize;
    uint32_t fccType;
    uint32_t dwDataOffset;
    uint32_t dwFlags;
};

struct _PRINTER_ENUM_VALUESA
{
    char* pValueName;
    uint32_t cbValueName;
    uint32_t dwType;
    uint32_t* pData;
    uint32_t cbData;
};

struct CoreCurveDataSegment
{
    float m_fCurveLength;
    int32_t m_BBOXminX;
    int32_t m_BBOXminY;
    int32_t m_BBOXminZ;
    int32_t m_BBOXmaxX;
    int32_t m_BBOXmaxY;
    int32_t m_BBOXmaxZ;
};

struct _CRYPT_PASSWORD_CREDENTIALSW
{
    uint32_t cbSize;
    uint32_t* pszUsername;
    uint32_t* pszPassword;
};

struct _OSVERSIONINFOEXA
{
    uint32_t dwOSVersionInfoSize;
    uint32_t dwMajorVersion;
    uint32_t dwMinorVersion;
    uint32_t dwBuildNumber;
    uint32_t dwPlatformId;
    char szCSDVersion[128];
    uint32_t wServicePackMajor;
    uint32_t wServicePackMinor;
    uint32_t wSuiteMask;
    uint32_t wProductType;
    uint32_t wReserved;
};

struct tMIXERCONTROLDETAILS_SIGNED
{
    int32_t lValue;
};

struct CoreRandom
{
    void Seed();
    int32_t GetRandom31();
    uint32_t GetRandom32();
};

struct _IMAGE_OPTIONAL_HEADER
{
    uint32_t Magic;
    uint32_t MajorLinkerVersion;
    uint32_t MinorLinkerVersion;
    uint32_t SizeOfCode;
    uint32_t SizeOfInitializedData;
    uint32_t SizeOfUninitializedData;
    uint32_t AddressOfEntryPoint;
    uint32_t BaseOfCode;
    uint32_t BaseOfData;
    uint32_t ImageBase;
    uint32_t SectionAlignment;
    uint32_t FileAlignment;
    uint32_t MajorOperatingSystemVersion;
    uint32_t MinorOperatingSystemVersion;
    uint32_t MajorImageVersion;
    uint32_t MinorImageVersion;
    uint32_t MajorSubsystemVersion;
    uint32_t MinorSubsystemVersion;
    uint32_t Win32VersionValue;
    uint32_t SizeOfImage;
    uint32_t SizeOfHeaders;
    uint32_t CheckSum;
    uint32_t Subsystem;
    uint32_t DllCharacteristics;
    uint32_t SizeOfStackReserve;
    uint32_t SizeOfStackCommit;
    uint32_t SizeOfHeapReserve;
    uint32_t SizeOfHeapCommit;
    uint32_t LoaderFlags;
    uint32_t NumberOfRvaAndSizes;
    _IMAGE_DATA_DIRECTORY DataDirectory[16];
};

struct _IMAGE_COFF_SYMBOLS_HEADER
{
    uint32_t NumberOfSymbols;
    uint32_t LvaToFirstSymbol;
    uint32_t NumberOfLinenumbers;
    uint32_t LvaToFirstLinenumber;
    uint32_t RvaToFirstByteOfCode;
    uint32_t RvaToLastByteOfCode;
    uint32_t RvaToFirstByteOfData;
    uint32_t RvaToLastByteOfData;
};

struct _IMAGE_SYMBOL
{
    _IMAGE_SYMBOL::__unnamed N;
    uint32_t Value;
    int32_t SectionNumber;
    uint32_t Type;
    uint32_t StorageClass;
    uint32_t NumberOfAuxSymbols;
};

struct tagEMRPOLYLINE16
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t cpts;
    tagPOINTS apts[1];
};

struct tagEMRPOLYDRAW
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t cptl;
    _POINTL aptl[1];
    uint32_t abTypes[1];
};

struct tagMENUBARINFO
{
    uint32_t cbSize;
    tagRECT rcBar;
    HMENU__* hMenu;
    HWND* hwndMenu;
    int32_t fBarFocused : 1;
    int32_t fFocused : 1;
};

struct _BYTE_SIZEDARR
{
    uint32_t clSize;
    uint32_t* pData;
};

struct _DRIVER_INFO_3W
{
    uint32_t cVersion;
    uint32_t* pName;
    uint32_t* pEnvironment;
    uint32_t* pDriverPath;
    uint32_t* pDataFile;
    uint32_t* pConfigFile;
    uint32_t* pHelpFile;
    uint32_t* pDependentFiles;
    uint32_t* pMonitorName;
    uint32_t* pDefaultDataType;
};

struct CoreDetectionMeshInfo
{
    CoreDetectionData* mesh;
    CoreMatrix transform;

    void CoreDetectionMeshInfo();
};

struct CorePhysicsWorld
{
    CorePhysicsBody* m_body[64];
    int32_t m_bodyNum;
    CorePhysicsJoint* m_joint[128];
    int32_t m_jointNum;
    CorePhysicsConstraint* m_constraint_mem;
    CorePhysicsConstraint* m_constraint;
    int32_t m_constraintNum;
    int32_t m_bodConList[64][64];
    int32_t m_bodConListNum[64];
    int32_t m_debugInputFlag;
    CorePhysicsCollision m_collisionList[256];
    float m_stableTimeStep;
    float m_minTimeStep;
    CoreVector m_gravity;
    float m_friction;
    float m_restitution;
    float m_velocityDamp;
    int32_t m_stepNum;
    float m_unsafeDepthThreshold;
    int32_t m_frictionMode;

    void CorePhysicsWorld();
    void Construct(CoreMemory* mem);
    void Destruct();
    void reset();
    void setGravity();
    void setFriction();
    void setFrictionMode();
    void setRestitution();
    void setVelocityDamping();
    void Init();
    int32_t getBodyIndex();
    CorePhysicsBody* getBody();
    void addBody();
    void removeBody(CorePhysicsBody* bod);
    void addJoint();
    void removeJoint(CorePhysicsJoint* joint);
    void updatePhysicsWorld(float i_timeStep, CoreDetectionMeshInfo* detMeshInfos, int32_t numMeshes, int32_t* i_rTreeBuffer);
    void addFixedCollision(int32_t bodIndex, CoreVector& newpos, CoreVector& norm, float depth, int32_t type);
    void addLimitConstraint(int32_t bodIndexA, int32_t bodIndexB, CoreVector& posA, CoreVector& posB);
    void addCollision(int32_t bodIndexA, int32_t bodIndexB, CoreVector& posA, CoreVector& posB, CoreVector& norm, float depth);
    void resetCollision();
    void disableContact();
    void DoDebug(CoreDebugInput* i_input);
    CorePhysicsCollision* getPhysicsCollsionList(float impactThreshold);
    CorePhysicsCollision* getFRPhysicsCollsionList();
    void integrate(float timeStep);
    void collideFixed();
    void collideDynamic();
    bool resolve();
    bool resolveBody();
    void resolveBodConList();
    void ~CorePhysicsWorld();
};

struct IXMLDOMEntityReference : IXMLDOMNode
{
    void IXMLDOMEntityReference();
};

struct IEAXUnified : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetEmulated();
    HRESULT __stdcall GetNativeSupport();
    HRESULT __stdcall GetCaps();
    HRESULT __stdcall GetEAXDSBuffer();
    void IEAXUnified();
};

struct CoreAnimCommandTimerStart
{
    enum TSFlags
    {
        TS_STOPONBLEND,
    };

    uint32_t m_nameHash;
    uint32_t m_flags;

    CoreHash GetNameHash();
    uint32_t GetFlags();
    bool IsStopOnBlend();
};

struct CoreAnimCommandEndOfAnim
{
};

struct CoreAnimCommandAudio
{
    enum AudioFlags
    {
        AF_START,
        AF_STOP,
        AF_TRIGGER,
        AF_CHECKSURFACETYPE,
        AF_2D,
    };

    uint32_t m_eventHash;
    uint32_t m_boneHash;
    uint32_t m_flags;
    uint32_t m_attenuation;
    uint32_t m_dummy;

    CoreHash GetEventHash();
    CoreHash GetBoneHash();
    uint32_t GetFlags();
    bool IsStart();
    bool IsStop();
    bool IsTrigger();
    bool IsCheckSurfaceType();
    bool Is2D();
    float GetAttenuation();
};

struct CoreAnimCommandFX
{
    uint32_t m_nameHash;

    CoreHash GetNameHash();
};

struct _STARTUPINFOA
{
    uint32_t cb;
    char* lpReserved;
    char* lpDesktop;
    char* lpTitle;
    uint32_t dwX;
    uint32_t dwY;
    uint32_t dwXSize;
    uint32_t dwYSize;
    uint32_t dwXCountChars;
    uint32_t dwYCountChars;
    uint32_t dwFillAttribute;
    uint32_t dwFlags;
    uint32_t wShowWindow;
    uint32_t cbReserved2;
    uint32_t* lpReserved2;
    void* hStdInput;
    void* hStdOutput;
    void* hStdError;
};

struct tagCOLORCORRECTPALETTE
{
    tagEMR emr;
    uint32_t ihPalette;
    uint32_t nFirstEntry;
    uint32_t nPalEntries;
    uint32_t nReserved;
};

struct HWAVEIN__
{
    int32_t unused;
};

struct tagMIDIINCAPS2A
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t dwSupport;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct _PRINTER_ENUM_VALUESW
{
    uint32_t* pValueName;
    uint32_t cbValueName;
    uint32_t dwType;
    uint32_t* pData;
    uint32_t cbData;
};

struct CoreModelCompiled
{
    enum
    {
        VERSION = 92,
    };

    static uint32_t s_modelCompiledID;
    uint32_t m_uiVersion;
    uint32_t m_oFileID;
    uint32_t m_uiName;
    char m_cName[8];
    uint32_t m_ucNumDetectors;
    uint32_t m_ucNumWeaponMarkers;
    uint32_t m_ucNumBodyMarkers;
    uint32_t m_ucNumRagdollCollidables;
    int32_t m_iDetectorsOffset;
    int32_t m_iWeaponMarkersOffset;
    int32_t m_iBodyMarkersOffset;
    int32_t m_iRagdollCollidablesOffset;
    int32_t m_iSkeletonOffset;
    int32_t m_iGeometryOffset;
    int32_t m_detectionDataOffset;
    int32_t m_blindDataSectionOffset;

    uint32_t GetVersion();
    bool CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
    void CoreModelCompiled();
    void ~CoreModelCompiled();
    uint32_t GetNameHash();
    char* GetName();
    bool IsStatic();
    bool IsAnimating();
    int32_t GetNumDetectors();
    int32_t GetNumRagdollCollidables();
    int32_t GetNumWeaponMarkers();
    int32_t GetNumBodyMarkers();
    CoreModelDetector* GetModelDetectorPtr();
    CoreModelRagdollCollidable* GetModelRagdollCollidablePtr();
    CoreModelWeaponMarker* GetModelWeaponMarkerPtr();
    CoreModelBodyMarker* GetModelBodyMarkerPtr();
    CoreModelSkeleton* GetModelSkeletonPtr();
    CoreModelGeometry* GetModelGeometryPtr();
    CoreDetectionData* GetDetectionDataPtr();
    CoreBlindDataSection* GetBlindDataSectionPtr();
    uint32_t GetPlatformVersion();
    uint32_t GetID();
    bool CheckVersion();
    bool CheckID();
};

struct CoreModelDetector
{
    enum
    {
        VERSION = 1,
    };

    float m_fX;
    float m_fY;
    float m_fZ;
    float m_fRadius;

    void CoreModelDetector();
    void ~CoreModelDetector();
    float GetRadius();
    CoreVector GetPosition();
};

struct CoreModelRagdollCollidable
{
    enum
    {
        VERSION = 1,
    };

    float m_fX;
    float m_fY;
    float m_fZ;
    float m_fRadius;
    uint32_t m_uiParentHash;

    void CoreModelRagdollCollidable();
    void ~CoreModelRagdollCollidable();
    float GetRadius();
    CoreVector GetPosition();
    uint32_t GetParentHash();
    CoreCollidableType GetGeometryType();
};

struct CoreModelWeaponMarker
{
    enum
    {
        VERSION = 1,
    };

    int32_t m_iWeaponType;
    int32_t m_iGeometryType;
    float m_fMinPointX;
    float m_fMinPointY;
    float m_fMinPointZ;
    float m_fMaxPointX;
    float m_fMaxPointY;
    float m_fMaxPointZ;
    float m_fRadius;
    float m_Power;
    float m_fFallOff;
    uint32_t m_uiParentHash;

    void CoreModelWeaponMarker();
    void ~CoreModelWeaponMarker();
    CoreVector GetMinPoint();
    CoreVector GetMaxPoint();
    uint32_t GetParentHash();
    CoreCombatMarkerGeometryType GetGeometryType();
    CoreWeaponMarkerType GetWeaponType();
    float GetPower();
    float GetFallOff();
    float GetRadius();
};

struct CoreModelBodyMarker
{
    enum
    {
        VERSION = 1,
    };

    int32_t m_iBodyType;
    int32_t m_iGeometryType;
    float m_fMinPointX;
    float m_fMinPointY;
    float m_fMinPointZ;
    float m_fMaxPointX;
    float m_fMaxPointY;
    float m_fMaxPointZ;
    float m_fRadius;
    float m_fDamageMultiplier;
    uint32_t m_uiParentHash;

    void CoreModelBodyMarker();
    void ~CoreModelBodyMarker();
    CoreVector GetMinPoint();
    CoreVector GetMaxPoint();
    CoreBodyMarkerType GetBodyType();
    CoreCombatMarkerGeometryType GetGeometryType();
    uint32_t GetParentHash();
    float GetRadius();
    float GetDamageMultiplier();
};

struct CAL0_AudioWadManager
{
    CAL0_AudioWadEntry** m_WadEntryTable;
    uint32_t m_NumberOfFilesInWad;
    bool m_WadActive;
    CAL0_File m_File;
    uint32_t m_FileOffset;

    // TODO vtable

    void CAL0_AudioWadManager();
    void ~CAL0_AudioWadManager();
    bool OpenAudioWad(char* filename, uint32_t offset);
    CAL0_AudioWadEntry* GetWadEntry();
    CAL0_File* GetOpenWadFile();
    uint32_t GetFileOffset();
    void CloseAudioWad();
    void ClearAllEntries();
};

struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t Flags;
    _GUID ObjectType;
    _GUID InheritedObjectType;
    uint32_t SidStart;
};

struct _DISPLAY_DEVICEA
{
    uint32_t cb;
    char DeviceName[32];
    char DeviceString[128];
    uint32_t StateFlags;
    char DeviceID[128];
    char DeviceKey[128];
};

struct _DRAGINFOA
{
    uint32_t uSize;
    tagPOINT pt;
    int32_t fNC;
    char* lpFileList;
    uint32_t grfKeyState;
};

struct CoreGeometryCompiledXB
{
    int32_t m_iNumIndices;
    int32_t m_iNumVertices;
    void* m_lpVB;
    int32_t m_iPad;

    void CoreGeometryCompiledXB();
    void ~CoreGeometryCompiledXB();
    int32_t GetNumVertices();
    int32_t GetNumIndices();
    uint32_t* lpusIndexDataPtr();
    void* lpVertexDataPtr();
    void* GetVertexBuffer();
    void SetVertexBuffer();
};

struct tagENHMETARECORD
{
    uint32_t iType;
    uint32_t nSize;
    uint32_t dParm[1];
};

struct tagMIXERCAPSA
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t fdwSupport;
    uint32_t cDestinations;
};

struct _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY
{
    char* pszObjId;
    uint32_t cValue;
    _CRYPTOAPI_BLOB* rgValue;
};

struct _remoteMETAFILEPICT
{
    int32_t mm;
    int32_t xExt;
    int32_t yExt;
    _userHMETAFILE* hMF;
};

struct tagPSDA
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    void* hDevMode;
    void* hDevNames;
    uint32_t Flags;
    tagPOINT ptPaperSize;
    tagRECT rtMinMargin;
    tagRECT rtMargin;
    HINSTANCE__* hInstance;
    int32_t lCustData;
    uint32_t* lpfnPageSetupHook;
    uint32_t* lpfnPagePaintHook;
    char* lpPageSetupTemplateName;
    void* hPageSetupTemplate;
};

struct mpeglayer3waveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wID;
    uint32_t fdwFlags;
    uint32_t nBlockSize;
    uint32_t nFramesPerBlock;
    uint32_t nCodecDelay;
};

struct CoreGeometryCompiledPC
{
    int32_t m_iVertexSizeInBytes;
    int32_t m_iNumVertices;
    int32_t m_iFlags;
    int32_t m_iPad;

    void CoreGeometryCompiledPC();
    void ~CoreGeometryCompiledPC();
    int32_t GetNumVertices();
    int32_t GetVertexSizeInBytes();
    int32_t GetFlags();
    float* GetVertexPosPtr();
    uint32_t* GetVertexColourPtr();
    float* GetVertexSTPtr();
    float* GetVertexNormalPtr();
    uint32_t* GetPaletteBoneIndex();
    float* GetVertexLinkPosPtr();
    float* GetVertexLinkWeightPtr();
    uint32_t* GetVertexLinkPaletteIndexPtr();
    uint32_t* GetVertexLinkColourPtr();
    float* GetVertexLinkSTPtr();
    float* GetVertexLinkNormalPtr();
    float* GetBlendShapeVertexPosPtr();
    uint32_t* GetBlendShapeColourPtr();
    float* GetBlendShapeSTPtr();
    float* GetBlendShapeNormalPtr();
    uint32_t* lpucVertexDataPtr();
};

struct tagEMRSCALEVIEWPORTEXTEX
{
    tagEMR emr;
    int32_t xNum;
    int32_t xDenom;
    int32_t yNum;
    int32_t yDenom;
};

struct tagJOYCAPS2W
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t szPname[32];
    uint32_t wXmin;
    uint32_t wXmax;
    uint32_t wYmin;
    uint32_t wYmax;
    uint32_t wZmin;
    uint32_t wZmax;
    uint32_t wNumButtons;
    uint32_t wPeriodMin;
    uint32_t wPeriodMax;
    uint32_t wRmin;
    uint32_t wRmax;
    uint32_t wUmin;
    uint32_t wUmax;
    uint32_t wVmin;
    uint32_t wVmax;
    uint32_t wCaps;
    uint32_t wMaxAxes;
    uint32_t wNumAxes;
    uint32_t wMaxButtons;
    uint32_t szRegKey[32];
    uint32_t szOEMVxD[260];
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct joyinfoex_tag
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwXpos;
    uint32_t dwYpos;
    uint32_t dwZpos;
    uint32_t dwRpos;
    uint32_t dwUpos;
    uint32_t dwVpos;
    uint32_t dwButtons;
    uint32_t dwButtonNumber;
    uint32_t dwPOV;
    uint32_t dwReserved1;
    uint32_t dwReserved2;
};

struct tagEMRELLIPSE
{
    tagEMR emr;
    _RECTL rclBox;
};

struct _CRL_FIND_ISSUED_FOR_PARA
{
    _CERT_CONTEXT* pSubjectCert;
    _CERT_CONTEXT* pIssuerCert;
};

struct _ACCESS_ALLOWED_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t SidStart;
};

struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION
{
    uint32_t ProcessorMask;
    _LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    _SYSTEM_LOGICAL_PROCESSOR_INFORMATION::__unnamed::__unnamed ProcessorCore;
    _SYSTEM_LOGICAL_PROCESSOR_INFORMATION::__unnamed::__unnamed NumaNode;
    uint32_t Reserved[2];
};

struct tagENHMETAHEADER
{
    uint32_t iType;
    uint32_t nSize;
    _RECTL rclBounds;
    _RECTL rclFrame;
    uint32_t dSignature;
    uint32_t nVersion;
    uint32_t nBytes;
    uint32_t nRecords;
    uint32_t nHandles;
    uint32_t sReserved;
    uint32_t nDescription;
    uint32_t offDescription;
    uint32_t nPalEntries;
    tagSIZE szlDevice;
    tagSIZE szlMillimeters;
    uint32_t cbPixelFormat;
    uint32_t offPixelFormat;
    uint32_t bOpenGL;
    tagSIZE szlMicrometers;
};

struct _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA
{
    uint32_t cbSize;
    uint32_t hCryptProv;
    uint32_t dwKeySpec;
    _CMSG_KEY_AGREE_RECIPIENT_INFO* pKeyAgree;
    uint32_t dwRecipientIndex;
    uint32_t dwRecipientEncryptedKeyIndex;
    _CRYPT_BIT_BLOB OriginatorPublicKey;
};

struct tagCAUL
{
    uint32_t cElems;
    uint32_t* pElems;
};

struct _DSFXFlanger
{
    float fWetDryMix;
    float fDepth;
    float fFeedback;
    float fFrequency;
    int32_t lWaveform;
    float fDelay;
    int32_t lPhase;
};

struct IDirectSoundFXFlanger : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    void IDirectSoundFXFlanger();
};

struct _TAPE_WMI_OPERATIONS
{
    uint32_t Method;
    uint32_t DataBufferSize;
    void* DataBuffer;
};

struct tagMCI_SYSINFO_PARMSW
{
    uint32_t dwCallback;
    uint32_t* lpstrReturn;
    uint32_t dwRetSize;
    uint32_t dwNumber;
    uint32_t wDeviceType;
};

struct CoreVertexSizes
{
    enum CoreVertexSizesEnum
    {
        NO_XYZ_SIZE = 0,
        XYZW32_SIZE = 16,
        XYZ32_SIZE = 16,
        XYZ16_SIZE = 8,
        XYZ8_SIZE = 4,
        NO_RGBA_SIZE = 0,
        RGBA32_SIZE = 16,
        RGBA16_SIZE = 8,
        RGBA8_SIZE = 4,
        NO_UV_SIZE = 0,
        UV32_SIZE = 8,
        UV16_SIZE = 4,
        UV8_SIZE = 2,
        NO_NORMALS_SIZE = 0,
        NORMALS32_SIZE = 12,
        NORMALS16_SIZE = 6,
        NORMALS8_SIZE = 3,
        NO_HARDSKINNING_INDEX_SIZE = 0,
        HARDSKINNING_INDEX8_SIZE = 1,
        NO_SOFTSKINNING_INDEX_SIZE = 0,
        SOFTSKINNING_WEIGHT20INDEX12_SIZE = 4,
        NO_BLENDSHAPE_TARGETS_SIZE = 0,
        BLENDSHAPETARGET16_SIZE = 6,
    };

    // TODO vtable

    void YouCannotInstanceThisClass();
    void CoreVertexSizes();
};

struct CoreSpecMapping
{
    enum
    {
        VERSION = 1,
    };

    CoreHash m_animSetName;
    CoreHash m_animSpecName;

    void CoreSpecMapping();
    void ~CoreSpecMapping();
    CoreHash GetAnimSetHash();
    CoreHash GetAnimSpecHash();
};

struct _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA
{
    uint32_t cOID;
    char** rgpszOID;
};

struct _IMAGE_THUNK_DATA32
{
    _IMAGE_THUNK_DATA32::__unnamed u1;
};

struct _RPC_MESSAGE
{
    void* Handle;
    uint32_t DataRepresentation;
    void* Buffer;
    uint32_t BufferLength;
    uint32_t ProcNum;
    _RPC_SYNTAX_IDENTIFIER* TransferSyntax;
    void* RpcInterfaceInformation;
    void* ReservedForRuntime;
    void* ManagerEpv;
    void* ImportContext;
    uint32_t RpcFlags;
};

struct _CRYPT_BIT_BLOB
{
    uint32_t cbData;
    uint32_t* pbData;
    uint32_t cUnusedBits;
};

struct tagBSTRBLOB
{
    uint32_t cbSize;
    uint32_t* pData;
};

struct _PRINTER_INFO_7A
{
    char* pszObjectGUID;
    uint32_t dwAction;
};

struct tagDVTARGETDEVICE
{
    uint32_t tdSize;
    uint32_t tdDriverNameOffset;
    uint32_t tdDeviceNameOffset;
    uint32_t tdPortNameOffset;
    uint32_t tdExtDevmodeOffset;
    uint32_t tdData[1];
};

struct nms_vbxadpcmmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
};

struct _s__RTTIBaseClassDescriptor
{
    _TypeDescriptor* pTypeDescriptor;
    uint32_t numContainedBases;
    _PMD where;
    uint32_t attributes;
};

struct tagMOUSEMOVEPOINT
{
    int32_t x;
    int32_t y;
    uint32_t time;
    uint32_t dwExtraInfo;
};

struct _CERT_PUBLIC_KEY_INFO
{
    _CRYPT_ALGORITHM_IDENTIFIER Algorithm;
    _CRYPT_BIT_BLOB PublicKey;
};

struct tagCAH
{
    uint32_t cElems;
    _LARGE_INTEGER* pElems;
};

struct tagHIGHCONTRASTA
{
    uint32_t cbSize;
    uint32_t dwFlags;
    char* lpszDefaultScheme;
};

struct _CERT_AUTHORITY_INFO_ACCESS
{
    uint32_t cAccDescr;
    _CERT_ACCESS_DESCRIPTION* rgAccDescr;
};

struct CoreDebug
{
    enum
    {
        VERSION = 3,
    };

    enum CoreDebugLevelEnum
    {
        FIRST_LEVEL = 0,
        GLOBAL = 0,
        GRAPHICS = 1,
        LOGIC = 2,
        MEMORY = 3,
        MENU_SYSTEM = 4,
        PANEL = 5,
        LEVEL = 6,
        DETECT = 7,
        CUT_SCENE_PLAYER = 8,
        PLAYER = 9,
        CAMERA = 10,
        FULL_SCREEN = 11,
        LIGHTS = 12,
        EFFECTS = 13,
        ASSET_MANAGER = 14,
        AUDIO = 15,
        AUDIO_LOC = 16,
        INPUT = 17,
        AI = 18,
        PHYSICS = 19,
        NETWORK = 20,
        GAME_OBJECTS = 21,
        ROOM = 22,
        MAX_LEVEL = 23,
    };

    enum CoreProfileLevelEnum
    {
        PROFILE_INACTIVE = 255,
        PROFILE_FIRST_LEVEL = 0,
        PROFILE_GLOBAL = 0,
        PROFILE_FUNCTION = 1,
        PROFILE_MAX_LEVEL = 2,
    };

    enum CoreCommandEnum
    {
        FLAT_LINE,
        GOURAUD_LINE,
        ARROW,
        TRIANGLE,
        QUAD,
        CIRCLE,
        SPHERE,
        CYLINDER,
        SAUSAGE,
        CONE,
        DEBUG_TEXT,
        CONSOLE_TEXT,
        CUBE,
        SPHERE_MATRIX,
        CONE_MATRIX,
        WIRE_CUBE,
    };

    enum CoreDrawTypeEnum
    {
        WORLD_Z,
        WORLD_FG,
        SCREEN_Z,
        SCREEN_FG,
    };

    static CoreVector m_vConsoleStartPos;
    static CoreVector m_vConsoleCurrentPos;
    static CoreVector m_vConsoleLineSize;
    static int32_t m_iCurrentDebugLevel;
    static CoreRGBA m_oDefaultConsoleColour;
    static CoreRGBA m_oModeTextColour;
    static CoreQWORD* m_lpqwCommandListBase;
    static CoreQWORD* m_lpqwCommandListNext;
    static CoreQWORD* m_lpqwCommandListEnd;
    static int32_t m_iCommandListLength;
    static int32_t m_iProfilerActiveLevel;
    static int32_t m_iProfilerNewActiveLevel;
    static CoreProfileEntry* m_lpoProfileEntries;
    static CoreProfileEntry* m_lpoProfileEntriesBuffer0;
    static CoreProfileEntry* m_lpoProfileEntriesBuffer1;
    static CoreProfileEntry* m_lpoPreviousProfileEntry;
    static int32_t m_iMaxNumProfileEntries;
    static uint32_t m_uiCurrentTimerCount;
    static uint32_t m_uiUserCounts[2][16];
    static CoreRGBA m_oUserColours[2][16];
    static int32_t m_iNumUserMarkers[2];
    static int32_t m_iUserBuffer;
    static CoreProfileEntry* m_profileStack[64];
    static int32_t m_profileStackPointer;
    static int32_t m_iNumClients;
    static int32_t m_iCurrentDebugClient;
    static CoreDebugClient m_oClients[23];
    static int32_t m_firstTiming;
    static uint32_t m_DebugValue;
    static bool m_bProfileTextDisplay;
    static bool m_bActive;

    // TODO vtable

    uint32_t GetVersion();
    bool IsLevelActive(CoreDebug::CoreDebugLevelEnum eLevel);
    void Message(CoreDebug::CoreDebugLevelEnum eLevel, char* lpcText);
    void Printf(CoreDebug::CoreDebugLevelEnum eLevel, char* lpcText);
    void DrawLineWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, bool bForeground);
    void DrawLineScreen();
    void DrawGouraudLineWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, CoreRGBA oColour2, bool bForeground);
    void DrawGouraudLineScreen();
    void DrawCurveNameWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreCurveSetData* lpoCurve, CoreRGBA oColour, bool bForeground);
    void DrawCurveCVsWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreCurveSetData* lpoCurve, CoreRGBA oColour, bool bForeground);
    void DrawCurveHullWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreCurveSetData* lpoCurve, CoreRGBA oColour, bool bForeground);
    void DrawCurveSplineWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreCurveSetData* lpoCurve, CoreRGBA oColour, bool bForeground);
    void DrawArrowWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, bool bForeground);
    void DrawArrowScreen();
    void DrawTriangleWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos0, CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour, bool bForeground);
    void DrawTriangleScreen();
    void DrawQuadWorld();
    void DrawQuadScreen(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vCentre, CoreVector& vSize, CoreRGBA oColour, bool bForeground);
    void DrawSphereWorldMatrix();
    void DrawSphereWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vCentre, float fRadius, CoreRGBA oColour, bool bForeground);
    void DrawSphereScreen();
    void DrawCircleWorld();
    void DrawCircleScreen();
    void DrawBBoxWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& i_min, CoreVector& i_max, CoreRGBA oColour, bool bForeground);
    void DrawCubeWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vCentre, CoreEulerAngle& eaOrient, CoreVector& vSize, CoreRGBA oColour, bool bForeground);
    void DrawWireBBoxWorld(CoreDebug::CoreDebugLevelEnum i_level, CoreVector& i_min, CoreVector& i_max, CoreRGBA i_colour, bool i_foreground);
    void DrawWireCubeWorld();
    void DrawSausageWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos1, CoreVector& vPos2, float fRadius, CoreRGBA oColour, bool bForeground);
    void DrawConeWorldMatrix();
    void DrawConeWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos1, CoreVector& vPos2, float fAngle, CoreRGBA oColour, bool bForeground);
    void DrawCylinderWorld();
    void DrawCylinderScreen();
    void DrawTextScreen(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos, CoreRGBA oColour, bool bForeground, char* lpcText);
    void DrawTextWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos, CoreRGBA oColour, bool bForeground, char* lpcText);
    void DrawConsoleText(CoreDebug::CoreDebugLevelEnum eLevel, CoreRGBA oColour, char* lpcText);
    void ChangeDebugLevel(CoreDebug::CoreDebugLevelEnum eNewLevel);
    void CycleDebugLevel(int32_t iDelta);
    void SetActive(bool bActive);
    bool IsActive();
    void Update(bool bRunDoDebug, CoreDebugInput* i_input, CoreWorldUpdateStruct* lpoWorldUpdateStruct);
    bool bCreateList(int32_t iCommandListLength, int32_t iMinCommandListLength, int32_t iMaxNumProfileEntries, CoreMemory* lpoMemory);
    void Render(CoreGraphicsDevice* io_graphicsDevice, int32_t iGameFrameRate, bool i_renderZ);
    void StartProfiler();
    void EndProfiler();
    void Profile(CoreDebug::CoreProfileLevelEnum i_level, CoreRGBA i_colour, char* i_name);
    void ToggleProfileTextDisplay();
    void MarkUserProfilePoint();
    float fConvertTimerCountToSeconds();
    uint32_t GetTimerCount();
    void CycleProfileLevel(int32_t iDelta);
    void SetDebugVar(uint32_t val);
    void ProfileExternal();
    void ProfilerPush();
    void ProfilerPop();
    bool bRegisterClient(char* i_name, int32_t iLevel, void* lpDoDebugFunc, void* lpUserData);
    void SetDebugLevelFromCommandLine();
    void CoreDebug();
    void ~CoreDebug();
    void YouCannotInstanceThisClass();
    void ResetCommandList();
    void RenderCommandList(CoreGraphicsDevice* io_graphicsDevice, CoreQWORD* lpqwListEnd, CoreDebug::CoreDrawTypeEnum eIgnoreDrawType1, CoreDebug::CoreDrawTypeEnum eIgnoreDrawType2);
    bool bAddHeaderToList(int32_t iNumQuadWords, CoreDebug::CoreCommandEnum eCommand, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    bool bAddQWORDToList();
    bool bAddColourToList();
    bool bAddMatrixToList();
    bool bAddVectorToList(CoreVector& vPos);
    bool bAddFloatToList();
    bool bAddIntToList();
    bool bAddStringToList(char* lpcText, int32_t iLen);
    bool bReadHeaderFromList();
    bool bReadQWORDFromList();
    bool bReadMatrixFromList(CoreMatrix& o_transform);
    bool bReadVectorFromList(CoreVector& vVec);
    bool bReadFloatFromList();
    bool bReadColourFromList();
    bool bReadIntFromList();
    bool bReadStringFromList(char*& lpcText, int32_t iLen);
    void AddFlatLineToList(CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddGouraudLineToList(CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour1, CoreRGBA oColour2, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddArrowToList(CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddTriangleToList(CoreVector& vPos0, CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddQuadToList(CoreVector& vCentre, CoreVector& vSize, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddCircleToList();
    void AddCubeToList(CoreVector& vCentre, CoreEulerAngle& eaOrient, CoreVector& vSize, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddWireCubeToList(CoreVector& vCentre, CoreEulerAngle& eaOrient, CoreVector& vSize, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddSphereToList(CoreVector& vCentre, float fRadius, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddSphereMatrixToList();
    void AddCylinderToList();
    void AddSausageToList(CoreVector& vPos1, CoreVector& vPos2, float fRadius, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddConeToList(CoreVector& vPos1, CoreVector& vPos2, float fAngle, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddConeMatrixToList();
    void AddDebugTextToList(char* lpcText, CoreVector& vPos, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
    void AddConsoleTextToList(char* lpcText, CoreRGBA oColour, CoreDebug::CoreDebugLevelEnum eLevel);
    void RenderFlatLine(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderGouraudLine(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderTriangle(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderArrow(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderQuad(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderCircle(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderCylinder(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderSausage(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderCone(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderConeMatrix(CoreRGBA i_colour, CoreDebug::CoreDrawTypeEnum i_drawType, CoreGraphicsDevice* i_device);
    void RenderCube(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderWireCube(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderDebugText(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice, int32_t iStringLen);
    void RenderConsoleText(CoreRGBA oColour, CoreGraphicsDevice* io_graphicsDevice, int32_t iStringLen);
    void RenderSphere(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
    void RenderSphereMatrix(CoreRGBA i_colour, CoreDebug::CoreDrawTypeEnum i_drawType, CoreGraphicsDevice* i_device);
    void StartProfilerInternal(uint32_t uiTimerCount);
    void EndProfilerInternal(uint32_t uiTimerCount);
    void ProfileInternal(uint32_t uiTimerCount, CoreRGBA oColour, char* i_name);
    void UpdatePreviousProfileEntry();
    CoreProfileEntry* FindFreeProfileEntry(uint32_t uiHash, bool& bFound);
    void RenderProfiler(CoreGraphicsDevice* io_graphicsDevice, int32_t iGameFrameRate);
    void ProfilerPushInternal();
    void ProfilerPopInternal();
    void InitTimerCount();
    void ResetTimerCount();
    bool bAddClientToList(char* i_name, int32_t iLevel, void* lpDoDebugFunc, void* lpUserData);
    void SortClientList();
};

struct _CoreGifPackRgbaq
{
    uint32_t R;
    uint32_t G;
    uint32_t B;
    uint32_t A;
};

struct _CRL_DIST_POINT_NAME
{
    uint32_t dwDistPointNameChoice;
    _CERT_ALT_NAME_INFO FullName;
};

struct _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO
{
    uint32_t cbSize;
    _CRYPT_BIT_BLOB RecipientPublicKey;
    _CERT_ID RecipientId;
    _FILETIME Date;
    _CRYPT_ATTRIBUTE_TYPE_VALUE* pOtherAttr;
};

struct tagEMRSETICMPROFILE
{
    tagEMR emr;
    uint32_t dwFlags;
    uint32_t cbName;
    uint32_t cbData;
    uint32_t Data[1];
};

struct _CERT_GENERAL_SUBTREE
{
    _CERT_ALT_NAME_ENTRY Base;
    uint32_t dwMinimum;
    int32_t fMaximum;
    uint32_t dwMaximum;
};

struct _CERT_KEY_CONTEXT
{
    uint32_t cbSize;
    uint32_t hCryptProv;
    uint32_t dwKeySpec;
};

struct _BINARY_CONTAINER
{
    uint32_t cbBuf;
    uint32_t* pData;
};

struct IDataFilter : IUnknown
{
    HRESULT __stdcall DoEncode();
    HRESULT __stdcall DoDecode();
    HRESULT __stdcall SetEncodingLevel();
    void IDataFilter();
};

struct ITypeLib2 : ITypeLib
{
    HRESULT __stdcall GetCustData();
    HRESULT __stdcall GetLibStatistics();
    HRESULT __stdcall GetDocumentation2();
    HRESULT __stdcall GetAllCustData();
    void ITypeLib2();
};

struct CAL1_AudioData
{
    ca_3DPoint m_Point;
    ca_3DVelocity m_Velocity;
    ca_fixed m_FrequencyOffset;
    ca_fixed m_MinDist;
    ca_fixed m_MaxDist;
    CA_PBPref m_PlaybackPreference;
    uint32_t m_mask;
    uint32_t m_GroupMask;
    uint32_t m_VolumeOffset;
    uint32_t m_Occlusion;
    int32_t m_LRPan;
    int32_t m_FRPan;
    uint32_t m_Priority;
    uint32_t m_ListenerIndex;
    bool m_3D;
    bool m_CameraRelative;

    // TODO vtable

    void CAL1_AudioData();
    void ~CAL1_AudioData();
    void Reset();
};

struct _ABC
{
    int32_t abcA;
    uint32_t abcB;
    int32_t abcC;
};

struct _HTTPSPolicyCallbackData
{
    uint32_t cbStruct;
    uint32_t cbSize;
    uint32_t dwAuthType;
    uint32_t fdwChecks;
    uint32_t* pwszServerName;
};

struct tagOFNA
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HINSTANCE__* hInstance;
    char* lpstrFilter;
    char* lpstrCustomFilter;
    uint32_t nMaxCustFilter;
    uint32_t nFilterIndex;
    char* lpstrFile;
    uint32_t nMaxFile;
    char* lpstrFileTitle;
    uint32_t nMaxFileTitle;
    char* lpstrInitialDir;
    char* lpstrTitle;
    uint32_t Flags;
    uint32_t nFileOffset;
    uint32_t nFileExtension;
    char* lpstrDefExt;
    int32_t lCustData;
    uint32_t* lpfnHook;
    char* lpTemplateName;
};

struct tagMCI_ANIM_WINDOW_PARMSA
{
    uint32_t dwCallback;
    HWND* hWnd;
    uint32_t nCmdShow;
    char* lpstrText;
};

struct _PRINTER_INFO_9A
{
    _devicemodeA* pDevMode;
};

struct _wireSAFEARRAY_UNION
{
    union __MIDL_IOleAutomationTypes_0001
    {
        _wireSAFEARR_BSTR BstrStr;
        _wireSAFEARR_UNKNOWN UnknownStr;
        _wireSAFEARR_DISPATCH DispatchStr;
        _wireSAFEARR_VARIANT VariantStr;
        _wireSAFEARR_BRECORD RecordStr;
        _wireSAFEARR_HAVEIID HaveIidStr;
        _BYTE_SIZEDARR ByteStr;
        _SHORT_SIZEDARR WordStr;
        _LONG_SIZEDARR LongStr;
        _HYPER_SIZEDARR HyperStr;
    };

    uint32_t sfType;
    _wireSAFEARRAY_UNION::__MIDL_IOleAutomationTypes_0001 u;
};

struct WSAData
{
    uint32_t wVersion;
    uint32_t wHighVersion;
    char szDescription[257];
    char szSystemStatus[129];
    uint32_t iMaxSockets;
    uint32_t iMaxUdpDg;
    char* lpVendorInfo;
};

struct CoreGsDrawEnv2
{
    CoreGsFrame frame2;
    uint32_t frame2addr;
    CoreGsZbuf zbuf2;
    int32_t zbuf2addr;
    CoreGsXyoffset xyoffset2;
    int32_t xyoffset2addr;
    CoreGsScissor scissor2;
    int32_t scissor2addr;
    CoreGsPrmodecont prmodecont;
    int32_t prmodecontaddr;
    CoreGsColclamp colclamp;
    int32_t colclampaddr;
    CoreGsDthe dthe;
    int32_t dtheaddr;
    CoreGsTest test2;
    int32_t test2addr;
};

struct tagACCESSTIMEOUT
{
    uint32_t cbSize;
    uint32_t dwFlags;
    uint32_t iTimeOutMSec;
};

struct _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE
{
    char* pszOrganization;
    uint32_t cNoticeNumbers;
    int32_t* rgNoticeNumbers;
};

struct _CERT_REVOCATION_CRL_INFO
{
    uint32_t cbSize;
    _CRL_CONTEXT* pBaseCrlContext;
    _CRL_CONTEXT* pDeltaCrlContext;
    _CRL_ENTRY* pCrlEntry;
    int32_t fDeltaCrlEntry;
};

struct _CERT_CHAIN_POLICY_PARA
{
    uint32_t cbSize;
    uint32_t dwFlags;
    void* pvExtraPolicyPara;
};

struct HWINEVENTHOOK__
{
    int32_t unused;
};

struct tagMCI_OVLY_OPEN_PARMSA
{
    uint32_t dwCallback;
    uint32_t wDeviceID;
    char* lpstrDeviceType;
    char* lpstrElementName;
    char* lpstrAlias;
    uint32_t dwStyle;
    HWND* hWndParent;
};

struct _CMC_TAGGED_REQUEST
{
    uint32_t dwTaggedRequestChoice;
    _CMC_TAGGED_CERT_REQUEST* pTaggedCertRequest;
};

struct _userFLAG_STGMEDIUM
{
    int32_t ContextFlags;
    int32_t fPassOwnership;
    _userSTGMEDIUM Stgmed;
};

struct _wireSAFEARRAY
{
    uint32_t cDims;
    uint32_t fFeatures;
    uint32_t cbElements;
    uint32_t cLocks;
    _wireSAFEARRAY_UNION uArrayStructs;
    tagSAFEARRAYBOUND rgsabound[1];
};

struct CoreGeometryCompiled
{
};

struct CoreGeometryCompiledPS
{
    uint32_t m_uiNumVertices;
    uint32_t m_uiVersion;
    uint32_t m_numParentLights;
    uint32_t m_referenceValue;
    uint32_t m_offsetToLightTags;
    uint32_t m_usDataFormat;
    uint32_t m_usCodeFlags;
    uint32_t m_usCycleCount;
    uint32_t m_usNumQWORDS;
    int32_t m_uiVertexPacketData;

    void CoreGeometryCompiledPS();
    void ~CoreGeometryCompiledPS();
    uint32_t usGetDataFormat();
    uint32_t usGetCodeFlags();
    uint32_t usGetCycleCount();
    uint32_t usGetNumQWORDS();
    CoreQWORD* lpqwGetQWORDPtr();
    uint32_t GetNumVertices();
    uint32_t GetVersion();
    uint32_t GetNumParentLights();
    uint32_t* GetVertexTagData();
    uint32_t GetReferenceValue();
    void SetReferenceValue();
};

struct CoretGS_DISPFB1
{
    uint32_t FBP : 9;
    uint32_t FBW : 6;
    uint32_t PSM : 5;
    uint32_t p0 : 12;
    uint32_t DBX : 11;
    uint32_t DBY : 11;
    uint32_t p1 : 10;
};

struct tWAVEFORMATEX
{
    uint32_t wFormatTag;
    uint32_t nChannels;
    uint32_t nSamplesPerSec;
    uint32_t nAvgBytesPerSec;
    uint32_t nBlockAlign;
    uint32_t wBitsPerSample;
    uint32_t cbSize;
};

struct _CMS_KEY_INFO
{
    uint32_t dwVersion;
    uint32_t Algid;
    uint32_t* pbOID;
    uint32_t cbOID;
};

struct _CTL_VERIFY_USAGE_PARA
{
    uint32_t cbSize;
    _CRYPTOAPI_BLOB ListIdentifier;
    uint32_t cCtlStore;
    void** rghCtlStore;
    uint32_t cSignerStore;
    void** rghSignerStore;
};

struct wavefilter_echo_tag
{
    wavefilter_tag wfltr;
    uint32_t dwVolume;
    uint32_t dwDelay;
};

struct CoreDrawFlags
{
    enum CoreDrawFlagsEnum
    {
        DRAW_SKELETON = (1 << 0),
        DRAW_BONE_BBOX = (1 << 1),
        DRAW_GEOMETRY = (1 << 2),
        DRAW_UNTEXTURED = (1 << 3),
        DRAW_UNLIT = (1 << 4),
        DRAW_BLENDSHAPE_OVERRIDE = (1 << 5),
        DRAW_BLENDSHAPE_OVERRIDE_BASE = (1 << 6),
        DRAW_STATIC_GEOMETRY = (1 << 10),
        DRAW_PARENTED_GEOMETRY = (1 << 11),
        DRAW_SOFTSKINNED_GEOMETRY = (1 << 12),
        DRAW_HARDSKINNED_GEOMETRY = (1 << 13),
        DRAW_BLENDSHAPE_GEOMETRY = (1 << 14),
        DRAW_OUTLINED = (1 << 15),
        DRAW_BONE_NAMES = (1 << 16),
    };

};

struct _CMSG_KEY_TRANS_ENCRYPT_INFO
{
    uint32_t cbSize;
    uint32_t dwRecipientIndex;
    _CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
    _CRYPTOAPI_BLOB EncryptedKey;
    uint32_t dwFlags;
};

struct CoreGroupCamera : CoreCameraObject
{
    enum
    {
        MAX_TARGETS = 4,
    };

    CoreObject* m_target[4];
    uint32_t m_numTargets;
    CoreVector m_offset;
    float m_idealDistance;
    float m_distance;
    float m_idealPitch;
    CoreEulerAngle m_angle;
    bool m_cameraOverride;
    CoreS128Aligned m_memoryPot[256];

    void CoreGroupCamera();
    void ~CoreGroupCamera();
    void Construct(CoreMemory* io_memory);
    void AdjustCameraAngle(float i_deltaAngle, float i_deltaPitch, float i_deltaRoll);
    void AdjustCameraDistance(float i_requiredDistance);
    void AddTarget();
    void RemoveTarget();
    void SetIdealDistance();
    void SetOffset();
    float GetActualDistance();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    int32_t FindTarget();
    CoreScripted::CommandReturn FnDefaultCameraLogic();
    CoreScripted::CommandReturn DefaultCameraLogic(CoreCommand* i_command);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
};

struct _MESSAGE_RESOURCE_ENTRY
{
    uint32_t Length;
    uint32_t Flags;
    uint32_t Text[1];
};

struct tagHIGHCONTRASTW
{
    uint32_t cbSize;
    uint32_t dwFlags;
    uint32_t* lpszDefaultScheme;
};

struct tagMCI_LOAD_PARMSA
{
    uint32_t dwCallback;
    char* lpfilename;
};

struct _CRYPT_RETRIEVE_AUX_INFO
{
    uint32_t cbSize;
    _FILETIME* pLastSyncTime;
    uint32_t dwMaxUrlRetrievalByteCount;
};

struct _TOKEN_AUDIT_POLICY_ELEMENT
{
    uint32_t Category;
    uint32_t PolicyMask;
};

struct tagPOLYTEXTW
{
    int32_t x;
    int32_t y;
    uint32_t n;
    uint32_t* lpstr;
    uint32_t uiFlags;
    tagRECT rcl;
    int32_t* pdx;
};

struct CoreVeryQuickTimer
{
    int32_t m_start64;

    void CoreVeryQuickTimer();
    void Start();
    uint32_t GetMicroSecondsSinceStart();
    uint32_t GetMilliSecondsSinceStart();
    float GetSecondsSinceStart();
    int32_t GetRaw64();
    uint32_t ConvertRaw64ToMicroSeconds();
    uint32_t ConvertRaw64ToMilliSeconds();
    float ConvertRaw64ToSeconds();
};

struct _PORT_INFO_1W
{
    uint32_t* pName;
};

struct _DRIVER_INFO_5A
{
    uint32_t cVersion;
    char* pName;
    char* pEnvironment;
    char* pDriverPath;
    char* pDataFile;
    char* pConfigFile;
    uint32_t dwDriverAttributes;
    uint32_t dwConfigVersion;
    uint32_t dwDriverVersion;
};

struct _BIDI_REQUEST_CONTAINER
{
    uint32_t Version;
    uint32_t Flags;
    uint32_t Count;
    _BIDI_REQUEST_DATA aData[1];
};

struct IDropSource : IUnknown
{
    HRESULT __stdcall QueryContinueDrag();
    HRESULT __stdcall GiveFeedback();
    void IDropSource();
};

struct IInternetProtocolSinkStackable : IUnknown
{
    HRESULT __stdcall SwitchSink();
    HRESULT __stdcall CommitSwitch();
    HRESULT __stdcall RollbackSwitch();
    void IInternetProtocolSinkStackable();
};

struct CoreArray<float>
{
};

struct CoreFXInternalData
{
};

struct SYSTEM_BATTERY_STATE
{
    uint32_t AcOnLine;
    uint32_t BatteryPresent;
    uint32_t Charging;
    uint32_t Discharging;
    uint32_t Spare1[4];
    uint32_t MaxCapacity;
    uint32_t RemainingCapacity;
    uint32_t Rate;
    uint32_t EstimatedTime;
    uint32_t DefaultAlert1;
    uint32_t DefaultAlert2;
};

struct tagSTYLEBUFW
{
    uint32_t dwStyle;
    uint32_t szDescription[32];
};

struct CoreGsTexclut
{
    uint32_t CBW : 6;
    uint32_t COU : 6;
    uint32_t COV : 10;
    uint32_t pad22 : 42;
};

struct CoreAnimSpec
{
    enum
    {
        VERSION = 6,
    };

    enum ASFlags
    {
        ASF_TERMINATOR,
        ASF_VELOCITY,
        ASF_GRAVITY,
        ASF_DETECTION,
        ASF_PRESET_DIRECTION,
        ASF_TIMESTRETCH,
        ASF_GAMESPECIFIC1,
        ASF_GAMESPECIFIC2,
        ASF_GAMESPECIFIC3,
        ASF_GAMESPECIFIC4,
        ASF_GAMESPECIFIC5,
        ASF_GAMESPECIFIC6,
        ASF_GAMESPECIFIC7,
        ASF_GAMESPECIFIC8,
        ASF_AUDIO_BLEND,
    };

    uint32_t m_context;
    uint32_t m_state;
    uint32_t m_flags;
    float m_defaultBlendTime;
    uint32_t m_animPathAltState;
    int32_t m_numAltAnims;
    int32_t m_numAnimBlends;
    int32_t m_numAnimCommands;
    int32_t m_altAnimTableOffset;
    int32_t m_animBlendTableOffset;
    int32_t m_animCommandTableOffset;
    int32_t m_animPathHashArrayOffset;

    void CoreAnimSpec();
    void ~CoreAnimSpec();
    CoreHash GetContext();
    CoreHash GetState();
    uint32_t GetFlags();
    float GetDefaultBlendTime();
    CoreHash GetAnimPathAltState();
    int32_t GetNumAltAnims();
    int32_t GetNumAnimBlends();
    int32_t GetNumAnimCommands();
    CoreAltAnim* GetAltAnim();
    CoreAnimBlend* GetAnimBlend();
    CoreAnimCommand* GetAnimCommand();
    void RemapStateByAnimPath(CoreHash& i_goalState, CoreHash& o_remapState);
    bool IsTerminator();
    bool HasVelocity();
    bool HasGravity();
    bool HasDetection();
    bool HasPresetDirection();
    bool HasTimestretch();
    bool HasGameSpecific1();
    bool HasGameSpecific2();
    bool HasGameSpecific3();
    bool HasGameSpecific4();
    bool HasGameSpecific5();
    bool HasGameSpecific6();
    bool HasGameSpecific7();
    bool HasGameSpecific8();
    bool HasAudioBlend();
    int32_t* GetAltAnimTable();
    int32_t* GetAnimBlendTable();
    int32_t* GetAnimCommandTable();
    CoreHashArray* GetAnimPathHashArray();
};

struct CoreAltAnim
{
    enum
    {
        VERSION = 2,
    };

    uint32_t m_conditionIndex;
    uint32_t m_numAltAnimAtoms;
    int32_t m_altAnimAtomOffset;

    void CoreAltAnim();
    void ~CoreAltAnim();
    uint32_t GetConditionIndex();
    int32_t GetNumAltAnimAtoms();
    CoreAltAnimAtom* GetAltAnimAtom();
};

struct CoreAnimBlend
{
    enum
    {
        VERSION = 3,
    };

    enum ABFlags
    {
        AB_HOLD_SRC,
        AB_HOLD_DEST,
        AB_AUTO_BLEND,
        AB_VELOCITY_BLEND,
        AB_OFFSET_BLEND_POS_X,
        AB_OFFSET_BLEND_POS_Y,
        AB_OFFSET_BLEND_POS_Z,
        AB_OFFSET_BLEND_ROT,
        AB_EASE,
    };

    uint32_t m_specTableIndex;
    uint32_t m_conditionIndex;
    uint32_t m_flags;
    uint32_t m_easeFrom;
    uint32_t m_easeTo;
    float m_srcStart;
    float m_srcEnd;
    float m_dstStart;
    float m_dstEnd;
    float m_blendTime;

    void CoreAnimBlend();
    void ~CoreAnimBlend();
    uint32_t GetSpecTableIndex();
    uint32_t GetConditionIndex();
    uint32_t GetFlags();
    float GetSourceStart();
    float GetSourceEnd();
    float GetDestStart();
    float GetDestEnd();
    float GetBlendTime();
    uint32_t GetEaseFrom();
    uint32_t GetEaseTo();
    bool IsHoldSourceAnim();
    bool IsHoldDestAnim();
    bool IsAutoBlend();
    bool IsVelocityBlend();
    bool IsEase();
    bool IsInBlendTime();
    float GetBlendedDestTime(float i_time);
};

struct ca_3DPoint
{
    ca_fixed x;
    ca_fixed y;
    ca_fixed z;

    void ca_3DPoint();
};

struct wavehdr_tag
{
    char* lpData;
    uint32_t dwBufferLength;
    uint32_t dwBytesRecorded;
    uint32_t dwUser;
    uint32_t dwFlags;
    uint32_t dwLoops;
    wavehdr_tag* lpNext;
    uint32_t reserved;
};

struct _CERT_REVOCATION_INFO
{
    uint32_t cbSize;
    uint32_t dwRevocationResult;
    char* pszRevocationOid;
    void* pvOidSpecificInfo;
    int32_t fHasFreshnessTime;
    uint32_t dwFreshnessTime;
    _CERT_REVOCATION_CRL_INFO* pCrlInfo;
};

struct _DSFXGargle
{
    uint32_t dwRateHz;
    uint32_t dwWaveShape;
};

struct _nlsversioninfo
{
    uint32_t dwNLSVersionInfoSize;
    uint32_t dwNLSVersion;
    uint32_t dwDefinedVersion;
};

struct _CMSG_MAIL_LIST_ENCRYPT_INFO
{
    uint32_t cbSize;
    uint32_t dwRecipientIndex;
    _CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
    _CRYPTOAPI_BLOB EncryptedKey;
    uint32_t dwFlags;
};

struct _CoreGifPackXyz
{
    int32_t X;
    int32_t Y;
    uint32_t Z;
    uint32_t pad96 : 15;
    uint32_t ADC : 1;
    uint32_t pad112 : 16;
};

struct tagMETAFILEPICT
{
    int32_t mm;
    int32_t xExt;
    int32_t yExt;
    HMETAFILE__* hMF;
};

struct ITypeComp : IUnknown
{
    HRESULT __stdcall Bind();
    HRESULT __stdcall BindType();
    void ITypeComp();
};

struct CoreClusterData
{
    enum
    {
        VERSION = 1,
    };

    static uint32_t s_clusterID;
    uint32_t m_version;
    uint32_t m_fileID;
    uint32_t m_headerSize;
    uint32_t m_numberOfFiles;
    uint32_t m_clusterHash;
    char m_description[12];
    CoreClusterFileHeader m_fileHeaders[1];

    void CoreClusterData();
    void ~CoreClusterData();
    bool CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
    uint32_t GetVersion();
    uint32_t GetPlatformVersion();
    uint32_t GetID();
    bool CheckVersion();
    bool CheckID();
    uint32_t GetNumberOfFiles();
    uint32_t GetHeaderSizeInBytes();
    uint32_t GetClusterHash();
    char* GetDescriptionPtr();
    CoreClusterFileHeader* FindFile(uint32_t i_fileHash);
    void ConvertFileNameToClusterFileFormat(char* clusterFileName, char* i_fileName);
    uint32_t GetFileOffset();
    char* GetFileNamePtr();
    uint32_t GetFileSize();
    uint32_t GetFileHash();
};

struct CoreClusterFileHeader
{
    uint32_t fileNameOffset;
    uint32_t size;
    uint32_t fileOffset;
    uint32_t fileHash;
};

struct _FOCUS_EVENT_RECORD
{
    int32_t bSetFocus;
};

struct _SHELLEXECUTEINFOA
{
    uint32_t cbSize;
    uint32_t fMask;
    HWND* hwnd;
    char* lpVerb;
    char* lpFile;
    char* lpParameters;
    char* lpDirectory;
    int32_t nShow;
    HINSTANCE__* hInstApp;
    void* lpIDList;
    char* lpClass;
    HKEY__* hkeyClass;
    uint32_t dwHotKey;
    void* hIcon;
    void* hMonitor;
    void* hProcess;
};

struct _CRYPT_HASH_MESSAGE_PARA
{
    uint32_t cbSize;
    uint32_t dwMsgEncodingType;
    uint32_t hCryptProv;
    _CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    void* pvHashAuxInfo;
};

struct _CERT_BASIC_CONSTRAINTS_INFO
{
    _CRYPT_BIT_BLOB SubjectType;
    int32_t fPathLenConstraint;
    uint32_t dwPathLenConstraint;
    uint32_t cSubtreesConstraint;
    _CRYPTOAPI_BLOB* rgSubtreesConstraint;
};

struct _wireSAFEARR_VARIANT
{
    uint32_t Size;
    _wireVARIANT** aVariant;
};

struct CoreGameOnScreenKeyboardParameters
{
    CoreGameFrame Frame;
    CoreRGBA ScreenBackGroundRGBA;
    CoreRGBA TitleTextRGBA;
    CoreRGBA TitleAreaBackGroundRGBA;
    CoreRGBA ButtonsTextRGBA;
    CoreRGBA ButtonsHighLightedTextRGBA;
    CoreRGBA ButtonsAreaBackGroundRGBA;
    CoreRGBA EditedTextRGBA;
    CoreRGBA EditedTextAreaBackGroundRGBA;
    static bool m_defaultsSet;
    float m_centreX;
    float m_centreY;
    float m_width;
    float m_height;
    float m_titleTextScaleX;
    float m_titleTextScaleY;
    float m_buttonsTextScaleX;
    float m_buttonsTextScaleY;
    float m_editedTextScaleX;
    float m_editedTextScaleY;
    float m_spaceBetweenTextAndFrameX;
    float m_spaceBetweenTextAndFrameY;
    float m_spaceBetweenTitleAndButtons;
    float m_spaceBetweenButtonsAndEditedText;
    float m_highLightFlashRate;
    float m_highLightFlashFrom;
    float m_highLightFlashTo;
    float m_dialogFadeUpTime;
    float m_dialogFadeDownTime;
    CoreHash m_startSoundHash;
    CoreHash m_selectSoundHash;
    CoreHash m_cancelSoundHash;
    CoreHash m_moveSoundHash;
    CoreHash m_fontHash;
    CoreHash m_textureSetHash;

    CoreGameOnScreenKeyboardParameters* GetDefaults();
    void CoreGameOnScreenKeyboardParameters();
    void SetDefaultsFromThis();
    void SetThisFromDefaults();
    void SetCentreXY();
    float GetCentreX();
    float GetCentreY();
    void SetWidth();
    float GetWidth();
    void SetHeight();
    float GetHeight();
    void SetTitleTextScales();
    float GetTitleTextScaleX();
    float GetTitleTextScaleY();
    void SetButtonsTextScales();
    float GetButtonsTextScaleX();
    float GetButtonsTextScaleY();
    void SetEditedTextScales();
    float GetEditedTextScaleX();
    float GetEditedTextScaleY();
    void SetSpaceBetweenTextAndFrameX();
    float GetSpaceBetweenTextAndFrameX();
    void SetSpaceBetweenTextAndFrameY();
    float GetSpaceBetweenTextAndFrameY();
    void SetSpaceBetweenTitleAndButtons();
    float GetSpaceBetweenTitleAndButtons();
    void SetSpaceBetweenButtonsAndEditedText();
    float GetSpaceBetweenButtonsAndEditedText();
    void SetHighLightFlash();
    float GetHighLightFlashRate();
    float GetHighLightFlashRangeFrom();
    float GetHighLightFlashRangeTo();
    void SetDialogFadeTimes();
    float GetDialogFadeUpTime();
    float GetDialogFadeDownTime();
    void SetFontHash(CoreHash i_fontHash);
    CoreFont* GetFont();
    void SetTextureSetHash(CoreHash i_textureSetHash);
    CoreTextureSet* GetTextureSet();
    void SetStartSoundHash(CoreHash i_soundHash);
    CoreHash GetStartSoundHash();
    void SetSelectSoundHash(CoreHash i_soundHash);
    CoreHash GetSelectSoundHash();
    void SetCancelSoundHash(CoreHash i_soundHash);
    CoreHash GetCancelSoundHash();
    void SetMoveSoundHash(CoreHash i_soundHash);
    CoreHash GetMoveSoundHash();
    void SetDefaults();
    void ~CoreGameOnScreenKeyboardParameters();
};

struct tagHELPWININFOW
{
    int32_t wStructSize;
    int32_t x;
    int32_t y;
    int32_t dx;
    int32_t dy;
    int32_t wMax;
    uint32_t rgchMember[2];
};

struct tagMCI_ANIM_RECT_PARMS
{
    uint32_t dwCallback;
    tagRECT rc;
};

struct _CERT_STORE_PROV_FIND_INFO
{
    uint32_t cbSize;
    uint32_t dwMsgAndCertEncodingType;
    uint32_t dwFindFlags;
    uint32_t dwFindType;
    void* pvFindPara;
};

struct _HYPER_SIZEDARR
{
    uint32_t clSize;
    int32_t* pData;
};

struct tagCANDIDATEFORM
{
    uint32_t dwIndex;
    uint32_t dwStyle;
    tagPOINT ptCurrentPos;
    tagRECT rcArea;
};

struct CoreSubObjectMarkerData
{
    enum
    {
        VERSION = 1,
    };

    enum eSubObjectMarkerStateEnum
    {
        INVALID,
        BEFORE_START,
        ACTIVE,
        AFTER_END,
    };

    uint32_t m_uiName;
    float m_fStartTime;
    float m_fEndTime;
    uint32_t m_uiPadding;

    void CoreSubObjectMarkerData();
    void ~CoreSubObjectMarkerData();
    uint32_t GetNameHash();
    float GetStartTime();
    float GetEndTime();
};

struct _RTL_VERIFIER_THUNK_DESCRIPTOR
{
    char* ThunkName;
    void* ThunkOldAddress;
    void* ThunkNewAddress;
};

struct tagMULTIKEYHELPA
{
    uint32_t mkSize;
    char mkKeylist;
    char szKeyphrase[1];
};

struct tagBinaryParam
{
    void* Buffer;
    int32_t Size;
};

struct _NTFS_STATISTICS
{
    uint32_t LogFileFullExceptions;
    uint32_t OtherExceptions;
    uint32_t MftReads;
    uint32_t MftReadBytes;
    uint32_t MftWrites;
    uint32_t MftWriteBytes;
    _NTFS_STATISTICS::__unnamed MftWritesUserLevel;
    uint32_t MftWritesFlushForLogFileFull;
    uint32_t MftWritesLazyWriter;
    uint32_t MftWritesUserRequest;
    uint32_t Mft2Writes;
    uint32_t Mft2WriteBytes;
    _NTFS_STATISTICS::__unnamed Mft2WritesUserLevel;
    uint32_t Mft2WritesFlushForLogFileFull;
    uint32_t Mft2WritesLazyWriter;
    uint32_t Mft2WritesUserRequest;
    uint32_t RootIndexReads;
    uint32_t RootIndexReadBytes;
    uint32_t RootIndexWrites;
    uint32_t RootIndexWriteBytes;
    uint32_t BitmapReads;
    uint32_t BitmapReadBytes;
    uint32_t BitmapWrites;
    uint32_t BitmapWriteBytes;
    uint32_t BitmapWritesFlushForLogFileFull;
    uint32_t BitmapWritesLazyWriter;
    uint32_t BitmapWritesUserRequest;
    _NTFS_STATISTICS::__unnamed BitmapWritesUserLevel;
    uint32_t MftBitmapReads;
    uint32_t MftBitmapReadBytes;
    uint32_t MftBitmapWrites;
    uint32_t MftBitmapWriteBytes;
    uint32_t MftBitmapWritesFlushForLogFileFull;
    uint32_t MftBitmapWritesLazyWriter;
    uint32_t MftBitmapWritesUserRequest;
    _NTFS_STATISTICS::__unnamed MftBitmapWritesUserLevel;
    uint32_t UserIndexReads;
    uint32_t UserIndexReadBytes;
    uint32_t UserIndexWrites;
    uint32_t UserIndexWriteBytes;
    uint32_t LogFileReads;
    uint32_t LogFileReadBytes;
    uint32_t LogFileWrites;
    uint32_t LogFileWriteBytes;
    _NTFS_STATISTICS::__unnamed Allocate;
};

struct OPENCARDNAME_EXA
{
    uint32_t dwStructSize;
    uint32_t hSCardContext;
    HWND* hwndOwner;
    uint32_t dwFlags;
    char* lpstrTitle;
    char* lpstrSearchDesc;
    HICON__* hIcon;
    OPENCARD_SEARCH_CRITERIAA* pOpenCardSearchCriteria;
    uint32_t* lpfnConnect;
    void* pvUserData;
    uint32_t dwShareMode;
    uint32_t dwPreferredProtocols;
    char* lpstrRdr;
    uint32_t nMaxRdr;
    char* lpstrCard;
    uint32_t nMaxCard;
    uint32_t dwActiveProtocol;
    uint32_t hCardHandle;
};

struct csimaadpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct tagMCI_OVLY_LOAD_PARMSA
{
    uint32_t dwCallback;
    char* lpfilename;
    tagRECT rc;
};

struct CoreGeometryTypes
{
    enum CoreGeometryTypeEnum
    {
        INSTANCE,
        STATIC,
        PARENTED,
        HARD_SKINNED,
        SOFT_SKINNED,
        BLENDSHAPE,
        UNKNOWN,
    };

    // TODO vtable

    void CoreGeometryTypes();
    void ~CoreGeometryTypes();
    void YouCannotInstanceThisClass();
};

struct CoreVector2D
{
    float x;
    float y;
};

struct CoreDataStorer
{
    char* m_buffer;
    uint32_t m_bufferSize;
    uint32_t m_bufferStored;

    void CoreDataStorer(void* o_buffer, int32_t i_size);
    int32_t Align();
    void Store();
    void StoreChar(char i_char);
    void StoreString(char* i_string);
    void StorePartString();
    uint32_t ZeroTerminate();
    void StoreChar16();
    void StoreString16();
    void StorePartString16();
    uint32_t ZeroTerminate16();
    uint32_t StoreUTF8AsString16();
    uint32_t StoreString16AsUTF8();
    void* GetBuffer();
    uint32_t GetSizeStored();
    uint32_t GetSizeRemaining();
    uint32_t GetSizeRequired();
    bool IsBufferFull();
    bool IsBufferOverFull();
};

struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t Flags;
    _GUID ObjectType;
    _GUID InheritedObjectType;
    uint32_t SidStart;
};

struct _EXIT_PROCESS_DEBUG_INFO
{
    uint32_t dwExitCode;
};

struct tagAUXCAPSA
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t wTechnology;
    uint32_t wReserved1;
    uint32_t dwSupport;
};

struct _SHNAMEMAPPINGA
{
    char* pszOldPath;
    char* pszNewPath;
    int32_t cchOldPath;
    int32_t cchNewPath;
};

struct _CMC_ADD_ATTRIBUTES_INFO
{
    uint32_t dwCmcDataReference;
    uint32_t cCertReference;
    uint32_t* rgdwCertReference;
    uint32_t cAttribute;
    _CRYPT_ATTRIBUTE* rgAttribute;
};

struct _DRIVER_INFO_6W
{
    uint32_t cVersion;
    uint32_t* pName;
    uint32_t* pEnvironment;
    uint32_t* pDriverPath;
    uint32_t* pDataFile;
    uint32_t* pConfigFile;
    uint32_t* pHelpFile;
    uint32_t* pDependentFiles;
    uint32_t* pMonitorName;
    uint32_t* pDefaultDataType;
    uint32_t* pszzPreviousNames;
    _FILETIME ftDriverDate;
    uint32_t dwlDriverVersion;
    uint32_t* pszMfgName;
    uint32_t* pszOEMUrl;
    uint32_t* pszHardwareID;
    uint32_t* pszProvider;
};

struct mediaspace_adpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wRevision;
};

struct _ImageArchitectureEntry
{
    uint32_t FixupInstRVA;
    uint32_t NewInst;
};

struct IMPORT_OBJECT_HEADER
{
    uint32_t Sig1;
    uint32_t Sig2;
    uint32_t Version;
    uint32_t Machine;
    uint32_t TimeDateStamp;
    uint32_t SizeOfData;
    uint32_t Ordinal;
    uint32_t Hint;
    uint32_t Type : 2;
    uint32_t NameType : 3;
    uint32_t Reserved : 11;
};

struct _CERT_CREATE_CONTEXT_PARA
{
    uint32_t cbSize;
    void* pfnFree;
    void* pvFree;
};

struct _JOB_INFO_1W
{
    uint32_t JobId;
    uint32_t* pPrinterName;
    uint32_t* pMachineName;
    uint32_t* pUserName;
    uint32_t* pDocument;
    uint32_t* pDatatype;
    uint32_t* pStatus;
    uint32_t Status;
    uint32_t Priority;
    uint32_t Position;
    uint32_t TotalPages;
    uint32_t PagesPrinted;
    _SYSTEMTIME Submitted;
};

struct IContinue : IUnknown
{
    HRESULT __stdcall FContinue();
    void IContinue();
};

struct IXMLDOMNodeList : IDispatch
{
    HRESULT __stdcall get_item();
    HRESULT __stdcall get_length();
    HRESULT __stdcall nextNode();
    HRESULT __stdcall reset();
    HRESULT __stdcall get__newEnum();
    void IXMLDOMNodeList();
};

struct CoreGsTex1
{
    uint32_t LCM : 1;
    uint32_t pad01 : 1;
    uint32_t MXL : 3;
    uint32_t MMAG : 1;
    uint32_t MMIN : 3;
    uint32_t MTBA : 1;
    uint32_t pad10 : 9;
    uint32_t L : 2;
    uint32_t pad21 : 11;
    uint32_t K : 12;
    uint32_t pad44 : 20;
};

struct CorePhysicsConstraint
{
    CoreVector m_relPosA;
    CoreVector m_relPosB;
    CoreVector m_pos;
    CoreVector m_creep;
    CoreVector m_norm;
    CoreVector m_vpad;
    int32_t m_bodyIndexA;
    int32_t m_bodyIndexB;
    int32_t m_flag;
    float m_relVel;
    float m_depth;
    int32_t m_type;
    float m_data0;
    float m_data1;

    void CorePhysicsConstraint();
};

struct CoreMem
{
    enum
    {
        MAX_GLOBAL_NEWDELETE_STACK_SIZE = 16,
    };

    struct CoreMD5State
    {
        uint32_t count[2];
        uint32_t abcd[4];
        uint32_t buf[64];
    };

    static bool s_banNewDelete;
    static bool s_banMallocFree;
    static CoreMemory* s_globalNewDeleteMemoryStack[16];
    static CoreMem::CoreMD5State s_md5State;
    static CoreMemory* m_debugMemoryAllocator;

    // TODO vtable

    void Copy(void* o_to, void* i_from, int32_t i_length);
    void CopyBackwards(void* o_to, void* i_from, int32_t i_length);
    void Zero(void* o_to, int32_t i_length);
    void Fill(void* o_to, char cValue, int32_t i_length);
    int32_t SameIndex();
    bool IsSame(void* i_memory, void* i_compare, int32_t i_length);
    uint32_t SwapEndian2(uint32_t* i_data);
    uint32_t SwapEndian4(uint32_t* i_data);
    uint32_t SwapEndian8(uint32_t* i_data);
    CoreU128 SwapEndian16(CoreU128* i_data);
    uint32_t GetHash(uint32_t* i_memory, uint32_t i_length);
    CoreU128 GetMD5Hash();
    void InitMD5Hash();
    void AppendMD5Hash();
    void CoreDelete(void* i_memory);
    void* CoreNew(uint32_t i_size);
    int32_t MemSize(int32_t i_bytesPerElement, int32_t i_numItems);
    int32_t MemAlignment();
    void* Alloc(uint32_t uiSize, CoreMemory* o_allocator, int32_t i_numItems, char* i_fileName, int32_t i_lineNumber);
    void Delete(void* i_memory);
    void PushGlobalNewDeleteMemory(CoreMemory* i_memory);
    void PopGlobalNewDeleteMemory();
    CoreMemory* GetGlobalNewDeleteMemory();
    bool IsNewDeleteBanned();
    bool SetNewDeleteBan();
    bool IsMallocFreeBanned();
    bool SetMallocFreeBan();
    void* Malloc(int32_t i_size);
    void Free();
    void* MemAlign(int32_t i_size, int32_t i_alignment);
    void SetDebugMemoryAllocator(CoreMemory* i_allocator);
    bool GetDebugMemoryAllocator(CoreMemory*& o_allocator);
    void ProcessMD5Hash();
    void CoreMem();
    void ~CoreMem();
    void YouCannotInstanceThisClass();
};

struct _CRYPT_TIME_STAMP_REQUEST_INFO
{
    char* pszTimeStampAlgorithm;
    char* pszContentType;
    _CRYPTOAPI_BLOB Content;
    uint32_t cAttribute;
    _CRYPT_ATTRIBUTE* rgAttribute;
};

struct tagCAUI
{
    uint32_t cElems;
    uint32_t* pElems;
};

struct CoretGS_EXTDATA
{
    uint32_t SX : 12;
    uint32_t SY : 11;
    uint32_t SMPH : 4;
    uint32_t SMPV : 2;
    uint32_t p0 : 3;
    uint32_t WW : 12;
    uint32_t WH : 11;
    uint32_t p1 : 9;
};

struct _CERT_AUTHORITY_KEY_ID2_INFO
{
    _CRYPTOAPI_BLOB KeyId;
    _CERT_ALT_NAME_INFO AuthorityCertIssuer;
    _CRYPTOAPI_BLOB AuthorityCertSerialNumber;
};

struct CoreMapFileParserSN : CoreMapFileParser
{
    bool iProcessAllFunctions();
    void CoreMapFileParserSN();
};

struct tagLOGPALETTE
{
    uint32_t palVersion;
    uint32_t palNumEntries;
    tagPALETTEENTRY palPalEntry[1];
};

struct CoreNodeBGLight : CoreNode
{
    CoreBGLightController* m_BGLight;

    void CoreNodeBGLight();
    void ~CoreNodeBGLight();
};

struct tagCBT_CREATEWNDW
{
    tagCREATESTRUCTW* lpcs;
    HWND* hwndInsertAfter;
};

struct ICancelMethodCalls : IUnknown
{
    HRESULT __stdcall Cancel();
    HRESULT __stdcall TestCancel();
    void ICancelMethodCalls();
};

struct tagSTGMEDIUM
{
    uint32_t tymed;
    HBITMAP__* hBitmap;
    void* hMetaFilePict;
    HENHMETAFILE__* hEnhMetaFile;
    void* hGlobal;
    uint32_t* lpszFileName;
    IStream* pstm;
    IStorage* pstg;
    IUnknown* pUnkForRelease;
};

struct CorePathNode
{
    CoreMemoryList m_Neighbors;
    CorePathNode* m_Predecessor;

    // TODO vtable

    void CorePathNode();
    void ~CorePathNode();
    float Cost();
    float CostTo();
    void SetCost();
    CorePathNode* GetPredecessor();
    void SetPredecessor();
    bool PushNeighbor();
};

struct tagMONERRSTRUCT
{
    uint32_t cb;
    uint32_t wLastError;
    uint32_t dwTime;
    void* hTask;
};

struct _PRINTPROCESSOR_INFO_1W
{
    uint32_t* pName;
};

struct _DSBUFFERDESC1
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwBufferBytes;
    uint32_t dwReserved;
    tWAVEFORMATEX* lpwfxFormat;
};

struct CoreCommandArgs
{
    CoreString m_oCommandPath;
    CoreArray<CoreArg> m_lpoArgs;
    CoreString m_oOutput;
    CoreArray<CoreString> m_lpoInputs;
    bool m_bNoOutput;

    void CoreCommandArgs();
    void ~CoreCommandArgs();
    void RegisterOption();
    bool IsOptionSet();
    char* GetStringParam();
    int32_t GetIntParam();
    float GetFloatParam();
    bool IsOutputSet();
    char* GetOutput();
    void SetNoOutput();
    bool bRequiresOutput();
    int32_t GetNumInputs();
    char* GetInput();
    char* GetInputExt();
    char* GetExecutable();
    void DisplayOptions();
    int32_t iCopyOptions();
    void ParseCommandLine();
    void ProcessFile();
    int32_t FindOption();
    void ParseStrings();
};

struct CoreGameText
{
    static CoreGameTextUnit* m_pGameText[5];
    static CoreHash m_hashFileName[5];

    void SetGlobalInstance(CoreGameTextUnit* i_gameText, uint32_t i_platformVersionBit);
    void AddOtherInstance();
    void RemoveOtherInstance();
    char* GetString(CoreHash i_id);
    int32_t ReplacePlaceholders();
    void CoreGameText();
    int32_t GetEmptySlot();
    bool CheckFileForDuplicates();
};

struct _stat
{
    uint32_t st_dev;
    uint32_t st_ino;
    uint32_t st_mode;
    int32_t st_nlink;
    int32_t st_uid;
    int32_t st_gid;
    uint32_t st_rdev;
    int32_t st_size;
    int32_t st_atime;
    int32_t st_mtime;
    int32_t st_ctime;
};

struct tagEMRSETWORLDTRANSFORM
{
    tagEMR emr;
    tagXFORM xform;
};

struct _CRYPT_HASH_INFO
{
    _CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    _CRYPTOAPI_BLOB Hash;
};

struct IServiceProvider : IUnknown
{
    HRESULT __stdcall QueryService();
    void IServiceProvider();
};

struct _STORAGE_DEVICE_NUMBER
{
    uint32_t DeviceType;
    uint32_t DeviceNumber;
    uint32_t PartitionNumber;
};

struct FLASHWINFO
{
    uint32_t cbSize;
    HWND* hwnd;
    uint32_t dwFlags;
    uint32_t uCount;
    uint32_t dwTimeout;
};

struct _CRYPT_OBJID_TABLE
{
    uint32_t dwAlgId;
    char* pszObjId;
};

struct tagICONMETRICSA
{
    uint32_t cbSize;
    int32_t iHorzSpacing;
    int32_t iVertSpacing;
    int32_t iTitleWrap;
    tagLOGFONTA lfFont;
};

struct _PERF_DATA_BLOCK
{
    uint32_t Signature[4];
    uint32_t LittleEndian;
    uint32_t Version;
    uint32_t Revision;
    uint32_t TotalByteLength;
    uint32_t HeaderLength;
    uint32_t NumObjectTypes;
    int32_t DefaultObject;
    _SYSTEMTIME SystemTime;
    _LARGE_INTEGER PerfTime;
    _LARGE_INTEGER PerfFreq;
    _LARGE_INTEGER PerfTime100nSec;
    uint32_t SystemNameLength;
    uint32_t SystemNameOffset;
};

struct IDirectSoundFXChorus : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    void IDirectSoundFXChorus();
};

struct CAL1_AudioDriverPCTest
{
    static int32_t gNumDevices;
    static char gProgressText[256];
    static char gDeviceText[256];
    static int32_t gCurrentDevice;
    static int32_t gDeviceStages;
    static int32_t gCurrentStage;
    int32_t m_Count;
    HWND* m_hWnd;
    CAL1_AudioDevice m_deviceList[16];
    char* m_NoiseBuffer;

    // TODO vtable

    void CAL1_AudioDriverPCTest();
    void ~CAL1_AudioDriverPCTest();
    void EnumerateDevices();
    int32_t GetNumberOfDevices();
    CAL1_AudioDevice* GetDevice();
    void UpdateProgress();
    int32_t __stdcall ADPCDSEnumCallback();
    int32_t __stdcall WindowProcAudioTest();
    void TestAudio();
    IDirectSoundBuffer* CreateBuffer();
    void DestroyBuffer();
};

struct CoreXMLDoc : CoreXMLNode_
{
    enum
    {
        AUTODETECT_FILE,
        XML_FILE,
        BIN_FILE,
        XML_FILE_PTR,
        BIN_FILE_PTR,
    };

    uint32_t m_ParseFlags;
    uint32_t m_DocType;
    char* m_pMemDoc;
    char* m_szError;
    CoreXMLNode_* m_pCurrNode;
    uint32_t m_currLevel;
    uint32_t m_maxLevel;
    CoreXMLNode_* m_pSchemaNode;
    bool m_bInSchema;
    CoreXMLStringTableHandler* m_pStringTable;
    CoreMemory* m_pMemory;

    void CoreXMLDoc();
    void ~CoreXMLDoc();
    CoreXMLNode_* NewNode();
    bool Open();
    bool Close();
    bool OpenMem();
    bool Parse();
    char* GetLastErrorString();
    int32_t Write();
    int32_t OutputTree();
    char* GetEntryAsString();
    int32_t GetEntryAsInt();
    float GetEntryAsFloat();
    bool GetEntryAsBool();
    CoreXMLStringTableHandler* StringTable();
    CoreMemory* GetMemory();
    void __SetErrorString();
    void ChangeDepthCount();
    CoreXMLSchemaNode* FindSchema();
    bool StartCallBack();
    bool EndCallBack();
    bool StartTAGCallBack();
    bool EndTAGCallBack();
    bool CDataCallBack();
    bool CommentCallBack();
    bool StaticStartCallBack();
    bool StaticEndCallBack();
    bool StaticStartTAGCallBack();
    bool StaticEndTAGCallBack();
    bool StaticCDataCallBack();
    bool StaticCommentCallBack();
};

struct tagWAVEOUTCAPSW
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t dwFormats;
    uint32_t wChannels;
    uint32_t wReserved1;
    uint32_t dwSupport;
};

struct _CERT_AUTHORITY_KEY_ID_INFO
{
    _CRYPTOAPI_BLOB KeyId;
    _CRYPTOAPI_BLOB CertIssuer;
    _CRYPTOAPI_BLOB CertSerialNumber;
};

struct _CERT_PAIR
{
    _CRYPTOAPI_BLOB Forward;
    _CRYPTOAPI_BLOB Reverse;
};

struct CoreRegExp
{
    char m_expStr[1024];
    char* m_chunkStarts[64];
    int32_t m_chunkLengths[64];
    int32_t m_chunks;

    bool ParseRegularExpression();
    void SetupExp();
    bool TestString();
};

struct tagPARAMDESC
{
    tagPARAMDESCEX* pparamdescex;
    uint32_t wParamFlags;
};

struct _ENUM_SERVICE_STATUSW
{
    uint32_t* lpServiceName;
    uint32_t* lpDisplayName;
    _SERVICE_STATUS ServiceStatus;
};

struct _DISK_EXTENT
{
    uint32_t DiskNumber;
    _LARGE_INTEGER StartingOffset;
    _LARGE_INTEGER ExtentLength;
};

struct tagCAFILETIME
{
    uint32_t cElems;
    _FILETIME* pElems;
};

struct _devicemodeA
{
    uint32_t dmDeviceName[32];
    uint32_t dmSpecVersion;
    uint32_t dmDriverVersion;
    uint32_t dmSize;
    uint32_t dmDriverExtra;
    uint32_t dmFields;
    int32_t dmOrientation;
    int32_t dmPaperSize;
    int32_t dmPaperLength;
    int32_t dmPaperWidth;
    int32_t dmScale;
    int32_t dmCopies;
    int32_t dmDefaultSource;
    int32_t dmPrintQuality;
    _POINTL dmPosition;
    uint32_t dmDisplayOrientation;
    uint32_t dmDisplayFixedOutput;
    int32_t dmColor;
    int32_t dmDuplex;
    int32_t dmYResolution;
    int32_t dmTTOption;
    int32_t dmCollate;
    uint32_t dmFormName[32];
    uint32_t dmLogPixels;
    uint32_t dmBitsPerPel;
    uint32_t dmPelsWidth;
    uint32_t dmPelsHeight;
    uint32_t dmDisplayFlags;
    uint32_t dmNup;
    uint32_t dmDisplayFrequency;
    uint32_t dmICMMethod;
    uint32_t dmICMIntent;
    uint32_t dmMediaType;
    uint32_t dmDitherType;
    uint32_t dmReserved1;
    uint32_t dmReserved2;
    uint32_t dmPanningWidth;
    uint32_t dmPanningHeight;
};

struct value_entW
{
    uint32_t* ve_valuename;
    uint32_t ve_valuelen;
    uint32_t ve_valueptr;
    uint32_t ve_type;
};

struct _CROSS_CERT_DIST_POINTS_INFO
{
    uint32_t dwSyncDeltaTime;
    uint32_t cDistPoint;
    _CERT_ALT_NAME_INFO* rgDistPoint;
};

struct _CHANGER_MOVE_MEDIUM
{
    _CHANGER_ELEMENT Transport;
    _CHANGER_ELEMENT Source;
    _CHANGER_ELEMENT Destination;
    uint32_t Flip;
};

struct OPENCARDNAMEW
{
    uint32_t dwStructSize;
    HWND* hwndOwner;
    uint32_t hSCardContext;
    uint32_t* lpstrGroupNames;
    uint32_t nMaxGroupNames;
    uint32_t* lpstrCardNames;
    uint32_t nMaxCardNames;
    _GUID* rgguidInterfaces;
    uint32_t cguidInterfaces;
    uint32_t* lpstrRdr;
    uint32_t nMaxRdr;
    uint32_t* lpstrCard;
    uint32_t nMaxCard;
    uint32_t* lpstrTitle;
    uint32_t dwFlags;
    void* pvUserData;
    uint32_t dwShareMode;
    uint32_t dwPreferredProtocols;
    uint32_t dwActiveProtocol;
    uint32_t* lpfnConnect;
    int32_t* lpfnCheck;
    void* lpfnDisconnect;
    uint32_t hCardHandle;
};

struct tagPARAMDESCEX
{
    uint32_t cBytes;
    tagVARIANT varDefaultValue;
};

struct IDirectSoundFXCompressor : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    void IDirectSoundFXCompressor();
};

struct CoreGsMiptbp2
{
    uint32_t TBP4 : 14;
    uint32_t TBW4 : 6;
    uint32_t TBP5 : 14;
    uint32_t TBW5 : 6;
    uint32_t TBP6 : 14;
    uint32_t TBW6 : 6;
    uint32_t pad60 : 4;
};

struct _IMAGE_FILE_HEADER
{
    uint32_t Machine;
    uint32_t NumberOfSections;
    uint32_t TimeDateStamp;
    uint32_t PointerToSymbolTable;
    uint32_t NumberOfSymbols;
    uint32_t SizeOfOptionalHeader;
    uint32_t Characteristics;
};

struct _PACKEDEVENTINFO
{
    uint32_t ulSize;
    uint32_t ulNumEventsForLogFile;
    uint32_t ulOffsets[0];
};

struct sockproto
{
    uint32_t sp_family;
    uint32_t sp_protocol;
};

struct _EFS_RPC_BLOB
{
    uint32_t cbData;
    uint32_t* pbData;
};

struct tagMULTI_QI
{
    _GUID* pIID;
    IUnknown* pItf;
    HRESULT hr;
};

struct IInternetPriority : IUnknown
{
    HRESULT __stdcall SetPriority();
    HRESULT __stdcall GetPriority();
    void IInternetPriority();
};

struct IDirectSoundCapture : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall CreateCaptureBuffer();
    HRESULT __stdcall GetCaps();
    HRESULT __stdcall Initialize();
    void IDirectSoundCapture();
};

struct tagWNDCLASSEXW
{
    uint32_t cbSize;
    uint32_t style;
    int32_t* lpfnWndProc;
    int32_t cbClsExtra;
    int32_t cbWndExtra;
    HINSTANCE__* hInstance;
    HICON__* hIcon;
    HICON__* hCursor;
    HBRUSH__* hbrBackground;
    uint32_t* lpszMenuName;
    uint32_t* lpszClassName;
    HICON__* hIconSm;
};

struct tagMENUITEMINFOW
{
    uint32_t cbSize;
    uint32_t fMask;
    uint32_t fType;
    uint32_t fState;
    uint32_t wID;
    HMENU__* hSubMenu;
    HBITMAP__* hbmpChecked;
    HBITMAP__* hbmpUnchecked;
    uint32_t dwItemData;
    uint32_t* dwTypeData;
    uint32_t cch;
    HBITMAP__* hbmpItem;
};

struct tagMIDIINCAPSA
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t dwSupport;
};

struct _s__RTTIBaseClassArray
{
    _s__RTTIBaseClassDescriptor* arrayOfBaseClassDescriptors[0];
};

struct CoreGsPrmode
{
    uint32_t pad00 : 3;
    uint32_t IIP : 1;
    uint32_t TME : 1;
    uint32_t FGE : 1;
    uint32_t ABE : 1;
    uint32_t AA1 : 1;
    uint32_t FST : 1;
    uint32_t CTXT : 1;
    uint32_t FIX : 1;
    uint32_t pad11 : 53;
};

struct CoreGsDBuff
{
    CoreGsDispEnv disp[2];
    CoreGifTag giftag0;
    CoreGsDrawEnv1 draw0;
    CoreGsClear clear0;
    CoreGifTag giftag1;
    CoreGsDrawEnv1 draw1;
    CoreGsClear clear1;
};

struct tagGCP_RESULTSA
{
    uint32_t lStructSize;
    char* lpOutString;
    uint32_t* lpOrder;
    int32_t* lpDx;
    int32_t* lpCaretPos;
    char* lpClass;
    uint32_t* lpGlyphs;
    uint32_t nGlyphs;
    int32_t nMaxFit;
};

struct IPersistFile : IPersist
{
    HRESULT __stdcall IsDirty();
    HRESULT __stdcall Load();
    HRESULT __stdcall Save();
    HRESULT __stdcall SaveCompleted();
    HRESULT __stdcall GetCurFile();
    void IPersistFile();
};

struct CoreGraphicsDeviceFogSettings
{
    float nearDist;
    float farDist;
    float red;
    float green;
    float blue;
    float alpha;
    bool on;
};

struct HTASK__
{
    int32_t unused;
};

struct CoreDetectLineSegment
{
};

struct CorePhysicsArticulate
{
    CorePhysicsJoint* m_joints;
    int32_t m_jointsNum;
    CorePhysicsBody* m_bodies;
    int32_t* m_bodyBoneIndex;
    int32_t* m_bodySimType;
    float* m_bodyBlendScale;
    int32_t* m_bodyBlendMode;
    int32_t* m_bodyJointIndex;
    int32_t m_bodiesNum;
    int32_t* m_boneSimParent;
    int32_t* m_boneSimChild;
    CoreVector* m_boneSimOffset;
    int32_t m_boneNum;
    int32_t m_setUpFlag;
    int32_t m_hasPurePhysicsBones;
    float m_activationBlastPower;
    CoreVector m_activationImpulse;
    CoreVector m_activationBlastPos;
    CoreMatrix m_prevHipMatrix;

    void CorePhysicsArticulate();
    void reset();
    void initBodies(CoreMemory* mem, CorePhysicsWorld* pWorld, CoreSingleCollidable* collidables, int32_t numCollidables, int32_t objID);
    void initJoints(CoreMemory* mem, CorePhysicsWorld* pWorld, CoreModelSkeleton* skele, int32_t numJoints);
    void initializeRagdoll(CoreMemory* io_mem, CorePhysicsWorld* i_world, CoreModelCollidable* i_collidables, int32_t i_numCollidables, CoreModelSkeleton* i_engineSkeleton, CoreModelSkeleton* i_renderSkeleton, int32_t i_objID);
    void destroy(CoreMemory* mem, CorePhysicsWorld* pWorld);
    void setUp(CoreMatrix& matrix, CoreMatrix* matrixList);
    void setCur(CoreMatrix& matrix, CoreMatrix* matrixList, float animVelScale);
    void getUp(CoreVector& newPos, CoreEulerAngle& newOrient, CoreMatrix* matrixList);
    void setImpulse();
    void applyImpulse();
    void setBlast();
    void addBlast(CoreVector& i_pos, float i_power);
    void clearAcc();
    void addAcc();
    void activate(CoreVector& vel);
    void deactivate();
    bool hasPurePhysicsBones();
    void setBlendScaleMode(float blendScale, int32_t blendMode);
    bool isBlending();
    void ~CorePhysicsArticulate();
};

struct tagMETARECORD
{
    uint32_t rdSize;
    uint32_t rdFunction;
    uint32_t rdParm[1];
};

struct tagRPC_ERROR_ENUM_HANDLE
{
    uint32_t Signature;
    void* CurrentPos;
    void* Head;
};

struct _PERF_BIN
{
    uint32_t NumberOfBins;
    uint32_t TypeOfBin;
    _BIN_RANGE BinsRanges[1];
};

struct CoreGameRender : CoreScripted
{
    enum
    {
        VERSION = 4,
    };

    enum CoreDrawFlagsEnum
    {
        DRAW_WEAPONMARKERS = 0,
        DRAW_BODYMARKERS = 1,
        DRAW_DETECTORS = 2,
        DRAW_COLLIDABLES = 3,
        DRAW_RAGDOLLCOLLIDABLES = 4,
        DRAW_ANIMLIST = 5,
        DRAW_STATIC_OBJECTS = 6,
        DRAW_ANIMATING_OBJECTS = 7,
        DRAW_LEVEL = 8,
        DRAW_OBJECTS = 9,
        DRAW_QUADS = 10,
        DRAW_EFFECTS = 11,
        DRAW_SHADOWS = 12,
        DRAW_SKELETON = 13,
        DRAW_BONE_BBOX = 14,
        DRAW_STATIC_GEOMETRY = 15,
        DRAW_PARENTED_GEOMETRY = 16,
        DRAW_SOFTSKINNED_GEOMETRY = 17,
        DRAW_HARDSKINNED_GEOMETRY = 18,
        DRAW_GEOMETRY = 19,
        DRAW_WEAPONMARKERS_DETAIL = 20,
        DRAW_BODYMARKERS_DETAIL = 21,
        DRAW_COLLIDABLES_DETAIL = 22,
        DRAW_OBJECTNAMES = 23,
        DRAW_SUBOBJECTMARKERS = 24,
        DRAW_BLENDSHAPE_OVERRIDE = 25,
        DRAW_BLENDSHAPE_OVERRIDE_BASE = 26,
        DRAW_BLENDSHAPE_OVERRIDE_TARGET_NUM_BITS = 3,
        DRAW_BLENDSHAPE_OVERRIDE_TARGET_BIT0 = 27,
        DRAW_BLENDSHAPE_GEOMETRY = 30,
        DRAW_PANEL = 31,
        DRAW_UNUSED = 32,
        DRAW_TEXTURES = 33,
        DRAW_GOURAUD = 34,
        DRAW_LIGHTING = 35,
        DRAW_OBJECTPIVOTS = 36,
        DRAW_SHADOW_VOLUMES = 37,
        DRAW_OPAQUE_MESHES = 38,
        DRAW_ALPHA_MESHES = 39,
        SORT_ALPHA_MESHES = 40,
        DRAW_DYNAMIC_LIGHT_VOLUMES = 41,
        DRAW_DEBUG_DYNAMIC_LIGHT_VOLUMES = 42,
        DRAW_POST_PROCESS_EFFECTS = 43,
        DRAW_MASK_MESHES = 44,
        ADD_MASKS_TO_LIST = 45,
        DRAW_INVIEW_SPHERES = 46,
        DISABLE_OBJECT_CULLING = 47,
        STATIC_MATERIAL_BBOX_CULL = 48,
        OVERRIDE_AUTO_LOD_CALCULATION = 49,
        OVERRIDE_LOD_LEVEL_NUM_BITS = 3,
        OVERRIDE_LOD_LEVEL_BIT0 = 50,
        DRAW_BLINDDATA = 53,
        ADD_ALPHAS_TO_LIST = 54,
        TEST_SPLIT_SCREEN = 55,
        TEST_SPLIT_SCREEN_ENABLE = 56,
        DRAW_OCCLUDERS = 57,
        DRAW_OCCLUDERS_DETAIL = 58,
        DRAW_BONE_NAMES = 59,
    };

    enum CoreQuadDrawFlagsEnum
    {
        QUAD_RENDERNOW = 0,
        QUAD_ALPHABLEND = 1,
        QUAD_ADDITIVEBLEND = 2,
        QUAD_SUBTRACTIVEBLEND = 3,
        QUAD_DESTINATION_ALPHABLEND = 4,
        QUAD_ALPHAWRITE = 5,
        QUAD_DESTINATION_ADDITIVEBLEND = 6,
        QUAD_NO_SCALE_TO_TARGET_PLATFORM = 7,
        QUAD_NOT_TEXTURE_SORTED = 8,
        QUAD_PRIVATE_SCREENSPACE = 30,
        QUAD_PRIVATE_ZBUFFER = 31,
    };

    CoreGameRenderInternalData* m_lpoData;

    void CoreGameRender();
    void ~CoreGameRender();
    void Construct(CoreMemory* i_memory);
    void Destruct(CoreMemory* lpoMemory);
    void Init(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void Reset(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void ResetLevelOnly(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    int32_t GetVersion();
    void StartRenderList();
    void EndRenderList();
    void SwapBuffers();
    void SetQuadStoreScale(CoreVector i_scale);
    bool bAddWorldToRenderList(CoreWorld* lpoWorld);
    bool bAddPanelToRenderList();
    bool bAddLevelToRenderList(CoreLevel* lpoLevel);
    bool bAddBackgroundObjectToRenderList();
    bool bAddPanelObjectToRenderList(CoreRenderableObject* lpoObject);
    bool bAddBeforeLevelObjectToRenderList(CoreRenderableObject* lpoObject);
    bool bAddLastObjectToRenderList(CoreRenderableObject* lpoObject);
    bool bAddObjectToRenderList(CoreRenderableObject* lpoObject);
    bool bAddEffectToRenderList();
    bool bAddConsoleToRenderList(CoreConsole* lpoConsole);
    bool IsSphereInView();
    bool IsBBoxInView(CoreVector i_min, CoreVector i_max);
    void SelectLights(CoreVector& vWorldPos, CoreGraphicsDeviceLightData* lpoLightData);
    uint32_t GetDrawFlags();
    void EnableSplitScreen(bool i_enable);
    bool IsSplitScreen();
    void Update(CoreWorldUpdateStruct* lpoUpdateStruct);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void DoDebug(CoreDebugInput* i_input);
    void DrawFgScreenQuadBounds(CoreVector& vTopLeft, CoreVector& vBottomRight, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV& oUV0, CoreUV& oUV1, CoreRGBA oColour, int32_t iFlags);
    void DrawFgScreenQuadCentreSize();
    void DrawFgScreenQuadPoints(CoreVector* lpvPoints, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV* lpoUVs, CoreRGBA oColour, int32_t iFlags);
    void DrawFgTransformedScreenQuadBounds(CoreVector& vTopLeft, CoreVector& vBottomRight, float fRotate, float fScale, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV& oUV0, CoreUV& oUV1, CoreRGBA oColour, int32_t iFlags);
    void DrawFgTransformedScreenQuadCentreSize(CoreVector& vCentre, float fWidth, float fHeight, float fRotate, float fScale, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV& oUVCentre, float fUVWidth, float fUVHeight, CoreRGBA oColour, int32_t iFlags);
    void DrawFgTransformedScreenQuadPoints();
    void DrawZScreenQuadBounds();
    void DrawZScreenQuadCentreSize();
    void DrawZScreenQuadPoints();
    void DrawZTransformedScreenQuadBounds();
    void DrawZTransformedScreenQuadCentreSize();
    void DrawZTransformedScreenQuadPoints();
    void DrawUntexturedFgScreenQuadBounds(CoreVector& vTopLeft, CoreVector& vBottomRight, CoreRGBA oColour, int32_t iFlags);
    void DrawUntexturedFgScreenQuadCentreSize();
    void DrawUntexturedFgScreenQuadPoints();
    void DrawUntexturedFgTransformedScreenQuadBounds();
    void DrawUntexturedFgTransformedScreenQuadCentreSize();
    void DrawUntexturedFgTransformedScreenQuadPoints();
    void DrawUntexturedZScreenQuadBounds();
    void DrawUntexturedZScreenQuadCentreSize();
    void DrawUntexturedZScreenQuadPoints();
    void DrawUntexturedZTransformedScreenQuadBounds();
    void DrawUntexturedZTransformedScreenQuadCentreSize();
    void DrawUntexturedZTransformedScreenQuadPoints();
    void DrawFgWorldQuadBounds();
    void DrawFgWorldQuadCentreSize();
    void DrawFgWorldQuadPoints();
    void DrawFgTransformedWorldQuadBounds();
    void DrawFgTransformedWorldQuadCentreSize();
    void DrawFgTransformedWorldQuadPoints();
    void DrawZWorldQuadBounds();
    void DrawZWorldQuadCentreSize();
    void DrawZWorldQuadPoints();
    void DrawZTransformedWorldQuadBounds();
    void DrawZTransformedWorldQuadCentreSize();
    void DrawZTransformedWorldQuadPoints();
    void DrawUntexturedFgWorldQuadBounds();
    void DrawUntexturedFgWorldQuadCentreSize();
    void DrawUntexturedFgWorldQuadPoints();
    void DrawUntexturedFgTransformedWorldQuadBounds();
    void DrawUntexturedFgTransformedWorldQuadCentreSize();
    void DrawUntexturedFgTransformedWorldQuadPoints();
    void DrawUntexturedZWorldQuadBounds();
    void DrawUntexturedZWorldQuadCentreSize();
    void DrawUntexturedZWorldQuadPoints();
    void DrawUntexturedZTransformedWorldQuadBounds();
    void DrawUntexturedZTransformedWorldQuadCentreSize();
    void DrawUntexturedZTransformedWorldQuadPoints();
    void SetCurrentViewerObject();
    void AddTriBatch(int32_t i_startIndex, int32_t i_triangleCount, uint32_t i_flags, CoreRGBA i_colour, CoreTextureSet* i_textureSet, CoreHash i_textureHash);
    void AddTriBatchDataXYZ();
    void AddTriBatchDataUVXYZ();
    uint32_t GetTriBatchDataCount();
    CoreScripted::CommandReturn eFnGraphicsUpdate(CoreCommand* lpoCommand);
    void ResetDrawFlags();
    void RenderLevel();
    void RenderWorld();
    void RenderMenuSystem();
    CoreVector vRotate2D(CoreVector& vVector, float fAngle);
    void RenderSingleQuad();
    void SetQuadBlendModes(int32_t iFlags);
    void StoreQuad(CoreVector* lpvPoints, float fRotate, float fScale, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV* lpoInputUVs, CoreRGBA oColour, int32_t iFlags);
    void RenderQuads();
    void ResetQuads();
    void RenderSingleTriBatch(TriBatchStore* i_triStore, float* i_triStoreData, CoreGraphicsDevice* i_device);
    void RenderTriBatches();
    void ResetTriBatches();
    CoreViewerObject* SelectViewer(CoreWorldUpdateStruct* i_updateStruct, uint32_t i_numViewers, uint32_t i_view);
};

struct QuadStore
{
    CoreVector m_points[4];
    CoreTextureSet* m_textureSet;
    CoreHash m_textureHash;
    CoreUV m_uv[4];
    CoreRGBA m_colour;
    uint32_t m_flags;

    void QuadStore();
    void ~QuadStore();
};

struct TriBatchStore
{
    uint32_t m_startIndex;
    uint32_t m_vertexCount;
    uint32_t m_flags;
    CoreRGBA m_colour;
    CoreTextureSet* m_textureSet;
    CoreHash m_textureHash;

    void TriBatchStore();
    void ~TriBatchStore();
};

struct CoreViewerObject : CoreCameraObject
{
    enum BlendMode
    {
        BlendModeLinear,
        BlendModeCatchUp,
        BlendModePolar,
    };

    bool m_allowDebugMode;
    float m_maxAcc;
    CoreVector m_oldPosition;
    CoreStringBuffer<256> m_nameString;
    CoreHash m_scriptvarAttachCam;
    CoreHash m_scriptvarSetCurrentCam;
    CoreHash m_scriptvarSetDefaultCam;
    bool m_scriptvarPopCamera;
    int32_t m_scriptvarNumActiveCameras;
    CoreCameraObject* m_attachedCameraList[128];
    int32_t m_numAttachedCameras;
    CoreCameraObject* m_defaultCamera;
    bool m_resetTriggers;
    CoreCameraObject* m_currentCamera;
    CoreCameraObject* m_currentFromCamera;
    bool m_blendingFlag;
    float m_blendTimer;
    float m_blendTimerMax;
    float m_currentBlendScale;
    bool m_cameraDirectFlag;
    bool m_cameraDirectUseLookAt;
    bool m_takeViewValuesFromCameraFlag;
    CoreViewerObject::BlendMode m_posBlendMode;
    bool m_lookAtCatchupFlag;
    bool m_useNearestCameraModeFlag;
    bool m_enableCameraSwitching;
    int32_t m_debugMode;
    CoreCommand* m_command;
    CoreObjectUpdateStruct* m_updateStruct;
    float m_currentFrameTime;
    CoreVector m_blendFromPos;
    CoreVector m_blendFromLookAtPos;
    float m_blendFromRoll;
    float m_blendFromZoom;
    float m_blendFromFOV;
    CoreVector m_blendToPos;
    CoreVector m_blendToLookAtPos;
    float m_blendToRoll;
    float m_blendToZoom;
    float m_blendToFOV;
    float m_screenX0;
    float m_screenY0;
    float m_screenX1;
    float m_screenY1;
    CoreCameraObject* m_nearestCamera;
    CoreObject* m_relatedObject;
    CoreHash m_relatedObjectHash;
    CoreCameraEffect m_cameraEffect;
    CoreS128Aligned m_memoryPot[256];

    void CoreViewerObject();
    void ~CoreViewerObject();
    void Construct(CoreMemory* io_memory);
    void Init(CoreHash i_nameHash, CoreHash i_scriptHash, CoreObjectUpdateStruct* io_updateStruct);
    CoreObject* Create(CoreMemory* io_memory);
    CoreCameraObject* GetCurrentCamera();
    void SetCurrentCamera(CoreCameraObject* i_camera);
    void SetCurrentCameraByName(CoreHash i_cameraname);
    void SetBlendingFlag(bool i_var);
    void SetCameraDirectFlag(bool i_var);
    bool GetCameraDirectFlag();
    bool GetCameraDirectUseLookAtFlag();
    void SetCameraDirectUseLookAtFlag(bool i_var);
    CoreHash GetTypeID();
    void SetLookAtCatchupMode();
    bool GetLookAtCatchupMode();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void Control(CoreObjectUpdateStruct* i_updateStruct);
    void SetDefaultCamera(CoreCameraObject* i_camera);
    void AttachCamera(CoreCameraObject* i_camera);
    void PopCamera();
    void SetRelatedObject(CoreObject* i_obj);
    CoreObject* GetRelatedObject();
    void SetRelatedObjectHash(CoreHash i_hash);
    CoreHash GetRelatedObjectHash();
    void SetNameString(CoreStringBuffer<256> i_str);
    CoreStringBuffer<256> GetNameString();
    void SetCameraSwitching();
    bool GetCameraSwitching();
    int32_t GetDebugMode();
    void ResetTriggers();
    CoreScripted::CommandReturn FnCreateCamera(CoreCommand* i_command);
    CoreScripted::CommandReturn FnUpdate();
    CoreScripted::CommandReturn FnSetCurrentCamera(CoreCommand* i_command);
    CoreScripted::CommandReturn FnPopCamera(CoreCommand* i_command);
    CoreScripted::CommandReturn FnSetDefaultCamera(CoreCommand* i_command);
    CoreScripted::CommandReturn FnAttachCamera(CoreCommand* i_command);
    CoreScripted::CommandReturn FnSetNearestCameraMode(CoreCommand* i_command);
    CoreScripted::CommandReturn FnSetCameraDirectMode(CoreCommand* i_command);
    CoreScripted::CommandReturn FnSetCameraDirectUseLookAtMode(CoreCommand* i_command);
    CoreScripted::CommandReturn FnTakeViewValuesFromCamera(CoreCommand* i_command);
    void UpdateDebugKeys();
    void DebugUpdate(CoreObjectUpdateStruct* lpoUpdateStruct);
    void TakeValuesFromCamera(CoreCameraObject* i_cam);
    void UpdateDirectCamera();
    void UpdateBlendCamera();
    void CalculateBlendScale();
    void BlendPos();
    void BlendLookAtPos();
    void BlendRoll();
    void BlendView();
    void BlendZoom();
    void StoreCommandStructure();
    void SelectNearestCamera();
    void ApplyCameraEffect();
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
};

struct tagWNDCLASSEXA
{
    uint32_t cbSize;
    uint32_t style;
    int32_t* lpfnWndProc;
    int32_t cbClsExtra;
    int32_t cbWndExtra;
    HINSTANCE__* hInstance;
    HICON__* hIcon;
    HICON__* hCursor;
    HBRUSH__* hbrBackground;
    char* lpszMenuName;
    char* lpszClassName;
    HICON__* hIconSm;
};

struct _UUID_VECTOR
{
    uint32_t Count;
    _GUID* Uuid[1];
};

struct _CRYPT_DECRYPT_MESSAGE_PARA
{
    uint32_t cbSize;
    uint32_t dwMsgAndCertEncodingType;
    uint32_t cCertStore;
    void** rghCertStore;
};

struct SCARD_T0_COMMAND
{
    uint32_t bCla;
    uint32_t bIns;
    uint32_t bP1;
    uint32_t bP2;
    uint32_t bP3;
};

struct tagDISPPARAMS
{
    tagVARIANT* rgvarg;
    int32_t* rgdispidNamedArgs;
    uint32_t cArgs;
    uint32_t cNamedArgs;
};

struct HWINSTA__
{
    int32_t unused;
};

struct _EFS_KEY_INFO
{
    uint32_t dwVersion;
    uint32_t Entropy;
    uint32_t Algorithm;
    uint32_t KeyLength;
};

struct tagEMRTEXT
{
    _POINTL ptlReference;
    uint32_t nChars;
    uint32_t offString;
    uint32_t fOptions;
    _RECTL rcl;
    uint32_t offDx;
};

struct tagWINDOWINFO
{
    uint32_t cbSize;
    tagRECT rcWindow;
    tagRECT rcClient;
    uint32_t dwStyle;
    uint32_t dwExStyle;
    uint32_t dwWindowStatus;
    uint32_t cxWindowBorders;
    uint32_t cyWindowBorders;
    uint32_t atomWindowType;
    uint32_t wCreatorVersion;
};

struct CoreMemoryStack : CoreMemory
{
    CoreMemoryStackMarker* m_markers;
    int32_t m_numMarkers;
    uint32_t* m_baseMem;
    uint32_t* m_maxMem;
    uint32_t* m_freeMem;

    void Construct();
    void Destruct();
    void* Alloc(uint32_t i_bytes, uint32_t i_alignment, char* i_fileName, uint32_t i_lineNumber);
    void Free(void* i_memory, char*, int32_t);
    int32_t GetMemoryAvailable();
    int32_t GetMemoryUsed();
    char* GetDebugTypeName();
    void CoreMemoryStack();
    void ~CoreMemoryStack();
    bool Init(int32_t i_poolSize, uint32_t* i_memory);
    bool Destroy();
    bool ResetToStart();
    bool ResetToNamedMarker(CoreHash i_markerName);
    bool CreateMarker(CoreHash i_markerName);
    uint32_t* GetMarkerMemoryPos(CoreHash i_markerName);
    void Zero();
    bool IsValid();
    CoreMemoryStackMarker* FindMarker(CoreHash i_markerName, bool& o_found);
    void RemoveMarkers();
    void InitMarkers();
};

struct __unnamed
{
    void* pad[2];
    void* userContext;
};

struct _SCONTEXT_QUEUE
{
    uint32_t NumberOfObjects;
    __unnamed** ArrayOfObjects;
};

struct IMallocSpy : IUnknown
{
    uint32_t __stdcall PreAlloc();
    void* __stdcall PostAlloc();
    void* __stdcall PreFree();
    void __stdcall PostFree();
    uint32_t __stdcall PreRealloc();
    void* __stdcall PostRealloc();
    void* __stdcall PreGetSize();
    uint32_t __stdcall PostGetSize();
    void* __stdcall PreDidAlloc();
    int32_t __stdcall PostDidAlloc();
    void __stdcall PreHeapMinimize();
    void __stdcall PostHeapMinimize();
    void IMallocSpy();
};

struct HMENU__
{
    int32_t unused;
};

struct tagWINDOWPLACEMENT
{
    uint32_t length;
    uint32_t flags;
    uint32_t showCmd;
    tagPOINT ptMinPosition;
    tagPOINT ptMaxPosition;
    tagRECT rcNormalPosition;
};

struct _CHANGER_READ_ELEMENT_STATUS
{
    _CHANGER_ELEMENT_LIST ElementList;
    uint32_t VolumeTagInfo;
};

struct CoreWorldUpdateStruct : CoreLevelUpdateStruct
{
    void CoreWorldUpdateStruct();
    void ~CoreWorldUpdateStruct();
};

struct CoreAltAnimAtom
{
    enum
    {
        VERSION = 1,
    };

    enum AAAFlags
    {
        AAAF_LOOPING,
        AAAF_MIRROR,
    };

    uint32_t m_animTableIndex;
    float m_weight;
    float m_playbackSpeed;
    uint32_t m_flags;

    void CoreAltAnimAtom();
    void ~CoreAltAnimAtom();
    uint32_t GetAnimTableIndex();
    float GetWeight();
    float GetPlaybackSpeed();
    uint32_t GetFlags();
    bool IsLooping();
    bool IsMirror();
};

struct _JOBOBJECT_BASIC_LIMIT_INFORMATION
{
    _LARGE_INTEGER PerProcessUserTimeLimit;
    _LARGE_INTEGER PerJobUserTimeLimit;
    uint32_t LimitFlags;
    uint32_t MinimumWorkingSetSize;
    uint32_t MaximumWorkingSetSize;
    uint32_t ActiveProcessLimit;
    uint32_t Affinity;
    uint32_t PriorityClass;
    uint32_t SchedulingClass;
};

struct tagVS_FIXEDFILEINFO
{
    uint32_t dwSignature;
    uint32_t dwStrucVersion;
    uint32_t dwFileVersionMS;
    uint32_t dwFileVersionLS;
    uint32_t dwProductVersionMS;
    uint32_t dwProductVersionLS;
    uint32_t dwFileFlagsMask;
    uint32_t dwFileFlags;
    uint32_t dwFileOS;
    uint32_t dwFileType;
    uint32_t dwFileSubtype;
    uint32_t dwFileDateMS;
    uint32_t dwFileDateLS;
};

struct tagMCI_WAVE_OPEN_PARMSW
{
    uint32_t dwCallback;
    uint32_t wDeviceID;
    uint32_t* lpstrDeviceType;
    uint32_t* lpstrElementName;
    uint32_t* lpstrAlias;
    uint32_t dwBufferSeconds;
};

struct _RPC_TRANSFER_SYNTAX
{
    _GUID Uuid;
    uint32_t VersMajor;
    uint32_t VersMinor;
};

struct _CRYPT_VERIFY_MESSAGE_PARA
{
    uint32_t cbSize;
    uint32_t dwMsgAndCertEncodingType;
    uint32_t hCryptProv;
    _CERT_CONTEXT** pfnGetSignerCertificate;
    void* pvGetArg;
};

struct HIMC__
{
    int32_t unused;
};

struct _EXCEPTION_RECORD32
{
    uint32_t ExceptionCode;
    uint32_t ExceptionFlags;
    uint32_t ExceptionRecord;
    uint32_t ExceptionAddress;
    uint32_t NumberParameters;
    uint32_t ExceptionInformation[15];
};

struct tagMENUITEMINFOA
{
    uint32_t cbSize;
    uint32_t fMask;
    uint32_t fType;
    uint32_t fState;
    uint32_t wID;
    HMENU__* hSubMenu;
    HBITMAP__* hbmpChecked;
    HBITMAP__* hbmpUnchecked;
    uint32_t dwItemData;
    char* dwTypeData;
    uint32_t cch;
    HBITMAP__* hbmpItem;
};

struct _CMSG_SIGNED_ENCODE_INFO
{
    uint32_t cbSize;
    uint32_t cSigners;
    _CMSG_SIGNER_ENCODE_INFO* rgSigners;
    uint32_t cCertEncoded;
    _CRYPTOAPI_BLOB* rgCertEncoded;
    uint32_t cCrlEncoded;
    _CRYPTOAPI_BLOB* rgCrlEncoded;
};

struct tagSAFEARRAY
{
    uint32_t cDims;
    uint32_t fFeatures;
    uint32_t cbElements;
    uint32_t cLocks;
    void* pvData;
    tagSAFEARRAYBOUND rgsabound[1];
};

struct CoreGsTest
{
    uint32_t ATE : 1;
    uint32_t ATST : 3;
    uint32_t AREF : 8;
    uint32_t AFAIL : 2;
    uint32_t DATE : 1;
    uint32_t DATM : 1;
    uint32_t ZTE : 1;
    uint32_t ZTST : 2;
    uint32_t pad19 : 45;
};

struct tagEMREXTCREATEPEN
{
    tagEMR emr;
    uint32_t ihPen;
    uint32_t offBmi;
    uint32_t cbBmi;
    uint32_t offBits;
    uint32_t cbBits;
    tagEXTLOGPEN elp;
};

struct _IMAGE_RELOCATION
{
    uint32_t VirtualAddress;
    uint32_t RelocCount;
    uint32_t SymbolTableIndex;
    uint32_t Type;
};

struct tagCHOOSEFONTW
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HDC__* hDC;
    tagLOGFONTW* lpLogFont;
    int32_t iPointSize;
    uint32_t Flags;
    uint32_t rgbColors;
    int32_t lCustData;
    uint32_t* lpfnHook;
    uint32_t* lpTemplateName;
    HINSTANCE__* hInstance;
    uint32_t* lpszStyle;
    uint32_t nFontType;
    uint32_t ___MISSING_ALIGNMENT__;
    int32_t nSizeMin;
    int32_t nSizeMax;
};

struct IDirectSoundFXParamEq : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    void IDirectSoundFXParamEq();
};

struct CorePhysicsJoint
{
    int32_t m_parentBodyWorldIndex;
    int32_t m_childBodyWorldIndex;
    int32_t m_flag;
    int32_t m_setupBodyIndex;
    CorePhysicsVert m_vertP;
    CorePhysicsVert m_vertC;
    CoreVector m_lowerEulerLimits;
    CoreVector m_upperEulerLimits;
    CoreMatrix m_parentToBindMatrix;
    CoreMatrix m_childToBindMatrix;
    CoreMatrix m_childToParentMatrix;
    static CorePhysicsWorld* CorePhysicsWorldInstance;

    CoreVector conjugateQuat();
    CoreVector multQuat();
    void CorePhysicsJoint();
    int32_t getParentBodyWorldIndex();
    int32_t getChildBodyWorldIndex();
    void initialize(CorePhysicsWorld* world, int32_t bodIndexA, int32_t bodIndexB, int32_t setupBodIndex);
    void destroy(CoreMemory* mem, CorePhysicsWorld* pWorld);
    void setUp(CoreVector& pos);
    void setCur();
    void setLimits(CoreVector& lowerEulerLim, CoreVector& upperEulerLim);
    void setBindInfo(CoreMatrix& parentBind, CoreMatrix& childBind);
    void enforceJointPos();
    void collideJointVsPlanePair(CoreVector& sPos, int32_t jindexC, int32_t jindexP, CoreVector& jposC, CoreVector& jposP, CoreVector& pnorm0, CoreVector& pnorm1, float len);
    void collideJointVSPlane();
    void enforceEulerLimits(int32_t debugFlag);
    void setSetupBodyIndex();
    int32_t getSetupBodyIndex();
    float getDist();
    CoreVector getRelA();
    CoreVector getRelB();
    void ~CorePhysicsJoint();
};

struct CoreFileSystem
{
    enum CoreFileLoadReturn
    {
        CORE_FILE_NOT_EXIST,
        CORE_FILE_NOT_LOADED,
        CORE_FILE_LOADED,
        CORE_FILE_ERROR,
    };

    enum CoreFileSystemAsyncState
    {
        ASYNC_IDLE,
        ASYNC_BEFORE_LOAD,
        ASYNC_IN_LOAD,
        ASYNC_DONE_LOAD,
        ASYNC_ERROR,
        ASYNC_ERROR_FILENAME_TOO_LONG,
        ASYNC_ERROR_SYNC_ACTIVE,
        ASYNC_ERROR_NOT_IDLE,
        ASYNC_ERROR_FILEHANDLE,
        ASYNC_ERROR_NUMREADBYTES,
        ASYNC_ERROR_READDEST,
        ASYNC_ERROR_FILENAMEHASH,
        ASYNC_ERROR_FILENAME,
        ASYNC_ERROR_WRONG_FILENAME,
        ASYNC_ERROR_DURING_OPENFILE,
        ASYNC_ERROR_DURING_CLOSEFILE,
        ASYNC_ERROR_DURING_LOAD,
    };

    CoreFileDevice* m_device;
    CoreFileHandle m_asyncFileHandle;
    int32_t m_asyncNumberOfBytesToRead;
    int32_t m_asyncStartOffset;
    void* m_asyncReadDestination;
    int32_t m_numOpenFiles;
    int32_t m_maxOpenFiles;
    CoreStringBuffer<256> m_filePrefix;
    CoreStringBuffer<256> m_asyncFileName;
    CoreHash m_asyncFileNameHash;
    CoreFileSystem::CoreFileSystemAsyncState m_asyncState;
    static bool m_absoluteFileAccess;

    // TODO vtable

    void CoreFileSystem();
    void ~CoreFileSystem();
    CoreFileSystem::CoreFileSystemAsyncState GetAsyncState();
    bool IsAsyncErrorState(CoreFileSystem::CoreFileSystemAsyncState i_state);
    bool IsAsyncLoadingDone();
    bool IsAsyncLoadingIdle(CoreHash i_fileNameHash);
    void Construct();
    void Destruct();
    void Init();
    CoreFileHandle Open();
    bool Close();
    int32_t Read();
    int32_t Write();
    bool Seek();
    int32_t FileSize();
    bool GetFileTimes();
    bool SetFileTimes();
    bool DoesFileExist();
    bool IsReadOnly();
    bool ChangeReadOnly();
    CoreFileSystem::CoreFileSystemAsyncState AsyncStartLoadFile(char* i_name, int32_t i_startOffset, int32_t i_size, void* o_dest);
    CoreFileSystem::CoreFileSystemAsyncState AsyncUpdate();
    CoreFileSystem::CoreFileSystemAsyncState AsyncEndLoadFile(char* i_name);
    char* GetCurrentAsyncState(CoreHash i_fileNameHash);
    CoreHash GetAsyncFileNameHash();
    char* GetAsyncFileName();
    int32_t GetNumberOfOpenFiles();
    void SetMaxNumberOfOpenFiles(int32_t i_maxOpenFiles);
    int32_t GetMaxNumberOfOpenFiles();
    int32_t IsFileOpen();
    CoreFileDevice* GetFileDevice();
    void SetFileDevice(CoreFileDevice* i_fileDevice);
    char* GetFilePrefix();
    void SetFilePrefix(char* i_filePrefix);
    bool GetAbsoluteFileAccess();
    void SetAbsoluteFileAccess();
    bool CompleteTheFileName(char* i_fileName, CoreStringBuffer<256>& o_fileName, bool i_convertToUppercase);
    bool IsAbsoluteFileName(char* i_fileName);
    bool IsValid();
    void Zero();
    bool OpenFile();
    bool CloseFile();
    void SetNumberOfOpenFiles();
    void IncrementNumberOfOpenFiles();
    void DecrementNumberOfOpenFiles();
    void SetAsyncFileName(char* i_fileName);
    void ClearAsyncFileName();
    void SetAsyncState();
    void* GetAsyncReadDestination();
    int32_t GetAsyncNumberOfBytesToRead();
    int32_t GetAsyncStartOffset();
    void SetAsyncFileNameHash(CoreHash i_hash);
};

struct _SCARD_ATRMASK
{
    uint32_t cbAtr;
    uint32_t rgbAtr[36];
    uint32_t rgbMask[36];
};

struct CAL1_AudioObject : CAL1_AudioItem
{
    ca_3DVelocity m_Velocity;
    ca_3DPoint m_Location;
    CAL0_List* m_SubObjects;
    CAL0_List* m_Events;
    CAL1_AudioObject* m_ParentObject;
    CAL1_AudioData* m_Data;
    bool m_Used;
    uint32_t m_LanguageMask;

    void CAL1_AudioObject();
    void ~CAL1_AudioObject();
    bool GetUsed();
    bool SetUsed();
    CAAudioError EventStart(uint32_t eventID);
    CAAudioError EventStartWithParams(uint32_t eventID, uint32_t gridPosition);
    CAAudioError EventUpdate(uint32_t eventID);
    CAAudioError EventTrigger(uint32_t eventID);
    CAAudioError EventEnd(uint32_t eventID);
    bool IsEventPlaying(uint32_t eventID);
    CAAudioError Update();
    CAAudioError SetLanguageMask();
    uint32_t GetLanguageMask();
    CAAudioError AllocateSubObjectList(uint32_t numSubObjects);
    CAAudioError AllocateEventList(uint32_t numEvents);
    CAAudioError SetAudioData(CAL1_AudioData* data);
    CAL1_AudioData* GetAudioData();
    CAAudioError AddSubObject();
    CAAudioError RemoveSubObject();
    CAAudioError GetSubObjectByIndex();
    CAAudioError AddEvent();
    CAAudioError AddEventLink();
    CAAudioError RemoveEvent();
    CAAudioError RemoveAllEventLinks();
    void SetParentObject();
    CAAudioError LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
    CAAudioError SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
    CAAudioError DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* aid);
    CAAudioError DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
};

struct CoreMapFileStringTable
{
    int32_t m_maximumSize;
    int32_t m_remaining;
    int32_t m_usedForStrings;
    int32_t m_stringCount;
    char* m_strings;
    char* m_stringsStore;
    char** m_lookups;

    void CoreMapFileStringTable();
    void ResetMaximumSize();
    void AddToMaximumSize();
    int32_t GetMaximumSize();
    void SetMemory();
    void Free();
    int32_t GetStringIndex();
    char* AddString();
    int32_t GetSizeUsedForStrings();
    char* GetStringsStart();
};

struct tagMCI_VD_ESCAPE_PARMSA
{
    uint32_t dwCallback;
    char* lpstrCommand;
};

struct _LANA_ENUM
{
    uint32_t length;
    uint32_t lana[255];
};

struct _CRYPT_KEY_PROV_PARAM
{
    uint32_t dwParam;
    uint32_t* pbData;
    uint32_t cbData;
    uint32_t dwFlags;
};

struct _QUERY_SERVICE_LOCK_STATUSW
{
    uint32_t fIsLocked;
    uint32_t* lpLockOwner;
    uint32_t dwLockDuration;
};

struct _PRINTER_INFO_6
{
    uint32_t dwStatus;
};

struct _MODEMDEVCAPS
{
    uint32_t dwActualSize;
    uint32_t dwRequiredSize;
    uint32_t dwDevSpecificOffset;
    uint32_t dwDevSpecificSize;
    uint32_t dwModemProviderVersion;
    uint32_t dwModemManufacturerOffset;
    uint32_t dwModemManufacturerSize;
    uint32_t dwModemModelOffset;
    uint32_t dwModemModelSize;
    uint32_t dwModemVersionOffset;
    uint32_t dwModemVersionSize;
    uint32_t dwDialOptions;
    uint32_t dwCallSetupFailTimer;
    uint32_t dwInactivityTimeout;
    uint32_t dwSpeakerVolume;
    uint32_t dwSpeakerMode;
    uint32_t dwModemOptions;
    uint32_t dwMaxDTERate;
    uint32_t dwMaxDCERate;
    uint32_t abVariablePortion[1];
};

struct CoreTool
{
    CoreCommandArgs m_oArgs;
    CoreString m_oName;
    CoreString m_oDesc;
    CoreString m_oTempOutput;
    int32_t m_iVersion;
    CoreArray<unsigned int> m_platformVersions;
    CoreArray<unsigned int> m_platformVersionBits;
    CoreArray<enum CorePlatformVersion::CorePlatformVersionEnum> m_platformVersionEnums;
    uint32_t m_numPlatforms;
    bool m_XBVersion;
    bool m_PSVersion;
    bool m_PSPVersion;
    bool m_PCVersion;
    bool m_GCVersion;
    bool m_bAllowNoInputs;
    static uint32_t s_numPlatformsGuess;

    // TODO vtable

    void CoreTool();
    void ~CoreTool();
    void Register();
    void Run();
    void MachineInit();
    void MachineEnd();
    void ConvertElapsedTimeToRealTime();
    void GetElapsedTime();
    void ReportTimePassed();
    void Main();
    void DisplayHelp();
    void Error();
    void Exit();
    void SetName();
    void SetDesc();
    void SetVersion();
    void SetAllowNoInputs();
    int32_t GetVersion();
    CoreCommandArgs& oArgs();
    void ParseCommandLine();
    void MakeDirectoryForFile();
    void MakeOutputDirectory();
    bool bCopyFile();
    bool bDeleteFile();
    bool bMakeTempFile();
    bool bCopyTempFileToOutputFile();
    char* GetTempOutput();
    bool IsXBVersion();
    bool IsPSVersion();
    bool IsPSPVersion();
    bool IsPCVersion();
    bool IsGCVersion();
    uint32_t GetNumPlatforms();
    CorePlatformVersion::CorePlatformVersionEnum GetPlatformVersionEnum();
    CoreArray<unsigned int>& GetPlatformVersions();
    uint32_t GetPlatformVersion();
    uint32_t GetPlatformVersionBit();
    CorePlatformVersion::CorePlatformVersionEnum GetPlatformVersionEnumIndex();
    uint32_t GetPlatformVersionIndex();
    uint32_t GetPlatformVersionBitIndex();
};

struct CoreArray<unsigned int>
{
    uint32_t* m_lpoContents;
    int32_t m_iAllocSize;
    int32_t m_iArraySize;
    bool m_allowResize;
    int32_t m_startAllocSize;

    void CoreArray<unsigned int>();
    void SetAllowResize();
    void ~CoreArray<unsigned int>();
    int32_t GetSize();
    void Insert();
    void Remove();
    void operator+=();
    bool CanFit();
    void Reset();
    void SetSize();
    void Resize();
    uint32_t* operator const unsigned int *();
    uint32_t* operator unsigned int *();
    uint32_t& GetElement();
    uint32_t* GetArray();
    bool operator==();
    bool operator!=();
    uint32_t& operator[]();
};

struct _MOUSE_EVENT_RECORD
{
    _COORD dwMousePosition;
    uint32_t dwButtonState;
    uint32_t dwControlKeyState;
    uint32_t dwEventFlags;
};

struct IOleContainer : IParseDisplayName
{
    HRESULT __stdcall EnumObjects();
    HRESULT __stdcall LockContainer();
    void IOleContainer();
};

struct _LIST_ENTRY
{
    _LIST_ENTRY* Flink;
    _LIST_ENTRY* Blink;
};

struct tagMCI_OVLY_LOAD_PARMSW
{
    uint32_t dwCallback;
    uint32_t* lpfilename;
    tagRECT rc;
};

struct NDR_ALLOC_ALL_NODES_CONTEXT
{
};

struct NDR_POINTER_QUEUE_STATE
{
};

struct _NDR_ASYNC_MESSAGE
{
};

struct _NDR_PROC_CONTEXT
{
};

struct _MIDL_STUB_MESSAGE
{
    _RPC_MESSAGE* RpcMsg;
    uint32_t* Buffer;
    uint32_t* BufferStart;
    uint32_t* BufferEnd;
    uint32_t* BufferMark;
    uint32_t BufferLength;
    uint32_t MemorySize;
    uint32_t* Memory;
    int32_t IsClient;
    int32_t ReuseBuffer;
    NDR_ALLOC_ALL_NODES_CONTEXT* pAllocAllNodesContext;
    NDR_POINTER_QUEUE_STATE* pPointerQueueState;
    int32_t IgnoreEmbeddedPointers;
    uint32_t* PointerBufferMark;
    uint32_t fBufferValid;
    uint32_t uFlags;
    uint32_t UniquePtrCount;
    uint32_t MaxCount;
    uint32_t Offset;
    uint32_t ActualCount;
    void** pfnAllocate;
    void* pfnFree;
    uint32_t* StackTop;
    uint32_t* pPresentedType;
    uint32_t* pTransmitType;
    void* SavedHandle;
    _MIDL_STUB_DESC* StubDesc;
    _FULL_PTR_XLAT_TABLES* FullPtrXlatTables;
    uint32_t FullPtrRefId;
    uint32_t PointerLength;
    int32_t fInDontFree : 1;
    int32_t fDontCallFreeInst : 1;
    int32_t fInOnlyParam : 1;
    int32_t fHasReturn : 1;
    int32_t fHasExtensions : 1;
    int32_t fHasNewCorrDesc : 1;
    int32_t fUnused : 10;
    int32_t fUnused2 : 16;
    uint32_t dwDestContext;
    void* pvDestContext;
    __unnamed** SavedContextHandles;
    int32_t ParamNumber;
    IRpcChannelBuffer* pRpcChannelBuffer;
    ARRAY_INFO* pArrayInfo;
    uint32_t* SizePtrCountArray;
    uint32_t* SizePtrOffsetArray;
    uint32_t* SizePtrLengthArray;
    void* pArgQueue;
    uint32_t dwStubPhase;
    void* LowStackMark;
    _NDR_ASYNC_MESSAGE* pAsyncMsg;
    _NDR_CORRELATION_INFO* pCorrInfo;
    uint32_t* pCorrMemory;
    void* pMemoryList;
    CS_STUB_INFO* pCSInfo;
    uint32_t* ConformanceMark;
    uint32_t* VarianceMark;
    int32_t Unused;
    _NDR_PROC_CONTEXT* pContext;
    int32_t Reserved51_1;
    int32_t Reserved51_2;
    int32_t Reserved51_3;
    int32_t Reserved51_4;
    int32_t Reserved51_5;
};

struct IXMLDOMCharacterData : IXMLDOMNode
{
    HRESULT __stdcall get_data();
    HRESULT __stdcall put_data();
    HRESULT __stdcall get_length();
    HRESULT __stdcall substringData();
    HRESULT __stdcall appendData();
    HRESULT __stdcall insertData();
    HRESULT __stdcall deleteData();
    HRESULT __stdcall replaceData();
    void IXMLDOMCharacterData();
};

struct _CONNECTDLGSTRUCTW
{
    uint32_t cbStructure;
    HWND* hwndOwner;
    _NETRESOURCEW* lpConnRes;
    uint32_t dwFlags;
    uint32_t dwDevNum;
};

struct tagMONHSZSTRUCTA
{
    uint32_t cb;
    int32_t fsAction;
    uint32_t dwTime;
    HSZ__* hsz;
    void* hTask;
    char str[1];
};

struct CoreSingleCollidable
{
    enum
    {
        UNKNOWN,
        BOUNDING,
        SIMPLE,
        DETAILED,
    };

    CoreCollidableType eType;
    CoreVector vPoints[2];
    CoreEulerAngle eaBoxRotation;
    float fRadius;
    uint32_t uiBoneHash;
    uint32_t subType;

    void CoreSingleCollidable();
};

struct tagEMRINVERTRGN
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t cbRgnData;
    uint32_t RgnData[1];
};

struct tagEMRALPHABLEND
{
    tagEMR emr;
    _RECTL rclBounds;
    int32_t xDest;
    int32_t yDest;
    int32_t cxDest;
    int32_t cyDest;
    uint32_t dwRop;
    int32_t xSrc;
    int32_t ySrc;
    tagXFORM xformSrc;
    uint32_t crBkColorSrc;
    uint32_t iUsageSrc;
    uint32_t offBmiSrc;
    uint32_t cbBmiSrc;
    uint32_t offBitsSrc;
    uint32_t cbBitsSrc;
    int32_t cxSrc;
    int32_t cySrc;
};

struct CoreLevelFileLight : CoreLevelLight
{
    void CoreLevelFileLight();
    void ~CoreLevelFileLight();
    void SetName(char* lpcName);
    void SetHash(uint32_t uiHash);
    void SetType(int32_t iType);
    void SetInnerMinusOuterColour(float fRed, float fGreen, float fBlue);
    void SetOuterColour(float fRed, float fGreen, float fBlue);
    void SetIntensity(float fIntensity);
    void SetPosition(float fX, float fY, float fZ);
    void SetPlane(float fX, float fY, float fZ, float fW);
    void SetOuterMinusInnerRadius(float fOuterMinusInnerRadius);
    void SetOuterRadius(float fOuterRadius);
    void SetSpotCosInnerMinusCosOuterConeAngle(float CosInnerMinusCosOuterConeAngle);
    void SetSpotCosOuterConeAngle(float CosOuterConeAngle);
    void SetAreaXSize(float fXSize);
    void SetAreaYSize(float fYSize);
    void SetAreaXNormal(float fX, float fY, float fZ);
    void SetAreaYNormal(float fX, float fY, float fZ);
    void SetAreaDXMinus(float fDXMinus);
    void SetAreaDXPlus(float fDXPlus);
    void SetAreaDYMinus(float fDYMinus);
    void SetAreaDYPlus(float fDYPlus);
    void SetCylinerLength(float fLength);
    void SetCylinderEndPoint1(float fX, float fY, float fZ);
    void SetCylinderEndPoint2(float fX, float fY, float fZ);
};

struct _FLOATING_SAVE_AREA
{
    uint32_t ControlWord;
    uint32_t StatusWord;
    uint32_t TagWord;
    uint32_t ErrorOffset;
    uint32_t ErrorSelector;
    uint32_t DataOffset;
    uint32_t DataSelector;
    uint32_t RegisterArea[80];
    uint32_t Cr0NpxState;
};

struct _IMAGE_SEPARATE_DEBUG_HEADER
{
    uint32_t Signature;
    uint32_t Flags;
    uint32_t Machine;
    uint32_t Characteristics;
    uint32_t TimeDateStamp;
    uint32_t CheckSum;
    uint32_t ImageBase;
    uint32_t SizeOfImage;
    uint32_t NumberOfSections;
    uint32_t ExportedNamesSize;
    uint32_t DebugDirectorySize;
    uint32_t SectionAlignment;
    uint32_t Reserved[2];
};

struct tagCOMPAREITEMSTRUCT
{
    uint32_t CtlType;
    uint32_t CtlID;
    HWND* hwndItem;
    uint32_t itemID1;
    uint32_t itemData1;
    uint32_t itemID2;
    uint32_t itemData2;
    uint32_t dwLocaleId;
};

struct _CERT_CHAIN_PARA
{
    uint32_t cbSize;
    _CERT_USAGE_MATCH RequestedUsage;
};

struct ICallFactory : IUnknown
{
    HRESULT __stdcall CreateCall();
    void ICallFactory();
};

struct _ENUM_SERVICE_STATUSA
{
    char* lpServiceName;
    char* lpDisplayName;
    _SERVICE_STATUS ServiceStatus;
};

struct _OSVERSIONINFOA
{
    uint32_t dwOSVersionInfoSize;
    uint32_t dwMajorVersion;
    uint32_t dwMinorVersion;
    uint32_t dwBuildNumber;
    uint32_t dwPlatformId;
    char szCSDVersion[128];
};

struct tagEMRRESTOREDC
{
    tagEMR emr;
    int32_t iRelative;
};

struct tagGUITHREADINFO
{
    uint32_t cbSize;
    uint32_t flags;
    HWND* hwndActive;
    HWND* hwndFocus;
    HWND* hwndCapture;
    HWND* hwndMenuOwner;
    HWND* hwndMoveSize;
    HWND* hwndCaret;
    tagRECT rcCaret;
};

struct _CERT_OTHER_NAME
{
    char* pszObjId;
    _CRYPTOAPI_BLOB Value;
};

struct IXMLDSOControl : IDispatch
{
    HRESULT __stdcall get_XMLDocument();
    HRESULT __stdcall put_XMLDocument();
    HRESULT __stdcall get_JavaDSOCompatible();
    HRESULT __stdcall put_JavaDSOCompatible();
    HRESULT __stdcall get_readyState();
    void IXMLDSOControl();
};

struct tagDEVNAMES
{
    uint32_t wDriverOffset;
    uint32_t wDeviceOffset;
    uint32_t wOutputOffset;
    uint32_t wDefault;
};

struct CoreHashElement
{
    uint32_t hash;
    uint32_t dataStore32;
};

struct _PRINTER_NOTIFY_OPTIONS_TYPE
{
    uint32_t Type;
    uint32_t Reserved0;
    uint32_t Reserved1;
    uint32_t Reserved2;
    uint32_t Count;
    uint32_t* pFields;
};

struct IOleItemContainer : IOleContainer
{
    HRESULT __stdcall GetObjectA();
    HRESULT __stdcall GetObjectStorage();
    HRESULT __stdcall IsRunning();
    void IOleItemContainer();
};

struct __wfinddata64_t
{
    uint32_t attrib;
    int32_t time_create;
    int32_t time_access;
    int32_t time_write;
    int32_t size;
    wchar_t name[260];
};

struct _cpinfoexW
{
    uint32_t MaxCharSize;
    uint32_t DefaultChar[2];
    uint32_t LeadByte[12];
    uint32_t UnicodeDefaultChar;
    uint32_t CodePage;
    uint32_t CodePageName[260];
};

struct tagCAPROPVARIANT
{
    uint32_t cElems;
    tagPROPVARIANT* pElems;
};

struct _SYSTEMTIME
{
    uint32_t wYear;
    uint32_t wMonth;
    uint32_t wDayOfWeek;
    uint32_t wDay;
    uint32_t wHour;
    uint32_t wMinute;
    uint32_t wSecond;
    uint32_t wMilliseconds;
};

struct _MMIOINFO
{
    uint32_t dwFlags;
    uint32_t fccIOProc;
    int32_t* pIOProc;
    uint32_t wErrorRet;
    HTASK__* htask;
    int32_t cchBuffer;
    char* pchBuffer;
    char* pchNext;
    char* pchEndRead;
    char* pchEndWrite;
    int32_t lBufOffset;
    int32_t lDiskOffset;
    uint32_t adwInfo[3];
    uint32_t dwReserved1;
    uint32_t dwReserved2;
    HMMIO__* hmmio;
};

struct tagMCI_ANIM_OPEN_PARMSA
{
    uint32_t dwCallback;
    uint32_t wDeviceID;
    char* lpstrDeviceType;
    char* lpstrElementName;
    char* lpstrAlias;
    uint32_t dwStyle;
    HWND* hWndParent;
};

struct _ENCRYPTION_CERTIFICATE
{
    uint32_t cbTotalLength;
    _SID* pUserSid;
    _CERTIFICATE_BLOB* pCertBlob;
};

struct _PROVIDOR_INFO_1W
{
    uint32_t* pName;
    uint32_t* pEnvironment;
    uint32_t* pDLLName;
};

struct tagCURSORINFO
{
    uint32_t cbSize;
    uint32_t flags;
    HICON__* hCursor;
    tagPOINT ptScreenPos;
};

struct value_entA
{
    char* ve_valuename;
    uint32_t ve_valuelen;
    uint32_t ve_valueptr;
    uint32_t ve_type;
};

struct CoreGsFog
{
    uint32_t pad00 : 56;
    uint32_t F : 8;
};

struct CAL0_SectionInfoExtended : CAL0_SectionInfo
{
    uint32_t m_MinorVersion;
    uint32_t m_MajorVersion;
    uint32_t m_DataSize;
    bool m_IsFile;
    uint32_t* m_DataPointer;
    CAL0_File* m_File;
    uint32_t m_FileOffset;
    bool m_DeleteFile;

    void CAL0_SectionInfoExtended();
};

struct mmtime_tag
{
    uint32_t wType;
    mmtime_tag::__unnamed u;
};

struct _CRYPT_CREDENTIALS
{
    uint32_t cbSize;
    char* pszCredentialsOid;
    void* pvCredentials;
};

struct ITypeChangeEvents : IUnknown
{
    HRESULT __stdcall RequestTypeChange();
    HRESULT __stdcall AfterTypeChange();
    void ITypeChangeEvents();
};

struct CoretGS_BUSDIR
{
    uint32_t DIR : 1;
    uint32_t p0 : 31;
    uint32_t p1;
};

struct _EXCEPTION_POINTERS
{
    _EXCEPTION_RECORD* ExceptionRecord;
    _CONTEXT* ContextRecord;
};

struct CAL1_ReverbManager : CAL0_List
{
    uint32_t m_fadeTimeMS;
    uint32_t m_ReverbStatus;
    uint32_t m_TickInterval;
    uint32_t m_Time;
    CAL1_AudioDriver* m_AD;
    CAL1_ReverbPreset* m_LastPreset;
    CAL1_ReverbPreset* m_CurrentPreset;
    uint32_t m_DefaultPresetIndex;
    bool m_bEffectActive;
    uint32_t m_EffectID;
    uint32_t m_EffectIndex;
    bool m_bTriggerActive;
    uint32_t m_CurrentTriggerIndex;
    uint32_t m_CurrentTriggerID;
    bool m_bLastTriggerIsActive;
    uint32_t m_LastTriggerIndex;
    uint32_t m_LastTriggerID;
    uint32_t m_RoomPresetIndex;
    uint32_t m_RoomID;
    int32_t m_MorphValue;

    void CAL1_ReverbManager();
    void ~CAL1_ReverbManager();
    void Reset();
    void Pause();
    void UnPause();
    CAAudioError RecallPreset(uint32_t i_index, uint32_t fadeTimeMS);
    CAAudioError Tick();
    CAAudioError SetTickInterval();
    CAAudioError SetDefaultPreset(uint32_t defPreset);
    CAAudioError SetRoomReverb();
    CAAudioError EnterReverbTrigger();
    CAAudioError ExitReverbTrigger();
    CAAudioError StartReverbEffect();
    CAAudioError StopReverbEffect();
    CAAudioError StartConversationEffect();
    CAAudioError EndConversationEffect();
    int32_t AddPreset();
    CAAudioError SetReverbLevel(CAL1_ReverbPreset* from, int32_t balance, CAL1_ReverbPreset* to);
    void BroadcastPreset();
    void SetRemotePreset(void* data);
    void WriteHeaderFile();
};

struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION
{
    _JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    _IO_COUNTERS IoInfo;
    uint32_t ProcessMemoryLimit;
    uint32_t JobMemoryLimit;
    uint32_t PeakProcessMemoryUsed;
    uint32_t PeakJobMemoryUsed;
};

struct tagPSDW
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    void* hDevMode;
    void* hDevNames;
    uint32_t Flags;
    tagPOINT ptPaperSize;
    tagRECT rtMinMargin;
    tagRECT rtMargin;
    HINSTANCE__* hInstance;
    int32_t lCustData;
    uint32_t* lpfnPageSetupHook;
    uint32_t* lpfnPagePaintHook;
    uint32_t* lpPageSetupTemplateName;
    void* hPageSetupTemplate;
};

struct CoreNavMeshExit
{
    CorePackedExit m_from;
    CorePackedExit m_to;
    float m_height;
    float m_gap;
};

struct CoreNavigationVertex
{
    float fX;
    float fY;
    float fZ;

    CoreVector GetVertex();
};

struct CoreGsScanmsk
{
    uint32_t MSK : 2;
    uint32_t pad02 : 62;
};

struct _D3DVECTOR
{
    float x;
    float y;
    float z;
};

struct _DRIVER_INFO_3A
{
    uint32_t cVersion;
    char* pName;
    char* pEnvironment;
    char* pDriverPath;
    char* pDataFile;
    char* pConfigFile;
    char* pHelpFile;
    char* pDependentFiles;
    char* pMonitorName;
    char* pDefaultDataType;
};

struct IAdviseSink : IUnknown
{
    void __stdcall OnDataChange();
    void __stdcall OnViewChange();
    void __stdcall OnRename();
    void __stdcall OnSave();
    void __stdcall OnClose();
    void IAdviseSink();
};

struct HMONITOR__
{
    int32_t unused;
};

struct _COORD
{
    int32_t X;
    int32_t Y;
};

struct tagMIXERCONTROLDETAILS_LISTTEXTA
{
    uint32_t dwParam1;
    uint32_t dwParam2;
    char szName[64];
};

struct _FSCTL_QUERY_FAT_BPB_BUFFER
{
    uint32_t First0x24BytesOfBootSector[36];
};

struct _DRIVER_INFO_6A
{
    uint32_t cVersion;
    char* pName;
    char* pEnvironment;
    char* pDriverPath;
    char* pDataFile;
    char* pConfigFile;
    char* pHelpFile;
    char* pDependentFiles;
    char* pMonitorName;
    char* pDefaultDataType;
    char* pszzPreviousNames;
    _FILETIME ftDriverDate;
    uint32_t dwlDriverVersion;
    char* pszMfgName;
    char* pszOEMUrl;
    char* pszHardwareID;
    char* pszProvider;
};

struct AsyncIMultiQI : IUnknown
{
    HRESULT __stdcall Begin_QueryMultipleInterfaces();
    HRESULT __stdcall Finish_QueryMultipleInterfaces();
    void AsyncIMultiQI();
};

struct CorePCStdCFileDevice : CoreFileDevice
{
    void CorePCStdCFileDevice();
    void ~CorePCStdCFileDevice();
    void Construct(CoreMemory*);
    void Destruct(CoreMemory*);
    void Init();
    CoreFileHandle Open(char* i_name, CoreFileOpenAttributes& i_attrib, uint32_t i_flags);
    bool Close(CoreFileHandle& i_handle, uint32_t i_flags);
    int32_t Read(CoreFileHandle& i_handle, void* o_dest, int32_t i_size, uint32_t i_flags);
    bool Seek(CoreFileHandle& i_handle, int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin, uint32_t i_flags);
    bool AsyncFinished(CoreFileHandle& i_handle, CoreFileDevice::CoreFileDeviceAsyncState i_successfulState, CoreFileDevice::CoreFileDeviceAsyncState i_failedState);
    int32_t Write(CoreFileHandle& i_handle, void* i_src, int32_t i_size);
    int32_t FileSize(CoreFileHandle& i_handle);
    bool GetFileTimes(char* i_fileName, CoreDateTime* o_creationTime, CoreDateTime* o_lastAccessTime, CoreDateTime* o_lastWriteTime);
    bool SetFileTimes(char* i_fileName, CoreDateTime* i_creationTime, CoreDateTime* i_lastAccessTime, CoreDateTime* i_lastWriteTime);
    bool DoesFileExist(char* i_fileName);
    bool IsReadOnly(char* i_fileName);
    bool ChangeReadOnly(char* i_fileName, bool i_readOnly, bool* o_changed);
    bool CompleteTheFileName(char* i_fileName, CoreStringBuffer<256>& o_fileName);
};

struct _CERT_INFO
{
    uint32_t dwVersion;
    _CRYPTOAPI_BLOB SerialNumber;
    _CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
    _CRYPTOAPI_BLOB Issuer;
    _FILETIME NotBefore;
    _FILETIME NotAfter;
    _CRYPTOAPI_BLOB Subject;
    _CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
    _CRYPT_BIT_BLOB IssuerUniqueId;
    _CRYPT_BIT_BLOB SubjectUniqueId;
    uint32_t cExtension;
    _CERT_EXTENSION* rgExtension;
};

struct _tagBINDINFO
{
    uint32_t cbSize;
    uint32_t* szExtraInfo;
    tagSTGMEDIUM stgmedData;
    uint32_t grfBindInfoF;
    uint32_t dwBindVerb;
    uint32_t* szCustomVerb;
    uint32_t cbstgmedData;
    uint32_t dwOptions;
    uint32_t dwOptionsFlags;
    uint32_t dwCodePage;
    _SECURITY_ATTRIBUTES securityAttributes;
    _GUID iid;
    IUnknown* pUnk;
    uint32_t dwReserved;
};

struct _MEMORYSTATUS
{
    uint32_t dwLength;
    uint32_t dwMemoryLoad;
    uint32_t dwTotalPhys;
    uint32_t dwAvailPhys;
    uint32_t dwTotalPageFile;
    uint32_t dwAvailPageFile;
    uint32_t dwTotalVirtual;
    uint32_t dwAvailVirtual;
};

struct _SHELLEXECUTEINFOW
{
    uint32_t cbSize;
    uint32_t fMask;
    HWND* hwnd;
    uint32_t* lpVerb;
    uint32_t* lpFile;
    uint32_t* lpParameters;
    uint32_t* lpDirectory;
    int32_t nShow;
    HINSTANCE__* hInstApp;
    void* lpIDList;
    uint32_t* lpClass;
    HKEY__* hkeyClass;
    uint32_t dwHotKey;
    void* hIcon;
    void* hMonitor;
    void* hProcess;
};

struct _DOC_INFO_1A
{
    char* pDocName;
    char* pOutputFile;
    char* pDatatype;
};

struct tagCLEANLOCALSTORAGE
{
    IUnknown* pInterface;
    void* pStorage;
    uint32_t flags;
};

struct tagTTPOLYGONHEADER
{
    uint32_t cb;
    uint32_t dwType;
    tagPOINTFX pfxStart;
};

struct tagMSGBOXPARAMSA
{
    uint32_t cbSize;
    HWND* hwndOwner;
    HINSTANCE__* hInstance;
    char* lpszText;
    char* lpszCaption;
    uint32_t dwStyle;
    char* lpszIcon;
    uint32_t dwContextHelpId;
    void* lpfnMsgBoxCallback;
    uint32_t dwLanguageId;
};

struct IBindProtocol : IUnknown
{
    HRESULT __stdcall CreateBinding();
    void IBindProtocol();
};

struct _DS3DLISTENER
{
    uint32_t dwSize;
    _D3DVECTOR vPosition;
    _D3DVECTOR vVelocity;
    _D3DVECTOR vOrientFront;
    _D3DVECTOR vOrientTop;
    float flDistanceFactor;
    float flRolloffFactor;
    float flDopplerFactor;
};

struct IDirectSound3DListener : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetAllParameters();
    HRESULT __stdcall GetDistanceFactor();
    HRESULT __stdcall GetDopplerFactor();
    HRESULT __stdcall GetOrientation();
    HRESULT __stdcall GetPosition();
    HRESULT __stdcall GetRolloffFactor();
    HRESULT __stdcall GetVelocity();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall SetDistanceFactor();
    HRESULT __stdcall SetDopplerFactor();
    HRESULT __stdcall SetOrientation();
    HRESULT __stdcall SetPosition();
    HRESULT __stdcall SetRolloffFactor();
    HRESULT __stdcall SetVelocity();
    HRESULT __stdcall CommitDeferredSettings();
    void IDirectSound3DListener();
};

struct CoreArray<CoreHashElement>
{
    CoreHashElement* m_lpoContents;
    int32_t m_iAllocSize;
    int32_t m_iArraySize;
    bool m_allowResize;
    int32_t m_startAllocSize;

    void CoreArray<CoreHashElement>();
    void SetAllowResize();
    void ~CoreArray<CoreHashElement>();
    int32_t GetSize();
    void Insert();
    void Remove();
    void operator+=();
    bool CanFit();
    void Reset();
    void SetSize();
    void Resize();
    CoreHashElement* operator const struct CoreHashElement *();
    CoreHashElement* operator struct CoreHashElement *();
    CoreHashElement& GetElement();
    CoreHashElement* GetArray();
    bool operator==();
    bool operator!=();
    CoreHashElement& operator[]();
};

struct _SHFILEOPSTRUCTW
{
    HWND* hwnd;
    uint32_t wFunc;
    uint32_t* pFrom;
    uint32_t* pTo;
    uint32_t fFlags;
    int32_t fAnyOperationsAborted;
    void* hNameMappings;
    uint32_t* lpszProgressTitle;
};

struct _IMAGE_ARCHIVE_MEMBER_HEADER
{
    uint32_t Name[16];
    uint32_t Date[12];
    uint32_t UserID[6];
    uint32_t GroupID[6];
    uint32_t Mode[8];
    uint32_t Size[10];
    uint32_t EndHeader[2];
};

struct CoreGameFrame
{
    enum TEXTURE_INDEX_TAG
    {
        TOP_LEFT,
        TOP,
        TOP_RIGHT,
        RIGHT,
        BOTTOM_RIGHT,
        BOTTOM,
        BOTTOM_LEFT,
        LEFT,
        BACKGROUND,
        BACKGROUND2,
        BACKGROUND3,
        TEXTURES_COUNT,
    };

    enum TEXTURE_INDEX
    {
        TOP_LEFT,
        TOP,
        TOP_RIGHT,
        RIGHT,
        BOTTOM_RIGHT,
        BOTTOM,
        BOTTOM_LEFT,
        LEFT,
        BACKGROUND,
        BACKGROUND2,
        BACKGROUND3,
        TEXTURES_COUNT,
    };

    CoreRGBA BackGroundRGBA;
    CoreRGBA EdgeRGBA;
    CoreRGBA TextureRGBA;
    CoreHash m_textures[11];
    bool m_anyTexturesSet;
    float m_edgeWidths;
    float m_edgeHeights;
    float m_backGroundOffsetX;
    float m_backGroundOffsetY;

    void CoreGameFrame();
    bool SetTexture(CoreGameFrame::TEXTURE_INDEX_TAG i_index, CoreHash i_textureID);
    void SetCornerTextures(CoreHash i_topLeft, CoreHash i_topRight, CoreHash i_bottomRight, CoreHash i_bottomLeft);
    void SetEdgeTextures(CoreHash i_top, CoreHash i_right, CoreHash i_bottom, CoreHash i_left);
    void SetBackGroundTextures(CoreHash i_backGround, CoreHash i_backGround2, CoreHash i_backGround3);
    void SetEdgeSizes();
    float GetEdgeWidths();
    float GetEdgeHeights();
    void SetBackGroundOffsets();
    float GetBackGroundOffsetX();
    float GetBackGroundOffsetY();
    void GetBackGroundXYXY();
    void Render(CoreGameRender* io_graphics, CoreTextureSet* i_textureSet, float i_x1, float i_y1, float i_x2, float i_y2, float i_alphaScaler, int32_t i_renderFlags);
    void ~CoreGameFrame();
};

struct CAL0_HeaderData
{
    char m_FileFormat[4];
    uint32_t m_FormatVersionMajor;
    uint32_t m_FormatVersionMinor;
    char m_FileSubFormat[4];
    uint32_t m_SubFormatVersionMajor;
    uint32_t m_SubFormatVersionMinor;
    uint32_t m_HeaderDataSize;
    uint32_t m_NumSections;
    CAL0_SectionInfo* m_SectionInfoArray;

    void CAL0_HeaderData();
    CAAudioError SetSubFormat();
};

struct _CERT_DSS_PARAMETERS
{
    _CRYPTOAPI_BLOB p;
    _CRYPTOAPI_BLOB q;
    _CRYPTOAPI_BLOB g;
};

struct tagTYPEDESC
{
    tagTYPEDESC* lptdesc;
    tagARRAYDESC* lpadesc;
    uint32_t hreftype;
    uint32_t vt;
};

struct IDirectSoundFXGargle : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    void IDirectSoundFXGargle();
};

struct CoreBreakPointPC
{
    void BreakPoint();
};

struct _NCB
{
    uint32_t ncb_command;
    uint32_t ncb_retcode;
    uint32_t ncb_lsn;
    uint32_t ncb_num;
    uint32_t* ncb_buffer;
    uint32_t ncb_length;
    uint32_t ncb_callname[16];
    uint32_t ncb_name[16];
    uint32_t ncb_rto;
    uint32_t ncb_sto;
    void* ncb_post;
    uint32_t ncb_lana_num;
    uint32_t ncb_cmd_cplt;
    uint32_t ncb_reserve[10];
    void* ncb_event;
};

struct IWinInetHttpInfo : IWinInetInfo
{
    HRESULT __stdcall QueryInfo();
    void IWinInetHttpInfo();
};

struct _SERVICE_FAILURE_ACTIONSA
{
    uint32_t dwResetPeriod;
    char* lpRebootMsg;
    char* lpCommand;
    uint32_t cActions;
    _SC_ACTION* lpsaActions;
};

struct _QUERY_SERVICE_CONFIGW
{
    uint32_t dwServiceType;
    uint32_t dwStartType;
    uint32_t dwErrorControl;
    uint32_t* lpBinaryPathName;
    uint32_t* lpLoadOrderGroup;
    uint32_t dwTagId;
    uint32_t* lpDependencies;
    uint32_t* lpServiceStartName;
    uint32_t* lpDisplayName;
};

struct _DSSSEED
{
    uint32_t counter;
    uint32_t seed[20];
};

struct _SHFILEOPSTRUCTA
{
    HWND* hwnd;
    uint32_t wFunc;
    char* pFrom;
    char* pTo;
    uint32_t fFlags;
    int32_t fAnyOperationsAborted;
    void* hNameMappings;
    char* lpszProgressTitle;
};

struct _IMAGE_EXPORT_DIRECTORY
{
    uint32_t Characteristics;
    uint32_t TimeDateStamp;
    uint32_t MajorVersion;
    uint32_t MinorVersion;
    uint32_t Name;
    uint32_t Base;
    uint32_t NumberOfFunctions;
    uint32_t NumberOfNames;
    uint32_t AddressOfFunctions;
    uint32_t AddressOfNames;
    uint32_t AddressOfNameOrdinals;
};

struct tagCLIPDATA
{
    uint32_t cbSize;
    int32_t ulClipFmt;
    uint32_t* pClipData;
};

struct _READ_ELEMENT_ADDRESS_INFO
{
    uint32_t NumberOfElements;
    _CHANGER_ELEMENT_STATUS ElementStatus[1];
};

struct _CRYPT_KEY_SIGN_MESSAGE_PARA
{
    uint32_t cbSize;
    uint32_t dwMsgAndCertEncodingType;
    uint32_t hCryptProv;
    uint32_t dwKeySpec;
    _CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    void* pvHashAuxInfo;
    _CRYPT_ALGORITHM_IDENTIFIER PubKeyAlgorithm;
};

struct IOleInPlaceObject : IOleWindow
{
    HRESULT __stdcall InPlaceDeactivate();
    HRESULT __stdcall UIDeactivate();
    HRESULT __stdcall SetObjectRects();
    HRESULT __stdcall ReactivateAndUndo();
    void IOleInPlaceObject();
};

struct adpcmcoef_tag
{
    int32_t iCoef1;
    int32_t iCoef2;
};

struct CoreGeometryCompiledPSP
{
    uint32_t m_iVertexSizeInBytes;
    int32_t m_iNumVertices;
    int32_t m_iGEFlags;
    int32_t m_iGameFlags;
    CoreVector m_bbMin;
    CoreVector m_bbMax;
    uint32_t m_numParentLights;
    uint32_t m_vertexTagOffset;
    uint32_t m_vertexTagSizeInBytes;
    uint32_t m_referenceValue;
    int32_t m_iPad;

    void CoreGeometryCompiledPSP();
    void ~CoreGeometryCompiledPSP();
    int32_t GetNumVertices();
    int32_t GetVertexSizeInBytes();
    int32_t GetTotalSizeInBytes();
    int32_t GetGEFlags();
    int32_t GetGameFlags();
    CoreVector GetBBMin();
    CoreVector GetBBMax();
    uint32_t GetReferenceValue();
    void SetReferenceValue();
    float* GetVertexDataPtr();
    void SetDisplayListPointer();
    void* GetDisplayList();
    uint32_t* GetVertexTagData();
    uint32_t GetNumParentLights();
    uint32_t* lpucVertexDataPtr();
};

struct tagEMREXTTEXTOUTA
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t iGraphicsMode;
    float exScale;
    float eyScale;
    tagEMRTEXT emrtext;
};

struct tagEMRPLGBLT
{
    tagEMR emr;
    _RECTL rclBounds;
    _POINTL aptlDest[3];
    int32_t xSrc;
    int32_t ySrc;
    int32_t cxSrc;
    int32_t cySrc;
    tagXFORM xformSrc;
    uint32_t crBkColorSrc;
    uint32_t iUsageSrc;
    uint32_t offBmiSrc;
    uint32_t cbBmiSrc;
    uint32_t offBitsSrc;
    uint32_t cbBitsSrc;
    int32_t xMask;
    int32_t yMask;
    uint32_t iUsageMask;
    uint32_t offBmiMask;
    uint32_t cbBmiMask;
    uint32_t offBitsMask;
    uint32_t cbBitsMask;
};

struct _CERT_POLICY_MAPPING
{
    char* pszIssuerDomainPolicy;
    char* pszSubjectDomainPolicy;
};

struct CoreAnimMapping
{
    enum
    {
        VERSION = 1,
    };

    CoreHash m_animSetName;
    CoreHash m_animName;

    void CoreAnimMapping();
    void ~CoreAnimMapping();
    CoreHash GetAnimSetHash();
    CoreHash GetAnimHash();
};

struct _LOAD_DLL_DEBUG_INFO
{
    void* hFile;
    void* lpBaseOfDll;
    uint32_t dwDebugInfoFileOffset;
    uint32_t nDebugInfoSize;
    void* lpImageName;
    uint32_t fUnicode;
};

struct _ACL
{
    uint32_t AclRevision;
    uint32_t Sbz1;
    uint32_t AclSize;
    uint32_t AceCount;
    uint32_t Sbz2;
};

struct IMAGE_LOAD_CONFIG_DIRECTORY32
{
    uint32_t Size;
    uint32_t TimeDateStamp;
    uint32_t MajorVersion;
    uint32_t MinorVersion;
    uint32_t GlobalFlagsClear;
    uint32_t GlobalFlagsSet;
    uint32_t CriticalSectionDefaultTimeout;
    uint32_t DeCommitFreeBlockThreshold;
    uint32_t DeCommitTotalFreeThreshold;
    uint32_t LockPrefixTable;
    uint32_t MaximumAllocationSize;
    uint32_t VirtualMemoryThreshold;
    uint32_t ProcessHeapFlags;
    uint32_t ProcessAffinityMask;
    uint32_t CSDVersion;
    uint32_t Reserved1;
    uint32_t EditList;
    uint32_t SecurityCookie;
    uint32_t SEHandlerTable;
    uint32_t SEHandlerCount;
};

struct _IMAGE_RUNTIME_FUNCTION_ENTRY
{
    uint32_t BeginAddress;
    uint32_t EndAddress;
    uint32_t UnwindInfoAddress;
};

struct tagCIEXYZ
{
    int32_t ciexyzX;
    int32_t ciexyzY;
    int32_t ciexyzZ;
};

struct _CMSG_HASHED_ENCODE_INFO
{
    uint32_t cbSize;
    uint32_t hCryptProv;
    _CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    void* pvHashAuxInfo;
};

struct _DRIVE_LAYOUT_INFORMATION
{
    uint32_t PartitionCount;
    uint32_t Signature;
    _PARTITION_INFORMATION PartitionEntry[1];
};

struct CoreLevelFileFlap : CoreLevelFlap
{
    void CoreLevelFileFlap();
    void ~CoreLevelFileFlap();
    void SetName(char* lpcName);
    void SetHash(uint32_t uiHash);
    void SetPosition(float fX, float fY, float fZ);
    void SetPlane(float fX, float fY, float fZ, float fW);
    void SetSize(float fXSize, float fYSize);
    void SetXNormal(float fX, float fY, float fZ);
    void SetYNormal(float fX, float fY, float fZ);
    void SetDX(float fDXMinus, float fDXPlus);
    void SetDY(float fDYMinus, float fDYPlus);
};

struct _CMSG_KEY_AGREE_RECIPIENT_INFO
{
    uint32_t dwVersion;
    uint32_t dwOriginatorChoice;
    _CERT_ID OriginatorCertId;
    _CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
    _CRYPTOAPI_BLOB UserKeyingMaterial;
    _CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
    uint32_t cRecipientEncryptedKeys;
    _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO** rgpRecipientEncryptedKeys;
};

struct _ENCRYPTION_CERTIFICATE_HASH_LIST
{
    uint32_t nCert_Hash;
    _ENCRYPTION_CERTIFICATE_HASH** pUsers;
};

struct tagCADATE
{
    uint32_t cElems;
    float* pElems;
};

struct DDEADVISE
{
    uint32_t reserved : 14;
    uint32_t fDeferUpd : 1;
    uint32_t fAckReq : 1;
    int32_t cfFormat;
};

struct IXMLDOMElement : IXMLDOMNode
{
    HRESULT __stdcall get_tagName();
    HRESULT __stdcall getAttribute();
    HRESULT __stdcall setAttribute();
    HRESULT __stdcall removeAttribute();
    HRESULT __stdcall getAttributeNode();
    HRESULT __stdcall setAttributeNode();
    HRESULT __stdcall removeAttributeNode();
    HRESULT __stdcall getElementsByTagName();
    HRESULT __stdcall normalize();
    void IXMLDOMElement();
};

union tagBINDPTR
{
    tagFUNCDESC* lpfuncdesc;
    tagVARDESC* lpvardesc;
    ITypeComp* lptcomp;
};

struct tagRGBQUAD
{
    uint32_t rgbBlue;
    uint32_t rgbGreen;
    uint32_t rgbRed;
    uint32_t rgbReserved;
};

struct tagMCI_SEEK_PARMS
{
    uint32_t dwCallback;
    uint32_t dwTo;
};

struct tagRPC_EE_INFO_PARAM
{
    tagExtendedErrorParamTypes ParameterType;
    tagRPC_EE_INFO_PARAM::__unnamed u;
};

union _FILE_SEGMENT_ELEMENT
{
    void* Buffer;
    uint32_t Alignment;
};

struct tagDDEML_MSG_HOOK_DATA
{
    uint32_t uiLo;
    uint32_t uiHi;
    uint32_t cbData;
    uint32_t Data[8];
};

struct _div_t
{
    int32_t quot;
    int32_t rem;
};

struct CoreGsTexflush
{
    uint32_t pad00;
};

struct tagStorageLayout
{
    uint32_t LayoutType;
    uint32_t* pwcsElementName;
    _LARGE_INTEGER cOffset;
    _LARGE_INTEGER cBytes;
};

struct CoreGsTexEnv
{
    CoreGsTexflush texflush;
    int32_t texflushaddr;
    CoreGsTex1 tex11;
    int32_t tex11addr;
    CoreGsTex0 tex01;
    int32_t tex01addr;
    CoreGsClamp clamp1;
    int32_t clamp1addr;
};

struct _CERT_CHAIN
{
    uint32_t cCerts;
    _CRYPTOAPI_BLOB* certs;
    _CRYPT_KEY_PROV_INFO keyLocatorInfo;
};

struct tagCAC
{
    uint32_t cElems;
    char* pElems;
};

struct _JOB_SET_ARRAY
{
    void* JobHandle;
    uint32_t MemberLevel;
    uint32_t Flags;
};

struct _CMSG_ENVELOPED_ENCODE_INFO
{
    uint32_t cbSize;
    uint32_t hCryptProv;
    _CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
    void* pvEncryptionAuxInfo;
    uint32_t cRecipients;
    _CERT_INFO** rgpRecipients;
};

struct tagLOGPEN
{
    uint32_t lopnStyle;
    tagPOINT lopnWidth;
    uint32_t lopnColor;
};

struct _FLAGGED_WORD_BLOB
{
    uint32_t fFlags;
    uint32_t clSize;
    uint32_t asData[1];
};

struct _CRYPT_BLOB_ARRAY
{
    uint32_t cBlob;
    _CRYPTOAPI_BLOB* rgBlob;
};

struct _MIDL_FORMAT_STRING
{
    int32_t Pad;
    uint32_t Format[0];
};

struct _GLYPHMETRICS
{
    uint32_t gmBlackBoxX;
    uint32_t gmBlackBoxY;
    tagPOINT gmptGlyphOrigin;
    int32_t gmCellIncX;
    int32_t gmCellIncY;
};

struct IInternetProtocolInfo : IUnknown
{
    HRESULT __stdcall ParseUrl();
    HRESULT __stdcall CombineUrl();
    HRESULT __stdcall CompareUrl();
    HRESULT __stdcall QueryInfo();
    void IInternetProtocolInfo();
};

struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
{
    _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    _IO_COUNTERS IoInfo;
};

struct HSZ__
{
    int32_t unused;
};

struct CoreLevelCompiled
{
    enum
    {
        MAX_NAME_LENGTH = 8,
    };

    static uint32_t s_levelCompiledID;
    uint32_t m_uiVersion;
    uint32_t m_oFileID;
    uint32_t m_uiName;
    uint32_t m_numModels;
    uint32_t m_numMaterials;
    uint32_t m_numOccluders;
    uint32_t m_numSceneContainers;
    char m_cName[8];
    int32_t m_iGeometryOffsetTableOffset;
    int32_t m_iMaterialNamesOffset;
    int32_t m_modelInViewOffset;
    int32_t m_materialsByModelOffset;
    int32_t m_iTextureSetOffset;
    int32_t m_iCollisionDetectionDataOffset;
    int32_t m_iFXDetectionDataOffset;
    int32_t m_iNavigationDataOffset;
    int32_t m_iLevelLightSetOffset;
    int32_t m_iCurveSetOffset;
    int32_t m_globalBlindDataSectionOffset;
    int32_t m_boundedBlindDataSectionOffset;
    int32_t m_occluderDataSectionOffset;
    int32_t m_sceneContainerDataSectionOffset;
    int32_t m_lightControllerDataSectionOffset;

    uint32_t GetVersion();
    bool CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
    void CoreLevelCompiled();
    void ~CoreLevelCompiled();
    uint32_t GetNameHash();
    char* GetName();
    uint32_t GetNumModels();
    uint32_t GetNumMaterials();
    uint32_t GetNumOccluders();
    uint32_t GetNumSceneContainers();
    CoreModelGeometry* GetModelGeometryPtr();
    uint32_t GetModelGeometryPtrSize();
    uint32_t* GetMaterialNames();
    CoreTextureSet* GetTextureSetPtr();
    uint32_t GetTextureSetPtrSize();
    CoreDetectionData* GetCollisionDetectionDataPtr();
    CoreDetectionData* GetFXDetectionDataPtr();
    CoreNavigationData* GetNavigationDataPtr();
    CoreLevelLightSet* GetLevelLightSetPtr();
    CoreCurveSet* GetCurveSetPtr();
    CoreBlindDataSection* GetGlobalBlindDataSectionPtr();
    CoreBlindDataSection* GetBoundedBlindDataSectionPtr();
    CoreOccluder* GetOccluderDataSectionPtr();
    CoreSceneContainer* GetSceneContainerDataSectionPtr();
    CoreSceneContainer* GetSceneContainerRawDataSectionPtr();
    uint32_t* GetLightControllerDataSectionPtr();
    uint32_t* GetModelInViewPtr();
    uint32_t* GetMaterialsByModelPtr();
    void Reset();
    int32_t* GetGeometryOffsetTable();
    uint32_t GetPlatformVersion();
    uint32_t GetID();
    bool CheckVersion();
    bool CheckID();
};

struct CoreNavigationData
{
    enum
    {
        VERSION = 9,
    };

    uint32_t m_version;
    uint32_t m_numNavMeshes;
    uint32_t m_navMeshOffsetsTableOffset;
    uint32_t m_nameToIndexTableOffset;
    uint32_t m_topLevelNavArrayOffset;

    void CoreNavigationData();
    void ~CoreNavigationData();
    uint32_t GetNumNavMeshes();
    uint32_t GetNavMeshIndex();
    CoreNavigationMesh* GetNavMeshByIndex();
    CoreNavigationMesh* GetNavMeshByName();
    int32_t GetNavMeshNextStep();
    CoreHashArray* GetNameToIndexTable();
    uint32_t* GetNavMeshOffsetsTable();
};

struct CoretGS_DISPFB2
{
    uint32_t FBP : 9;
    uint32_t FBW : 6;
    uint32_t PSM : 5;
    uint32_t p0 : 12;
    uint32_t DBX : 11;
    uint32_t DBY : 11;
    uint32_t p1 : 10;
};

struct _CERT_RDN_ATTR
{
    char* pszObjId;
    uint32_t dwValueType;
    _CRYPTOAPI_BLOB Value;
};

struct _PORT_INFO_3W
{
    uint32_t dwStatus;
    uint32_t* pszStatus;
    uint32_t dwSeverity;
};

struct IInternetSecurityManager : IUnknown
{
    HRESULT __stdcall SetSecuritySite();
    HRESULT __stdcall GetSecuritySite();
    HRESULT __stdcall MapUrlToZone();
    HRESULT __stdcall GetSecurityId();
    HRESULT __stdcall ProcessUrlAction();
    HRESULT __stdcall QueryCustomPolicy();
    HRESULT __stdcall SetZoneMapping();
    HRESULT __stdcall GetZoneMappings();
    void IInternetSecurityManager();
};

struct CoreDetectionVertex
{
    float fX;
    float fY;
    float fZ;
    uint32_t padding;

    CoreVector GetVertex();
};

struct _OSVERSIONINFOEXW
{
    uint32_t dwOSVersionInfoSize;
    uint32_t dwMajorVersion;
    uint32_t dwMinorVersion;
    uint32_t dwBuildNumber;
    uint32_t dwPlatformId;
    uint32_t szCSDVersion[128];
    uint32_t wServicePackMajor;
    uint32_t wServicePackMinor;
    uint32_t wSuiteMask;
    uint32_t wProductType;
    uint32_t wReserved;
};

struct _NOTIFYICONDATAA
{
    uint32_t cbSize;
    HWND* hWnd;
    uint32_t uID;
    uint32_t uFlags;
    uint32_t uCallbackMessage;
    HICON__* hIcon;
    char szTip[64];
};

struct IDirectSound3DBuffer : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetAllParameters();
    HRESULT __stdcall GetConeAngles();
    HRESULT __stdcall GetConeOrientation();
    HRESULT __stdcall GetConeOutsideVolume();
    HRESULT __stdcall GetMaxDistance();
    HRESULT __stdcall GetMinDistance();
    HRESULT __stdcall GetMode();
    HRESULT __stdcall GetPosition();
    HRESULT __stdcall GetVelocity();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall SetConeAngles();
    HRESULT __stdcall SetConeOrientation();
    HRESULT __stdcall SetConeOutsideVolume();
    HRESULT __stdcall SetMaxDistance();
    HRESULT __stdcall SetMinDistance();
    HRESULT __stdcall SetMode();
    HRESULT __stdcall SetPosition();
    HRESULT __stdcall SetVelocity();
    void IDirectSound3DBuffer();
};

struct CoreTexturePage
{
    enum
    {
        VERSION = 2,
    };

    uint32_t m_powerOfTwoWidth;
    uint32_t m_powerOfTwoHeight;
    uint32_t m_flags;
    uint32_t m_combinedSetThisHash;
    uint32_t m_engineID;
    uint32_t m_TextureSetIndex;
    char m_debugName[16];

    void CoreTexturePage();
    void ~CoreTexturePage();
    uint32_t sGetWidth();
    uint32_t sGetHeight();
    uint32_t GetWidth();
    uint32_t GetHeight();
    uint32_t GetPowerOfTwoWidth();
    uint32_t GetPowerOfTwoHeight();
    uint32_t GetFlags();
    uint32_t GetHash();
    void SetFlags();
    bool Is32Bit();
    bool Is24Bit();
    bool Is8Bit();
    bool Is4Bit();
    bool HasAlpha();
    bool HasPalette();
    bool HasMipMaps();
    bool HasNoMipMaps();
    bool IsDoubleSided();
    uint32_t GetEngineID();
    void SetEngineID();
    void SetDoubleSided();
    void SetTextureSetIndex();
    uint32_t GetTextureSetIndex();
    void Construct();
    char* GetDebugName();
    void SetHash();
};

struct CoreGraphicsDevice
{
    enum
    {
        INVALID_LIGHT_VOLUME_INDEX = 255,
    };

    enum CorePassDrawFlagsEnum
    {
        PASS_DRAW_LEVEL,
        PASS_DRAW_OBJECTS,
        PASS_DRAW_SHADOW_MESHES,
        PASS_DRAW_SHADOW_CASTERS,
        PASS_DRAW_SHADOW_RECEIVERS,
        PASS_DRAW_NOT_SHADOW_RECEIVERS,
        PASS_SORT_ALPHA_MESHES,
        PASS_DRAW_ALPHA_MESHES,
        PASS_DRAW_OPAQUE_MESHES,
        PASS_DRAW_MASK_MESHES,
        PASS_ADD_MASKS_TO_LIST,
        PASS_ADD_ALPHAS_TO_LIST,
    };

    enum CoreVertexFormat
    {
        VERTEX_FORMAT_XYZ32_ARGB8_UV32,
    };

    enum CoreGeometryType
    {
        GEOM_TYPE_TRILIST,
        GEOM_TYPE_TRISTRIP,
    };

    enum CoreLightVolumeShape
    {
        LV_INVALID,
        LV_SPHERE,
        LV_CONE,
    };

    enum CoreTextureFilterTypes
    {
        TPOINT,
        BILINEAR,
        TRILINEAR,
    };

    enum CoreGeometryDrawEnum
    {
        STATIC_MESH,
        PARENTED_MESH,
        SOFT_SKINNED_MESH,
        HARD_SKINNED_MESH,
        BLENDSHAPE_MESH,
        ALPHA_MESH_SORT_ORDER,
        DRAW_LODS_BBOX,
    };

    enum CoreBlendModeEnum
    {
        BLEND_ALPHA,
        BLEND_ADD,
        BLEND_SUBTRACT,
        BLEND_FIXED,
        BLEND_ALPHA_WRITE_ONLY,
        BLEND_DESTINATION_ALPHA,
        BLEND_DESTINATION_ADD_ALPHA,
    };

    enum CoreMaterialPropertiesFlags
    {
        ALPHA_BLENDED_BIT,
        ENV_MAPPED_BIT,
    };

    bool m_bIsWireFrame;
    CoreGraphicsDeviceInternalData* m_lpoData;
    uint32_t m_uiDebugFlags;
    CoreMeshMatrixPalette* m_lpoMatrixPalette;
    CoreMatrix* m_lpmtMatrixList;
    char* m_lpcVisibleList;
    CoreVector m_vCameraPos;
    CoreEulerAngle m_vCameraOrient;
    CoreGraphicsDeviceFogSettings m_fog;
    CoreGraphicsDeviceFullScreenSettings m_fullScreen;
    float m_fNearClip;
    float m_fFarClip;
    float m_fVerticalFieldOfView;
    float m_fDisplayAspectRatio;
    CoreMatrix m_mtObject2World;
    CoreMatrix m_mtLocal2Object;
    CoreMatrix m_mtLocal2World;
    float* m_lpfBlendShapeAlpha;
    float m_gameTime;
    uint32_t m_drawFlags;
    CoreGraphicsDevice::CoreTextureFilterTypes m_textureFiltering;
    float m_sOffset;
    float m_tOffset;
    uint32_t m_numScreens;
    uint32_t m_activeScreen;
    bool m_horizontalSplit;
    bool m_isFading;
    float m_fontScale;
    bool m_bDoubleSided;
    CoreMemory* m_pMemPool;
    CoreMatrix m_viewMatrix;
    CorePlaneEquation m_viewFrustrumPlanes[6];
    CoreGraphicsDeviceLightData m_oLightData;
    static CoreGraphicsDevice* m_instance;

    // TODO vtable

    CoreGraphicsDevice* CreateDevice(CoreMemory* i_memory, CoreHash i_type);
    void RegisterRenderTextureSet(CoreMemory*, uint32_t, CoreTextureSet*);
    void UpdateRenderTextureSet(uint32_t, CoreTextureSet*);
    void AddStaticMesh(CoreGeometryCompiled*, uint32_t, CoreTextureInfo*, CoreTexturePage*, uint32_t);
    void FlushBatchRender(uint32_t);
    void ResetBatchRender(uint32_t);
    void ReleaseRenderer();
    void SetRenderProfileMark(char*, uint32_t, uint32_t, uint32_t);
    void SetMatrices();
    void* GetFastQuadPtr();
    void* GetFastQuadPtrMax();
    void SetFastQuadPtr(void*);
    void SetBGColour(uint32_t val);
    uint32_t* ReserveDynamicDisplayList(uint32_t);
    uint32_t GetScreenWidth();
    uint32_t GetScreenHeight();
    void RenderLevelMeshList(CoreModelMaterial*** iModelMaterialLists, uint32_t* iNumModelsPerList, uint32_t* iInViewList, uint32_t iNumTotalLists, CoreTextureSet* iTextureSet);
    CoreModelMaterial* CopyAndLightMaterialMesh(CoreModelMaterial*, CoreVector, CoreVector);
    void CoreGraphicsDevice();
    void ~CoreGraphicsDevice();
    void Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams, char* lpcAppName);
    void Destruct(CoreMemory* lpoMemory);
    void Init();
    void Reset();
    void ResetLevelOnly();
    void DoDebug(CoreDebugInput* i_input);
    void DoDebugFullScreen(CoreDebugInput* i_input);
    void SetCameraLookAt();
    void SetCameraProperties(float fVerticalFieldOfView, float fNearClip, float fFarClip, float fDisplayAspectRatio, bool i_fogOn, float i_fogNear, float i_fogFar, float i_fogRed, float i_fogGreen, float i_fogBlue, float i_fogAlpha, bool i_bloom, float i_bloomIntensity, float i_bloomFeedback, float i_bloomThreshold, bool i_focalBlur, float i_focalBlurZ, float i_focalBlurAmount, bool i_motionBlur, float i_motionBlurAmount, bool i_radialBlur, float i_radialBlurAngle, float i_radialBlurScale, float i_radialBlurCenterX, float i_radialBlurCenterY, bool i_FSFX0, bool i_FSFX1, bool i_FSFX2, bool i_FSFX3, bool i_FSFX4, bool i_FSFX5, bool i_FSFX6, bool i_FSFX7, bool i_FSFX8, bool i_FSFX9);
    void SetDisplayAspectRatio();
    void SetDrawFlags();
    uint32_t GetDrawFlags();
    void SetForceWireFrame(bool bVal);
    float GetGameTime();
    void SetGameDeltaTime();
    uint32_t GetNumScreens();
    uint32_t GetActiveScreen();
    void SetSingleViewMode();
    void SetNumScreens(uint32_t i_count);
    void InitScreen(uint32_t i_index);
    void SetHorizontalSplit();
    bool GetHorizontalSplit();
    void SetCamera(CoreVector& vPos, CoreEulerAngle& eaOrient);
    void ClearScreen();
    void FinishBuffer();
    void SwapBuffer();
    void ClearZBuffer();
    void PanicModeRender();
    uint32_t GetDisplayWidth();
    uint32_t GetDisplayHeight();
    int32_t GetNumGeometryPasses();
    uint32_t uiBeginGeometryPass(int32_t);
    void EndGeometryPass(int32_t);
    void End3DScene(bool i_drawPostProcessEffects);
    CoreVector unProject(float iX, float iY, float iZ);
    CoreVector Project(float iX, float iY, float iZ);
    void getLocalMousePos(float& oX, float& oY);
    void getLocalMouseDelta(float& oX, float& oY);
    CoreGeometry::CoreInViewEnum IsSphereInView(CoreVector centre, float radius);
    CoreGeometry::CoreInViewEnum IsBBoxInView(CoreVector i_min, CoreVector i_max);
    void BeginDrawDynamicLightVolume();
    void EndDrawDynamicLightVolume();
    void DrawDynamicLightVolume();
    CoreVector vWorldToScreen();
    CoreVector vViewToScreen();
    void PrintString2D(CoreVector& vPos, CoreRGBA oColour, char* lpcText);
    void PrintString(CoreVector& vPos, CoreRGBA oColour, char* lpcText);
    void PrintStringScreen(CoreVector& vPos, CoreRGBA oColour, char* lpcText);
    void GouraudLine();
    void Line();
    void Triangle();
    void Quad();
    void TexturedQuad();
    void TexturedQuadFast();
    void LineStrip();
    void TriBatch();
    void TexturedTriBatch();
    void BeginFastQuadRender();
    void EndFastQuadRender();
    void GouraudLineScreen();
    void LineScreen();
    void TriangleScreen();
    void QuadScreen();
    void TexturedQuadScreen();
    void LineStripScreen();
    void TriBatchScreen();
    void TexturedTriBatchScreen();
    void TexturedFilledBoxScreen(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour, CoreUV oUV1, CoreUV oUV4);
    void FilledBoxScreen(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour);
    void UnfilledBoxScreen(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour);
    void Line2D(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
    void UnfilledBox2D(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour);
    void FilledBox2D(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour);
    void LineStrip2D(CoreVector& vPos, CoreVector& vScale, float* lpfCoordPointer, int32_t iNumCoords, CoreRGBA oColour);
    void Triangle2D(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreRGBA oColour);
    void Quad2D(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour);
    void TexturedQuad2D(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour, CoreUV oUV0, CoreUV oUV1, CoreUV oUV2, CoreUV oUV3);
    void SphereObjectMatrix();
    void CylinderObjectMatrix();
    void SausageObject();
    void ConeObject();
    void ConeObjectMatrix();
    void* GetVertexBuffer();
    void RenderVertexBuffer();
    void Arrow(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
    void ArrowScreen(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
    void ArrowScaled(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour, float i_arrowScale);
    void ArrowScreenScaled(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour, float i_arrowScale);
    void Circle(CoreVector& vCentre, float fRadius, CoreRGBA oColour);
    void CircleScreen(CoreVector& vCentre, float fRadius, CoreRGBA oColour);
    void Sphere(CoreVector& vCentre, float fRadius, CoreRGBA oColour);
    void Cylinder(CoreVector& vBaseCentre, float fRadius, float fHeight, CoreRGBA oColour);
    void SphereScreen(CoreVector& vCentre, float fRadius, CoreRGBA oColour);
    void CylinderScreen(CoreVector& vBaseCentre, float fRadius, float fHeight, CoreRGBA oColour);
    void Sausage(CoreVector& vPos1, CoreVector& vPos2, float fRadius, CoreRGBA oColour);
    void Cone(CoreVector& vPos1, CoreVector& vPos2, float fAngle, CoreRGBA oColour);
    void SolidCuboidObjectMatrix();
    void WireFrameCuboidObjectMatrix();
    void SphereObject(CoreVector& vCentre, CoreEulerAngle& eaOrient, CoreVector& vScale, CoreRGBA oColour);
    void CylinderObject(CoreVector& vBaseCentre, CoreEulerAngle& eaOrient, CoreVector& vScale, CoreRGBA oColour);
    void WireFrameCuboidObject(CoreVector& vPos, CoreEulerAngle& eaOrient, CoreVector& vScale, CoreRGBA oColour);
    void SolidCuboidObject(CoreVector& vPos, CoreEulerAngle& eaOrient, CoreVector& vScale, CoreRGBA oColour);
    float GetFontWidth();
    float GetFontHeight();
    void SetFontScale(float i_scale);
    void DrawMeshGroup();
    void DrawStaticMesh();
    void DrawModelCompiled(CoreGraphicsDeviceModelCompiledInfo* lpoModelInfo);
    void DrawStaticModelCompiledNonDebug(CoreGraphicsDeviceModelCompiledInfo* i_modelInfo);
    void SetObject2World();
    void SetLocal2Object();
    void SetMatrixList(CoreMatrix* lpmtMatrixList, char* lpcVisibleList, uint32_t uiNumEntriesInMatrixList);
    void SetMatrixPalette();
    CoreMatrix& mtGetObject2World();
    CoreMatrix& mtGetLocal2Object();
    CoreMatrix& mtGetLocal2World();
    void ComputeLocal2World();
    void SetUnLit(CoreTextureSet* i_texSet, CoreTextureInfo* i_texInfo, uint32_t i_flags, uint32_t i_pass);
    void SetMaterialProperties();
    void EnableAlphaBlend();
    void DisableAlphaBlend();
    void SetAlphaBlendFunc();
    void SetAdditiveBlendFunc();
    void SetSubtractiveBlendFunc();
    void SetDestinationAlphaBlendFunc();
    void SetDestinationAlphaAdditiveBlendFunc();
    void SetAlphaWriteOnlyBlendFunc();
    void SetFixedAlphaBlendFunc(float fFixedAlpha);
    void Set1BitAlphaMode(bool i_enable);
    void SetMultipleDrawModes();
    void LockOrthogonal();
    void UnlockOrthogonal();
    void DisableZTest();
    void DisableZWrite();
    void DisableZTestAndWrite();
    void EnableZTest();
    void EnableZWrite();
    void EnableZTestAndWrite();
    void EnableOverbrightMode();
    void DisableOverbrightMode();
    float* GetBlendShapeAlphaPtr();
    float GetBlendShapeAlpha();
    CoreVector GetCameraPos();
    CoreEulerAngle GetCameraOrient();
    float GetNearClip();
    float GetFarClip();
    float GetVerticalFieldOfView();
    float GetDisplayAspectRatio();
    void SetNearClip();
    void SetFarClip();
    void SetVerticalFieldOfView();
    CoreMatrix GetWorldToScreenMatrix();
    void SetIsFading();
    bool GetIsFading();
    CoreGraphicsDeviceFogSettings* GetFogSettings();
    CoreGraphicsDeviceFullScreenSettings* GetFullScreenSettings();
    bool bCanILoadTextureData();
    bool bLoadTextureData();
    void UnLoadTextureData();
    bool bCanILoadModelData();
    bool bCanILoadLevelData();
    bool bLoadModelData();
    void UnLoadModelData();
    void MoveTextureData();
    void MoveModelData();
    void DisableTexturing();
    void EnableTexturing();
    void GouraudShading(bool bEnable);
    void CycleTextureShading();
    void SetGlobalDynamicLightVolumeColour();
    CoreRGBA GetGlobalDynamicLightVolumeColour();
    int32_t RenderDynamicLightVolumes();
    int32_t ActivateLightVolume(CoreGraphicsDevice::CoreLightVolumeShape i_shape);
    bool DeActivateLightVolume(int32_t i_index);
    bool SetLightVolumeTransform(int32_t i_index, CoreVector& i_position, CoreEulerAngle& i_orientation, CoreVector& i_scale);
    void SetLights();
    void SelectLights();
    void SetShadowDirection();
    void StartSortedMeshRendering();
    void EndSortedMeshRendering();
    bool AddMeshInfo(CoreHash i_type, char* i_name, CoreGraphicsDeviceModelCompiledInfo* lpoModelCompiledInfo, int32_t iMaterialIndex, uint32_t uiMaterialHash, CoreModelMaterial* lpoModelMaterial, bool i_sorted);
    bool AddSortedMesh();
    void SetLevelLightSet(CoreLevelLightSet* lpoLevelLightSet);
    void LightParticle();
    CoreVector GetStaticLighting();
    CoreTextureInfo* GetDrawBufferTexture();
    void SetUnTextured();
    void SetDoubleSided();
    bool GetDoubleSided();
    void SetTextureFiltering();
    void SetTextureFilterSettings(bool overrideTextureFilterSettings, int32_t lcmValue, int32_t maxMipMapLevel, int32_t mmagValue, int32_t mminValue, int32_t lodLValue, int32_t lodKValue);
    bool SpecificFunction();
    void ResetRenderStates();
    CoreGraphicsDevice* GetInstance();
    CoreMatrix GetViewMatrix();
    CoreVector GetViewDirection();
    CorePlaneEquation* GetViewFrustrumPlanes();
    bool SnapshotDrawBuffer(char* i_name);
    bool SnapshotVideoMemory(char* i_name);
    bool WriteTGA(uint32_t* i_img, uint32_t i_width, uint32_t i_height, char* i_name);
    float GetDisplayListUsage();
    CorePlaneEquation* GetFrustrumPlanes();
    void SetZOffset(uint32_t val);
    void UpdateMeshTagColours(CoreGeometryCompiled* iModelCompiled, uint32_t iLightID, uint32_t iblendFrameStart, uint32_t iblendFrameEnd, uint32_t iblendTime, uint32_t iblendTimeMax);
    void GetGeometryCompiledReport(CoreModelMesh* iModelMesh, CoreStringBuffer<256>& iStr);
    void GetGeometryCompiledInfo(CoreModelMesh* iModelMesh, uint32_t& nVerts);
    void RenderGeometryCompiledBounds(CoreModelMesh* iModelMesh);
    CoreLevelLightSet* GetLevelLightSet();
    void RenderMeshInfo(CoreGraphicsDeviceMeshInfo* i_meshInfo, uint32_t i_lastObjectHash);
    CoreMatrix* lpmtGetMatrixList();
    char* GetVisibleList();
    CoreMeshMatrixPalette* GetMatrixPalette();
    CoreMatrix MakeViewMatrix();
    void SelectTexture();
    void SelectUnLit();
    void SelectMaterialProperties();
    void SelectMatrixPalette();
    void SetBlendState();
    void SetBlendFunction();
    uint32_t GetDebugFlags();
    void SetTexture(CoreTextureSet* i_texSet, CoreTextureInfo* i_texInfo, uint32_t i_pass);
    void SetTextureOffsets();
    bool IsValidActiveDynamicLightVolume();
    void DrawDebugDynamicLightVolumes();
    bool AddSortedMeshInfo(CoreGraphicsDeviceMeshInfo* i_meshInfo);
    uint32_t FindMeshInfoIndex(CoreHash i_type, CoreGraphicsDeviceMeshInfo* i_meshInfo);
    CoreMemory* GetMemory();
    float GetSOffset();
    float GetTOffset();
    void ComputeFrustrumPlanes();
    CoreGraphicsDevice* CreateSpecificDevice(CoreMemory* i_memory, CoreHash i_type);
};

struct CoreMeshGroup
{
};

struct CoreMeshMatrixPalette
{
    enum
    {
        VERSION = 1,
    };

    uint32_t m_uiNumPaletteEntries;
    uint32_t m_ucMatrixPalette[4];

    void CoreMeshMatrixPalette();
    void ~CoreMeshMatrixPalette();
    uint32_t GetNumPaletteEntries();
    uint32_t* GetMatrixPalette();
    int32_t* GetEndOfMatrixPalette();
};

struct CoreGraphicsDeviceFullScreenSettings
{
    bool bloom;
    float bloomIntensity;
    float bloomFeedback;
    float bloomThreshold;
    bool focalBlur;
    float focalBlurZ;
    float focalBlurAmount;
    bool motionBlur;
    float motionBlurAmount;
    bool radialBlur;
    float radialBlurAngle;
    float radialBlurScale;
    float radialBlurCenterX;
    float radialBlurCenterY;
    bool FSFX0;
    bool FSFX1;
    bool FSFX2;
    bool FSFX3;
    bool FSFX4;
    bool FSFX5;
    bool FSFX6;
    bool FSFX7;
    bool FSFX8;
    bool FSFX9;
};

struct CoreGraphicsDeviceMeshInfo
{
    enum
    {
        MAX_MESHINFOTYPE_NAME = 16,
    };

    CoreGraphicsDeviceModelCompiledInfo* lpoModelCompiledInfo;
    char name[16];
    CoreHash type;
    int32_t iMaterialIndex;
    uint32_t uiMaterialHash;
    uint32_t uiObjectHash;
    CoreVector vWorldPos;
    float fWorldBBOXRadius;
    CoreVector vWorldBBOXMin;
    CoreVector vWorldBBOXMax;
    CoreGraphicsDeviceMeshInfo* nextMeshInfo;

    void CoreGraphicsDeviceMeshInfo();
    void ~CoreGraphicsDeviceMeshInfo();
};

struct CoreGraphicsDeviceDynamicLightVolume
{
    CoreGraphicsDevice::CoreLightVolumeShape shape;
    CoreMatrix transform;

    void CoreGraphicsDeviceDynamicLightVolume();
};

struct in_addr
{
    in_addr::__unnamed S_un;
};

struct _ADDJOB_INFO_1A
{
    char* Path;
    uint32_t JobId;
};

struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION
{
    uint32_t dwFlags;
    uint32_t ulFormatVersion;
    uint32_t ulAssemblyCount;
    uint32_t ulRootManifestPathType;
    uint32_t ulRootManifestPathChars;
    uint32_t ulRootConfigurationPathType;
    uint32_t ulRootConfigurationPathChars;
    uint32_t ulAppDirPathType;
    uint32_t ulAppDirPathChars;
    uint32_t* lpRootManifestPath;
    uint32_t* lpRootConfigurationPath;
    uint32_t* lpAppDirPath;
};

struct _DEBUG_EVENT
{
    uint32_t dwDebugEventCode;
    uint32_t dwProcessId;
    uint32_t dwThreadId;
    _DEBUG_EVENT::__unnamed u;
};

struct _PRINTER_INFO_4W
{
    uint32_t* pPrinterName;
    uint32_t* pServerName;
    uint32_t Attributes;
};

struct _SECURITY_DESCRIPTOR_RELATIVE
{
    uint32_t Revision;
    uint32_t Sbz1;
    uint32_t Control;
    uint32_t Owner;
    uint32_t Group;
    uint32_t Sacl;
    uint32_t Dacl;
};

struct _SHFILEINFOA
{
    HICON__* hIcon;
    int32_t iIcon;
    uint32_t dwAttributes;
    char szDisplayName[260];
    char szTypeName[80];
};

struct _BIN_COUNT
{
    _BIN_RANGE BinRange;
    uint32_t BinCount;
};

struct tagEMRCREATEMONOBRUSH
{
    tagEMR emr;
    uint32_t ihBrush;
    uint32_t iUsage;
    uint32_t offBmi;
    uint32_t cbBmi;
    uint32_t offBits;
    uint32_t cbBits;
};

struct CoreScriptUpdate
{
    CoreVariableStore* m_variableStore;
    CoreScriptStore* m_scriptStore;

    void CoreScriptUpdate();
    void ~CoreScriptUpdate();
    void SetVariableStore();
    void SetScriptStore();
    CoreVariableStore* GetVariableStore();
    CoreScriptStore* GetScriptStore();
};

struct CAL1_SRAMLoader : CAL0_FileLoader
{
    uint32_t m_BlockAddr;
    CAL1_AudioDriver* m_AD;
    CAL1_AudioItemDatabase* m_AID;

    void CAL1_SRAMLoader();
    void ~CAL1_SRAMLoader();
    uint32_t GetSRAMAddress();
    CAAudioError LoadTheSection(char* type, uint32_t version, uint32_t dataSize);
    CAAudioError LoadSAMM(uint32_t version, uint32_t dataSize);
    CAAudioError LoadSAMD(uint32_t version, uint32_t dataSize);
    CAAudioError ParseSAMM_V1_0(uint32_t* data, uint32_t dataSize);
};

struct tagWAVEINCAPSW
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t dwFormats;
    uint32_t wChannels;
    uint32_t wReserved1;
};

struct _CERT_REVOCATION_STATUS
{
    uint32_t cbSize;
    uint32_t dwIndex;
    uint32_t dwError;
    uint32_t dwReason;
    int32_t fHasFreshnessTime;
    uint32_t dwFreshnessTime;
};

struct tagTYPEATTR
{
    _GUID guid;
    uint32_t lcid;
    uint32_t dwReserved;
    int32_t memidConstructor;
    int32_t memidDestructor;
    uint32_t* lpstrSchema;
    uint32_t cbSizeInstance;
    tagTYPEKIND typekind;
    uint32_t cFuncs;
    uint32_t cVars;
    uint32_t cImplTypes;
    uint32_t cbSizeVft;
    uint32_t cbAlignment;
    uint32_t wTypeFlags;
    uint32_t wMajorVerNum;
    uint32_t wMinorVerNum;
    tagTYPEDESC tdescAlias;
    tagIDLDESC idldescType;
};

struct CoreMenuComponentListBox : CoreMenuComponent
{
    enum
    {
        MAX_LISTBOX_ITEMS = 48,
        MAX_LISTBOX_ITEM_TEXTWIDTH = 64,
    };

    struct ListBoxItem
    {
        int32_t m_flags;
        char m_text[64];
        CoreHash m_textHash;
        CoreHash m_iconHash;

        void ListBoxItem();
        void ~ListBoxItem();
    };

    CoreMenuComponentListBox::ListBoxItem m_item[48];
    int32_t m_numberItems;
    int32_t m_selectedItem;
    int32_t m_visibleItems;
    bool m_hasIcons;
    float m_iconHeight;
    float m_textScale;
    CoreMenuComponentSlider m_itemRed[48];
    CoreMenuComponentSlider m_itemGreen[48];
    CoreMenuComponentSlider m_itemBlue[48];
    CoreMenuComponentSlider m_itemAlpha[48];
    bool m_itemCustomColour[48];
    CoreMenuComponentSlider m_backgroundRed;
    CoreMenuComponentSlider m_backgroundGreen;
    CoreMenuComponentSlider m_backgroundBlue;
    CoreMenuComponentSlider m_backgroundAlpha;
    CoreMenuComponentSlider m_highlightRed;
    CoreMenuComponentSlider m_highlightGreen;
    CoreMenuComponentSlider m_highlightBlue;
    CoreMenuComponentSlider m_highlightAlpha;
    CoreMenuComponentSlider m_normalTextRed;
    CoreMenuComponentSlider m_normalTextGreen;
    CoreMenuComponentSlider m_normalTextBlue;
    CoreMenuComponentSlider m_normalTextAlpha;

    void Init(CoreHash i_name, CoreHash i_type);
    void SetRGBABackground(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
    void SetRGBAHighlight(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
    void SetRGBANormalText(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
    bool AddItem(char* i_text, uint32_t i_customColour, CoreHash i_icon);
    void ClearContents();
    void SetItemIconVisibility(int32_t i_itemIndex, bool i_visible);
    bool GetItemIconVisibility(int32_t i_itemIndex);
    void SetNumberOfVisibleItems(int32_t i_visibleItemCount);
    int32_t GetNumberOfVisibleItems();
    CoreRGBA GetCustomRGBA(uint32_t i_index, float i_visMult);
    CoreRGBA GetRGBABackground(float i_visMult);
    CoreRGBA GetRGBAHighlight(float i_visMult);
    CoreRGBA GetRGBANormalText(float i_visMult);
    float GetRedBackground();
    float GetGreenBackground();
    float GetBlueBackground();
    float GetAlphaBackground();
    float GetRedHighlight();
    float GetGreenHighlight();
    float GetBlueHighlight();
    float GetAlphaHighlight();
    float GetRedNormalText();
    float GetGreenNormalText();
    float GetBlueNormalText();
    float GetAlphaNormalText();
    CoreHash GetItemHash(int32_t i_itemIndex);
    char* GetItemText(int32_t i_itemIndex);
    bool GetSelectable();
    void Update(float i_time);
    void Render(CoreGameRender* io_graphics, float i_visibilityMultiplier);
    void RenderBackground(CoreGameRender* io_graphics, float i_visibilityMultiplier, int32_t i_drawFlags);
    void RenderHighlight(CoreGameRender* io_graphics, float i_visibilityMultiplier, int32_t i_drawFlags);
    void RenderText(CoreGameRender* io_graphics, float i_visibilityMultiplier, int32_t i_drawFlags);
    bool InternalMovementHandler(CoreMenuComponent::CompDirection i_direction);
    int32_t GetInternalSelection();
    void SetInternalSelection(uint32_t i_index);
    uint32_t GetNumberOfItems();
    void CoreMenuComponentListBox();
    void ~CoreMenuComponentListBox();
};

struct tagSAFEARRAYBOUND
{
    uint32_t cElements;
    int32_t lLbound;
};

struct CoreModelInfo
{
    uint32_t m_audioHash;
    uint32_t m_flagHash1;
    uint32_t m_flagHash2;
    uint32_t m_flagHash3;
    uint32_t m_flagHash4;
};

struct _TOKEN_STATISTICS
{
    _LUID TokenId;
    _LUID AuthenticationId;
    _LARGE_INTEGER ExpirationTime;
    _TOKEN_TYPE TokenType;
    _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    uint32_t DynamicCharged;
    uint32_t DynamicAvailable;
    uint32_t GroupCount;
    uint32_t PrivilegeCount;
    _LUID ModifiedId;
};

struct CoreXMLNode
{
    CoreXMLNodeData* m_data;

    void CoreXMLNode();
    void ~CoreXMLNode();
    int32_t GetNumChildren();
    CoreXMLNode GetChild();
    CoreXMLNode GetChildByName();
    bool HasChildByName();
    CoreXMLNode GetChildTextByName();
    bool IsUndefined();
    int32_t GetType();
    char* GetName();
    char* GetValue();
    void PrivateInitialise();
    void GetNodeData();
};

struct CoreXMLNodeData
{
};

struct IXMLDOMComment : IXMLDOMCharacterData
{
    void IXMLDOMComment();
};

struct tagQUERYCONTEXT
{
    uint32_t dwContext;
    tagCSPLATFORM Platform;
    uint32_t Locale;
    uint32_t dwVersionHi;
    uint32_t dwVersionLo;
};

struct CoreStdFileSystem : CoreFileSystem
{
    void CoreStdFileSystem();
    void ~CoreStdFileSystem();
    void Construct(CoreMemory*);
    void Destruct(CoreMemory*);
    void Init(int32_t i_maxOpenFiles);
    CoreFileHandle Open(char* i_name, CoreFileOpenAttributes& i_attrib);
    bool Close(CoreFileHandle& i_handle);
    int32_t Read(CoreFileDevice* i_device, CoreFileHandle& i_handle, void* o_dest, int32_t i_size);
    int32_t Write(CoreFileDevice* i_device, CoreFileHandle& i_handle, void* i_src, int32_t i_size);
    bool Seek(CoreFileDevice* i_device, CoreFileHandle& i_handle, int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin);
    int32_t FileSize(CoreFileDevice* i_device, char* i_name);
    bool GetFileTimes(CoreFileDevice* i_device, char* i_fileName, CoreDateTime* o_creationTime, CoreDateTime* o_lastAccessTime, CoreDateTime* o_lastWriteTime);
    bool SetFileTimes(CoreFileDevice* i_device, char* i_fileName, CoreDateTime* i_creationTime, CoreDateTime* i_lastAccessTime, CoreDateTime* i_lastWriteTime);
    bool DoesFileExist(CoreFileDevice* i_device, char* i_fileName);
    bool IsReadOnly(CoreFileDevice* i_device, char* i_fileName);
    bool ChangeReadOnly(CoreFileDevice* i_device, char* i_fileName, bool i_readOnly, bool* o_changed);
};

struct _SHNAMEMAPPINGW
{
    uint32_t* pszOldPath;
    uint32_t* pszNewPath;
    int32_t cchOldPath;
    int32_t cchNewPath;
};

struct CoreGsFrame
{
    uint32_t FBP : 9;
    uint32_t pad09 : 7;
    uint32_t FBW : 6;
    uint32_t pad22 : 2;
    uint32_t PSM : 6;
    uint32_t pad30 : 2;
    uint32_t FBMSK : 32;
};

struct _PRIVILEGE_SET
{
    uint32_t PrivilegeCount;
    uint32_t Control;
    _LUID_AND_ATTRIBUTES Privilege[1];
};

struct _TAPE_GET_POSITION
{
    uint32_t Type;
    uint32_t Partition;
    _LARGE_INTEGER Offset;
};

struct HWND__
{
    int32_t unused;
};

struct _BIN_RANGE
{
    _LARGE_INTEGER StartValue;
    _LARGE_INTEGER Length;
};

struct _CERT_X942_DH_VALIDATION_PARAMS
{
    _CRYPT_BIT_BLOB seed;
    uint32_t pgenCounter;
};

struct _CERT_CHAIN_POLICY_STATUS
{
    uint32_t cbSize;
    uint32_t dwError;
    int32_t lChainIndex;
    int32_t lElementIndex;
    void* pvExtraPolicyStatus;
};

struct CAL0_SectionInfo
{
    char m_SectionType[4];
    uint32_t m_SectionOffset;

    void CAL0_SectionInfo();
};

struct tagMCI_OVLY_WINDOW_PARMSA
{
    uint32_t dwCallback;
    HWND* hWnd;
    uint32_t nCmdShow;
    char* lpstrText;
};

struct tagEMREOF
{
    tagEMR emr;
    uint32_t nPalEntries;
    uint32_t offPalEntries;
    uint32_t nSizeLast;
};

struct CorePackedDateTime
{
    uint32_t m_year : 6;
    uint32_t m_month : 4;
    uint32_t m_day : 5;
    uint32_t m_hour : 5;
    uint32_t m_minute : 6;
    uint32_t m_second : 6;

    void CorePackedDateTime();
    void Reset();
    void Set();
    CorePackedDateTime& operator=();
    void SetToCurrent();
    CorePackedDateTime& GetCurrent();
    CorePackedDateTime& GetDummy();
    char* GetTimeString();
    bool IsTimeValid();
    bool IsTimeInvalid();
    int32_t GetYear();
    int32_t GetMonth();
    int32_t GetDay();
    int32_t GetHour();
    int32_t GetMinute();
    int32_t GetSecond();
    int32_t GetCompareValue();
    bool IsSameTime();
    bool IsNotSameTime();
    bool operator==();
    bool operator!=();
};

struct ScePspDateTime
{
};

struct CAL1_ObjectManager
{
    CAL1_AudioObject* m_Object;
    CAL1_AudioItemDatabase* m_AID;
    CAL1_API* m_CAL1API;
    char m_FilePath[1024];

    void CAL1_ObjectManager();
    void ~CAL1_ObjectManager();
    CAAudioError LoadObject();
    CAAudioError UnLoadObject();
    CAAudioError RefreshObject();
    CAL1_AudioObject* GetAudioObject();
    CAL1_AudioEvent* FindEvent();
    uint32_t GetNumEvents();
    CAL1_AudioEvent* GetEvent();
    CAAudioError ExtractEvents();
    CAAudioError ExtractSamples();
    CAAudioError ExtractSGP();
    CAAudioError ExtractSG();
    CAAudioError LoadSampleData();
};

struct tagCREATESTRUCTW
{
    void* lpCreateParams;
    HINSTANCE__* hInstance;
    HMENU__* hMenu;
    HWND* hwndParent;
    int32_t cy;
    int32_t cx;
    int32_t y;
    int32_t x;
    int32_t style;
    uint32_t* lpszName;
    uint32_t* lpszClass;
    uint32_t dwExStyle;
};

struct tagMCI_GETDEVCAPS_PARMS
{
    uint32_t dwCallback;
    uint32_t dwReturn;
    uint32_t dwItem;
};

struct tagBLOB
{
    uint32_t cbSize;
    uint32_t* pBlobData;
};

struct IDirectSoundCaptureFXNoiseSuppress : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    HRESULT __stdcall Reset();
    void IDirectSoundCaptureFXNoiseSuppress();
};

struct _CTL_INFO
{
    uint32_t dwVersion;
    _CTL_USAGE SubjectUsage;
    _CRYPTOAPI_BLOB ListIdentifier;
    _CRYPTOAPI_BLOB SequenceNumber;
    _FILETIME ThisUpdate;
    _FILETIME NextUpdate;
    _CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
    uint32_t cCTLEntry;
    _CTL_ENTRY* rgCTLEntry;
    uint32_t cExtension;
    _CERT_EXTENSION* rgExtension;
};

struct tagPALETTEENTRY
{
    uint32_t peRed;
    uint32_t peGreen;
    uint32_t peBlue;
    uint32_t peFlags;
};

struct tagRPC_CALL_ATTRIBUTES_V1_W
{
    uint32_t Version;
    uint32_t Flags;
    uint32_t ServerPrincipalNameBufferLength;
    uint32_t* ServerPrincipalName;
    uint32_t ClientPrincipalNameBufferLength;
    uint32_t* ClientPrincipalName;
    uint32_t AuthenticationLevel;
    uint32_t AuthenticationService;
    int32_t NullSession;
};

struct CorePS2StdCFileDevice : CoreFileDevice
{
    bool m_asyncActive;

    void CorePS2StdCFileDevice();
    void ~CorePS2StdCFileDevice();
    void Construct();
    void Destruct();
    void Init();
    CoreFileHandle Open();
    bool Close();
    int32_t Read();
    bool Seek();
    bool AsyncFinished();
    int32_t Write();
    int32_t FileSize();
    bool GetFileTimes();
    bool SetFileTimes();
    bool DoesFileExist();
    bool IsReadOnly();
    bool ChangeReadOnly();
    bool CompleteTheFileName();
};

struct _UNIVERSAL_NAME_INFOW
{
    uint32_t* lpUniversalName;
};

struct IErrorInfo : IUnknown
{
    HRESULT __stdcall GetGUID();
    HRESULT __stdcall GetSource();
    HRESULT __stdcall GetDescription();
    HRESULT __stdcall GetHelpFile();
    HRESULT __stdcall GetHelpContext();
    void IErrorInfo();
};

struct tagLOGCOLORSPACEW
{
    uint32_t lcsSignature;
    uint32_t lcsVersion;
    uint32_t lcsSize;
    int32_t lcsCSType;
    int32_t lcsIntent;
    tagICEXYZTRIPLE lcsEndpoints;
    uint32_t lcsGammaRed;
    uint32_t lcsGammaGreen;
    uint32_t lcsGammaBlue;
    uint32_t lcsFilename[260];
};

struct _RSAPUBKEY
{
    uint32_t magic;
    uint32_t bitlen;
    uint32_t pubexp;
};

struct _PRINTER_NOTIFY_INFO
{
    uint32_t Version;
    uint32_t Flags;
    uint32_t Count;
    _PRINTER_NOTIFY_INFO_DATA aData[1];
};

struct CoreSaveGameHelper
{
    CoreSaveGameInterfaceSize SizeFree;
    CoreSaveGameInterfaceSize SizeUsed;
    CoreSaveGameInterfaceSize SizeRequired;
    bool m_active;
    bool m_busy;
    bool m_shouldRetry;
    int32_t m_fileSize;
    CORE_SAVEGAME_RESULT_TAG m_result;

    void CoreSaveGameHelper();
    bool IsActive();
    bool IsBusy();
    bool Start();
    bool Process();
    bool ShouldRetry();
    int32_t GetFileSize();
    CORE_SAVEGAME_RESULT_TAG GetResult();
    void FinishedCallBack();
};

struct CoreSaveGameInterface : CoreCommonDialogStatus
{
    enum CoreSaveGameTypeTag
    {
        CORE_SAVEGAME_LOAD,
        CORE_SAVEGAME_AUTO_LOAD,
        CORE_SAVEGAME_SAVE,
        CORE_SAVEGAME_AUTO_SAVE,
        CORE_SAVEGAME_LIST_LOAD,
        CORE_SAVEGAME_LIST_SAVE,
        CORE_SAVEGAME_LIST_DELETE,
        CORE_SAVEGAME_DELETE,
        CORE_SAVEGAME_GET_SIZE_FREE,
        CORE_SAVEGAME_GET_SIZE_USED,
        CORE_SAVEGAME_GET_SIZE_REQUIRED,
        CORE_SAVEGAME_GET_ALL_SIZES,
        CORE_SAVEGAME_NO_TYPE,
    };

    enum CoreSaveGameType
    {
        CORE_SAVEGAME_LOAD,
        CORE_SAVEGAME_AUTO_LOAD,
        CORE_SAVEGAME_SAVE,
        CORE_SAVEGAME_AUTO_SAVE,
        CORE_SAVEGAME_LIST_LOAD,
        CORE_SAVEGAME_LIST_SAVE,
        CORE_SAVEGAME_LIST_DELETE,
        CORE_SAVEGAME_DELETE,
        CORE_SAVEGAME_GET_SIZE_FREE,
        CORE_SAVEGAME_GET_SIZE_USED,
        CORE_SAVEGAME_GET_SIZE_REQUIRED,
        CORE_SAVEGAME_GET_ALL_SIZES,
        CORE_SAVEGAME_NO_TYPE,
    };

    CoreSaveGameInterfaceSize SizeFree;
    CoreSaveGameInterfaceSize SizeUsed;
    CoreSaveGameInterfaceSize SizeRequired;
    CoreSaveGameInterface::CoreSaveGameTypeTag m_type;
    void* m_buffer;
    int32_t m_bufferSize;
    static CoreSaveGameInterface* m_dummyInstance;
    static CoreSaveGameInterface* m_defaultInstance;

    CoreSaveGameInterface* CreateInstance(CoreMemory* i_memoryInterface);
    CoreSaveGameInterface* GetDummyInstance();
    CoreSaveGameInterface* GetDefaultInstance();
    void SetDefaultInstance();
    void DeleteInstance();
    bool Start();
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    bool IsReady();
    bool PrepareLoad();
    bool PrepareAutoLoad();
    bool PrepareSave();
    bool PrepareAutoSave();
    bool PrepareListLoad();
    bool PrepareListSave();
    bool PrepareListDelete();
    bool PrepareDelete();
    bool PrepareGetSizeFree();
    bool PrepareGetSizeUsed();
    bool PrepareGetSizeRequired();
    bool PrepareGetAllSizes();
    bool Prepare(CoreSaveGameInterface::CoreSaveGameTypeTag i_type, void* io_buffer, int32_t i_bufferSize);
    void CoreSaveGameInterface();
};

struct _GRADIENT_RECT
{
    uint32_t UpperLeft;
    uint32_t LowerRight;
};

struct IOleWindow : IUnknown
{
    HRESULT __stdcall GetWindow();
    HRESULT __stdcall ContextSensitiveHelp();
    void IOleWindow();
};

struct _ADMINISTRATOR_POWER_POLICY
{
    _SYSTEM_POWER_STATE MinSleep;
    _SYSTEM_POWER_STATE MaxSleep;
    uint32_t MinVideoTimeout;
    uint32_t MaxVideoTimeout;
    uint32_t MinSpindownTimeout;
    uint32_t MaxSpindownTimeout;
};

struct _SESSION_BUFFER
{
    uint32_t lsn;
    uint32_t state;
    uint32_t local_name[16];
    uint32_t remote_name[16];
    uint32_t rcvs_outstanding;
    uint32_t sends_outstanding;
};

struct _IMAGE_RESOURCE_DATA_ENTRY
{
    uint32_t OffsetToData;
    uint32_t Size;
    uint32_t CodePage;
    uint32_t Reserved;
};

struct _TAPE_ERASE
{
    uint32_t Type;
    uint32_t Immediate;
};

struct _RemotableHandle
{
    union __MIDL_IWinTypes_0009
    {
        int32_t hInproc;
        int32_t hRemote;
    };

    int32_t fContext;
    _RemotableHandle::__MIDL_IWinTypes_0009 u;
};

struct CoreObjectUpdateStruct : CoreScriptUpdate
{
    CoreGameTextUnit* m_lpoGameText;
    CoreObjectController* m_lpoObjectController;
    CoreCutScenePlayer* m_lpoCutScenePlayer;
    CoreAIController* m_lpoAIController;
    CoreGameRender* m_lpoGraphics;
    CoreGraphicsDevice* m_lpoGraphicsDevice;
    CoreInput* m_lpoInput;
    CoreWorld* m_lpoWorld;
    CoreNet* m_lpoNet;
    CoreAssetManager* m_lpoAssetManager;
    float m_fTotalRealTimeInSeconds;
    float m_fTotalGameTimeInSeconds;
    float m_fDeltaFrameTimeInSeconds;
    float m_fDeltaScaledFrameTimeInSeconds;
    float m_fTimeScale;

    void InitWorldToObjectStruct();
    void InitLevelToObjectStruct();
    void InitGameControllerToObjectStruct();
    void SetTotalRealTime();
    void SetTotalGameTime();
    void SetDeltaFrameTime();
    void SetTimeScale();
    CoreGameRender* GetGraphics();
    CoreInput* GetInput();
    CoreWorld* GetWorld();
    CoreObjectController* GetObjectController();
    CoreCutScenePlayer* GetCutScenePlayer();
    CoreAIController* GetAIController();
    CoreGameTextUnit* GetGameText();
    CoreNet* GetNet();
    CoreAssetManager* GetAssetManager();
    float GetTotalRealTime();
    float GetTotalGameTime();
    float GetDeltaFrameTime();
    float GetTimeScale();
    float GetDeltaScaledFrameTime();
    CoreGraphicsDevice* GetGraphicsDevice();
    void CoreObjectUpdateStruct();
    void ~CoreObjectUpdateStruct();
};

struct _CMSG_SP3_COMPATIBLE_AUX_INFO
{
    uint32_t cbSize;
    uint32_t dwFlags;
};

struct CoreGeometryCompiledPSPStaticLitMeshVertexWeights
{
    uint32_t wa8;
    uint32_t wb8;
    uint32_t wc8;
    uint32_t wd8;
    uint32_t we8;
    uint32_t wf8;
    uint32_t wg8;
    uint32_t wh8;
    uint32_t u16;
    uint32_t v16;
    uint32_t col8888;
    float x32;
    float y32;
    float z32;
};

struct tagEMRPOLYPOLYLINE16
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t nPolys;
    uint32_t cpts;
    uint32_t aPolyCounts[1];
    tagPOINTS apts[1];
};

struct _FLAG_STGMEDIUM
{
    int32_t ContextFlags;
    int32_t fPassOwnership;
    tagSTGMEDIUM Stgmed;
};

struct tagCUSTDATA
{
    uint32_t cCustData;
    tagCUSTDATAITEM* prgCustData;
};

struct wavefilter_tag
{
    uint32_t cbStruct;
    uint32_t dwFilterTag;
    uint32_t fdwFilter;
    uint32_t dwReserved[5];
};

struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
{
    _LARGE_INTEGER TotalUserTime;
    _LARGE_INTEGER TotalKernelTime;
    _LARGE_INTEGER ThisPeriodTotalUserTime;
    _LARGE_INTEGER ThisPeriodTotalKernelTime;
    uint32_t TotalPageFaultCount;
    uint32_t TotalProcesses;
    uint32_t ActiveProcesses;
    uint32_t TotalTerminatedProcesses;
};

struct tagMCI_OVLY_OPEN_PARMSW
{
    uint32_t dwCallback;
    uint32_t wDeviceID;
    uint32_t* lpstrDeviceType;
    uint32_t* lpstrElementName;
    uint32_t* lpstrAlias;
    uint32_t dwStyle;
    HWND* hWndParent;
};

struct _GET_MEDIA_TYPES
{
    uint32_t DeviceType;
    uint32_t MediaInfoCount;
    _DEVICE_MEDIA_INFO MediaInfo[1];
};

struct _PRINTER_INFO_9W
{
    _devicemodeW* pDevMode;
};

struct _COMSTAT
{
    uint32_t fCtsHold : 1;
    uint32_t fDsrHold : 1;
    uint32_t fRlsdHold : 1;
    uint32_t fXoffHold : 1;
    uint32_t fXoffSent : 1;
    uint32_t fEof : 1;
    uint32_t fTxim : 1;
    uint32_t fReserved : 25;
    uint32_t cbInQue;
    uint32_t cbOutQue;
};

struct IRunnableObject : IUnknown
{
    HRESULT __stdcall GetRunningClass();
    HRESULT __stdcall Run();
    int32_t __stdcall IsRunning();
    HRESULT __stdcall LockRunning();
    HRESULT __stdcall SetContainedObject();
    void IRunnableObject();
};

union _LARGE_INTEGER
{
    uint32_t LowPart;
    int32_t HighPart;
    _LARGE_INTEGER::__unnamed u;
    int32_t QuadPart;
};

struct _DOC_INFO_2A
{
    char* pDocName;
    char* pOutputFile;
    char* pDatatype;
    uint32_t dwMode;
    uint32_t JobId;
};

struct _PROPSHEETPAGEA_V1
{
    uint32_t dwSize;
    uint32_t dwFlags;
    HINSTANCE__* hInstance;
    char* pszTemplate;
    DLGTEMPLATE* pResource;
    HICON__* hIcon;
    char* pszIcon;
    char* pszTitle;
    int32_t* pfnDlgProc;
    int32_t lParam;
    uint32_t* pfnCallback;
    uint32_t* pcRefParent;
};

struct creative_fastspeech8format_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wRevision;
};

struct _FILE_PREFETCH
{
    uint32_t Type;
    uint32_t Count;
    uint32_t Prefetch[1];
};

struct tagPANOSE
{
    uint32_t bFamilyType;
    uint32_t bSerifStyle;
    uint32_t bWeight;
    uint32_t bProportion;
    uint32_t bContrast;
    uint32_t bStrokeVariation;
    uint32_t bArmStyle;
    uint32_t bLetterform;
    uint32_t bMidline;
    uint32_t bXHeight;
};

struct _ENUM_SERVICE_STATUS_PROCESSW
{
    uint32_t* lpServiceName;
    uint32_t* lpDisplayName;
    _SERVICE_STATUS_PROCESS ServiceStatusProcess;
};

struct CoreGsTex2
{
    uint32_t pad00 : 20;
    uint32_t PSM : 6;
    uint32_t pad26 : 11;
    uint32_t CBP : 14;
    uint32_t CPSM : 4;
    uint32_t CSM : 1;
    uint32_t CSA : 5;
    uint32_t CLD : 3;
};

struct tagMIXERCONTROLDETAILS_LISTTEXTW
{
    uint32_t dwParam1;
    uint32_t dwParam2;
    uint32_t szName[64];
};

struct tagIMEMENUITEMINFOA
{
    uint32_t cbSize;
    uint32_t fType;
    uint32_t fState;
    uint32_t wID;
    HBITMAP__* hbmpChecked;
    HBITMAP__* hbmpUnchecked;
    uint32_t dwItemData;
    char szString[80];
    HBITMAP__* hbmpItem;
};

struct tagKERNINGPAIR
{
    uint32_t wFirst;
    uint32_t wSecond;
    int32_t iKernAmount;
};

struct tagCOLORMATCHTOTARGET
{
    tagEMR emr;
    uint32_t dwAction;
    uint32_t dwFlags;
    uint32_t cbName;
    uint32_t cbData;
    uint32_t Data[1];
};

struct _wireSAFEARR_UNKNOWN
{
    uint32_t Size;
    IUnknown** apUnknown;
};

struct CoreAudio
{
    enum CoreAudioType
    {
        CORE_CORE_AUDIO,
        CORE_AUDIO_NONE,
    };

    static CoreAudio::CoreAudioType m_eAudioType;
    static char m_lpcAppName[256];
    static CoreHashTable m_oSoundDatabase;
    static int32_t m_iUseCD;
    static CAL1_API* m_CoreAudio;
    static char* m_AudioHeap;
    static char* m_SampleItemData;
    static CoreMemory* m_CoreMemory;
    static CoreHash m_SpeechHash;
    static CoreHash m_MusicHash;
    static CoreHash m_NextMusicHash;
    static bool m_FadeOut;
    static bool m_FadeIn;
    static bool m_demo;
    static uint32_t m_FadeFrameCount;
    static uint32_t m_FadeValue;
    static uint32_t m_MusicVolume;
    static COREAUDIO_MUSIC_STATE m_MusicState;
    static COREAUDIO_MUSIC_STATE m_NextMusicState;
    static uint32_t m_MusicDuckPercentage;
    static uint32_t m_LastMenuMusicVolume;
    static uint32_t m_LastMenuSFXVolume;
    static uint32_t m_LastMenuSpeechVolume;
    static uint32_t m_AudioMemSize;
    static uint32_t m_AudioSRAMSize;
    static float m_MenuMusicVolume;
    static float m_MenuSFXVolume;
    static float m_MenuSpeechVolume;
    static float m_MenuMusicVolumeScaled;
    static bool m_MusicVolumeChanged;
    static CoreHashTable m_SurfaceTypeIndex;
    static CoreHash m_SurfaceTypeStringHashIndex[256];
    static uint32_t m_LastSurfaceType;
    static CoreHashTable m_AdditionalEventTable;
    static CoreAudio_SpeechQueue m_SpeechQueue;

    // TODO vtable

    uint32_t GetVersion();
    void Construct(CoreMemory* lpoMemory, CoreHash i_audioType, char* lpcAppName, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize);
    void Init();
    void Reset();
    void Pause();
    void UnPause();
    void StopAll();
    void DisconnectHardware();
    void ReconnectHardware();
    bool IsHardwareConnected();
    void SetDemo();
    bool LoadScene();
    bool LoadLevel(char* lpcLevelName, char* lpcSceneName, uint32_t languageMask);
    bool UnloadLevel();
    bool LoadLevelScene(char* lpcSceneName, uint32_t languageMask);
    bool UnloadLevelScene();
    bool MarkArea();
    bool UnmarkArea();
    void Destruct(CoreMemory* lpoMemory);
    void Update();
    void UpdateMusic(CoreWorldUpdateStruct* lpoWorldUpdateStruct);
    bool PlayAnimatingSample(CoreHash i_ModelName, CoreHash i_hash, CoreVector i_position);
    bool PlaySound2D(CoreHash hash, int32_t iPercentage, uint32_t iGroupMask);
    bool PlaySound2DParam(CoreHash hash, int32_t iPercentage, uint32_t iIndex, uint32_t iGroupMask);
    bool PlaySound3D(CoreHash hash, CoreVector& vPosition, int32_t iPercentage, uint32_t iGroupMask);
    bool PlaySound3DParam();
    bool PlaySound3DWobble();
    bool UpdateSound3D(CoreHash hash, CoreVector& vPosition);
    bool UpdateSoundVolume(CoreHash hash, int32_t iPercentage);
    bool StopSound(CoreHash hash);
    bool PlaySpeech(CoreHash hash, int32_t iPercentage, uint32_t iGroupMask);
    bool PlaySpeechParam(CoreHash hash, int32_t iPercentage, uint32_t param, uint32_t iGroupMask);
    bool StopSpeech();
    bool AddSpeechToQueue();
    bool ProcessSpeechQueue();
    bool ClearSpeechQueue();
    bool PlayMusic(CoreHash i_Hash);
    bool StopMusic();
    void ResetMusic();
    bool DuckMusic(uint32_t i_Percentage);
    bool UnDuckMusic();
    bool DuckSFX(uint32_t i_Percentage);
    bool UnDuckSFX();
    bool IsSoundPlaying(uint32_t i_ObjectID, uint32_t i_ObjectInstance, uint32_t iEventID);
    void SetMasterVolume(float factor);
    void ReadSampleTable();
    void DoDebug(CoreDebugInput* i_input, CoreWorldUpdateStruct* i_worldUpdateStruct);
    void CreateAudioLocator();
    void SetGlobalReverb(CoreHash reverbHash);
    void ResetAudioData();
    void SetAudioData_DataMask();
    void SetAudioData_3D(bool is3D);
    void SetAudioData_CameraRelative();
    void SetAudioData_FrequencyOffset(float freqOffset);
    void SetAudiOData_FRPan();
    void SetAudioData_GroupMask();
    void SetAudioData_ListenerIndex();
    void SetAudioData_LRPan();
    void SetAudioData_MaxDist(float maxDist);
    void SetAudioData_MinDist(float minDist);
    void SetAudioData_Occlusion();
    void SetAudioData_PlaybackPreference();
    void SetAudioData_Point(CoreVector point);
    void SetAudioData_Velocity();
    void SetAudioData_VolumeOffset(uint32_t volumeOffset);
    void StartObjectEvent(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash);
    void StartObjectEventParam(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash, uint32_t i_Index);
    void UpdateObjectEvent(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash);
    void TriggerObjectEvent(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash);
    void StopObjectEvent(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash);
    void StartEvent(CoreHash i_EventHash, uint32_t i_EventInstance);
    void StartEventParam(CoreHash i_EventHash, uint32_t i_EventInstance, uint32_t i_Param);
    void UpdateEvent();
    void TriggerEvent(CoreHash i_EventHash, uint32_t i_EventInstance);
    void StopEvent(CoreHash i_EventHash, uint32_t i_EventInstance);
    void UpdateObject();
    bool CreateInstance(CoreHash i_ObjectHash, uint32_t& o_instance);
    float GetMenuMusicVolume();
    float GetMenuSpeechVolume();
    float GetMenuSFXVolume();
    void SetMenuMusicVolume(float musicVolume);
    void SetMenuSpeechVolume();
    void SetMenuSFXVolume();
    float GetMenuMusicVolumeScaled();
    bool AddSurfaceType(CoreHash hash, uint32_t index);
    uint32_t GetSurfaceTypeIndex(CoreHash hash);
    bool AddAdditionalEvent(CoreHash hash, CoreHash addHash);
    uint32_t GetAdditionalEvent(CoreHash hash);
    void DebugShowAudioStats();
    void SetGroupVolume();
    uint32_t GetGroupVolume();
    void GetHeapMemoryStats(int32_t& o_memUsed, int32_t& o_memFree, int32_t& o_memTotal);
    void GetSRAMMemoryStats(int32_t& o_memUsed, int32_t& o_memFree, int32_t& o_memTotal);
    void CoreAudio();
    void ~CoreAudio();
    void YouCannotInstanceThisClass();
    void RegisterSound();
    bool FindSound();
    bool InitPlatformSpecific();
    bool LoadScenePlatformSpecific();
    bool LoadLevelPlatformSpecific(char* lpcLevelName, char* lpcSceneName, uint32_t languageMask);
    bool CreateDevice(CoreMemory* i_memory, uint32_t i_audioMemSize, uint32_t i_audioSRAMSize);
};

union _ULARGE_INTEGER
{
    uint32_t LowPart;
    uint32_t HighPart;
    _ULARGE_INTEGER::__unnamed u;
    uint32_t QuadPart;
};

struct _CMSG_SIGNER_ENCODE_INFO
{
    uint32_t cbSize;
    _CERT_INFO* pCertInfo;
    uint32_t hCryptProv;
    uint32_t dwKeySpec;
    _CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    void* pvHashAuxInfo;
    uint32_t cAuthAttr;
    _CRYPT_ATTRIBUTE* rgAuthAttr;
    uint32_t cUnauthAttr;
    _CRYPT_ATTRIBUTE* rgUnauthAttr;
};

struct tagCHOOSECOLORW
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HWND* hInstance;
    uint32_t rgbResult;
    uint32_t* lpCustColors;
    uint32_t Flags;
    int32_t lCustData;
    uint32_t* lpfnHook;
    uint32_t* lpTemplateName;
};

struct tagPRINTPAGERANGE
{
    uint32_t nFromPage;
    uint32_t nToPage;
};

struct tagEMRCREATEPEN
{
    tagEMR emr;
    uint32_t ihPen;
    tagLOGPEN lopn;
};

struct _CERT_DH_PARAMETERS
{
    _CRYPTOAPI_BLOB p;
    _CRYPTOAPI_BLOB g;
};

struct _MIDL_STUBLESS_PROXY_INFO
{
    _MIDL_STUB_DESC* pStubDesc;
    uint32_t* ProcFormatString;
    uint32_t* FormatStringOffset;
    _RPC_SYNTAX_IDENTIFIER* pTransferSyntax;
    uint32_t nCount;
    _MIDL_SYNTAX_INFO* pSyntaxInfo;
};

struct _GET_CHANGER_PARAMETERS
{
    uint32_t Size;
    uint32_t NumberTransportElements;
    uint32_t NumberStorageElements;
    uint32_t NumberCleanerSlots;
    uint32_t NumberIEElements;
    uint32_t NumberDataTransferElements;
    uint32_t NumberOfDoors;
    uint32_t FirstSlotNumber;
    uint32_t FirstDriveNumber;
    uint32_t FirstTransportNumber;
    uint32_t FirstIEPortNumber;
    uint32_t FirstCleanerSlotAddress;
    uint32_t MagazineSize;
    uint32_t DriveCleanTimeout;
    uint32_t Features0;
    uint32_t Features1;
    uint32_t MoveFromTransport;
    uint32_t MoveFromSlot;
    uint32_t MoveFromIePort;
    uint32_t MoveFromDrive;
    uint32_t ExchangeFromTransport;
    uint32_t ExchangeFromSlot;
    uint32_t ExchangeFromIePort;
    uint32_t ExchangeFromDrive;
    uint32_t LockUnlockCapabilities;
    uint32_t PositionCapabilities;
    uint32_t Reserved1[2];
    uint32_t Reserved2[2];
};

struct tagMCI_INFO_PARMSW
{
    uint32_t dwCallback;
    uint32_t* lpstrReturn;
    uint32_t dwRetSize;
};

struct ISequentialStream : IUnknown
{
    HRESULT __stdcall Read();
    HRESULT __stdcall Write();
    void ISequentialStream();
};

struct _KEY_EVENT_RECORD
{
    int32_t bKeyDown;
    uint32_t wRepeatCount;
    uint32_t wVirtualKeyCode;
    uint32_t wVirtualScanCode;
    _KEY_EVENT_RECORD::__unnamed uChar;
    uint32_t dwControlKeyState;
};

struct _PROPSHEETPAGEW_V1
{
    uint32_t dwSize;
    uint32_t dwFlags;
    HINSTANCE__* hInstance;
    uint32_t* pszTemplate;
    DLGTEMPLATE* pResource;
    HICON__* hIcon;
    uint32_t* pszIcon;
    uint32_t* pszTitle;
    int32_t* pfnDlgProc;
    int32_t lParam;
    uint32_t* pfnCallback;
    uint32_t* pcRefParent;
};

struct IXMLDOMDocumentType : IXMLDOMNode
{
    HRESULT __stdcall get_name();
    HRESULT __stdcall get_entities();
    HRESULT __stdcall get_notations();
    void IXMLDOMDocumentType();
};

struct _RPC_SECURITY_QOS
{
    uint32_t Version;
    uint32_t Capabilities;
    uint32_t IdentityTracking;
    uint32_t ImpersonationType;
};

struct _SEC_WINNT_AUTH_IDENTITY_A
{
    uint32_t* User;
    uint32_t UserLength;
    uint32_t* Domain;
    uint32_t DomainLength;
    uint32_t* Password;
    uint32_t PasswordLength;
    uint32_t Flags;
};

struct _CRYPT_ATTRIBUTE
{
    char* pszObjId;
    uint32_t cValue;
    _CRYPTOAPI_BLOB* rgValue;
};

struct _PRINTPROCESSOR_CAPS_1
{
    uint32_t dwLevel;
    uint32_t dwNupOptions;
    uint32_t dwPageOrderFlags;
    uint32_t dwNumberOfCopies;
};

struct tagCLIENTCREATESTRUCT
{
    void* hWindowMenu;
    uint32_t idFirstChild;
};

struct HMIDISTRM__
{
    int32_t unused;
};

struct CoreWeaponMarker
{
    CoreWeaponMarkerType eWeaponType;
    CoreCombatMarkerGeometryType eGeometryType;
    CoreVector vPoint[2];
    float fRadius;
    float Power;
    float fFallOff;
    float fFieldOfFire;
    uint32_t uiBoneHash;
    bool bActive;
    CoreVector vTransformedPoint[2];
    CoreVector vLastTransformedPoint[2];
    CoreVector vDirection;
    float fSpeed;
    float fTransformedRadius;
    int32_t iLastValid;

    void CoreWeaponMarker();
};

struct _OBJECTID
{
    _GUID Lineage;
    uint32_t Uniquifier;
};

struct _SYSTEM_ALARM_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t SidStart;
};

struct IMAGE_LOAD_CONFIG_DIRECTORY64
{
    uint32_t Size;
    uint32_t TimeDateStamp;
    uint32_t MajorVersion;
    uint32_t MinorVersion;
    uint32_t GlobalFlagsClear;
    uint32_t GlobalFlagsSet;
    uint32_t CriticalSectionDefaultTimeout;
    uint32_t DeCommitFreeBlockThreshold;
    uint32_t DeCommitTotalFreeThreshold;
    uint32_t LockPrefixTable;
    uint32_t MaximumAllocationSize;
    uint32_t VirtualMemoryThreshold;
    uint32_t ProcessAffinityMask;
    uint32_t ProcessHeapFlags;
    uint32_t CSDVersion;
    uint32_t Reserved1;
    uint32_t EditList;
    uint32_t SecurityCookie;
    uint32_t SEHandlerTable;
    uint32_t SEHandlerCount;
};

struct tagEMRSETPIXELV
{
    tagEMR emr;
    _POINTL ptlPixel;
    uint32_t crColor;
};

struct _RPC_SERVER_INTERFACE
{
    uint32_t Length;
    _RPC_SYNTAX_IDENTIFIER InterfaceId;
    _RPC_SYNTAX_IDENTIFIER TransferSyntax;
    RPC_DISPATCH_TABLE* DispatchTable;
    uint32_t RpcProtseqEndpointCount;
    _RPC_PROTSEQ_ENDPOINT* RpcProtseqEndpoint;
    void* DefaultManagerEpv;
    void* InterpreterInfo;
    uint32_t Flags;
};

struct _NT_TIB64
{
    uint32_t ExceptionList;
    uint32_t StackBase;
    uint32_t StackLimit;
    uint32_t SubSystemTib;
    uint32_t FiberData;
    uint32_t Version;
    uint32_t ArbitraryUserPointer;
    uint32_t Self;
};

struct _ABCFLOAT
{
    float abcfA;
    float abcfB;
    float abcfC;
};

struct tagEMRCREATECOLORSPACE
{
    tagEMR emr;
    uint32_t ihCS;
    tagLOGCOLORSPACEA lcs;
};

struct _numberfmtW
{
    uint32_t NumDigits;
    uint32_t LeadingZero;
    uint32_t Grouping;
    uint32_t* lpDecimalSep;
    uint32_t* lpThousandSep;
    uint32_t NegativeOrder;
};

struct _CRYPT_PKCS8_EXPORT_PARAMS
{
    uint32_t hCryptProv;
    uint32_t dwKeySpec;
    char* pszPrivateKeyObjId;
    int32_t* pEncryptPrivateKeyFunc;
    void* pVoidEncryptFunc;
};

struct _DISPLAY_DEVICEW
{
    uint32_t cb;
    uint32_t DeviceName[32];
    uint32_t DeviceString[128];
    uint32_t StateFlags;
    uint32_t DeviceID[128];
    uint32_t DeviceKey[128];
};

struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
{
    uint32_t BeginAddress;
    uint32_t EndAddress;
    uint32_t ExceptionHandler;
    uint32_t HandlerData;
    uint32_t PrologEndAddress;
};

struct _CERT_NAME_VALUE
{
    uint32_t dwValueType;
    _CRYPTOAPI_BLOB Value;
};

struct _wfinddatai64_t
{
    uint32_t attrib;
    int32_t time_create;
    int32_t time_access;
    int32_t time_write;
    int32_t size;
    wchar_t name[260];
};

struct CoreVariableStore
{
    int32_t m_numberOfVariables;
    int32_t m_maxVariables;
    CoreVariable* m_variables;

    void CoreVariableStore();
    void ~CoreVariableStore();
    void Init(CoreMemory* io_memory, int32_t i_maxVariables);
    void Destruct(CoreMemory* io_memory);
    int32_t GetDebugNumVariables();
    CoreVariable* GetDebugVariable(int32_t i_index);
    void Reset();
    CoreVariable* Allocate(CoreHash i_owner, int32_t i_numRequired);
    void Remove(CoreVariable* i_firstVariable, int32_t i_variableCount);
    CoreVariable* GetFirstVariable();
    bool IsFirstVariable(CoreHash i_owner, CoreVariable* i_predictedFirst);
    CoreVariable* FindVariable(CoreHash i_owner, CoreHash i_name);
    int32_t BinarySearch(int32_t i_start, int32_t i_end, uint32_t i_searchValue);
    int32_t GetFirstVariableIndexOrAbove(CoreHash i_owner);
    int32_t GetFirstVariableIndex(CoreHash i_owner);
    int32_t FindVariableIndex(CoreHash i_owner, CoreHash i_name);
    void MoveBlock(int32_t i_start, int32_t i_distance);
};

struct _TAPE_GET_MEDIA_PARAMETERS
{
    _LARGE_INTEGER Capacity;
    _LARGE_INTEGER Remaining;
    uint32_t BlockSize;
    uint32_t PartitionCount;
    uint32_t WriteProtected;
};

struct tagMCI_LOAD_PARMSW
{
    uint32_t dwCallback;
    uint32_t* lpfilename;
};

struct _PROV_ENUMALGS
{
    uint32_t aiAlgid;
    uint32_t dwBitLen;
    uint32_t dwNameLen;
    char szName[20];
};

struct IAsyncManager : IUnknown
{
    HRESULT __stdcall CompleteCall();
    HRESULT __stdcall GetCallContext();
    HRESULT __stdcall GetState();
    void IAsyncManager();
};

struct IReleaseMarshalBuffers : IUnknown
{
    HRESULT __stdcall ReleaseMarshalBuffer();
    void IReleaseMarshalBuffers();
};

struct CoreVolatileMemory : CoreMemory
{
    CoreMemory* m_fallBackAllocator;
    uint32_t m_fallBackActiveAllocations;
    uint32_t m_fallBackTotalAllocations;
    uint32_t m_fallBackTotalAllocated;
    uint32_t m_fallBackLargestAllocation;
    uint32_t m_volatileActiveAllocations;
    uint32_t m_volatileTotalAllocations;
    uint32_t m_volatileTotalAllocated;
    uint32_t m_volatileLargestAllocation;
    uint32_t* m_volatileMemoryStart;
    uint32_t* m_volatileMemoryEnd;
    uint32_t* m_volatileMemoryWhere;
    uint32_t m_volatileMemorySize;
    uint32_t m_volatileMemoryFree;
    int32_t m_volatileMemoryLockCounter;
    uint32_t m_largestAllocation;
    uint32_t m_totalAllocations;
    uint32_t m_totalAllocated;

    void CoreVolatileMemory();
    void ~CoreVolatileMemory();
    void Construct();
    void Destruct();
    void* Alloc();
    void* FallBackAlloc();
    void Free();
    int32_t GetMemoryAvailable();
    int32_t GetMemoryUsed();
    char* GetDebugTypeName();
    void SetFallBackAllocator();
    void ClearFallBackAllocator();
    bool Lock();
    void Unlock();
    void ForceUnlock();
    uint32_t GetTotalAllocated();
    uint32_t GetTotalAllocations();
    uint32_t GetLargestAllocation();
    uint32_t GetVolatileTotalAllocated();
    uint32_t GetVolatileTotalAllocations();
    uint32_t GetVolatileLargestAllocation();
    uint32_t GetFallBackTotalAllocated();
    uint32_t GetFallBackTotalAllocations();
    uint32_t GetFallBackLargestAllocation();
    void ClearVolatileMemoryVariables();
    void ClearVariables();
};

struct _CRL_ISSUING_DIST_POINT
{
    _CRL_DIST_POINT_NAME DistPointName;
    int32_t fOnlyContainsUserCerts;
    int32_t fOnlyContainsCACerts;
    _CRYPT_BIT_BLOB OnlySomeReasonFlags;
    int32_t fIndirectCRL;
};

struct tagSTATDATA
{
    tagFORMATETC formatetc;
    uint32_t advf;
    IAdviseSink* pAdvSink;
    uint32_t dwConnection;
};

struct fmtowns_snd_waveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wRevision;
};

struct CoreConfigFile
{
    // TODO vtable

    int32_t ParseConfigFile();
    char* FindStartOfNextLine();
    char* EatWhiteSpace();
    char* FindNextChar();
    char* FindNextToken();
    void CoreConfigFile();
    void ~CoreConfigFile();
    void YouCannotInstanceThisClass();
    void CopyString();
};

struct _IMAGE_BOUND_FORWARDER_REF
{
    uint32_t TimeDateStamp;
    uint32_t OffsetModuleName;
    uint32_t Reserved;
};

struct tagCRGB
{
    uint32_t bRed;
    uint32_t bGreen;
    uint32_t bBlue;
    uint32_t bExtra;
};

struct _CRYPT_ENROLLMENT_NAME_VALUE_PAIR
{
    uint32_t* pwszName;
    uint32_t* pwszValue;
};

struct _DSBCAPS
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwBufferBytes;
    uint32_t dwUnlockTransferRate;
    uint32_t dwPlayCpuOverhead;
};

struct CoreRenderTextSettings
{
    enum JUSTIFY_X_TAG
    {
        JustifyX_Left = 1,
        JustifyX_Center = 2,
        JustifyX_Right = 4,
        __JustifyX_Mask = 7,
    };

    enum JUSTIFY_X
    {
        JustifyX_Left = 1,
        JustifyX_Center = 2,
        JustifyX_Right = 4,
        __JustifyX_Mask = 7,
    };

    enum JUSTIFY_Y_TAG
    {
        JustifyY_Top = 16,
        JustifyY_Center = 32,
        JustifyY_Bottom = 64,
        __JustifyY_Mask = 112,
    };

    enum JUSTIFY_Y
    {
        JustifyY_Top = 16,
        JustifyY_Center = 32,
        JustifyY_Bottom = 64,
        __JustifyY_Mask = 112,
    };

    enum JUSTIFY_TAG
    {
        Justify_LeftTop = 17,
        Justify_LeftCenter = 33,
        Justify_LeftBottom = 65,
        Justify_CenterTop = 18,
        Justify_Center = 34,
        Justify_CenterBottom = 66,
        Justify_RightTop = 20,
        Justify_RightCenter = 36,
        Justify_RightBottom = 68,
        Justify_TopLeft = 17,
        Justify_CenterLeft = 33,
        Justify_BottomLeft = 65,
        Justify_TopCenter = 18,
        Justify_BottomCenter = 66,
        Justify_TopRight = 20,
        Justify_CenterRight = 36,
        Justify_BottomRight = 68,
        __Justify_Mask = 119,
    };

    enum JUSTIFY
    {
        Justify_LeftTop = 17,
        Justify_LeftCenter = 33,
        Justify_LeftBottom = 65,
        Justify_CenterTop = 18,
        Justify_Center = 34,
        Justify_CenterBottom = 66,
        Justify_RightTop = 20,
        Justify_RightCenter = 36,
        Justify_RightBottom = 68,
        Justify_TopLeft = 17,
        Justify_CenterLeft = 33,
        Justify_BottomLeft = 65,
        Justify_TopCenter = 18,
        Justify_BottomCenter = 66,
        Justify_TopRight = 20,
        Justify_CenterRight = 36,
        Justify_BottomRight = 68,
        __Justify_Mask = 119,
    };

    enum DROP_SHADOW_TAG
    {
        NoDropShadow,
        DropShadow,
        DropShadow4,
        DropShadow8,
    };

    enum DROP_SHADOW
    {
        NoDropShadow,
        DropShadow,
        DropShadow4,
        DropShadow8,
    };

    CoreRGBA TextRGBA;
    CoreRGBA DropShadowRGBA;
    float m_scaleX;
    float m_scaleY;
    float m_baseWidth;
    float m_baseHeight;
    CoreRenderTextSettings::JUSTIFY_TAG m_justify;
    bool m_fixedSize;
    CoreRenderTextSettings::DROP_SHADOW_TAG m_dropShadow;
    float m_dropShadowOffsetX;
    float m_dropShadowOffsetY;
    float m_extraSpacingX;
    float m_extraSpacingY;
    float m_wordWrapWidth;

    void CoreRenderTextSettings();
    void SetScaleX();
    float GetScaleX();
    void SetScaleY();
    float GetScaleY();
    void SetScales();
    void SetBaseWidth();
    float GetBaseWidth();
    void SetBaseHeight();
    float GetBaseHeight();
    void SetJustify();
    void SetJustifyX();
    void SetJustifyY();
    CoreRenderTextSettings::JUSTIFY_TAG GetJustify();
    CoreRenderTextSettings::JUSTIFY_X_TAG GetJustifyX();
    CoreRenderTextSettings::JUSTIFY_Y_TAG GetJustifyY();
    float GetJustifyMultiplierX();
    float GetJustifyMultiplierY();
    void SetDropShadow();
    void CancelDropShadow();
    CoreRenderTextSettings::DROP_SHADOW_TAG GetDrawDropShadow();
    float GetDropShadowOffsetX();
    float GetDropShadowOffsetY();
    void SetExtraSpacing();
    void SetExtraSpacingX();
    void SetExtraSpacingY();
    float GetExtraSpacingX();
    float GetExtraSpacingY();
    void SetWordWrapWidth();
    float GetWordWrapWidth();
    void SetFixedSize();
    void CancelFixedSize();
    bool IsFixedSize();
};

struct tagDIBSECTION
{
    tagBITMAP dsBm;
    tagBITMAPINFOHEADER dsBmih;
    uint32_t dsBitfields[3];
    void* dshSection;
    uint32_t dsOffset;
};

struct tagRemHBITMAP
{
    uint32_t cbData;
    uint32_t data[1];
};

struct _WIN32_STREAM_ID
{
    uint32_t dwStreamId;
    uint32_t dwStreamAttributes;
    _LARGE_INTEGER Size;
    uint32_t dwStreamNameSize;
    uint32_t cStreamName[1];
};

struct tagENUMLOGFONTEXW
{
    tagLOGFONTW elfLogFont;
    uint32_t elfFullName[64];
    uint32_t elfStyle[32];
    uint32_t elfScript[32];
};

struct _devicemodeW
{
    uint32_t dmDeviceName[32];
    uint32_t dmSpecVersion;
    uint32_t dmDriverVersion;
    uint32_t dmSize;
    uint32_t dmDriverExtra;
    uint32_t dmFields;
    int32_t dmOrientation;
    int32_t dmPaperSize;
    int32_t dmPaperLength;
    int32_t dmPaperWidth;
    int32_t dmScale;
    int32_t dmCopies;
    int32_t dmDefaultSource;
    int32_t dmPrintQuality;
    _POINTL dmPosition;
    uint32_t dmDisplayOrientation;
    uint32_t dmDisplayFixedOutput;
    int32_t dmColor;
    int32_t dmDuplex;
    int32_t dmYResolution;
    int32_t dmTTOption;
    int32_t dmCollate;
    uint32_t dmFormName[32];
    uint32_t dmLogPixels;
    uint32_t dmBitsPerPel;
    uint32_t dmPelsWidth;
    uint32_t dmPelsHeight;
    uint32_t dmDisplayFlags;
    uint32_t dmNup;
    uint32_t dmDisplayFrequency;
    uint32_t dmICMMethod;
    uint32_t dmICMIntent;
    uint32_t dmMediaType;
    uint32_t dmDitherType;
    uint32_t dmReserved1;
    uint32_t dmReserved2;
    uint32_t dmPanningWidth;
    uint32_t dmPanningHeight;
};

struct _CTL_USAGE
{
    uint32_t cUsageIdentifier;
    char** rgpszUsageIdentifier;
};

struct _CMSG_RC2_AUX_INFO
{
    uint32_t cbSize;
    uint32_t dwBitLen;
};

struct _TOKEN_OWNER
{
    void* Owner;
};

struct _CMSG_RC4_AUX_INFO
{
    uint32_t cbSize;
    uint32_t dwBitLen;
};

struct _tagRemBINDINFO
{
    uint32_t cbSize;
    uint32_t* szExtraInfo;
    uint32_t grfBindInfoF;
    uint32_t dwBindVerb;
    uint32_t* szCustomVerb;
    uint32_t cbstgmedData;
    uint32_t dwOptions;
    uint32_t dwOptionsFlags;
    uint32_t dwCodePage;
    _REMSECURITY_ATTRIBUTES securityAttributes;
    _GUID iid;
    IUnknown* pUnk;
    uint32_t dwReserved;
};

struct _EVENTSFORLOGFILE
{
    uint32_t ulSize;
    uint32_t szLogicalLogFile[256];
    uint32_t ulNumRecords;
    _EVENTLOGRECORD pEventLogRecords[0];
};

struct IXMLHttpRequest : IDispatch
{
    HRESULT __stdcall open();
    HRESULT __stdcall setRequestHeader();
    HRESULT __stdcall getResponseHeader();
    HRESULT __stdcall getAllResponseHeaders();
    HRESULT __stdcall send();
    HRESULT __stdcall abort();
    HRESULT __stdcall get_status();
    HRESULT __stdcall get_statusText();
    HRESULT __stdcall get_responseXML();
    HRESULT __stdcall get_responseText();
    HRESULT __stdcall get_responseBody();
    HRESULT __stdcall get_responseStream();
    HRESULT __stdcall get_readyState();
    HRESULT __stdcall put_onreadystatechange();
    void IXMLHttpRequest();
};

struct CoreObjectListNode
{
    CoreObject* objectPtr;
    CoreObjectListNode* nextNode;
};

struct _COAUTHINFO
{
    uint32_t dwAuthnSvc;
    uint32_t dwAuthzSvc;
    uint32_t* pwszServerPrincName;
    uint32_t dwAuthnLevel;
    uint32_t dwImpersonationLevel;
    _COAUTHIDENTITY* pAuthIdentityData;
    uint32_t dwCapabilities;
};

struct CoreNodeChainGroup
{
    CoreNodeChain m_nodeChains[11];

    CoreNodeChain& GetChain();
    void CoreNodeChainGroup();
    void ~CoreNodeChainGroup();
};

struct _RPC_ASYNC_STATE
{
    uint32_t Size;
    uint32_t Signature;
    int32_t Lock;
    uint32_t Flags;
    void* StubInfo;
    void* UserInfo;
    void* RuntimeInfo;
    _RPC_ASYNC_EVENT Event;
    _RPC_NOTIFICATION_TYPES NotificationType;
    _RPC_ASYNC_STATE::__unnamed u;
    int32_t Reserved[4];
};

struct _OFNOTIFYA
{
    tagNMHDR hdr;
    tagOFNA* lpOFN;
    char* pszFile;
};

struct CorePhysicsVert
{
    CoreVector m_curPos;
    CoreVector m_oldPos;
    CoreVector m_lagPos;
    CoreVector m_relPos;

    void CorePhysicsVert();
};

struct CAL0_File
{
    char m_FilePath[260];
    bool m_FileOpen;
    uint32_t m_FileHandle;
    static uint32_t m_NumOpenRequests;
    static uint32_t m_NumCloseRequests;

    // TODO vtable

    void CAL0_File();
    void ~CAL0_File();
    CAAudioError Open(char* i_filePath, CAL0_FILE_ACCESS i_accessType, bool lockToUser);
    CAAudioError Reopen(CAL0_FILE_ACCESS i_accessType);
    CAAudioError Read(uint32_t* o_destination, uint32_t i_numBytes, uint32_t& o_BytesRead);
    CAAudioError Seek(int32_t i_offset, CAL0_FILE_SEEK i_seekType);
    CAAudioError Write(uint32_t* i_source, uint32_t i_numBytes);
    CAAudioError Close();
    uint32_t GetCursorPosition();
    uint32_t GetFileLength();
    bool IsFileOpen();
    char* GetFilePath();
    CAAudioError Delete();
    CAAudioError CopyDataFromFile();
    CAAudioError Write_uint32();
    CAAudioError Write_int32();
    CAAudioError Write_uint16();
    CAAudioError Write_int16();
    CAAudioError Write_uint8();
    CAAudioError Write_int8();
    CAAudioError Write_fixed();
    CAAudioError Write_fixedhp();
    uint32_t Read_uint32();
    int32_t Read_int32();
    uint32_t Read_uint16();
    int32_t Read_int16();
    uint32_t Read_uint8();
    int32_t Read_int8();
    ca_floatfp Read_fixed();
    ca_floatfp Read_fixedhp();
};

struct _CERT_KEY_USAGE_RESTRICTION_INFO
{
    uint32_t cCertPolicyId;
    _CERT_POLICY_ID* rgCertPolicyId;
    _CRYPT_BIT_BLOB RestrictedKeyUsage;
};

struct tagLAYERPLANEDESCRIPTOR
{
    uint32_t nSize;
    uint32_t nVersion;
    uint32_t dwFlags;
    uint32_t iPixelType;
    uint32_t cColorBits;
    uint32_t cRedBits;
    uint32_t cRedShift;
    uint32_t cGreenBits;
    uint32_t cGreenShift;
    uint32_t cBlueBits;
    uint32_t cBlueShift;
    uint32_t cAlphaBits;
    uint32_t cAlphaShift;
    uint32_t cAccumBits;
    uint32_t cAccumRedBits;
    uint32_t cAccumGreenBits;
    uint32_t cAccumBlueBits;
    uint32_t cAccumAlphaBits;
    uint32_t cDepthBits;
    uint32_t cStencilBits;
    uint32_t cAuxBuffers;
    uint32_t iLayerPlane;
    uint32_t bReserved;
    uint32_t crTransparent;
};

struct _CONSOLE_CURSOR_INFO
{
    uint32_t dwSize;
    int32_t bVisible;
};

struct CS_STUB_INFO
{
    uint32_t WireCodeset;
    uint32_t DesiredReceivingCodeset;
    void* CSArrayInfo;
};

struct _STARTUPINFOW
{
    uint32_t cb;
    uint32_t* lpReserved;
    uint32_t* lpDesktop;
    uint32_t* lpTitle;
    uint32_t dwX;
    uint32_t dwY;
    uint32_t dwXSize;
    uint32_t dwYSize;
    uint32_t dwXCountChars;
    uint32_t dwYCountChars;
    uint32_t dwFillAttribute;
    uint32_t dwFlags;
    uint32_t wShowWindow;
    uint32_t cbReserved2;
    uint32_t* lpReserved2;
    void* hStdInput;
    void* hStdOutput;
    void* hStdError;
};

struct _CRYPT_CSP_PROVIDER
{
    uint32_t dwKeySpec;
    uint32_t* pwszProviderName;
    _CRYPT_BIT_BLOB Signature;
};

struct _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA
{
    uint32_t cbSize;
    uint32_t dwSignerIndex;
    _CRYPTOAPI_BLOB blob;
};

struct CoretGS_BGCOLOR
{
    uint32_t R : 8;
    uint32_t G : 8;
    uint32_t B : 8;
    uint32_t p0 : 8;
    uint32_t p1;
};

struct _ACCESS_DENIED_OBJECT_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t Flags;
    _GUID ObjectType;
    _GUID InheritedObjectType;
    uint32_t SidStart;
};

struct _IMAGE_DOS_HEADER
{
    uint32_t e_magic;
    uint32_t e_cblp;
    uint32_t e_cp;
    uint32_t e_crlc;
    uint32_t e_cparhdr;
    uint32_t e_minalloc;
    uint32_t e_maxalloc;
    uint32_t e_ss;
    uint32_t e_sp;
    uint32_t e_csum;
    uint32_t e_ip;
    uint32_t e_cs;
    uint32_t e_lfarlc;
    uint32_t e_ovno;
    uint32_t e_res[4];
    uint32_t e_oemid;
    uint32_t e_oeminfo;
    uint32_t e_res2[10];
    int32_t e_lfanew;
};

struct _CTL_ANY_SUBJECT_INFO
{
    _CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
    _CRYPTOAPI_BLOB SubjectIdentifier;
};

struct olisbcwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct _DSCAPS
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwMinSecondarySampleRate;
    uint32_t dwMaxSecondarySampleRate;
    uint32_t dwPrimaryBuffers;
    uint32_t dwMaxHwMixingAllBuffers;
    uint32_t dwMaxHwMixingStaticBuffers;
    uint32_t dwMaxHwMixingStreamingBuffers;
    uint32_t dwFreeHwMixingAllBuffers;
    uint32_t dwFreeHwMixingStaticBuffers;
    uint32_t dwFreeHwMixingStreamingBuffers;
    uint32_t dwMaxHw3DAllBuffers;
    uint32_t dwMaxHw3DStaticBuffers;
    uint32_t dwMaxHw3DStreamingBuffers;
    uint32_t dwFreeHw3DAllBuffers;
    uint32_t dwFreeHw3DStaticBuffers;
    uint32_t dwFreeHw3DStreamingBuffers;
    uint32_t dwTotalHwMemBytes;
    uint32_t dwFreeHwMemBytes;
    uint32_t dwMaxContigFreeHwMemBytes;
    uint32_t dwUnlockTransferRateHwBuffers;
    uint32_t dwPlayCpuOverheadSwBuffers;
    uint32_t dwReserved1;
    uint32_t dwReserved2;
};

struct CoreGsHwreg
{
    uint32_t WDATA;
};

struct tagBITMAPCOREHEADER
{
    uint32_t bcSize;
    uint32_t bcWidth;
    uint32_t bcHeight;
    uint32_t bcPlanes;
    uint32_t bcBitCount;
};

struct _PRIVKEYVER3
{
    uint32_t magic;
    uint32_t bitlenP;
    uint32_t bitlenQ;
    uint32_t bitlenJ;
    uint32_t bitlenX;
    _DSSSEED DSSSeed;
};

struct _CRL_DIST_POINTS_INFO
{
    uint32_t cDistPoint;
    _CRL_DIST_POINT* rgDistPoint;
};

struct _SERVICE_STATUS
{
    uint32_t dwServiceType;
    uint32_t dwCurrentState;
    uint32_t dwControlsAccepted;
    uint32_t dwWin32ExitCode;
    uint32_t dwServiceSpecificExitCode;
    uint32_t dwCheckPoint;
    uint32_t dwWaitHint;
};

struct CoreGsFogcol
{
    uint32_t FCR : 8;
    uint32_t FCG : 8;
    uint32_t FCB : 8;
    uint32_t pad24 : 40;
};

struct tagCAI
{
    uint32_t cElems;
    int32_t* pElems;
};

struct CoreError
{
    enum CoreErrorVersion
    {
        VERSION = 9,
    };

    enum CoreErrorTypesEnum
    {
        MESSAGE_BOX = 1,
        LOG,
        PRINT,
        PRINT_ERROR,
        LOG_FILE,
    };

    static uint32_t s_disableFlags;
    static int32_t s_exitReturnCode;
    static CoreStringBuffer<256> s_exeName;
    static int32_t s_fatalErrorException;
    static bool m_fatalErrorEnabled;

    // TODO vtable

    uint32_t GetVersion();
    void FatalError(char* i_string);
    void ErrorBox(char* i_string);
    void Print(char* i_string);
    void PrintError(char* i_string);
    CoreStringBuffer<2048>* GetErrorStringArray();
    bool CreateLog(char* i_name, uint32_t i_colour, uint32_t i_background);
    void Log(CoreHash i_id, char* i_string);
    void EnableLog();
    void DisableLog();
    void LogFile(char* i_fileName, char* i_string);
    void InitLogFile(char* i_fileName);
    void Exit(int32_t i_code);
    int32_t SystemCommand();
    void EnableFatalError();
    void DisableFatalError();
    void EnableErrorBox();
    void DisableErrorBox();
    void EnablePrint();
    void DisablePrint();
    void EnablePrintError();
    void DisablePrintError();
    void EnableLogFile();
    void DisableLogFile();
    int32_t GetExitReturnCode();
    char* GetExeName();
    void SetExeName(char* exeName);
    char* GetSystemErrorString(uint32_t i_error);
    char* GetLastSystemErrorString();
    void Hang();
    void CoreError();
    void YouCannotInstanceThisClass();
    void ~CoreError();
    void RealMessageBox(char* i_string);
    void PrintToConsole(char* i_string);
    void RealFatalError(char* i_string);
    void RealPrint(char* i_string);
};

struct tagPOINT
{
    int32_t x;
    int32_t y;
};

struct HDROP__
{
    int32_t unused;
};

struct _SHORT_SIZEDARR
{
    uint32_t clSize;
    uint32_t* pData;
};

struct digiadpcmmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
};

struct tagEMRSELECTOBJECT
{
    tagEMR emr;
    uint32_t ihObject;
};

struct _userHGLOBAL
{
    union __MIDL_IWinTypes_0003
    {
        int32_t hInproc;
        _FLAGGED_BYTE_BLOB* hRemote;
        int32_t hInproc64;
    };

    int32_t fContext;
    _userHGLOBAL::__MIDL_IWinTypes_0003 u;
};

struct CoreMapFileFunctionClassName
{
    uint32_t m_className_STLU;
};

struct tagHELPINFO
{
    uint32_t cbSize;
    int32_t iContextType;
    int32_t iCtrlId;
    void* hItemHandle;
    uint32_t dwContextId;
    tagPOINT MousePos;
};

struct IRunningObjectTable : IUnknown
{
    HRESULT __stdcall Register();
    HRESULT __stdcall Revoke();
    HRESULT __stdcall IsRunning();
    HRESULT __stdcall GetObjectA();
    HRESULT __stdcall NoteChangeTime();
    HRESULT __stdcall GetTimeOfLastChange();
    HRESULT __stdcall EnumRunning();
    void IRunningObjectTable();
};

struct mpeg1waveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t fwHeadLayer;
    uint32_t dwHeadBitrate;
    uint32_t fwHeadMode;
    uint32_t fwHeadModeExt;
    uint32_t wHeadEmphasis;
    uint32_t fwHeadFlags;
    uint32_t dwPTSLow;
    uint32_t dwPTSHigh;
};

struct tagMCI_ANIM_STEP_PARMS
{
    uint32_t dwCallback;
    uint32_t dwFrames;
};

struct _CERT_ALT_NAME_ENTRY
{
    uint32_t dwAltNameChoice;
    _CERT_OTHER_NAME* pOtherName;
    uint32_t* pwszRfc822Name;
    uint32_t* pwszDNSName;
    _CRYPTOAPI_BLOB DirectoryName;
    uint32_t* pwszURL;
    _CRYPTOAPI_BLOB IPAddress;
    char* pszRegisteredID;
};

struct _CRYPT_PASSWORD_CREDENTIALSA
{
    uint32_t cbSize;
    char* pszUsername;
    char* pszPassword;
};

struct _DRAGINFOW
{
    uint32_t uSize;
    tagPOINT pt;
    int32_t fNC;
    uint32_t* lpFileList;
    uint32_t grfKeyState;
};

struct _PROPSHEETPAGEA
{
    uint32_t dwSize;
    uint32_t dwFlags;
    HINSTANCE__* hInstance;
    char* pszTemplate;
    DLGTEMPLATE* pResource;
    HICON__* hIcon;
    char* pszIcon;
    char* pszTitle;
    int32_t* pfnDlgProc;
    int32_t lParam;
    uint32_t* pfnCallback;
    uint32_t* pcRefParent;
    char* pszHeaderTitle;
    char* pszHeaderSubTitle;
};

struct IErrorLog : IUnknown
{
    HRESULT __stdcall AddError();
    void IErrorLog();
};

struct olioprwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct _IMAGE_DEBUG_MISC
{
    uint32_t DataType;
    uint32_t Length;
    uint32_t Unicode;
    uint32_t Reserved[3];
    uint32_t Data[1];
};

struct CoreCommonDialogStatus
{
    enum CommonDialogStatusTag
    {
        CORE_COMMON_DIALOG_IDLE,
        CORE_COMMON_DIALOG_STARTING,
        CORE_COMMON_DIALOG_ACTIVE,
        CORE_COMMON_DIALOG_STOPPING,
        CORE_COMMON_DIALOG_FAILED = 255,
    };

    enum CommonDialogStatus
    {
        CORE_COMMON_DIALOG_IDLE,
        CORE_COMMON_DIALOG_STARTING,
        CORE_COMMON_DIALOG_ACTIVE,
        CORE_COMMON_DIALOG_STOPPING,
        CORE_COMMON_DIALOG_FAILED = 255,
    };

    static int32_t m_activeCommonDialogCount;
    CoreCommonDialogStatus::CommonDialogStatusTag m_status;

    // TODO vtable

    void CoreCommonDialogStatus();
    void SetIdle();
    void SetFailed();
    void SetStarting();
    void SetActive();
    void SetStopping();
    bool IsIdle();
    bool HasFailed();
    bool IsNotBusy();
    bool IsStarting();
    bool IsActive();
    bool IsStopping();
    bool IsBusy();
    char* GetCommonDialogTitle();
    bool AnyActive();
};

struct tagEMRSETCOLORADJUSTMENT
{
    tagEMR emr;
    tagCOLORADJUSTMENT ColorAdjustment;
};

struct _CERT_NAME_INFO
{
    uint32_t cRDN;
    _CERT_RDN* rgRDN;
};

struct CoreScenePortal
{
    CoreVector m_ptlPos[4];
    CoreVector m_ptlNormal;
    uint32_t m_ptlTarget;
    uint32_t m_ptlAlign[3];

    void CoreScenePortal();
};

struct CoreGsFba
{
    uint32_t FBA : 1;
    uint32_t pad01 : 63;
};

struct _FPO_DATA
{
    uint32_t ulOffStart;
    uint32_t cbProcSize;
    uint32_t cdwLocals;
    uint32_t cdwParams;
    uint32_t cbProlog : 8;
    uint32_t cbRegs : 3;
    uint32_t fHasSEH : 1;
    uint32_t fUseBP : 1;
    uint32_t reserved : 1;
    uint32_t cbFrame : 2;
};

struct tagNONCLIENTMETRICSW
{
    uint32_t cbSize;
    int32_t iBorderWidth;
    int32_t iScrollWidth;
    int32_t iScrollHeight;
    int32_t iCaptionWidth;
    int32_t iCaptionHeight;
    tagLOGFONTW lfCaptionFont;
    int32_t iSmCaptionWidth;
    int32_t iSmCaptionHeight;
    tagLOGFONTW lfSmCaptionFont;
    int32_t iMenuWidth;
    int32_t iMenuHeight;
    tagLOGFONTW lfMenuFont;
    tagLOGFONTW lfStatusFont;
    tagLOGFONTW lfMessageFont;
};

struct _CONSOLE_SCREEN_BUFFER_INFO
{
    _COORD dwSize;
    _COORD dwCursorPosition;
    uint32_t wAttributes;
    _SMALL_RECT srWindow;
    _COORD dwMaximumWindowSize;
};

struct tagCSPLATFORM
{
    uint32_t dwPlatformId;
    uint32_t dwVersionHi;
    uint32_t dwVersionLo;
    uint32_t dwProcessorArch;
};

struct IOleInPlaceUIWindow : IOleWindow
{
    HRESULT __stdcall GetBorder();
    HRESULT __stdcall RequestBorderSpace();
    HRESULT __stdcall SetBorderSpace();
    HRESULT __stdcall SetActiveObject();
    void IOleInPlaceUIWindow();
};

struct _SERVICE_DESCRIPTIONA
{
    char* lpDescription;
};

struct CoreNavigationTriangle
{
    int32_t m_iIndex[3];
};

struct tagEMRPOLYDRAW16
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t cpts;
    tagPOINTS apts[1];
    uint32_t abTypes[1];
};

struct _LONG_SIZEDARR
{
    uint32_t clSize;
    uint32_t* pData;
};

struct CoreMenuComponent
{
    enum CompDirection
    {
        COMP_UP,
        COMP_DOWN,
        COMP_LEFT,
        COMP_RIGHT,
        NUM_DIRECTIONS,
    };

    enum CompFrameTag
    {
        COMP_FRAME_TOP_LEFT,
        COMP_FRAME_TOP,
        COMP_FRAME_TOP_RIGHT,
        COMP_FRAME_RIGHT,
        COMP_FRAME_BOTTOM_RIGHT,
        COMP_FRAME_BOTTOM,
        COMP_FRAME_BOTTOM_LEFT,
        COMP_FRAME_LEFT,
        COMP_FRAME_BACKGROUND,
        COMP_FRAME_BACKGROUND2,
        COMP_FRAME_BACKGROUND3,
        NUM_FRAME_TEXTURES,
    };

    enum CompFrame
    {
        COMP_FRAME_TOP_LEFT,
        COMP_FRAME_TOP,
        COMP_FRAME_TOP_RIGHT,
        COMP_FRAME_RIGHT,
        COMP_FRAME_BOTTOM_RIGHT,
        COMP_FRAME_BOTTOM,
        COMP_FRAME_BOTTOM_LEFT,
        COMP_FRAME_LEFT,
        COMP_FRAME_BACKGROUND,
        COMP_FRAME_BACKGROUND2,
        COMP_FRAME_BACKGROUND3,
        NUM_FRAME_TEXTURES,
    };

    enum CompLeftRightJustify
    {
        COMP_JUST_LEFT = 255,
        COMP_JUST_CENTRE = 0,
        COMP_JUST_RIGHT = 1,
    };

    enum CompTopBottomJustify
    {
        COMP_JUST_TOP = 255,
        COMP_JUST_MIDDLE = 0,
        COMP_JUST_BOTTOM = 1,
    };

    enum CompAnchor
    {
        COMP_ANCHOR_CENTRE,
        COMP_ANCHOR_LEFT = (1 << 0),
        COMP_ANCHOR_RIGHT = (1 << 1),
        COMP_ANCHOR_TOP = (1 << 2),
        COMP_ANCHOR_BOTTOM = (1 << 3),
    };

    enum Flags
    {
        ACTIVE,
        SELECTABLE,
        REQUIRE_CALLBACKS,
        CENTRE_SCALE,
        IS_TEXT,
        HOLD_TIMER_ACTIVE,
        NO_PLATFORM_SCALE,
        IS_FRAME,
        IS_FRAME_FULL_SCREEN,
        IS_TEXT_SPACED_EVENLY,
        FORCE_STD_RENDER,
        FULL_SCREEN,
        LEFT_HALF,
        RIGHT_HALF,
        TOP_HALF,
        BOTTOM_HALF,
        KEEP_ASPECT,
        SCALE_WH,
    };

    static CoreHash DEFAULT_COMPONENT;
    static CoreHash SERVER_LISTBOX_COMPONENT;
    static CoreHash CLIENT_LISTBOX_COMPONENT;
    int32_t m_flags;
    uint32_t m_anchor;
    CoreHash m_name;
    CoreHash m_type;
    CoreMenuComponentSlider m_x;
    CoreMenuComponentSlider m_y;
    CoreMenuComponentSlider m_width;
    CoreMenuComponentSlider m_height;
    CoreMenuComponentSlider m_rotation;
    CoreMenuComponentSlider m_red;
    CoreMenuComponentSlider m_green;
    CoreMenuComponentSlider m_blue;
    CoreMenuComponentSlider m_alpha;
    CoreMenuComponentSlider m_visibility;
    CoreMenuComponentSlider m_u0;
    CoreMenuComponentSlider m_v0;
    CoreMenuComponentSlider m_u1;
    CoreMenuComponentSlider m_v1;
    CoreHash m_texSetID;
    CoreHash m_textureID;
    CoreTextureSet* m_textureSet;
    CoreHash m_fontID;
    CoreFont* m_font;
    CoreHash m_text;
    int32_t m_textMode;
    float m_textWidth;
    float m_textHeight;
    float m_horizontalSplitScreenX;
    float m_horizontalSplitScreenY;
    float m_verticalSplitScreenX;
    float m_verticalSplitScreenY;
    CoreMenuComponent* m_spaceTextEvenlyWithinComponent;
    int32_t m_spaceTextEvenlyItemCount;
    int32_t m_spaceTextEvenlyItemIndex;
    float m_spaceTextEvenlyItemOffset;
    float m_spaceTextEvenlyItemHeight;
    float m_visibilityHoldTime;
    float m_visibilityFadeTime;
    CoreHash m_directions[4];
    CoreHash m_frameTextureIDs[11];
    float m_frameCornerWidths;
    float m_frameCornerHeights;
    float m_frameBackGroundOffsetX;
    float m_frameBackGroundOffsetY;

    // TODO vtable

    void CoreMenuComponent();
    void ~CoreMenuComponent();
    void Init(CoreHash i_name, CoreHash i_type);
    void SetAnchor(int32_t i_horiz, int32_t i_vert);
    void SetXY(float i_x, float i_y, int32_t i_mode, float i_time);
    void SetWH(float i_width, float i_height, int32_t i_mode, float i_time);
    void SetHorizontalSplitScreenXY(float i_x, float i_y);
    void SetVerticalSplitScreenXY(float i_x, float i_y);
    void SetUV0(float i_u0, float i_v0, int32_t i_mode, float i_time);
    void SetUV1(float i_u1, float i_v1, int32_t i_mode, float i_time);
    void SetRGBA(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
    void SetRGBABackground(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
    void SetRGBAHighlight(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
    void SetRGBANormalText(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
    void SetRotation(float i_rotation, int32_t i_mode, float i_time);
    void SetVisibility(float i_visibility, int32_t i_mode, float i_time);
    void SetVisibilityHoldTimer(float i_timeUp, float i_timeHold, float i_timeDown);
    void SetDirection(int32_t i_dir, CoreHash i_comp);
    void SetTextureSet(CoreTextureSet* i_texSet);
    void SetActive();
    void SetSelectable(bool i_selectable);
    void SetRequireCallbacks(bool i_requireCallbacks);
    void SetCentreScale(bool i_centreScale);
    void SetNoPlatformScale(bool i_noPlatformScale);
    void SetForceStdRender();
    void SetFont(CoreFont* i_font);
    void SetText(CoreHash i_text);
    void SpaceTextEvenly(CoreMenuComponent* i_withinComponent, int32_t i_itemCount, int32_t i_itemIndex, float i_itemOffset, float i_itemHeight);
    bool AddItem(char* i_text, uint32_t i_customColour, CoreHash i_icon);
    void ClearContents();
    void SetItemIconVisibility(int32_t i_itemIndex, bool i_visible);
    bool GetItemIconVisibility(int32_t i_itemIndex);
    void SetNumberOfVisibleItems(int32_t i_visibleItemCount);
    int32_t GetNumberOfVisibleItems();
    void SetTextMode(int32_t i_xMode, int32_t i_yMode, float i_width, float i_height);
    void SetTextureID(CoreHash i_textureID);
    void SetFontID(CoreHash i_fontID);
    void SetFrameTextureID(CoreMenuComponent::CompFrameTag i_index, CoreHash i_textureID);
    void SetFrameCornerSizes(float i_cornerWidths, float i_cornerHeights);
    void SetFrameBackGroundOffsets(float i_offsetX, float i_offsetY);
    CoreHash GetName();
    CoreHash GetType();
    void GetAnchor();
    float GetX();
    float GetY();
    float GetWidth();
    float GetHeight();
    float GetRotation();
    float GetU0();
    float GetV0();
    float GetU1();
    float GetV1();
    float GetRed();
    float GetGreen();
    float GetBlue();
    float GetAlpha();
    float GetVisibility();
    float GetHorizontalSplitScreenX();
    float GetHorizontalSplitScreenY();
    float GetVerticalSplitScreenX();
    float GetVerticalSplitScreenY();
    CoreHash GetDirection(int32_t i_dir);
    CoreHash GetTextureID();
    CoreTextureSet* GetTextureSet();
    bool GetActive();
    bool GetSelectable();
    bool GetRequireCallbacks();
    bool GetCentreScale();
    bool GetNoPlatformScale();
    bool GetForceStdRender();
    bool IsText();
    bool IsTextSpacedEvenly();
    bool IsFrame();
    bool IsFrameFullScreen();
    CoreHash GetFontID();
    CoreFont* GetFont();
    CoreHash GetText();
    int32_t GetTextMode();
    float GetTextWidth();
    float GetTextHeight();
    CoreHash GetItemHash(int32_t i_itemIndex);
    char* GetItemText(int32_t i_itemIndex);
    CoreRGBA GetRGBA(float i_visMult);
    CoreRGBA GetRGBABackground(float i_visMult);
    CoreRGBA GetRGBAHighlight(float i_visMult);
    CoreRGBA GetRGBANormalText(float i_visMult);
    CoreUV GetUV0();
    CoreUV GetUV1();
    void SetScaleWH();
    void SetKeepAspect();
    void SetFullScreen();
    void SetLeftHalf();
    void SetRightHalf();
    void SetTopHalf();
    void SetBottomHalf();
    bool InternalMovementHandler(CoreMenuComponent::CompDirection i_direction);
    int32_t GetInternalSelection();
    void SetInternalSelection(uint32_t i_index);
    uint32_t GetNumberOfItems();
    void Update(float i_time);
    void Render(CoreGameRender* io_graphics, float i_visibilityMultiplier);
    void RenderCustomString(CoreGameRender* io_graphics, char* i_str, float i_visibilityMultiplier);
    void GetRenderXYWH(float& o_x, float& o_y, float& o_w, float& o_h);
    void DoDebug(int32_t i_debugLevel, CoreDebugInput* i_input);
    float GetRatio();
    void GetScreenXYWH(float& o_x, float& o_y, float& o_width, float& o_height);
    void RenderFrameTexture(CoreGameRender* io_graphics, int32_t i_frameTextureIndex, float i_x1, float i_y1, float i_x2, float i_y2, CoreRGBA i_rgba, int32_t i_flags);
};

struct _SEC_WINNT_AUTH_IDENTITY_W
{
    uint32_t* User;
    uint32_t UserLength;
    uint32_t* Domain;
    uint32_t DomainLength;
    uint32_t* Password;
    uint32_t PasswordLength;
    uint32_t Flags;
};

struct ARRAY_INFO
{
    int32_t Dimension;
    uint32_t* BufferConformanceMark;
    uint32_t* BufferVarianceMark;
    uint32_t* MaxCountArray;
    uint32_t* OffsetArray;
    uint32_t* ActualCountArray;
};

struct _NDR_USER_MARSHAL_INFO
{
    uint32_t InformationLevel;
    _NDR_USER_MARSHAL_INFO_LEVEL1 Level1;
};

struct CoreBlendShapeData
{
    enum
    {
        VERSION = 1,
    };

    int32_t m_iNumTargets;
    int32_t m_iCurveTableOffset;
    int32_t m_iSkeletonTargetIndex[1];

    void CoreBlendShapeData();
    void ~CoreBlendShapeData();
    int32_t GetNumTargets();
    int32_t GetSkeletonIndex();
    CoreF32CurveData* GetCurve();
    float GetAlpha();
    int32_t* GetCurveTableOffsetPtr();
};

struct CoreF32CurveData
{
    int32_t m_sNumKeys;
    int32_t m_sPad;
    CoreF32AnimKeyData m_oKeys[1];

    void CoreF32CurveData();
    void ~CoreF32CurveData();
    float GetValue(float fTime, bool& bNoKeys);
    float GetTangent();
    bool GetValueBool(float fTime);
    int32_t GetNumKeys();
    int32_t FindKey(float fTime);
    CoreF32AnimKeyData* GetKeyPtr();
};

struct tagEMRSETVIEWPORTORGEX
{
    tagEMR emr;
    _POINTL ptlOrigin;
};

struct tagMIXERCAPS2W
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t fdwSupport;
    uint32_t cDestinations;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct _CHANGER_ELEMENT_STATUS
{
    _CHANGER_ELEMENT Element;
    _CHANGER_ELEMENT SrcElementAddress;
    uint32_t Flags;
    uint32_t ExceptionCode;
    uint32_t TargetId;
    uint32_t Lun;
    uint32_t Reserved;
    uint32_t PrimaryVolumeID[36];
    uint32_t AlternateVolumeID[36];
};

struct _SERVICE_TABLE_ENTRYA
{
    char* lpServiceName;
    void* lpServiceProc;
};

struct CoreLevelUpdateStruct : CoreObjectUpdateStruct
{
    void CoreLevelUpdateStruct();
    void ~CoreLevelUpdateStruct();
};

struct CoretGS_EXTBUF
{
    uint32_t EXBP : 14;
    uint32_t EXBW : 6;
    uint32_t FBIN : 2;
    uint32_t WFFMD : 1;
    uint32_t EMODA : 2;
    uint32_t EMODC : 2;
    uint32_t p0 : 5;
    uint32_t WDX : 11;
    uint32_t WDY : 11;
    uint32_t p1 : 10;
};

struct tagENUMLOGFONTEXA
{
    tagLOGFONTA elfLogFont;
    uint32_t elfFullName[64];
    uint32_t elfStyle[32];
    uint32_t elfScript[32];
};

struct _RPC_PROTSEQ_VECTORA
{
    uint32_t Count;
    uint32_t* Protseq[1];
};

struct CoreJointData
{
    enum
    {
        VERSION = 8,
    };

    enum CoreCurveType
    {
        COMPILED_VELOCITY = -666,
        COMPILED_FLOAT_TRANS_X = 0,
        COMPILED_FLOAT_TRANS_Y = 1,
        COMPILED_FLOAT_TRANS_Z = 2,
        COMPILED_FLOAT_ROT_X = 3,
        COMPILED_FLOAT_ROT_Y = 4,
        COMPILED_FLOAT_ROT_Z = 5,
        COMPILED_FLOAT_SCALE_X = 6,
        COMPILED_FLOAT_SCALE_Y = 7,
        COMPILED_FLOAT_SCALE_Z = 8,
        COMPILED_FLOAT_VISIBILITY = 9,
        COMPILED_VECTOR_TRANS_XYZ = 10,
        COMPILED_VECTOR_ROT_XYZ = 11,
        COMPILED_VECTOR_SCALE_XYZ = 12,
        COMPILED_QUAT_ROT_XYZW = 13,
        COMPILED_BOOL_VISIBILITY = 14,
        COMPILED_FLOAT_BLENDSHAPE_TARGET_ALPHA = 15,
        COMPILED_BEZIER_TRANSLATE_X = 16,
        COMPILED_BEZIER_TRANSLATE_Y = 17,
        COMPILED_BEZIER_TRANSLATE_Z = 18,
        COMPILED_BEZIER_QUATERNION_ROTATE_X = 19,
        COMPILED_BEZIER_QUATERNION_ROTATE_Y = 20,
        COMPILED_BEZIER_QUATERNION_ROTATE_Z = 21,
        COMPILED_BEZIER_QUATERNION_ROTATE_W = 22,
        COMPILED_BEZIER_SCALE_X = 23,
        COMPILED_BEZIER_SCALE_Y = 24,
        COMPILED_BEZIER_SCALE_Z = 25,
        COMPILED_QUATERNION_SIGN = 26,
        COMPILED_ANGLEAXIS_X = 27,
        COMPILED_ANGLEAXIS_Y = 28,
        COMPILED_ANGLEAXIS_Z = 29,
        COMPILED_ANGLEAXIS_ANGLE = 30,
        COMPILED_QUATERNION_GENERATE_W = 31,
        COMPILED_UNKNOWN = 999,
    };

    enum CoreRotationOrderEnum
    {
        XYZ,
        ZXY,
    };

    char m_cNumCurves;
    char m_cRotationOrder;
    uint32_t m_padding;
    uint32_t m_uCurveMask;
    uint32_t m_uConstMask;
    CoreCurveIndexData m_oCurveIndexData;

    void CoreJointData();
    void ~CoreJointData();
    float GetCurveValue(CoreJointData::CoreCurveType eCurveType, float fTime);
    CoreVector GetCurveValueVector();
    CoreQuat GetCurveValueQuat(CoreJointData::CoreCurveType eCurveType, float fTime);
    bool GetCurveValueBool();
    float GetCurveValueBezier(CoreJointData::CoreCurveType eCurveType, float fTime);
    bool GetQuaternionSign(float fTime);
    void UpdateJointStates(float fTime, CoreJointState* lpoJointState, bool mirror);
    void BlendJointStates();
    char* GetCurveName();
    bool IsXYZRotation();
    bool IsZXYRotation();
    bool HasCurve();
    bool IsCurveConstant();
    int32_t GetCurveMask();
    int32_t GetNumCurves();
    bool IsQuaternionRotation();
    CoreCurveIndexData* GetCurveIndexPtr();
    CoreF32CurveData* GetFloatCurve();
    CoreVectorCurveData* GetVectorCurve();
    CoreQuatCurveData* GetQuatCurve();
    CoreBezierCurveData* GetBezierCurve();
    CoreConstF32CurveData* GetConstFloatCurve();
    CoreConstQuatCurveData* GetConstQuatCurve();
    CoreJointData::CoreCurveType GetCurveType();
    CoreVector GetTranslation(float fTime);
    CoreEulerAngle GetRotationEuler(float fTime);
    CoreQuat GetRotationQuat(float fTime);
    CoreVector GetScale(float fTime);
    bool GetVisible(float fTime);
    CoreVector GetRotationVector(float fTime);
    void* GetCurve(CoreJointData::CoreCurveType eType);
};

struct CoreCurveIndexData
{
    uint32_t m_curveOffsetID;
};

struct CoreVectorCurveData
{
    int32_t m_sNumKeys;
    int32_t m_sPad;
    CoreVectorAnimKeyData m_oKeys[1];

    void CoreVectorCurveData();
    void ~CoreVectorCurveData();
    CoreVector GetValue();
    CoreVector GetTangent();
    int32_t GetNumKeys();
    int32_t FindKey();
    CoreVectorAnimKeyData* GetKeyPtr();
};

struct CoreBezierCurveData
{
    int32_t m_numKeys;
    uint32_t m_isKeyDataShort;
    uint32_t m_pad;
    void* m_keyData;

    void CoreBezierCurveData();
    void ~CoreBezierCurveData();
    float GetValue();
    int32_t GetNumKeys();
    float GetValueLong(float i_time);
    float GetValueShort(float i_time);
    int32_t FindKeyLong(float i_time);
    int32_t FindKeyShort();
    float ConvertTime();
    uint32_t ConvertTimeReverse();
    CoreVector ConvertValue(CoreVector i_value);
    CoreBezierAnimKeyDataLong* GetKeyPtrLong();
    CoreBezierAnimKeyDataShort* GetKeyPtrShort();
    float EvalCurveShort(CoreBezierAnimKeyDataShort* i_currKey, CoreBezierAnimKeyDataShort* i_nextKey, float i_time);
};

struct CoreConstF32CurveData
{
    float m_value;

    void CoreConstF32CurveData();
    void ~CoreConstF32CurveData();
    float GetValue();
    bool GetValueBool();
    int32_t GetNumKeys();
};

struct CoreConstQuatCurveData
{
    float m_value[4];

    void CoreConstQuatCurveData();
    void ~CoreConstQuatCurveData();
    CoreQuat GetValue();
    int32_t GetNumKeys();
};

struct tagMETAHEADER
{
    uint32_t mtType;
    uint32_t mtHeaderSize;
    uint32_t mtVersion;
    uint32_t mtSize;
    uint32_t mtNoObjects;
    uint32_t mtMaxRecord;
    uint32_t mtNoParameters;
};

struct _REMOTE_NAME_INFOA
{
    char* lpUniversalName;
    char* lpConnectionName;
    char* lpRemainingPath;
};

struct _CMSG_STREAM_INFO
{
    uint32_t cbContent;
    int32_t* pfnStreamOutput;
    void* pvArg;
};

struct _CHANGER_SET_ACCESS
{
    _CHANGER_ELEMENT Element;
    uint32_t Control;
};

struct _DATATYPES_INFO_1W
{
    uint32_t* pName;
};

struct _FIND_NAME_HEADER
{
    uint32_t node_count;
    uint32_t reserved;
    uint32_t unique_group;
};

struct tagFILTERKEYS
{
    uint32_t cbSize;
    uint32_t dwFlags;
    uint32_t iWaitMSec;
    uint32_t iDelayMSec;
    uint32_t iRepeatMSec;
    uint32_t iBounceMSec;
};

struct tagEMRSETTEXTCOLOR
{
    tagEMR emr;
    uint32_t crColor;
};

struct tagMONHSZSTRUCTW
{
    uint32_t cb;
    int32_t fsAction;
    uint32_t dwTime;
    HSZ__* hsz;
    void* hTask;
    uint32_t str[1];
};

struct _FIND_NAME_BUFFER
{
    uint32_t length;
    uint32_t access_control;
    uint32_t frame_control;
    uint32_t destination_addr[6];
    uint32_t source_addr[6];
    uint32_t routing_info[18];
};

struct _ACTION_HEADER
{
    uint32_t transport_id;
    uint32_t action_code;
    uint32_t reserved;
};

struct _PRINTER_NOTIFY_OPTIONS
{
    uint32_t Version;
    uint32_t Flags;
    uint32_t Count;
    _PRINTER_NOTIFY_OPTIONS_TYPE* pTypes;
};

struct IOleCache2 : IOleCache
{
    HRESULT __stdcall UpdateCache();
    HRESULT __stdcall DiscardCache();
    void IOleCache2();
};

struct _DOCINFOW
{
    int32_t cbSize;
    uint32_t* lpszDocName;
    uint32_t* lpszOutput;
    uint32_t* lpszDatatype;
    uint32_t fwType;
};

struct _CERT_KEY_ATTRIBUTES_INFO
{
    _CRYPTOAPI_BLOB KeyId;
    _CRYPT_BIT_BLOB IntendedKeyUsage;
    _CERT_PRIVATE_KEY_VALIDITY* pPrivateKeyUsagePeriod;
};

struct ISynchronizeMutex : ISynchronize
{
    HRESULT __stdcall ReleaseMutex();
    void ISynchronizeMutex();
};

struct tagSTATPROPSTG
{
    uint32_t* lpwstrName;
    uint32_t propid;
    uint32_t vt;
};

struct _RTL_CRITICAL_SECTION
{
    _RTL_CRITICAL_SECTION_DEBUG* DebugInfo;
    int32_t LockCount;
    int32_t RecursionCount;
    void* OwningThread;
    void* LockSemaphore;
    uint32_t SpinCount;
};

struct tagWNDCLASSA
{
    uint32_t style;
    int32_t* lpfnWndProc;
    int32_t cbClsExtra;
    int32_t cbWndExtra;
    HINSTANCE__* hInstance;
    HICON__* hIcon;
    HICON__* hCursor;
    HBRUSH__* hbrBackground;
    char* lpszMenuName;
    char* lpszClassName;
};

struct CAL0_API
{
    bool m_Initialised;
    uint32_t m_HeapSize;
    bool m_UseSysMemory;
    void* m_Address;

    // TODO vtable

    void CAL0_API();
    void ~CAL0_API();
    CAAudioError Initialise(uint32_t i_heapSize, void* i_address, bool useSysMemory);
    CAAudioError Reset();
    CAAudioError Destroy();
    void SetHeapLogging(bool log);
    void SetMemoryLogging(bool log);
};

struct HMMIO__
{
    int32_t unused;
};

struct _CHANGER_PRODUCT_DATA
{
    uint32_t VendorId[8];
    uint32_t ProductId[16];
    uint32_t Revision[4];
    uint32_t SerialNumber[32];
    uint32_t DeviceType;
};

struct IAddrExclusionControl : IUnknown
{
    HRESULT __stdcall GetCurrentAddrExclusionList();
    HRESULT __stdcall UpdateAddrExclusionList();
    void IAddrExclusionControl();
};

struct tagDELETEITEMSTRUCT
{
    uint32_t CtlType;
    uint32_t CtlID;
    uint32_t itemID;
    HWND* hwndItem;
    uint32_t itemData;
};

struct tagHSZPAIR
{
    HSZ__* hszSvc;
    HSZ__* hszTopic;
};

struct _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO
{
    uint32_t cbSize;
    _CRYPTOAPI_BLOB EncryptedKey;
};

struct tagIMECHARPOSITION
{
    uint32_t dwSize;
    uint32_t dwCharPos;
    tagPOINT pt;
    uint32_t cLineHeight;
    tagRECT rcDocument;
};

struct _CRL_REVOCATION_INFO
{
    _CRL_ENTRY* pCrlEntry;
    _CRL_CONTEXT* pCrlContext;
    _CERT_CHAIN_CONTEXT* pCrlIssuerChain;
};

struct CoreAnimatingObject : CoreGeometryObject
{
    enum CoreNetworkUpdateBitFields
    {
        BIT_ACTIVE,
        BIT_DEAD,
        BIT_PARENT,
        BIT_POS,
        BIT_ORIENT_Y,
        BIT_ORIENT_XZ,
        BIT_SCALE,
        BIT_ANIM,
        BIT_LOOPING,
        BIT_NEXT_ANIM,
        BIT_NEXT_LOOPING,
        BIT_BLENDING,
        BIT_SECOND_ANIM,
        BIT_FIRST_USER,
        BIT_FORCE_ABSOLUTE,
    };

    enum CoreBoneOverrideBitsEnum
    {
        CORE_RELATIVE_X,
        CORE_RELATIVE_Y,
        CORE_RELATIVE_Z,
        CORE_ABSOLUTE_X,
        CORE_ABSOLUTE_Y,
        CORE_ABSOLUTE_Z,
        CORE_REMOVE_JOINT_TRANSLATE_BIT,
    };

    enum CoreBoneOverrideFlagsEnum
    {
        CORE_RELATIVE_XYZ = 7,
        CORE_ABSOLUTE_XYZ = 56,
    };

    enum CoreBoneOverrideComponentBitsEnum
    {
        CORE_OVERRIDE_X,
        CORE_OVERRIDE_Y,
        CORE_OVERRIDE_Z,
    };

    enum CoreBoneOverrideComponentFlagsEnum
    {
        CORE_OVERRIDE_XYZ = 7,
    };

    CoreAnimatingObjectData* m_lpoData;

    void CoreAnimatingObject();
    void ~CoreAnimatingObject();
    void Construct(CoreMemory* lpoMemory);
    void Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Reset();
    void AddToRenderList(CoreGameRender* lpoGraphics);
    void Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
    void RenderAnimList(CoreGameRender* lpoGraphics);
    void Constrain();
    void UnConstrain();
    CoreFileSystem::CoreFileLoadReturn AttachAnimationSetFile(CoreObjectUpdateStruct* i_updateStruct, char* i_animationSetName);
    void SetAnimating();
    bool IsAnimating();
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, CoreObjectUpdateStruct* lpoUpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, int32_t& iDataRead, CoreObjectUpdateStruct* lpoUpdateStruct);
    bool AddAnimNormal(CoreHash i_slotID, CoreHash i_animID);
    bool AddAnim(CoreHash i_slotID, CoreHash i_animID, CorePlayAnimInfo* i_animInfo);
    bool CanAddAnim();
    bool SetGoalState(CoreHash i_slotID, CoreHash i_animID);
    bool AddImmediateBlend();
    CoreHash GetPrimaryAnimID();
    CoreHash GetPrimaryAnimContext();
    float GetPrimaryAnimTime();
    float GetPrimaryAnimEndTime();
    float GetPrimaryAnimPlaybackSpeed();
    CoreHash GetSlotAnimID(CoreHash i_slotID);
    float GetSlotAnimTime(CoreHash i_slotID);
    float GetSlotAnimEndTime(CoreHash i_slotID);
    bool IsSlotAnimBlending();
    bool IsSlotAnimMirrored();
    bool IsSlotPlaying();
    void SetSlotWeight(CoreHash i_slotID, float i_weight, float i_time, bool i_killOnZeroWeight);
    float GetSlotWeight();
    void SetSlotPlaybackSpeed();
    float GetSlotPlaybackSpeed();
    CoreAnimationSet* GetAnimationSet(CoreHash i_animName);
    bool IsPrimaryAnimSpecFlagSet(int32_t i_flag);
    bool IsAnimSpecFlagSet(CoreHash i_animSpec, int32_t i_flag);
    CoreHash GetAnimSpecAltState(CoreHash i_animSpec);
    CoreEulerAngle GetAnimationDirection();
    void SetAnimationDirection();
    CoreHash GetAnimStateContext();
    float GetAnimStateEndTime();
    bool GetAnimStateLooping();
    bool GetTimer();
    void CreateBlender(int32_t i_blenderType, CoreObjectUpdateStruct* i_updateStruct);
    int32_t GetBlenderType();
    bool HandleAnimCommandCallback(CoreHash i_slotID, CoreAnimCommand* i_command);
    bool GetFloorSurfaceType(CoreVector& i_detectPosition, uint32_t& o_surfaceType);
    CoreHashArray* GetSkeletonJointIndexTable();
    int32_t GetNumAnimDataSets();
    CoreHash GetAnimDataSetHash();
    void ClearOffsetBlends();
    bool SetAnimFlag();
    void ClearAnimFlag();
    bool IsAnimFlagSet();
    void ClearAllAnimFlags();
    void InitialiseAnimFlagsFromModel();
    void GetBlenderStats();
    CoreVector GetVelocityPosition();
    CoreEulerAngle GetVelocityOrientation();
    void Animate(CoreObjectUpdateStruct* updateStruct, float deltaTimeInSeconds);
    float AnimTimeAdjust(float time);
    void ResetAnimations();
    void ClearAnimList();
    float GetDefaultEndTime(CoreHash oAnimName);
    CoreEulerAngle GetOrientationChange(CoreHash oName, float fStartTime, float fEndTime, float fAnimEndTime, bool bLooping, bool mirror);
    CoreVector GetPositionChange(CoreHash oName, float fStartTime, float fEndTime, float fAnimEndTime, bool bLooping, bool mirror);
    void GetAnimateVelocity(CoreVector* o_velocityPos, CoreEulerAngle* o_velocityRot, CoreVector* o_offsetPos, CoreEulerAngle* o_offsetRot);
    void LookAt();
    void SetBoneOrientationOverride(CoreHash oBoneName, CoreEulerAngle& eaNewOrient, uint32_t uiOverrideFlags);
    void SetBoneTranslationOverride(CoreHash oBoneName, CoreVector& vNewTranslation, uint32_t uiOverrideFlags);
    void UnSetBoneOrientationOverride();
    void UnSetBoneOrientationXYZOverride();
    void UnSetBoneTranslationOverride();
    void UnSetBoneTranslationXYZOverride();
    void SetBoneOrientationXYZAbs();
    void SetBoneOrientationXYZRel();
    void SetBoneTranslationXYZAbs(CoreHash oBoneName, CoreVector& vNewTranslation);
    void SetBoneTranslationXYZRel();
    void EnableBlendShapeOverride();
    void DisableBlendShapeOverride();
    void SetBlendShapeTargetValue();
    bool DoesTimeMarkerExist();
    float GetTimeMarkerStartTime();
    float GetTimeMarkerEndTime();
    int32_t GetNumTimeMarkers();
    uint32_t GetTimeMarkerName();
    bool DoesMarkerExist();
    CoreVector GetSubObjectMarkerPosition(CoreHash oMarkerName);
    CoreEulerAngle GetSubObjectMarkerOrientation(CoreHash oMarkerName);
    CoreVector GetSubObjectMarkerScale(CoreHash oMarkerName);
    CoreSubObjectMarkerData::eSubObjectMarkerStateEnum eGetSubObjectMarkerState();
    float GetSubObjectMarkerStartTime();
    float GetSubObjectMarkerEndTime();
    CoreMatrix mGetSubObjectMarkerWorldMatrix();
    void GetBoundingBox();
    void SetVisible(CoreHash oBoneName, bool bVisible);
    void UnSetVisible(CoreHash oBoneName);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
    bool AttachAnimationSet();
    bool AttachAnimationSequencer();
    void AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
    CoreScripted::CommandReturn eFnSetAnimTemplate(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetAnimTemplateSimple(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetAnimTemplateComplex(CoreCommand* lpoCommand);
    void CreateSkeletonOverrideValues(int32_t iNumBlendShapeTargets);
    void UpdateBlendShapeTargetAlphaValues(float* lpfBlendShapeAlphaValues);
    int32_t GetNumSubObjectMarkers();
    CoreHash GetSubObjectMarkerHash(int32_t iSubObjectMarkerIndex);
    void HandleCallBack();
    void UpdateJointsState(CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates);
    void ApplyBoneOverrides(CoreJointState* io_jointStates, bool i_hasAnim);
    CoreScripted::CommandReturn eFnSetAnim(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetAnimNonLoop(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnNetUpdateAnimatingObject(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetAnimFlag(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnClearAnimFlag(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnClearAllAnimFlags(CoreCommand* lpoCommand);
};

struct _s__ThrowInfo
{
    uint32_t attributes;
    void* pmfnUnwind;
    int32_t* pForwardCompat;
    _s__CatchableTypeArray* pCatchableTypeArray;
};

struct _CoreGifPackNop
{
    uint32_t pad[2];
};

struct tagMENUGETOBJECTINFO
{
    uint32_t dwFlags;
    uint32_t uPos;
    HMENU__* hmenu;
    void* riid;
    void* pvObj;
};

struct tagMONITORINFOEXW : tagMONITORINFO
{
    uint32_t szDevice[32];
};

struct _CERT_RDN
{
    uint32_t cRDNAttr;
    _CERT_RDN_ATTR* rgRDNAttr;
};

struct dvi_adpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
};

struct tagWNDCLASSW
{
    uint32_t style;
    int32_t* lpfnWndProc;
    int32_t cbClsExtra;
    int32_t cbWndExtra;
    HINSTANCE__* hInstance;
    HICON__* hIcon;
    HICON__* hCursor;
    HBRUSH__* hbrBackground;
    uint32_t* lpszMenuName;
    uint32_t* lpszClassName;
};

struct tagRPC_EXTENDED_ERROR_INFO
{
    uint32_t Version;
    uint32_t* ComputerName;
    uint32_t ProcessID;
    tagRPC_EXTENDED_ERROR_INFO::__unnamed u;
    uint32_t GeneratingComponent;
    uint32_t Status;
    uint32_t DetectionLocation;
    uint32_t Flags;
    int32_t NumberOfParameters;
    tagRPC_EE_INFO_PARAM Parameters[4];
};

struct IOleInPlaceFrame : IOleInPlaceUIWindow
{
    HRESULT __stdcall InsertMenus();
    HRESULT __stdcall SetMenu();
    HRESULT __stdcall RemoveMenus();
    HRESULT __stdcall SetStatusText();
    HRESULT __stdcall EnableModeless();
    HRESULT __stdcall TranslateAcceleratorA();
    void IOleInPlaceFrame();
};

struct tagNEWTEXTMETRICW
{
    int32_t tmHeight;
    int32_t tmAscent;
    int32_t tmDescent;
    int32_t tmInternalLeading;
    int32_t tmExternalLeading;
    int32_t tmAveCharWidth;
    int32_t tmMaxCharWidth;
    int32_t tmWeight;
    int32_t tmOverhang;
    int32_t tmDigitizedAspectX;
    int32_t tmDigitizedAspectY;
    uint32_t tmFirstChar;
    uint32_t tmLastChar;
    uint32_t tmDefaultChar;
    uint32_t tmBreakChar;
    uint32_t tmItalic;
    uint32_t tmUnderlined;
    uint32_t tmStruckOut;
    uint32_t tmPitchAndFamily;
    uint32_t tmCharSet;
    uint32_t ntmFlags;
    uint32_t ntmSizeEM;
    uint32_t ntmCellHeight;
    uint32_t ntmAvgWidth;
};

struct _CMC_TAGGED_CERT_REQUEST
{
    uint32_t dwBodyPartID;
    _CRYPTOAPI_BLOB SignedCertRequest;
};

struct tagOFNW
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HINSTANCE__* hInstance;
    uint32_t* lpstrFilter;
    uint32_t* lpstrCustomFilter;
    uint32_t nMaxCustFilter;
    uint32_t nFilterIndex;
    uint32_t* lpstrFile;
    uint32_t nMaxFile;
    uint32_t* lpstrFileTitle;
    uint32_t nMaxFileTitle;
    uint32_t* lpstrInitialDir;
    uint32_t* lpstrTitle;
    uint32_t Flags;
    uint32_t nFileOffset;
    uint32_t nFileExtension;
    uint32_t* lpstrDefExt;
    int32_t lCustData;
    uint32_t* lpfnHook;
    uint32_t* lpTemplateName;
};

struct tagEMRMASKBLT
{
    tagEMR emr;
    _RECTL rclBounds;
    int32_t xDest;
    int32_t yDest;
    int32_t cxDest;
    int32_t cyDest;
    uint32_t dwRop;
    int32_t xSrc;
    int32_t ySrc;
    tagXFORM xformSrc;
    uint32_t crBkColorSrc;
    uint32_t iUsageSrc;
    uint32_t offBmiSrc;
    uint32_t cbBmiSrc;
    uint32_t offBitsSrc;
    uint32_t cbBitsSrc;
    int32_t xMask;
    int32_t yMask;
    uint32_t iUsageMask;
    uint32_t offBmiMask;
    uint32_t cbBmiMask;
    uint32_t offBitsMask;
    uint32_t cbBitsMask;
};

struct CoreMessageBoxHelper
{
    bool m_active;
    bool m_busy;
    char m_requiredButton;
    char m_selectedButton;

    void CoreMessageBoxHelper();
    bool IsActive();
    bool IsBusy();
    int32_t GetSelectedButton();
    bool IsRequiredButton();
    bool Start();
    bool Process();
    bool Stop();
    void FinishedCallBack();
};

struct IAdviseSink2 : IAdviseSink
{
    void __stdcall OnLinkSrcChange();
    void IAdviseSink2();
};

struct CoreMoviePlayerInterface
{
    static CoreMoviePlayerInterface* m_dummyInstance;
    static CoreStringBuffer<256> m_moviePath;
    static bool m_readyToPlay;

    // TODO vtable

    CoreMoviePlayerInterface* CreateInstance();
    CoreMoviePlayerInterface* GetDummyInstance();
    void DeleteInstance();
    bool Play();
    bool Stop();
    void CompleteMovieFileName();
    void SetMoviePath();
    char* GetMoviePath();
    char* GetLanguageSpecificMoviePath();
    void SetReadyToPlayMovies();
    bool IsReadyToPlayMovies();
    void StartMovie();
    float CheckForAbort();
    float GetAbortScaler();
    void CoreMoviePlayerInterface();
};

struct CAL1_AudioListener
{
    ca_3DPoint m_Position;
    ca_3DVelocity m_Velocity;
    ca_3DPoint m_TopOrientation;
    ca_3DPoint m_FrontOrientation;

    void CAL1_AudioListener();
};

struct CoreU128Aligned
{
    uint32_t ui64one;
    uint32_t ui64two;
};

struct _ENCRYPTION_CERTIFICATE_LIST
{
    uint32_t nUsers;
    _ENCRYPTION_CERTIFICATE** pUsers;
};

struct _VERIFY_INFORMATION
{
    _LARGE_INTEGER StartingOffset;
    uint32_t Length;
};

struct ISurrogate : IUnknown
{
    HRESULT __stdcall LoadDllServer();
    HRESULT __stdcall FreeSurrogate();
    void ISurrogate();
};

struct _complex
{
    float x;
    float y;
};

struct tagEMRPIXELFORMAT
{
    tagEMR emr;
    tagPIXELFORMATDESCRIPTOR pfd;
};

struct _SYSTEM_AUDIT_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t SidStart;
};

struct tagMCI_OVLY_RECT_PARMS
{
    uint32_t dwCallback;
    tagRECT rc;
};

struct tagMIXERCAPSW
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t fdwSupport;
    uint32_t cDestinations;
};

struct tagMCI_RECORD_PARMS
{
    uint32_t dwCallback;
    uint32_t dwFrom;
    uint32_t dwTo;
};

struct IViewObject : IUnknown
{
    HRESULT __stdcall Draw();
    HRESULT __stdcall GetColorSet();
    HRESULT __stdcall Freeze();
    HRESULT __stdcall Unfreeze();
    HRESULT __stdcall SetAdvise();
    HRESULT __stdcall GetAdvise();
    void IViewObject();
};

struct ITypeInfo2 : ITypeInfo
{
    HRESULT __stdcall GetTypeKind();
    HRESULT __stdcall GetTypeFlags();
    HRESULT __stdcall GetFuncIndexOfMemId();
    HRESULT __stdcall GetVarIndexOfMemId();
    HRESULT __stdcall GetCustData();
    HRESULT __stdcall GetFuncCustData();
    HRESULT __stdcall GetParamCustData();
    HRESULT __stdcall GetVarCustData();
    HRESULT __stdcall GetImplTypeCustData();
    HRESULT __stdcall GetDocumentation2();
    HRESULT __stdcall GetAllCustData();
    HRESULT __stdcall GetAllFuncCustData();
    HRESULT __stdcall GetAllParamCustData();
    HRESULT __stdcall GetAllVarCustData();
    HRESULT __stdcall GetAllImplTypeCustData();
    void ITypeInfo2();
};

struct tagTLIBATTR
{
    _GUID guid;
    uint32_t lcid;
    tagSYSKIND syskind;
    uint32_t wMajorVerNum;
    uint32_t wMinorVerNum;
    uint32_t wLibFlags;
};

struct SERVICE_STATUS_HANDLE__
{
    int32_t unused;
};

struct _PROVIDOR_INFO_2A
{
    char* pOrder;
};

struct IEnumSTATSTG : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumSTATSTG();
};

struct CoreGifTag
{
    uint32_t NLOOP : 15;
    uint32_t EOP : 1;
    uint32_t pad16 : 16;
    uint32_t id : 14;
    uint32_t PRE : 1;
    uint32_t PRIM : 11;
    uint32_t FLG : 2;
    uint32_t NREG : 4;
    uint32_t REGS0 : 4;
    uint32_t REGS1 : 4;
    uint32_t REGS2 : 4;
    uint32_t REGS3 : 4;
    uint32_t REGS4 : 4;
    uint32_t REGS5 : 4;
    uint32_t REGS6 : 4;
    uint32_t REGS7 : 4;
    uint32_t REGS8 : 4;
    uint32_t REGS9 : 4;
    uint32_t REGS10 : 4;
    uint32_t REGS11 : 4;
    uint32_t REGS12 : 4;
    uint32_t REGS13 : 4;
    uint32_t REGS14 : 4;
    uint32_t REGS15 : 4;
};

struct tagMENUINFO
{
    uint32_t cbSize;
    uint32_t fMask;
    uint32_t dwStyle;
    uint32_t cyMax;
    HBRUSH__* hbrBack;
    uint32_t dwContextHelpID;
    uint32_t dwMenuData;
};

struct tagSOUNDSENTRYA
{
    uint32_t cbSize;
    uint32_t dwFlags;
    uint32_t iFSTextEffect;
    uint32_t iFSTextEffectMSec;
    uint32_t iFSTextEffectColorBits;
    uint32_t iFSGrafEffect;
    uint32_t iFSGrafEffectMSec;
    uint32_t iFSGrafEffectColor;
    uint32_t iWindowsEffect;
    uint32_t iWindowsEffectMSec;
    char* lpszWindowsEffectDLL;
    uint32_t iWindowsEffectOrdinal;
};

struct _numberfmtA
{
    uint32_t NumDigits;
    uint32_t LeadingZero;
    uint32_t Grouping;
    char* lpDecimalSep;
    char* lpThousandSep;
    uint32_t NegativeOrder;
};

struct HACCEL__
{
    int32_t unused;
};

struct tagFINDREPLACEA
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HINSTANCE__* hInstance;
    uint32_t Flags;
    char* lpstrFindWhat;
    char* lpstrReplaceWith;
    uint32_t wFindWhatLen;
    uint32_t wReplaceWithLen;
    int32_t lCustData;
    uint32_t* lpfnHook;
    char* lpTemplateName;
};

struct CoreGsTex0
{
    uint32_t TBP0 : 14;
    uint32_t TBW : 6;
    uint32_t PSM : 6;
    uint32_t TW : 4;
    uint32_t TH : 4;
    uint32_t TCC : 1;
    uint32_t TFX : 2;
    uint32_t CBP : 14;
    uint32_t CPSM : 4;
    uint32_t CSM : 1;
    uint32_t CSA : 5;
    uint32_t CLD : 3;
};

struct tMIXERCONTROLDETAILS_BOOLEAN
{
    int32_t fValue;
};

struct tagINTERFACEDATA
{
    tagMETHODDATA* pmethdata;
    uint32_t cMembers;
};

struct _ICONINFO
{
    int32_t fIcon;
    uint32_t xHotspot;
    uint32_t yHotspot;
    HBITMAP__* hbmMask;
    HBITMAP__* hbmColor;
};

struct tagMCI_VD_PLAY_PARMS
{
    uint32_t dwCallback;
    uint32_t dwFrom;
    uint32_t dwTo;
    uint32_t dwSpeed;
};

struct _DRIVER_INFO_1W
{
    uint32_t* pName;
};

struct _CRYPTPROTECT_PROMPTSTRUCT
{
    uint32_t cbSize;
    uint32_t dwPromptFlags;
    HWND* hwndApp;
    uint32_t* szPrompt;
};

struct IViewObject2 : IViewObject
{
    HRESULT __stdcall GetExtent();
    void IViewObject2();
};

struct tag_s_RIFFWAVE_INST
{
};

struct tagMIXERCONTROLA
{
    uint32_t cbStruct;
    uint32_t dwControlID;
    uint32_t dwControlType;
    uint32_t fdwControl;
    uint32_t cMultipleItems;
    char szShortName[16];
    char szName[64];
    tagMIXERCONTROLA::__unnamed Bounds;
    tagMIXERCONTROLA::__unnamed Metrics;
};

struct tagMIXERLINECONTROLSA
{
    uint32_t cbStruct;
    uint32_t dwLineID;
    uint32_t dwControlID;
    uint32_t dwControlType;
    uint32_t cControls;
    uint32_t cbmxctrl;
    tagMIXERCONTROLA* pamxctrl;
};

struct CoreTextureFunctionsPS2
{
    uint32_t SwizzedClutIndex();
    void CoreTextureFunctionsPS2();
    void ~CoreTextureFunctionsPS2();
};

struct ITypeLib : IUnknown
{
    uint32_t __stdcall GetTypeInfoCount();
    HRESULT __stdcall GetTypeInfo();
    HRESULT __stdcall GetTypeInfoType();
    HRESULT __stdcall GetTypeInfoOfGuid();
    HRESULT __stdcall GetLibAttr();
    HRESULT __stdcall GetTypeComp();
    HRESULT __stdcall GetDocumentation();
    HRESULT __stdcall IsName();
    HRESULT __stdcall FindName();
    void __stdcall ReleaseTLibAttr();
    void ITypeLib();
};

struct _exception
{
    int32_t type;
    char* name;
    float arg1;
    float arg2;
    float retval;
};

struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR
{
    uint32_t Length;
    _RTL_VERIFIER_DLL_DESCRIPTOR* ProviderDlls;
    void* ProviderDllLoadCallback;
    void* ProviderDllUnloadCallback;
    uint32_t* VerifierImage;
    uint32_t VerifierFlags;
    uint32_t VerifierDebug;
    void* RtlpGetStackTraceAddress;
    void* RtlpDebugPageHeapCreate;
    void* RtlpDebugPageHeapDestroy;
};

struct _PROCESS_INFORMATION
{
    void* hProcess;
    void* hThread;
    uint32_t dwProcessId;
    uint32_t dwThreadId;
};

struct DRVCONFIGINFOEX
{
    uint32_t dwDCISize;
    uint32_t* lpszDCISectionName;
    uint32_t* lpszDCIAliasName;
    uint32_t dnDevNode;
};

struct IOleClientSite : IUnknown
{
    HRESULT __stdcall SaveObject();
    HRESULT __stdcall GetMoniker();
    HRESULT __stdcall GetContainer();
    HRESULT __stdcall ShowObject();
    HRESULT __stdcall OnShowWindow();
    HRESULT __stdcall RequestNewObjectLayout();
    void IOleClientSite();
};

struct tagWINDOWPOS
{
    HWND* hwnd;
    HWND* hwndInsertAfter;
    int32_t x;
    int32_t y;
    int32_t cx;
    int32_t cy;
    uint32_t flags;
};

struct tagNONCLIENTMETRICSA
{
    uint32_t cbSize;
    int32_t iBorderWidth;
    int32_t iScrollWidth;
    int32_t iScrollHeight;
    int32_t iCaptionWidth;
    int32_t iCaptionHeight;
    tagLOGFONTA lfCaptionFont;
    int32_t iSmCaptionWidth;
    int32_t iSmCaptionHeight;
    tagLOGFONTA lfSmCaptionFont;
    int32_t iMenuWidth;
    int32_t iMenuHeight;
    tagLOGFONTA lfMenuFont;
    tagLOGFONTA lfStatusFont;
    tagLOGFONTA lfMessageFont;
};

struct HWAVE__
{
    int32_t unused;
};

struct HMIDI__
{
    int32_t unused;
};

struct _BIDI_DATA
{
    uint32_t dwBidiType;
    _BIDI_DATA::__unnamed u;
};

struct _cpinfo
{
    uint32_t MaxCharSize;
    uint32_t DefaultChar[2];
    uint32_t LeadByte[12];
};

struct IXMLDOMParseError : IDispatch
{
    HRESULT __stdcall get_errorCode();
    HRESULT __stdcall get_url();
    HRESULT __stdcall get_reason();
    HRESULT __stdcall get_srcText();
    HRESULT __stdcall get_line();
    HRESULT __stdcall get_linepos();
    HRESULT __stdcall get_filepos();
    void IXMLDOMParseError();
};

struct _CoreGifPackAd
{
    uint32_t DATA;
    uint32_t ADDR;
};

struct tagWAVEINCAPSA
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t dwFormats;
    uint32_t wChannels;
    uint32_t wReserved1;
};

struct IMonikerProp : IUnknown
{
    HRESULT __stdcall PutProperty();
    void IMonikerProp();
};

struct CorePSPBuildSystemFileDevice : CoreBuildSystemInterfaceUsingNamedPipe
{
    bool CompleteTheFileName();
    void CorePSPBuildSystemFileDevice();
    void ~CorePSPBuildSystemFileDevice();
};

struct tagMIDIINCAPSW
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t dwSupport;
};

struct _CRL_DIST_POINT
{
    _CRL_DIST_POINT_NAME DistPointName;
    _CRYPT_BIT_BLOB ReasonFlags;
    _CERT_ALT_NAME_INFO CRLIssuer;
};

struct CoreVectorAnimKeyData
{
    float m_fTime;
    float m_fValue[3];
    float m_Tangent[3];
};

struct _wfinddata_t
{
    uint32_t attrib;
    int32_t time_create;
    int32_t time_access;
    int32_t time_write;
    uint32_t size;
    wchar_t name[260];
};

struct tagEMRSETMITERLIMIT
{
    tagEMR emr;
    float eMiterLimit;
};

struct _PERF_INSTANCE_DEFINITION
{
    uint32_t ByteLength;
    uint32_t ParentObjectTitleIndex;
    uint32_t ParentObjectInstance;
    int32_t UniqueID;
    uint32_t NameOffset;
    uint32_t NameLength;
};

struct IEnumVARIANT : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumVARIANT();
};

struct _SYSTEM_AUDIT_OBJECT_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t Flags;
    _GUID ObjectType;
    _GUID InheritedObjectType;
    uint32_t SidStart;
};

struct tagMONCBSTRUCT
{
    uint32_t cb;
    uint32_t dwTime;
    void* hTask;
    uint32_t dwRet;
    uint32_t wType;
    uint32_t wFmt;
    HCONV__* hConv;
    HSZ__* hsz1;
    HSZ__* hsz2;
    HDDEDATA__* hData;
    uint32_t dwData1;
    uint32_t dwData2;
    tagCONVCONTEXT cc;
    uint32_t cbData;
    uint32_t Data[8];
};

struct netent
{
    char* n_name;
    char** n_aliases;
    int32_t n_addrtype;
    uint32_t n_net;
};

struct _DRIVER_INFO_1A
{
    char* pName;
};

struct digirealwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
};

union _SLIST_HEADER
{
    uint32_t Alignment;
    _SINGLE_LIST_ENTRY Next;
    uint32_t Depth;
    uint32_t Sequence;
};

struct tagLOGBRUSH32
{
    uint32_t lbStyle;
    uint32_t lbColor;
    uint32_t lbHatch;
};

struct tagVARIANT
{
    uint32_t vt;
    uint32_t wReserved1;
    uint32_t wReserved2;
    uint32_t wReserved3;
    int32_t llVal;
    int32_t lVal;
    uint32_t bVal;
    int32_t iVal;
    float fltVal;
    float dblVal;
    int32_t boolVal;
    int32_t scode;
    tagCY cyVal;
    float date;
    uint32_t* bstrVal;
    IUnknown* punkVal;
    IDispatch* pdispVal;
    tagSAFEARRAY* parray;
    uint32_t* pbVal;
    int32_t* piVal;
    int32_t* plVal;
    int32_t* pllVal;
    float* pfltVal;
    float* pdblVal;
    int32_t* pboolVal;
    int32_t* pscode;
    tagCY* pcyVal;
    float* pdate;
    uint32_t** pbstrVal;
    IUnknown** ppunkVal;
    IDispatch** ppdispVal;
    tagSAFEARRAY** pparray;
    tagVARIANT* pvarVal;
    void* byref;
    char cVal;
    uint32_t uiVal;
    uint32_t ulVal;
    uint32_t ullVal;
    int32_t intVal;
    uint32_t uintVal;
    tagDEC* pdecVal;
    char* pcVal;
    uint32_t* puiVal;
    uint32_t* pulVal;
    uint32_t* pullVal;
    int32_t* pintVal;
    uint32_t* puintVal;
    void* pvRecord;
    IRecordInfo* pRecInfo;
    tagDEC decVal;
};

struct _CRYPT_PKCS8_IMPORT_PARAMS
{
    _CRYPTOAPI_BLOB PrivateKey;
    int32_t* pResolvehCryptProvFunc;
    void* pVoidResolveFunc;
    int32_t* pDecryptPrivateKeyFunc;
    void* pVoidDecryptFunc;
};

struct _DSCBCAPS
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwBufferBytes;
    uint32_t dwReserved;
};

struct _FORM_INFO_1A
{
    uint32_t Flags;
    char* pName;
    tagSIZE Size;
    _RECTL ImageableArea;
};

struct IPersistStorage : IPersist
{
    HRESULT __stdcall IsDirty();
    HRESULT __stdcall InitNew();
    HRESULT __stdcall Load();
    HRESULT __stdcall Save();
    HRESULT __stdcall SaveCompleted();
    HRESULT __stdcall HandsOffStorage();
    void IPersistStorage();
};

struct tagEMRGDICOMMENT
{
    tagEMR emr;
    uint32_t cbData;
    uint32_t Data[1];
};

struct CoreGsBitbltbuf
{
    uint32_t SBP : 14;
    uint32_t pad14 : 2;
    uint32_t SBW : 6;
    uint32_t pad22 : 2;
    uint32_t SPSM : 6;
    uint32_t pad30 : 2;
    uint32_t DBP : 14;
    uint32_t pad46 : 2;
    uint32_t DBW : 6;
    uint32_t pad54 : 2;
    uint32_t DPSM : 6;
    uint32_t pad62 : 2;
};

struct HKEY__
{
    int32_t unused;
};

struct _CRYPT_ENCRYPT_MESSAGE_PARA
{
    uint32_t cbSize;
    uint32_t dwMsgEncodingType;
    uint32_t hCryptProv;
    _CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
    void* pvEncryptionAuxInfo;
    uint32_t dwFlags;
    uint32_t dwInnerContentType;
};

struct DLGITEMTEMPLATE
{
    uint32_t style;
    uint32_t dwExtendedStyle;
    int32_t x;
    int32_t y;
    int32_t cx;
    int32_t cy;
    uint32_t id;
};

struct _DSFXDistortion
{
    float fGain;
    float fEdge;
    float fPostEQCenterFrequency;
    float fPostEQBandwidth;
    float fPreLowpassCutoff;
};

struct IOleAdviseHolder : IUnknown
{
    HRESULT __stdcall Advise();
    HRESULT __stdcall Unadvise();
    HRESULT __stdcall EnumAdvise();
    HRESULT __stdcall SendOnRename();
    HRESULT __stdcall SendOnSave();
    HRESULT __stdcall SendOnClose();
    void IOleAdviseHolder();
};

struct tagRECONVERTSTRING
{
    uint32_t dwSize;
    uint32_t dwVersion;
    uint32_t dwStrLen;
    uint32_t dwStrOffset;
    uint32_t dwCompStrLen;
    uint32_t dwCompStrOffset;
    uint32_t dwTargetStrLen;
    uint32_t dwTargetStrOffset;
};

struct _NETCONNECTINFOSTRUCT
{
    uint32_t cbStructure;
    uint32_t dwFlags;
    uint32_t dwSpeed;
    uint32_t dwDelay;
    uint32_t dwOptDataSize;
};

struct _RPC_VERSION
{
    uint32_t MajorVersion;
    uint32_t MinorVersion;
};

struct CAL1_AudioDriverPC : CAL1_AudioDriver
{
    static char exception_string[1024];
    IDirectSound8* m_DS;
    _DSBUFFERDESC m_DSBufferDesc;
    IDirectSoundBuffer* m_DSPrimaryBuffer;
    IDirectSound3DListener* m_DSListener;
    IDirectSoundBuffer** m_DSBuffer;
    IDirectSound3DBuffer** m_DS3DBuffer;
    _DSCAPS m_DSCaps;
    HRESULT m_DSCapsRes;
    HWND* m_hWnd;
    _GUID* m_guid;
    bool* m_DeferredListLoop;
    uint32_t* m_SampleDataBuffer;
    uint32_t m_ThreadID;
    void* m_ThreadHandle;
    uint32_t m_CompletionThreadIDI;
    uint32_t m_CompletionThreadIDII;
    void* m_CompletionThreadHandleI;
    void* m_CompletionThreadHandleII;
    bool m_ExitThread;
    bool m_ThreadExited;
    void* m_ChSema;
    void** m_EventHandles;

    void CAL1_AudioDriverPC();
    void ~CAL1_AudioDriverPC();
    CAAudioError PauseChannel(uint32_t channel);
    CAAudioError ResumeChannel(uint32_t channel);
    void UnpauseAll();
    void PauseAll();
    CAAudioError DeallocateAllStreams();
    CAAudioError Stream();
    CAAudioError FrameEnd();
    CAAudioError WriteChannelBufferData(uint32_t channel, uint32_t offset, uint32_t length, void* data);
    uint32_t GetChannelPlayCursor(uint32_t channel);
    CAAudioError SetNextListener(CAL1_AudioListener* listener);
    CAAudioError CreateBuffer(uint32_t channel, uint32_t bufferLength, uint32_t bitsPerSample, uint32_t baseFrequency, bool hardware, bool threeD, uint32_t numChannels);
    void BeginStreamThread();
    void BeginCompletionThread();
    CAAudioError Update3DListener();
    CAAudioError StartSample(CAL1_Sample* sample);
    CAAudioError Create();
    bool IsChannelPlaying(uint32_t channel, bool ignoreDeferred);
    CAAudioError StopChannel(uint32_t channel);
    CAAudioError SetChannelVolume(uint32_t channel, uint32_t volume);
    CAAudioError SetChannelPan(uint32_t channel, int32_t pan, int32_t panFR);
    CAAudioError SetChannelFrequency(uint32_t channel, uint32_t frequency);
    CAAudioError SetChannel3D();
    CAAudioError Set3DAndDopplerMode(uint32_t threeDMode, uint32_t dopplerMode);
    uint32_t GetAccelCaps();
    uint32_t GetDopplerCaps();
    uint32_t Get3DCaps();
    uint32_t GetReverbCaps();
    void GetDSCaps();
    CAAudioError EnableAllHWAcceleration(bool enable);
    CAAudioError EnableNon3DHWAcceleration(bool enable);
    CAAudioError Enable3DHWAcceleration(bool enable);
    uint32_t __stdcall _CA_AudioDriverPC_Stream(void* lpParameter);
    int32_t TestExceptionCode(_EXCEPTION_POINTERS* exceptPtrs);
    uint32_t __stdcall CA_AudioDriverPC_Stream(void* lpParameter);
    uint32_t __stdcall CA_AudioDriverPC_CompletionThreadI();
    uint32_t __stdcall CA_AudioDriverPC_CompletionThreadII();
    CAAudioError GetAdditionalChannelPropertySets(uint32_t channel, bool threeD, bool hardware);
    CAAudioError ReleaseAdditionalChannelPropertySets(uint32_t channel);
};

struct tagALTTABINFO
{
    uint32_t cbSize;
    int32_t cItems;
    int32_t cColumns;
    int32_t cRows;
    int32_t iColFocus;
    int32_t iRowFocus;
    int32_t cxItem;
    int32_t cyItem;
    tagPOINT ptStart;
};

struct _CERT_SYSTEM_STORE_INFO
{
    uint32_t cbSize;
};

struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA
{
    uint32_t cbSize;
    uint32_t dwRegPolicySettings;
    _CMSG_SIGNER_INFO* pSignerInfo;
};

struct _userHBITMAP
{
    union __MIDL_IWinTypes_0007
    {
        int32_t hInproc;
        _userBITMAP* hRemote;
        int32_t hInproc64;
    };

    int32_t fContext;
    _userHBITMAP::__MIDL_IWinTypes_0007 u;
};

struct _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA
{
    uint32_t cbSize;
    uint32_t hCryptProv;
    uint32_t dwSignerIndex;
    uint32_t dwSignerType;
    void* pvSigner;
};

struct XMLDOMDocumentEvents : IDispatch
{
    void XMLDOMDocumentEvents();
};

struct ICreateTypeLib2 : ICreateTypeLib
{
    HRESULT __stdcall DeleteTypeInfo();
    HRESULT __stdcall SetCustData();
    HRESULT __stdcall SetHelpStringContext();
    HRESULT __stdcall SetHelpStringDll();
    void ICreateTypeLib2();
};

struct _TAPE_CREATE_PARTITION
{
    uint32_t Method;
    uint32_t Count;
    uint32_t Size;
};

struct _WIN32_FIND_DATAA
{
    uint32_t dwFileAttributes;
    _FILETIME ftCreationTime;
    _FILETIME ftLastAccessTime;
    _FILETIME ftLastWriteTime;
    uint32_t nFileSizeHigh;
    uint32_t nFileSizeLow;
    uint32_t dwReserved0;
    uint32_t dwReserved1;
    char cFileName[260];
    char cAlternateFileName[14];
};

struct tagEMRSETCOLORSPACE
{
    tagEMR emr;
    uint32_t ihCS;
};

struct _NETRESOURCEA
{
    uint32_t dwScope;
    uint32_t dwType;
    uint32_t dwDisplayType;
    uint32_t dwUsage;
    char* lpLocalName;
    char* lpRemoteName;
    char* lpComment;
    char* lpProvider;
};

struct _PROVIDOR_INFO_1A
{
    char* pName;
    char* pEnvironment;
    char* pDLLName;
};

struct CoreVertexTypes
{
    enum CoreVertexTypesEnum
    {
        INVALID = 0,
        XYZ32 = 0,
        XYZ16 = 1,
        XYZ8 = 2,
        VOLUMES_MESH = 3,
        SHADOW_MESH = 4,
        RGBA8 = 5,
        UV32 = 6,
        UV16 = 7,
        UV8 = 8,
        NORMALS32 = 9,
        NORMALS16 = 10,
        NORMALS8 = 11,
        BLENDSHAPETARGET16 = 12,
        HARDSKINNING_INDEX8 = 13,
        SOFTSKINNING_WEIGHT20INDEX12 = 14,
        NO_XYZ = 16,
        NO_RGBA = 17,
        NO_UV = 18,
        NO_NORMALS = 19,
        NO_HARDSKINNING_INDEX = 20,
        NO_SOFTSKINNING_INDEX = 21,
        NO_BLENDSHAPE_TARGETS = 22,
    };

    // TODO vtable

    void YouCannotInstanceThisClass();
    void CoreVertexTypes();
};

struct IEnumSTATPROPSTG : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumSTATPROPSTG();
};

struct CoreSingleRagdollCollidable
{
    CoreCollidableType eType;
    CoreVector vPoints[2];
    float fRadius;
    uint32_t uiBoneHash;

    void CoreSingleRagdollCollidable();
};

struct CoreBreakPoint
{
    static bool m_enableCoreBreakPoint;
    static bool m_shouldAssertBreakPoint;

    // TODO vtable

    void EnableCoreBreakPoint(bool i_enable);
    bool IsCoreBreakPointEnabled();
    void SetAssertShouldBreakPoint(bool i_shouldBreakPoint);
    bool ShouldAssertBreakPoint();
    void YouCannotInstanceThisClass();
    void CoreBreakPoint();
};

struct CoreVectorData
{
    float m_x;
    float m_y;
    float m_z;
    float m_w;
};

struct CoreDetect
{
    enum CoreDetectDrawFlags
    {
        DRAW_POLYLIST,
        DRAW_ENABLED,
        DRAW_COLLIDABLES,
        DRAW_COLLIDABLES_DETAIL,
        DRAW_POLYLIST_WIREFRAME,
        DRAW_POLY_NORMALS,
        DRAW_POLY_SUBTYPE1,
        DRAW_POLY_SUBTYPE2,
        DRAW_LAST_DETECT_LIST,
    };

    enum CoreDetectFlags
    {
        DF_NO_FLOORS,
        DF_NO_WALLS_FACING_AWAY,
        DF_NO_OBJECTS,
        DF_NO_COLLIDABLES,
        DF_CAMERA,
    };

    CoreDetectInternalData* m_lpoData;

    // TODO vtable

    void CoreDetect();
    void ~CoreDetect();
    void Construct(CoreMemory* lpoMemory, CoreWorld* lpoWorld, int32_t i_numCaches);
    void Destruct(CoreMemory* lpoMemory);
    void Update();
    void ResetCaches();
    void SetCacheForced();
    void SetCacheLocked(int32_t i_cache, bool i_value);
    void SetFloorHeightCacheRadius(float i_value);
    bool FillDetectPolyList();
    CoreDetectResult* Detect(CoreVector& vOldPos, CoreVector& vNewPos, CoreGeometryObject* lpoObject, uint32_t i_flags);
    CoreDetectResult* SingleSphereDetect(CoreVector& vOldPos, CoreVector& vNewPos, CoreVector i_singleSpherePos, float i_singleSphereRadius, uint32_t i_flags);
    bool bLineOfSight(CoreVector& vFrom, CoreVector& vTo, CoreVector& vIntersection, CorePlaneEquation& peIntersectPlane, int32_t accurate);
    uint32_t GetFloorHeight(CoreVector& i_startPos, float& o_floorHeightBelow, float& o_floorHeightAbove, CoreDetectPoly*& o_floorBelowPoly, CoreDetectPoly*& o_floorAbovePoly);
    uint32_t GetCeilingHeight(CoreVector& i_startPos, float& o_ceilingAbove, CoreDetectPoly*& o_ceilingAbovePoly);
    void ToggleDebugRenderDetectors();
    bool GetDebugRenderDetectors();
    void DoDebug(CoreDebugInput* i_input);
    void GenerateTransformedBox(CoreVector* vTransformedBox, CoreVector* vTransformedBoxBounds, CoreEulerAngle& eaBoxRotation, CoreMatrix& mBone);
    bool ChooseDetectionCache(CoreVector& i_posA, CoreVector& i_posB, float i_radius, bool i_wantFloorCache);
    bool GetDetectionPolys(CoreVector& i_posA, CoreVector& i_posB, float i_radius);
    bool GetDetectionPolysIntoCurrentCache(CoreVector& i_posA, CoreVector& i_posB, float i_radius);
    bool SetupDetect(CoreVector& vPosA, CoreVector& vPosB, CoreVector i_singleSphereLocalPos, float i_singleSphereRadius);
    bool InternalSetupDetect(CoreVector& vPosA, CoreVector& vPosB);
    void TransformAllCollidables(bool bIgnoreYCullingLevelCollidables, bool bIgnoreYCullingObjectCollidables);
    bool bTransformSingleCollidable(CoreSingleCollidable* lpoCollidable, CoreAnimatingObject* lpoParentObject, CoreDetectHit eHitResult, bool bIgnoreYCulling);
    bool AddObjectDetectionMesh(CoreDetectionMesh* i_detectionMesh, CoreAnimatingObject* i_parentObject, bool i_ignoreYCulling);
    void GenerateSortedPolyList();
    void AddBoxToDetectPolyList(CoreVector* vTransformedBox, CoreGeometryObject* lpoParent, CoreDetectPolyType ePolyType_SpecialAttributes);
    void AddRectangleToDetectPolyList(CoreVector& vVert0, CoreVector& vVert1, CoreVector& vVert2, CoreVector& vVert3, CoreGeometryObject* lpoParent, CoreDetectPolyType ePolyType_SpecialAttributes);
    void DetectPolysAndObjects();
    void SphereDetectAllCollidables();
    bool SphereDetectMesh(uint32_t currentCycle);
    void AddPolyToList(CoreDetectPoly* lpoPoly, int32_t iWhichList);
    bool bSphereToPolyDetection(CoreDetectPoly* i_poly);
    void HitFloor(CoreDetectPoly* lpoPoly);
    void HitWall(CoreDetectPoly* lpoPoly);
    void HitCeiling(CoreDetectPoly* lpoPoly);
    void HitTransformedCollidableSphere(CoreTransformedCollidable* lpoTransformedCollidable, float fIntersectDistance);
    void HitTransformedCollidableSausage(CoreTransformedCollidable* lpoTransformedCollidable, float fIntersectDistance, CoreVector& vClosestPoint);
    void AddCollisionEvent(CoreDetectHit eWhatHit, uint32_t i_subType1, uint32_t i_subType2, CoreGeometryObject* i_objectPtr);
    void CalculateWallButt();
    bool GetFloorHeightsInternal(CoreVector& i_startPos, uint32_t i_maxNumFloors, float& o_bestHeightBelow, float& o_bestHeightAbove, float& o_lowestCeilingAbove, CoreFloorHeightInfo* o_floors, uint32_t& o_numFloorsFound, CoreDetectPoly*& o_floorBelowPoly, CoreDetectPoly*& o_floorAbovePoly, CoreDetectPoly*& o_ceilingAbovePoly);
    void DebugDrawPoly(uint32_t i_debugFlags, CoreDetectPoly* i_poly);
    void DebugDrawCollidable(uint32_t i_debugFlags, CoreTransformedCollidable* i_collidable);
    void DebugDrawFloorTestVector();
    void DebugDrawBoundingBox();
};

struct CoreTransformedCollidable
{
    CoreCollidableType eType;
    CoreDetectHit eHitResult;
    CoreGeometryObject* lpoParent;
    CoreVector vPoints[2];
    float fRadius;

    void CoreTransformedCollidable();
};

struct BuildSystemHelper
{
    static CoreStringBuffer<256> m_projectName;
    static CoreStringBuffer<256> m_optionsFileName;

    // TODO vtable

    char* GetProjectName();
    char* GetOptionsFileName();
    void Set();
    void SetSimple(char* i_projectName);
    bool GetMutexName();
    bool GetBusyMutexName();
    bool GetQuietMutexName();
    bool GetSharedMemoryName();
    void YouCannotInstanceThisClass();
    void BuildSystemHelper();
};

struct _SYSTEM_POWER_POLICY
{
    uint32_t Revision;
    POWER_ACTION_POLICY PowerButton;
    POWER_ACTION_POLICY SleepButton;
    POWER_ACTION_POLICY LidClose;
    _SYSTEM_POWER_STATE LidOpenWake;
    uint32_t Reserved;
    POWER_ACTION_POLICY Idle;
    uint32_t IdleTimeout;
    uint32_t IdleSensitivity;
    uint32_t DynamicThrottle;
    uint32_t Spare2[2];
    _SYSTEM_POWER_STATE MinSleep;
    _SYSTEM_POWER_STATE MaxSleep;
    _SYSTEM_POWER_STATE ReducedLatencySleep;
    uint32_t WinLogonFlags;
    uint32_t Spare3;
    uint32_t DozeS4Timeout;
    uint32_t BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL DischargePolicy[4];
    uint32_t VideoTimeout;
    uint32_t VideoDimDisplay;
    uint32_t VideoReserved[3];
    uint32_t SpindownTimeout;
    uint32_t OptimizeForPower;
    uint32_t FanThrottleTolerance;
    uint32_t ForcedThrottle;
    uint32_t MinThrottle;
    POWER_ACTION_POLICY OverThrottled;
};

struct joyinfo_tag
{
    uint32_t wXpos;
    uint32_t wYpos;
    uint32_t wZpos;
    uint32_t wButtons;
};

struct _wireSAFEARR_BSTR
{
    uint32_t Size;
    _FLAGGED_WORD_BLOB** aBstr;
};

struct HICON__
{
    int32_t unused;
};

struct _CERT_EXTENSION
{
    char* pszObjId;
    int32_t fCritical;
    _CRYPTOAPI_BLOB Value;
};

struct _CHANGER_SEND_VOLUME_TAG_INFORMATION
{
    _CHANGER_ELEMENT StartingElement;
    uint32_t ActionCode;
    uint32_t VolumeIDTemplate[40];
};

struct tagSOUNDSENTRYW
{
    uint32_t cbSize;
    uint32_t dwFlags;
    uint32_t iFSTextEffect;
    uint32_t iFSTextEffectMSec;
    uint32_t iFSTextEffectColorBits;
    uint32_t iFSGrafEffect;
    uint32_t iFSGrafEffectMSec;
    uint32_t iFSGrafEffectColor;
    uint32_t iWindowsEffect;
    uint32_t iWindowsEffectMSec;
    uint32_t* lpszWindowsEffectDLL;
    uint32_t iWindowsEffectOrdinal;
};

struct tagMCI_SET_PARMS
{
    uint32_t dwCallback;
    uint32_t dwTimeFormat;
    uint32_t dwAudio;
};

struct _CRL_ENTRY
{
    _CRYPTOAPI_BLOB SerialNumber;
    _FILETIME RevocationDate;
    uint32_t cExtension;
    _CERT_EXTENSION* rgExtension;
};

struct _OLESTREAM
{
    _OLESTREAMVTBL* lpstbl;
};

struct CoreNetCreateObjectMsg
{
    CoreHash oObjectName;
    CoreHash oScriptName;
    CoreHash oType;
    bool IsClientControlled;
    bool bPadding[3];

    void CoreNetCreateObjectMsg();
    void ~CoreNetCreateObjectMsg();
};

struct CoreFontRange
{
    uint32_t start;
    uint32_t end;
    uint32_t index;
};

struct tagMONCONVSTRUCT
{
    uint32_t cb;
    int32_t fConnect;
    uint32_t dwTime;
    void* hTask;
    HSZ__* hszSvc;
    HSZ__* hszTopic;
    HCONV__* hConvClient;
    HCONV__* hConvServer;
};

struct CoreTriStripper
{
    enum
    {
        MAX_TUNNEL = 75,
    };

    struct Triangle
    {
        int32_t iNumConnects;
        int32_t lpiConnects[8];
        bool lpbOn[8];
        bool bCollect;
        int32_t iNumOnConnects;
    };

    struct Tunnel
    {
        int32_t iLength;
        int32_t lpiNodes[75];
    };

    int32_t m_iNumTriangles;
    CoreTriStripper::Triangle* m_lpoTriangles;
    CoreMemory* m_lpoMemory;

    void CoreTriStripper();
    void ~CoreTriStripper();
    void Init();
    void InitTriangle();
    bool bConnect();
    void TriStrip();
    bool bCollectStrip();
    void CountUpConnects();
    bool IsConnectionOn();
    int32_t GetNumOnConnections();
    void Turn();
    void Flip();
    void FindTunnel();
};

struct CoreGameRenderInternalData
{
    CorePanel* lpoPanel;
    CoreLevel* lpoLevel;
    CoreWorld* lpoWorld;
    CoreObject* lplpoObjects[256];
    CoreObject* lplpoPanelObjects[32];
    CoreObject* lplpoBackgroundObjects[64];
    CoreObject* lplpoEffectObjects[64];
    CoreObject* lplpoBeforeLevelObjects[8];
    CoreObject* lplpoLastObjects[8];
    CoreConsole* lpoConsole;
    int32_t iNumBackgroundObjects;
    int32_t iNumPanelObjects;
    int32_t iNumObjects;
    int32_t iNumBeforeLevelObjects;
    int32_t iNumLastObjects;
    int32_t iNumEffectObjects;
    uint32_t ulDrawFlags;
    CoreVector quadStoreScale;
    QuadStore m_quadStore[1];
    uint32_t m_currentQuad;
    TriBatch m_triBatch[2];
    int32_t m_triBatchBuffer;
    int32_t iSelectedDebugObject1;
    int32_t iSelectedDebugObject2;
    float shadowDirX;
    float shadowDirY;
    float shadowDirZ;
    float shadowMaxLength;
    bool m_bLighting;
    bool shadowsOn;
    int32_t currentViewerObject;
    bool enableSplitScreen;

    void CoreGameRenderInternalData();
    void ~CoreGameRenderInternalData();
};

struct _IMAGE_FUNCTION_ENTRY
{
    uint32_t StartingAddress;
    uint32_t EndingAddress;
    uint32_t EndOfPrologue;
};

struct tagMEASUREITEMSTRUCT
{
    uint32_t CtlType;
    uint32_t CtlID;
    uint32_t itemID;
    uint32_t itemWidth;
    uint32_t itemHeight;
    uint32_t itemData;
};

struct _RPC_PROTSEQ_ENDPOINT
{
    uint32_t* RpcProtocolSequence;
    uint32_t* Endpoint;
};

struct IDummyHICONIncluder : IUnknown
{
    HRESULT __stdcall Dummy();
    void IDummyHICONIncluder();
};

struct CoreObjectController
{
    CoreObjectControllerInfo* m_lpoData;
    static int32_t s_memoryPoolSize;

    // TODO vtable

    void CoreObjectController();
    void ~CoreObjectController();
    void Construct(CoreMemory* lpoMemory);
    void Destruct(CoreMemory* lpoMemory);
    void Init();
    void Update(CoreWorldUpdateStruct* io_WorldUpdateStruct);
    void SetDefaultMemoryPoolSize();
    void RegisterTypes();
    void DoDebug();
    int32_t GetNumObjectTypes();
    CoreMemory* GetMemory();
    int32_t GetNumObjects();
    int32_t GetNumObjectsInType(int32_t i_type);
    int32_t GetMaxObjectsInType();
    int32_t GetObjectTypeByTypeHash(uint32_t i_hash);
    CoreObject* GetObjectByType(int32_t i_type, int32_t i_index);
    int32_t GetObjectNumberWithNameHash(CoreHash oNameHash);
    CoreObject* GetObjectByIndex(int32_t iIndex);
    CoreObject* GetObjectWithNameHash(CoreHash oNameHash);
    CoreObjectListNode* GetObjectListByProperty(uint32_t i_propertyIndex);
    CoreObject* GetPlayerObject();
    CoreObject* ServerCreateNamedObject(CoreHash oMsgType, void* lpMsg, int32_t iMsgLength, CoreObjectUpdateStruct* lpoUpdateStruct);
    CoreObject* ClientCreateNamedObject(CoreHash oMsgType, void* lpMsg, CoreObjectUpdateStruct* lpoUpdateStruct);
    void CreateDealWithExtendedData(CoreHash, CoreObject*, void*, CoreObjectUpdateStruct*);
    CoreObject* CreateNamedObject(CoreHash oObjectName, CoreHash oScriptName, CoreHash oType, CoreObjectUpdateStruct* lpoUpdateStruct);
    void DestroyObjects(CoreObjectUpdateStruct* lpoUpdateStruct);
    void SendServerObject(CoreObject* lpoObject, CoreObjectUpdateStruct* lpoUpdateStruct);
    void UpdateClientObject(void* lpData, CoreObjectUpdateStruct* lpoUpdateStruct);
    void UpdateSingleObject(CoreObjectUpdateStruct* i_updateStruct, CoreObject* i_object);
    void UpdateObjects(CoreObjectUpdateStruct* i_updateStruct);
    void PostEvent(CoreEvent& i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
    void ProcessEvents(CoreObjectUpdateStruct* io_UpdateStruct);
    void ProcessNetworkEvent(void* i_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void AddToRenderList(CoreGameRender* lpoGraphics);
    void SetPauseObjects(bool bPause);
    int32_t ComputeMemNeeded();
    CoreViewerObject* GetCurrentViewerObject();
    void SetCurrentViewerObject(CoreViewerObject* i_viewer);
    int32_t GetCurrentViewerObjectID();
    void SetCurrentViewerObjectID();
    void OnPostRender();
    CoreCutSceneObject* GetCutSceneObjectObject();
    int32_t GetNumCutSceneObjectObjects();
    CoreCutSceneObject* FindCutSceneObjectObject();
    CoreCutSceneObject* FindParentedCutSceneObjectObject();
    int32_t GetMaxCutSceneObjectObjects();
    CoreCutSceneCamera* GetCutSceneCameraObject();
    int32_t GetNumCutSceneCameraObjects();
    CoreCutSceneCamera* FindCutSceneCameraObject();
    CoreCutSceneCamera* FindParentedCutSceneCameraObject();
    int32_t GetMaxCutSceneCameraObjects();
    CoreViewerObject* GetViewerObject();
    int32_t GetNumViewerObjects();
    CoreViewerObject* FindViewerObject(CoreHash oName);
    CoreViewerObject* FindParentedViewerObject();
    int32_t GetMaxViewerObjects();
    CoreAudioLocatorObject* GetAudioLocatorObject(int32_t iIndex);
    int32_t GetNumAudioLocatorObjects();
    CoreAudioLocatorObject* FindAudioLocatorObject();
    CoreAudioLocatorObject* FindParentedAudioLocatorObject();
    int32_t GetMaxAudioLocatorObjects();
    void DestroyObject(int32_t i_index, CoreObjectUpdateStruct* i_updateStruct);
    void MakeObjectLists();
    void RegisterType(int32_t i_index, CoreHash oType, int32_t iMax, CoreObject** create);
    void SetNumObjectTypes(int32_t i_numTypes);
    void OnDestroyObject(CoreObject*, CoreObjectUpdateStruct*);
    void OnDestroyObjects(CoreObjectUpdateStruct*);
};

struct CoreCutSceneObject : CoreAnimatingObject
{
    CoreCutSceneObjectData* m_lpoData;
    CoreS128Aligned m_lpqwMemoryPot[384];

    void CoreCutSceneObject();
    void ~CoreCutSceneObject();
    void Construct(CoreMemory* lpoMemory);
    void Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
    CoreObject* Create(CoreMemory* lpoMemory);
    void Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Reset();
    CoreHash GetTypeID();
    float AnimTimeAdjust(float time);
    bool IsReady();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnWaitForStart();
    CoreScripted::CommandReturn eFnAnimate(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnDie();
    void SetPosOrientAndScaleFromKeys(CoreObjectUpdateStruct* lpoUpdateStruct, float fTime);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
};

struct CoreCutSceneCamera : CoreCameraObject
{
    CoreS128Aligned m_memoryPot[256];

    void CoreCutSceneCamera();
    void Construct(CoreMemory* io_memory);
    void UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
    void SetTarget();
    void SetDistance();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreScripted::CommandReturn FnDefaultCameraLogic();
    CoreScripted::CommandReturn DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    void ~CoreCutSceneCamera();
};

struct CoreAudioLocatorObject : CoreObject
{
    CoreS128Aligned m_lpqwMemoryPot[16];
    CoreAudioLocatorObjectData* m_Data;

    void CoreAudioLocatorObject();
    void ~CoreAudioLocatorObject();
    void Construct(CoreMemory* lpoMemory);
    void Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
    void Reset();
    void Update();
    CoreObject* Create(CoreMemory* lpoMemory);
    CoreHash GetTypeID();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetAudioObjectAndEvent(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetAutoStart();
    CoreScripted::CommandReturn FnStart();
    CoreScripted::CommandReturn FnStop();
    CoreScripted::CommandReturn FnTrigger();
    CoreScripted::CommandReturn FnUpdate(CoreCommand* io_command);
    void Start();
    void Stop();
    void Trigger();
    void SetCullByDistanceFlag();
    float GetMinDist();
    float GetMaxDist();
    uint32_t GetAudioEventHash();
    void DoDebug(CoreWorldUpdateStruct* i_worldUpdateStruct);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
};

struct CoreTextureAnimationInfo
{
    enum
    {
        VERSION = 1,
    };

    uint32_t m_countFrames;
    uint32_t m_offsetFrames;
    char m_debugName[16];

    void CoreTextureAnimationInfo();
    void ~CoreTextureAnimationInfo();
    uint32_t GetNumberOfFrames();
    CoreTextureAnimationFrameInfo* GetFrame();
    char* GetDebugName();
    void* GetOffset();
};

struct CoreTextureAnimationFrameInfo
{
    enum
    {
        VERSION = 1,
    };

    uint32_t m_textureHash;
    float m_duration;

    void CoreTextureAnimationFrameInfo();
    void ~CoreTextureAnimationFrameInfo();
    CoreHash GetTextureHash();
    float GetFrameDuration();
};

struct tagENUMLOGFONTW
{
    tagLOGFONTW elfLogFont;
    uint32_t elfFullName[64];
    uint32_t elfStyle[32];
};

struct midiproptimediv_tag
{
    uint32_t cbStruct;
    uint32_t dwTimeDiv;
};

struct _CRYPT_ALGORITHM_IDENTIFIER
{
    char* pszObjId;
    _CRYPTOAPI_BLOB Parameters;
};

struct _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO
{
    uint32_t cbSize;
    _CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
    void* pvKeyEncryptionAuxInfo;
    _CRYPT_ALGORITHM_IDENTIFIER KeyWrapAlgorithm;
    void* pvKeyWrapAuxInfo;
    uint32_t hCryptProv;
    uint32_t dwKeySpec;
    uint32_t dwKeyChoice;
    _CRYPT_ALGORITHM_IDENTIFIER* pEphemeralAlgorithm;
    _CERT_ID* pSenderId;
    _CRYPTOAPI_BLOB UserKeyingMaterial;
    uint32_t cRecipientEncryptedKeys;
    _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO** rgpRecipientEncryptedKeys;
};

struct _PRINTER_INFO_3
{
    void* pSecurityDescriptor;
};

struct IRpcHelper : IUnknown
{
    HRESULT __stdcall GetDCOMProtocolVersion();
    HRESULT __stdcall GetIIDFromOBJREF();
    void IRpcHelper();
};

struct _FORMAT_EX_PARAMETERS
{
    _MEDIA_TYPE MediaType;
    uint32_t StartCylinderNumber;
    uint32_t EndCylinderNumber;
    uint32_t StartHeadNumber;
    uint32_t EndHeadNumber;
    uint32_t FormatGapLength;
    uint32_t SectorsPerTrack;
    uint32_t SectorNumber[1];
};

struct tagCAL
{
    uint32_t cElems;
    int32_t* pElems;
};

struct _CREATE_THREAD_DEBUG_INFO
{
    void* hThread;
    void* lpThreadLocalBase;
    uint32_t* lpStartAddress;
};

struct tagMCI_VD_STEP_PARMS
{
    uint32_t dwCallback;
    uint32_t dwFrames;
};

struct tagEMRGLSRECORD
{
    tagEMR emr;
    uint32_t cbData;
    uint32_t Data[1];
};

struct CoreCollisionBall
{
    CorePhysicsVert m_vert;
    float m_radius;
    int32_t m_flag;
    float m_maxDepth;
    int32_t m_parentBodyWorldIndex;
    static CorePhysicsWorld* CorePhysicsWorldInstance;

    void CoreCollisionBall();
    int32_t collideWithFixedVert(CoreVector& vpos);
    int32_t collideWithFixedEdge(CoreVector& e0, CoreVector& e1);
    int32_t collideWithFixedTriangle(CoreVector& v0, CoreVector& v1, CoreVector& v2, CoreVector& normal);
    void collideWithBall(CoreCollisionBall& ball);
    int32_t getFlag();
    void setFlag();
    void updateSafePos();
    void ~CoreCollisionBall();
};

struct _IMAGE_SECTION_HEADER
{
    uint32_t Name[8];
    _IMAGE_SECTION_HEADER::__unnamed Misc;
    uint32_t VirtualAddress;
    uint32_t SizeOfRawData;
    uint32_t PointerToRawData;
    uint32_t PointerToRelocations;
    uint32_t PointerToLinenumbers;
    uint32_t NumberOfRelocations;
    uint32_t NumberOfLinenumbers;
    uint32_t Characteristics;
};

struct tagWAVEOUTCAPS2A
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t dwFormats;
    uint32_t wChannels;
    uint32_t wReserved1;
    uint32_t dwSupport;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct tagMCI_OVLY_WINDOW_PARMSW
{
    uint32_t dwCallback;
    HWND* hWnd;
    uint32_t nCmdShow;
    uint32_t* lpstrText;
};

struct _DOC_INFO_1W
{
    uint32_t* pDocName;
    uint32_t* pOutputFile;
    uint32_t* pDatatype;
};

struct CoreScript
{
    uint32_t GetExpectedScriptID();
    uint32_t GetExpectedScriptVersion();
    CoreHash GetScriptName();
    CoreHash GetParentName();
    bool HasValidID();
    uint32_t GetSize();
    CoreVariable* InitVariables(CoreScripted* io_object, CoreVariableStore* io_variableStore, int32_t& io_numVariables);
    void ResetVariables(CoreScripted* io_object);
    CoreScript* GetCommand(CoreCommand* o_command, CoreScripted* io_object, CoreProgramCounter* io_PC, CoreScriptUpdate* io_update);
    void NextCommand(CoreProgramCounter* io_PC);
    CoreScript* GetScript(CoreScriptStore* i_scriptStore, CoreHash i_scriptName);
    void CoreScript();
    void ReadCommand(CoreCommand* o_command, CoreScripted* io_object, CoreProgramCounter* io_PC, CoreScriptUpdate* io_update);
    uint32_t* FindState(CoreScripted* i_object, CoreVariableStore* i_variableStore);
    void ReadConditionParam(CoreVariable* o_var, int32_t& io_condRead, int32_t i_type, uint32_t* i_currentCond, CoreScripted* i_object, CoreVariableStore* i_variableStore);
    uint32_t* GetScriptBase();
    uint32_t* GetHeaderSection();
    uint32_t GetScriptNameHash();
    uint32_t GetParentNameHash();
    uint32_t GetID();
    uint32_t GetVersion();
    uint32_t GetTotalSize();
    uint32_t* GetVariablesSection();
    uint32_t* GetStatesSection();
    uint32_t* GetStringSection();
    uint32_t GetNumVariables();
    uint32_t* GetVariable();
    uint32_t GetVariableName();
    int32_t GetVariableType();
    void* GetVariableDefaultValuePointer();
    uint32_t GetNumStates();
    uint32_t* GetFirstState();
    uint32_t* GetNextState();
    uint32_t GetNumConditionBlocks();
    uint32_t* GetFirstConditionBlock();
    uint32_t* GetNextConditionBlock();
    uint32_t GetNumConditions();
    uint32_t* GetFirstCondition();
    int32_t GetConditionOpType();
    int32_t GetConditionLeftType();
    int32_t GetConditionRightType();
    uint32_t GetConditionParam();
    uint32_t* GetCurrentCommand();
    uint32_t GetCommandSize();
    uint32_t GetCommandFunction();
    int32_t GetCommandReturnType();
    int32_t GetCommandSpecialFlags();
    int32_t GetCommandParamType();
    uint32_t GetCommandParam();
    char* GetString();
    CoreHash GetHash(uint32_t i_value);
};

struct CoreProgramCounter
{
    CoreHash m_currentScriptName;
    uint32_t m_currentPosition;
    uint32_t m_repeatPosition;

    void CoreProgramCounter();
    void ~CoreProgramCounter();
    void Reset();
    CoreScript* GetCurrentScript(CoreScriptStore* i_scriptStore);
    CoreHash GetCurrentScriptName();
    uint32_t GetCurrentPosition();
    bool IsReset();
    void SetCurrentScript(CoreHash i_scriptName);
    void SetCurrentPosition(uint32_t i_position);
    void SetRepeatPosition(uint32_t i_position);
    void JumpToRepeatPosition();
};

struct tagBITMAP
{
    int32_t bmType;
    int32_t bmWidth;
    int32_t bmHeight;
    int32_t bmWidthBytes;
    uint32_t bmPlanes;
    uint32_t bmBitsPixel;
    void* bmBits;
};

struct _CONSOLE_FONT_INFO
{
    uint32_t nFont;
    _COORD dwFontSize;
};

struct _CRYPT_X942_OTHER_INFO
{
    char* pszContentEncryptionObjId;
    uint32_t rgbCounter[4];
    uint32_t rgbKeyLength[4];
    _CRYPTOAPI_BLOB PubInfo;
};

struct IRpcStubBuffer : IUnknown
{
    HRESULT __stdcall Connect();
    void __stdcall Disconnect();
    HRESULT __stdcall Invoke();
    IRpcStubBuffer* __stdcall IsIIDSupported();
    uint32_t __stdcall CountRefs();
    HRESULT __stdcall DebugServerQueryInterface();
    void __stdcall DebugServerRelease();
    void IRpcStubBuffer();
};

struct tagSTGOPTIONS
{
    uint32_t usVersion;
    uint32_t reserved;
    uint32_t ulSectorSize;
    uint32_t* pwcsTemplateFile;
};

struct _DISCDLGSTRUCTW
{
    uint32_t cbStructure;
    HWND* hwndOwner;
    uint32_t* lpLocalName;
    uint32_t* lpRemoteName;
    uint32_t dwFlags;
};

struct tagWAVEOUTCAPS2W
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t dwFormats;
    uint32_t wChannels;
    uint32_t wReserved1;
    uint32_t dwSupport;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct truespeechwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wRevision;
    uint32_t nSamplesPerBlock;
    uint32_t abReserved[28];
};

struct tagLOCALESIGNATURE
{
    uint32_t lsUsb[4];
    uint32_t lsCsbDefault[2];
    uint32_t lsCsbSupported[2];
};

struct tagVersionedStream
{
    _GUID guidVersion;
    IStream* pStream;
};

struct _JOBOBJECT_BASIC_PROCESS_ID_LIST
{
    uint32_t NumberOfAssignedProcesses;
    uint32_t NumberOfProcessIdsInList;
    uint32_t ProcessIdList[1];
};

struct _REMSECURITY_ATTRIBUTES
{
    uint32_t nLength;
    uint32_t lpSecurityDescriptor;
    int32_t bInheritHandle;
};

struct CAL1_Sample : CAL1_AudioPlayback
{
    enum ASampleDataFormat
    {
        ASampleDataFormat_None,
        ASampleDataFormat_PCM,
        ASampleDataFormat_PC_ADPCM,
        ASampleDataFormat_PS2_ADPCM,
        ASampleDataFormat_XBOX_PCM,
        ASampleDataFormat_XBOX_ADPCM,
    };

    enum ASampleStatus
    {
        ASampleStatus_Stopped,
        ASampleStatus_Starting,
        ASampleStatus_Playing,
        ASampleStatus_Paused,
        ASampleStatus_Ending,
    };

    enum ASamplePlaybackType
    {
        ASamplePlaybackType_Memory,
        ASamplePlaybackType_StreamedFromMemory,
        ASamplePlaybackType_StreamedFromFile,
    };

    CAL1_AudioStreamer* m_Streamer;
    CAL1_Sample* m_NextSample;
    CAL1_Sample* m_PrevSample;
    CAL1_Sample* m_GhostSample;
    char* m_StreamFileName;
    uint32_t* m_SampleData;
    char* m_FileName;
    uint32_t m_DataLength;
    uint32_t m_BaseFrequency;
    uint32_t m_StreamStartOffset;
    uint32_t m_StreamEndOffset;
    uint32_t m_StreamLocation;
    uint32_t m_syncCount;
    uint32_t m_LanguageMask;
    ca_fixed m_DopplerFactor;
    uint32_t m_Channel;
    uint32_t m_BaseVolume;
    int32_t m_Pan;
    uint32_t m_3DDistanceAttn;
    int32_t m_3DPanPosition;
    int32_t m_3DPanPositionFR;
    uint32_t m_DataFormat;
    uint32_t m_BitsPerSample;
    uint32_t m_PlaybackType;
    uint32_t m_NumberOfChannels;
    bool m_OwnSampleData;
    bool m_Loop;
    bool m_FileExists;
    bool m_WaitingToStream;
    ca_fixed m_BaseFrequencyFactor;

    void CAL1_Sample();
    void ~CAL1_Sample();
    CAAudioError Tick();
    bool IsPlaying();
    bool IsDeferred();
    ca_fixed GetBaseFrequencyFactor();
    CAAudioError SetBaseFrequencyFactor();
    CAAudioError TransferToSRAM();
    CAAudioError SetDopplerFactor();
    CAAudioError SetBasePan();
    CAAudioError SetBaseVolume();
    CAAudioError Set3DPanPosition();
    CAAudioError Set3DDistanceAttn();
    CAAudioError Set3DParams();
    CAAudioError SetDataFormat(CAL1_Sample::ASampleDataFormat dataFormat);
    CAAudioError SetBitsPerSample();
    CAAudioError SetBaseFrequency();
    CAAudioError SetGhostSample();
    CAAudioError SetSampleData(uint32_t* data, uint32_t length, bool owned);
    CAAudioError SetChannel();
    CAAudioError SetStreamFileName();
    CAAudioError SetStreamStartOffset(uint32_t startOffset);
    CAAudioError SetStreamEndOffset(uint32_t endOffset);
    CAAudioError SetStreamLocation(uint32_t streamLocation);
    CAAudioError SetNumberOfChannels();
    CAAudioError SetLoop(bool loop);
    CAAudioError SetFileExists();
    CAAudioError SetPlaybackType(CAL1_Sample::ASamplePlaybackType playbackType);
    CAAudioError SetAudioDriver();
    CAAudioError SetNextSample();
    CAAudioError SetPrevSample();
    CAAudioError SetWaitingToStream(bool waiting);
    CAAudioError SetLanguageMask();
    CAAudioError SetFileName(uint32_t* filename);
    CAAudioError ResetStreamer();
    CAL1_Sample::ASampleDataFormat GetDataFormat();
    uint32_t GetBitsPerSample();
    uint32_t GetBaseFrequency();
    CAL1_Sample* GetGhostSample();
    uint32_t* GetSampleData();
    uint32_t GetDataLength();
    CAL1_Sample::ASamplePlaybackType GetPlaybackType();
    uint32_t GetChannelNumber();
    uint32_t GetBaseVolume();
    int32_t GetBasePan();
    ca_fixed GetDopplerFactor();
    uint32_t Get3DDistanceAttn();
    int32_t Get3DPanPosition();
    int32_t Get3DPanPositionFR();
    char* GetStreamFileName();
    uint32_t GetStreamStartOffset();
    uint32_t GetStreamEndOffset();
    uint32_t GetStreamLocation();
    uint32_t GetNumberOfChannels();
    bool GetLoop();
    bool GetFileExists();
    CAL1_Sample* GetNextSample();
    CAL1_Sample* GetPrevSample();
    CAL1_AudioStreamer* GetStreamer();
    uint32_t GetLanguageMask();
    char* GetFileName();
    bool GetWaitingToStream();
    CAAudioError Update();
    void SetAudioData(CAL1_AudioData* data, uint32_t mixVolume);
    CAAudioError Pause();
    CAAudioError Resume();
    uint32_t RestoreData(uint32_t* memPtr);
    CAAudioError LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
    CAAudioError SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
    CAAudioError End();
    CAAudioError Start();
    CAAudioError DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* i_AID);
    CAAudioError DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
};

struct IMalloc : IUnknown
{
    void* __stdcall Alloc();
    void* __stdcall Realloc();
    void __stdcall Free();
    uint32_t __stdcall GetSize();
    int32_t __stdcall DidAlloc();
    void __stdcall HeapMinimize();
    void IMalloc();
};

struct IInternetSecurityMgrSite : IUnknown
{
    HRESULT __stdcall GetWindow();
    HRESULT __stdcall EnableModeless();
    void IInternetSecurityMgrSite();
};

struct IDirectSoundCaptureBuffer : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetCaps();
    HRESULT __stdcall GetCurrentPosition();
    HRESULT __stdcall GetFormat();
    HRESULT __stdcall GetStatus();
    HRESULT __stdcall Initialize();
    HRESULT __stdcall Lock();
    HRESULT __stdcall Start();
    HRESULT __stdcall Stop();
    HRESULT __stdcall Unlock();
    void IDirectSoundCaptureBuffer();
};

struct tagNEWTEXTMETRICA
{
    int32_t tmHeight;
    int32_t tmAscent;
    int32_t tmDescent;
    int32_t tmInternalLeading;
    int32_t tmExternalLeading;
    int32_t tmAveCharWidth;
    int32_t tmMaxCharWidth;
    int32_t tmWeight;
    int32_t tmOverhang;
    int32_t tmDigitizedAspectX;
    int32_t tmDigitizedAspectY;
    uint32_t tmFirstChar;
    uint32_t tmLastChar;
    uint32_t tmDefaultChar;
    uint32_t tmBreakChar;
    uint32_t tmItalic;
    uint32_t tmUnderlined;
    uint32_t tmStruckOut;
    uint32_t tmPitchAndFamily;
    uint32_t tmCharSet;
    uint32_t ntmFlags;
    uint32_t ntmSizeEM;
    uint32_t ntmCellHeight;
    uint32_t ntmAvgWidth;
};

struct tagSTYLEBUFA
{
    uint32_t dwStyle;
    char szDescription[32];
};

struct IDirectSoundCaptureFXAec : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    HRESULT __stdcall GetStatus();
    HRESULT __stdcall Reset();
    void IDirectSoundCaptureFXAec();
};

struct CAL1_AudioEvent : CAL1_AudioPlayback
{
    enum AEventPlaybackType
    {
        AEventPlaybackType_3D,
        AEventPlaybackType_2D,
    };

    CAL1_AudioPlayback* m_PlayingItem;
    uint32_t* m_Grid;
    CAL0_List* m_PlaybackList;
    uint32_t m_NumGridEntries;
    uint32_t m_GridPosition;
    CAL1_AudioEvent::AEventPlaybackType m_EventPlaybackType;
    bool m_UseParameter;
    bool m_Used;

    void CAL1_AudioEvent();
    void ~CAL1_AudioEvent();
    bool GetUseParameter();
    CAAudioError SetUseParameter();
    uint32_t GetGridEntry();
    CAAudioError SetGridEntry();
    CAAudioError SetGridPosition(uint32_t gridPosition);
    uint32_t GetGridPosition();
    uint32_t GetNumGridEntries();
    CAAudioError SetNumGridEntries(uint32_t numGridEntries);
    CAL1_AudioEvent::AEventPlaybackType GetEventPlaybackType();
    CAL1_AudioEvent::AEventPlaybackType SetEventPlaybackType();
    bool GetUsed();
    bool SetUsed();
    CAAudioError AddPlaybackEvent();
    CAAudioError AddPlaybackLink();
    CAAudioError Start();
    CAAudioError End();
    CAAudioError Update();
    CAAudioError Trigger();
    bool IsPlaying();
    uint32_t GetSaveDataCount();
    uint32_t SaveData(uint32_t* memPtr);
    uint32_t RestoreData(uint32_t* memPtr);
    CAAudioError LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
    CAAudioError SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
    CAAudioError DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* aid);
    CAAudioError DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
};

struct ICodeInstall : IWindowForBindingUI
{
    HRESULT __stdcall OnCodeInstallProblem();
    void ICodeInstall();
};

struct tagCAUH
{
    uint32_t cElems;
    _ULARGE_INTEGER* pElems;
};

struct type_info
{
};

struct IRecordInfo : IUnknown
{
    HRESULT __stdcall RecordInit();
    HRESULT __stdcall RecordClear();
    HRESULT __stdcall RecordCopy();
    HRESULT __stdcall GetGuid();
    HRESULT __stdcall GetName();
    HRESULT __stdcall GetSize();
    HRESULT __stdcall GetTypeInfo();
    HRESULT __stdcall GetField();
    HRESULT __stdcall GetFieldNoCopy();
    HRESULT __stdcall PutField();
    HRESULT __stdcall PutFieldNoCopy();
    HRESULT __stdcall GetFieldNames();
    int32_t __stdcall IsMatchingType();
    void* __stdcall RecordCreate();
    HRESULT __stdcall RecordCreateCopy();
    HRESULT __stdcall RecordDestroy();
    void IRecordInfo();
};

struct NUMPARSE
{
    int32_t cDig;
    uint32_t dwInFlags;
    uint32_t dwOutFlags;
    int32_t cchUsed;
    int32_t nBaseShift;
    int32_t nPwr10;
};

struct CoreSubTypeDebugName
{
    uint32_t m_cName[16];
};

struct tagFINDREPLACEW
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    HINSTANCE__* hInstance;
    uint32_t Flags;
    uint32_t* lpstrFindWhat;
    uint32_t* lpstrReplaceWith;
    uint32_t wFindWhatLen;
    uint32_t wReplaceWithLen;
    int32_t lCustData;
    uint32_t* lpfnHook;
    uint32_t* lpTemplateName;
};

struct CoreFXLibrary
{
    CoreHashTable m_RegisteredCmdLists;
    CoreHashTable m_RegisteredItemLists;
    CoreHashTable m_RegisteredItemListNames;
    CoreHashTable m_RegisteredItemControlFunctions;
    uint32_t m_ItemGroupIterator;
    CoreMemory* m_pMemPool;
    static CoreFXLibrary* m_pInstance;

    // TODO vtable

    void CoreFXLibrary();
    void ~CoreFXLibrary();
    void Construct(CoreMemory* pMemPool);
    void Destruct();
    void RegisterFXCommands();
    int32_t* GetRegisteredCommandList(CoreHash hName);
    uint32_t ExtractFromCommandList(int32_t* pCmd, uint32_t fxCmd);
    CoreHash FindRegisteredCommandListName();
    char* GetControlListName();
    CoreFXLibrary* CreateInstance(CoreMemory* pMemPool);
    void RegisterCommandList(char* pName, int32_t* pCmd);
    void Update();
    void RegisterItemGroup(char* pName, CoreFXEmitterItem* pItemGroup, void* i_controlFunction);
    CoreFXEmitterItem* GetRegisteredItemGroup(CoreHash hName);
    char* GetFirstItemGroup();
    char* GetNextItemGroup();
    CoreHash GetRegisteredItemGroupHash(uint32_t iIndex);
    uint32_t GetRegisteredItemGroupIndex(CoreHash iName);
    void* GetRegisteredItemControlFunction(CoreHash hName);
};

struct tagSIZE
{
    int32_t cx;
    int32_t cy;
};

struct _PERF_OBJECT_TYPE
{
    uint32_t TotalByteLength;
    uint32_t DefinitionLength;
    uint32_t HeaderLength;
    uint32_t ObjectNameTitleIndex;
    uint32_t* ObjectNameTitle;
    uint32_t ObjectHelpTitleIndex;
    uint32_t* ObjectHelpTitle;
    uint32_t DetailLevel;
    uint32_t NumCounters;
    int32_t DefaultCounter;
    int32_t NumInstances;
    uint32_t CodePage;
    _LARGE_INTEGER PerfTime;
    _LARGE_INTEGER PerfFreq;
};

struct IMarshal : IUnknown
{
    HRESULT __stdcall GetUnmarshalClass();
    HRESULT __stdcall GetMarshalSizeMax();
    HRESULT __stdcall MarshalInterface();
    HRESULT __stdcall UnmarshalInterface();
    HRESULT __stdcall ReleaseMarshalData();
    HRESULT __stdcall DisconnectObject();
    void IMarshal();
};

struct CoreTexturePageCommon : CoreTexturePage
{
    uint32_t m_image[1];

    void CoreTexturePageCommon();
    void ~CoreTexturePageCommon();
    uint32_t* GetImage32();
};

struct CoreMapFileDataHandler
{
    uint32_t* m_data;
    int32_t m_dataSize;

    void CoreMapFileDataHandler();
    void* Get();
    void* Set();
    int32_t GetSize();
    void Copy();
};

struct _CMSG_KEY_TRANS_RECIPIENT_INFO
{
    uint32_t dwVersion;
    _CERT_ID RecipientId;
    _CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
    _CRYPTOAPI_BLOB EncryptedKey;
};

struct IDirectSoundBuffer8 : IDirectSoundBuffer
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetCaps();
    HRESULT __stdcall GetCurrentPosition();
    HRESULT __stdcall GetFormat();
    HRESULT __stdcall GetVolume();
    HRESULT __stdcall GetPan();
    HRESULT __stdcall GetFrequency();
    HRESULT __stdcall GetStatus();
    HRESULT __stdcall Initialize();
    HRESULT __stdcall Lock();
    HRESULT __stdcall Play();
    HRESULT __stdcall SetCurrentPosition();
    HRESULT __stdcall SetFormat();
    HRESULT __stdcall SetVolume();
    HRESULT __stdcall SetPan();
    HRESULT __stdcall SetFrequency();
    HRESULT __stdcall Stop();
    HRESULT __stdcall Unlock();
    HRESULT __stdcall Restore();
    HRESULT __stdcall SetFX();
    HRESULT __stdcall AcquireResources();
    HRESULT __stdcall GetObjectInPath();
    void IDirectSoundBuffer8();
};

struct _DSCEFFECTDESC
{
    uint32_t dwSize;
    uint32_t dwFlags;
    _GUID guidDSCFXClass;
    _GUID guidDSCFXInstance;
    uint32_t dwReserved1;
    uint32_t dwReserved2;
};

struct _CRYPT_PRIVATE_KEY_INFO
{
    uint32_t Version;
    _CRYPT_ALGORITHM_IDENTIFIER Algorithm;
    _CRYPTOAPI_BLOB PrivateKey;
    _CRYPT_ATTRIBUTES* pAttributes;
};

struct IForegroundTransfer : IUnknown
{
    HRESULT __stdcall AllowForegroundTransfer();
    void IForegroundTransfer();
};

struct CoreStringBuffer<6>
{
    char m_buffer[6];

    void CoreStringBuffer<6>();
    void Clear();
    char* operator const char *();
    char* GetString();
    uint32_t GetLength();
    uint32_t GetMaxLength();
    bool IsSame();
    bool IsSameIgnoreCase();
    void operator=();
    void Copy();
    void NCopy();
    void Cat();
    void ToUpper();
    void ToLower();
    float ToFloat();
    int32_t ToInt();
    int32_t FindChar();
    int32_t ReverseFindChar();
    int32_t VSPrint();
    int32_t SPrint();
    int32_t CatPrint();
};

struct audiofile_af10waveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct _tagPROTOCOLFILTERDATA
{
    uint32_t cbSize;
    IInternetProtocolSink* pProtocolSink;
    IInternetProtocol* pProtocol;
    IUnknown* pUnk;
    uint32_t dwFilterFlags;
};

struct _ldiv_t
{
    int32_t quot;
    int32_t rem;
};

struct CoreMapFileFunctionParameter
{
    uint32_t m_parameters_STLU;
};

struct CoreF32AnimKeyData
{
    float m_fTime;
    float m_fValue;
    float m_Tangent;
};

struct tagBITMAPFILEHEADER
{
    uint32_t bfType;
    uint32_t bfSize;
    uint32_t bfReserved1;
    uint32_t bfReserved2;
    uint32_t bfOffBits;
};

struct _SERVICE_DESCRIPTIONW
{
    uint32_t* lpDescription;
};

struct CoreProcessorCycles
{
    // TODO vtable

    uint32_t Get();
    void CoreProcessorCycles();
    void YouCannotInstanceThisClass();
};

struct _IMAGE_NT_HEADERS64
{
    uint32_t Signature;
    _IMAGE_FILE_HEADER FileHeader;
    _IMAGE_OPTIONAL_HEADER64 OptionalHeader;
};

struct _WGLSWAP
{
    HDC__* hdc;
    uint32_t uiFlags;
};

struct tagCASCODE
{
    uint32_t cElems;
    int32_t* pElems;
};

struct _iobuf
{
    char* _ptr;
    int32_t _cnt;
    char* _base;
    int32_t _flag;
    int32_t _file;
    int32_t _charbuf;
    int32_t _bufsiz;
    char* _tmpfname;
};

struct _FIXED
{
    uint32_t fract;
    int32_t value;
};

struct CoreModelMatrixPalette
{
    enum
    {
        VERSION = 2,
    };

    int32_t m_iMeshGroupOffset;
    CoreMeshMatrixPalette m_oMatrixPalette;

    void CoreModelMatrixPalette();
    void ~CoreModelMatrixPalette();
    CoreMeshMatrixPalette* GetMeshMatrixPalettePtr();
    uint32_t* GetMatrixPalette();
    uint32_t GetNumPaletteEntries();
    CoreMeshGroup* GetMeshGroupPtr();
    int32_t* GetModelMeshIndexTable();
};

struct IEnumUnknown : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumUnknown();
};

struct creative_fastspeechformat_tag
{
    tWAVEFORMATEX ewf;
};

struct stat
{
    uint32_t st_dev;
    uint32_t st_ino;
    uint32_t st_mode;
    int32_t st_nlink;
    int32_t st_uid;
    int32_t st_gid;
    uint32_t st_rdev;
    int32_t st_size;
    int32_t st_atime;
    int32_t st_mtime;
    int32_t st_ctime;
};

struct pcmwaveformat_tag
{
    waveformat_tag wf;
    uint32_t wBitsPerSample;
};

struct _CMC_DATA_INFO
{
    uint32_t cTaggedAttribute;
    _CMC_TAGGED_ATTRIBUTE* rgTaggedAttribute;
    uint32_t cTaggedRequest;
    _CMC_TAGGED_REQUEST* rgTaggedRequest;
    uint32_t cTaggedContentInfo;
    _CMC_TAGGED_CONTENT_INFO* rgTaggedContentInfo;
    uint32_t cTaggedOtherMsg;
    _CMC_TAGGED_OTHER_MSG* rgTaggedOtherMsg;
};

struct IPersistMoniker : IUnknown
{
    HRESULT __stdcall GetClassID();
    HRESULT __stdcall IsDirty();
    HRESULT __stdcall Load();
    HRESULT __stdcall Save();
    HRESULT __stdcall SaveCompleted();
    HRESULT __stdcall GetCurMoniker();
    void IPersistMoniker();
};

struct oliadpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct _PSINJECTDATA
{
    uint32_t DataBytes;
    uint32_t InjectionPoint;
    uint32_t PageNumber;
};

struct DDEDATA
{
    uint32_t unused : 12;
    uint32_t fResponse : 1;
    uint32_t fRelease : 1;
    uint32_t reserved : 1;
    uint32_t fAckReq : 1;
    int32_t cfFormat;
    uint32_t Value[1];
};

struct _RGNDATA
{
    _RGNDATAHEADER rdh;
    char Buffer[1];
};

struct _CRYPT_DECODE_PARA
{
    uint32_t cbSize;
    void** pfnAlloc;
    void* pfnFree;
};

struct _tagHIT_LOGGING_INFO
{
    uint32_t dwStructSize;
    char* lpszLoggedUrlName;
    _SYSTEMTIME StartTime;
    _SYSTEMTIME EndTime;
    char* lpszExtendedInfo;
};

struct CAL1_AudioDriverMenuPC
{
    CAL1_AudioDriverConfigPC* m_Config;

    // TODO vtable

    void CAL1_AudioDriverMenuPC();
    void ~CAL1_AudioDriverMenuPC();
    bool GetEnableEnableAudio();
    void SetUseWindowsDefaultDevice();
    bool GetCheckUseWindowsDefaultDevice();
    bool GetEnableUseWindowsDefaultDevice();
    bool GetCheckEnableAudio();
    bool GetEnableSelectAudioDevice();
    bool GetEnableAudioSettings();
    void SetCheckEnableAudio();
    void SelectDeviceIndex();
    int32_t GetCurrentDeviceIndex();
    CAL1_AudioRegistryEntry* GetCurrentRegistryEntry();
    CAL1_AudioDriverConfigPC* GetConfig();
};

struct CorePCBuildSystemFileDevice : CoreBuildSystemInterfaceUsingNamedPipe
{
    bool CompleteTheFileName(char* i_fileName, CoreStringBuffer<256>& o_fileName);
    void CorePCBuildSystemFileDevice();
    void ~CorePCBuildSystemFileDevice();
};

struct IXMLDOMCDATASection : IXMLDOMText
{
    void IXMLDOMCDATASection();
};

struct tagEMREXTFLOODFILL
{
    tagEMR emr;
    _POINTL ptlStart;
    uint32_t crColor;
    uint32_t iMode;
};

struct tagMIXERCONTROLW
{
    uint32_t cbStruct;
    uint32_t dwControlID;
    uint32_t dwControlType;
    uint32_t fdwControl;
    uint32_t cMultipleItems;
    uint32_t szShortName[16];
    uint32_t szName[64];
    tagMIXERCONTROLW::__unnamed Bounds;
    tagMIXERCONTROLW::__unnamed Metrics;
};

struct _ACCESS_ALLOWED_CALLBACK_ACE
{
    _ACE_HEADER Header;
    uint32_t Mask;
    uint32_t SidStart;
};

struct digifixwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct CorePhysicsBody
{
    CoreVector m_min;
    CoreVector m_max;
    CoreVector m_cog;
    CoreVector m_acc;
    CoreVector m_imp;
    CoreVector m_oldPos;
    CoreVector m_curPos;
    CoreVector m_animPos;
    CoreMatrix m_oldMatrix;
    CoreMatrix m_curMatrix;
    CoreMatrix m_animMatrix;
    CorePhysicsVert* m_pVerts;
    int32_t m_pVertsNum;
    CorePhysicsRod* m_pRods;
    int32_t m_pRodsNum;
    CoreCollisionBall* m_collisionBalls;
    int32_t m_collisionBallsNum;
    float m_radius;
    float m_prevTimeStep;
    float m_mass;
    int32_t m_material;
    int32_t m_limbID;
    int32_t m_objectID;
    int32_t m_safeFlag;
    int32_t m_activeFlag;
    int32_t m_lagFlag;
    CorePhysicsVert* m_pVerts_mem;

    void CorePhysicsBody();
    void initialize(CoreMemory* mem, CorePhysicsWorld* pWorld, CoreSingleCollidable* collidables, int32_t numCollidables, int32_t objID);
    void destroy(CoreMemory* mem, CorePhysicsWorld* pWorld);
    void setUp(CoreMatrix& matrix);
    void setCur(CoreMatrix& matrix, float velScale);
    void calcCurPosRot();
    void getUp(CoreMatrix& newMat);
    void getUpOld();
    void clearAcc();
    void addAcc(CoreVector& acc);
    CoreVector getAcc();
    void integrate(float timeStep, float velDamp);
    CoreVector getRelToCur(CoreVector& rel);
    CoreVector getRelToOld(CoreVector& rel);
    CoreVector getCurToRel(CoreVector& cur);
    void calcSafeFlag(float threshold);
    void updateCollisionPrims();
    void updateCollisionPrimsLag();
    void drawCollisionPrims(CoreRGBA drawColour, CoreRGBA oldColour);
    int32_t insideCollisionPrims();
    int32_t collide();
    void drawRods();
    void resolveRods();
    void resolveConstraintA(CorePhysicsConstraint* con, float massB);
    void resolveConstraintB(CorePhysicsConstraint* con, float massA);
    void resolveConstraints(CorePhysicsConstraint* fixedCon, CorePhysicsConstraint* freeCon, int32_t bIndex);
    void ~CorePhysicsBody();
};

struct CoreGsGParam
{
    int32_t CoreGsInterMode;
    int32_t CoreGsOutMode;
    int32_t CoreGsFFMode;
    int32_t CoreGsVersion;
    int32_t* CoreGsVSCfunc;
    int32_t CoreGsVSCid;
};

struct _EVENTLOG_FULL_INFORMATION
{
    uint32_t dwFull;
};

struct tagWAVEINCAPS2W
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t dwFormats;
    uint32_t wChannels;
    uint32_t wReserved1;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO
{
    uint32_t cbSize;
    _CMSG_SIGNED_ENCODE_INFO SignedInfo;
    _CMSG_ENVELOPED_ENCODE_INFO EnvelopedInfo;
};

struct IEnumOLEVERB : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumOLEVERB();
};

struct AsyncIAdviseSink2 : AsyncIAdviseSink
{
    void __stdcall Begin_OnLinkSrcChange();
    void __stdcall Finish_OnLinkSrcChange();
    void AsyncIAdviseSink2();
};

struct CoreGeometryCompiledPSPDynamicLitMeshVertex
{
    uint32_t u16;
    uint32_t v16;
    float nx32;
    float ny32;
    float nz32;
    float x32;
    float y32;
    float z32;
};

struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS
{
    uint32_t cbSize;
    int32_t fCommercial;
};

struct _ADAPTER_STATUS
{
    uint32_t adapter_address[6];
    uint32_t rev_major;
    uint32_t reserved0;
    uint32_t adapter_type;
    uint32_t rev_minor;
    uint32_t duration;
    uint32_t frmr_recv;
    uint32_t frmr_xmit;
    uint32_t iframe_recv_err;
    uint32_t xmit_aborts;
    uint32_t xmit_success;
    uint32_t recv_success;
    uint32_t iframe_xmit_err;
    uint32_t recv_buff_unavail;
    uint32_t t1_timeouts;
    uint32_t ti_timeouts;
    uint32_t reserved1;
    uint32_t free_ncbs;
    uint32_t max_cfg_ncbs;
    uint32_t max_ncbs;
    uint32_t xmit_buf_unavail;
    uint32_t max_dgram_size;
    uint32_t pending_sess;
    uint32_t max_cfg_sess;
    uint32_t max_sess;
    uint32_t max_sess_pkt_size;
    uint32_t name_count;
};

struct _CPS_URLS
{
    uint32_t* pszURL;
    _CRYPT_ALGORITHM_IDENTIFIER* pAlgorithm;
    _CRYPTOAPI_BLOB* pDigest;
};

struct _CRYPT_SEQUENCE_OF_ANY
{
    uint32_t cValue;
    _CRYPTOAPI_BLOB* rgValue;
};

struct CoreTextureOverride
{
    uint32_t baseTexture;
    uint32_t newTexture;
    int32_t textureSetIndex;
    CoreTextureSet* textureSet;
};

struct _SECURITY_DESCRIPTOR
{
    uint32_t Revision;
    uint32_t Sbz1;
    uint32_t Control;
    void* Owner;
    void* Group;
    _ACL* Sacl;
    _ACL* Dacl;
};

struct HRGN__
{
    int32_t unused;
};

struct tagPARAMDATA
{
    uint32_t* szName;
    uint32_t vt;
};

struct _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO
{
    _CRYPT_ALGORITHM_IDENTIFIER EncryptionAlgorithm;
    _CRYPTOAPI_BLOB EncryptedPrivateKey;
};

struct sonarcwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wCompType;
};

struct CoreGsUv
{
    uint32_t U : 14;
    uint32_t pad14 : 2;
    uint32_t V : 14;
    uint32_t pad30 : 34;
};

struct _IMAGE_RESOURCE_DIR_STRING_U
{
    uint32_t Length;
    uint32_t NameString[1];
};

struct _USER_MARSHAL_CB
{
    uint32_t Flags;
    _MIDL_STUB_MESSAGE* pStubMsg;
    uint32_t* pReserve;
    uint32_t Signature;
    _USER_MARSHAL_CB_TYPE CBType;
    uint32_t* pFormat;
    uint32_t* pTypeFormat;
};

struct CoreMeshGroupPS
{
    uint32_t m_uiNumMeshes;
    int32_t m_iModelMeshIndexTable[1];

    void CoreMeshGroupPS();
    void ~CoreMeshGroupPS();
    CoreModelMesh* GetModelMeshPtr();
    uint32_t GetNumMeshes();
    int32_t* GetModelMeshIndexTable();
};

struct __stat64
{
    uint32_t st_dev;
    uint32_t st_ino;
    uint32_t st_mode;
    int32_t st_nlink;
    int32_t st_uid;
    int32_t st_gid;
    uint32_t st_rdev;
    int32_t st_size;
    int32_t st_atime;
    int32_t st_mtime;
    int32_t st_ctime;
};

struct _CERT_REGISTRY_STORE_CLIENT_GPT_PARA
{
    HKEY__* hKeyBase;
    uint32_t* pwszRegPath;
};

struct IWinInetInfo : IUnknown
{
    HRESULT __stdcall QueryOption();
    void IWinInetInfo();
};

struct tagTTPOLYCURVE
{
    uint32_t wType;
    uint32_t cpfx;
    tagPOINTFX apfx[1];
};

struct IDirectSoundFXDistortion : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    void IDirectSoundFXDistortion();
};

struct CoreXMLParser
{
    char* m_pFile;
    uint32_t m_size;
    bool* StartTAGCallback;
    bool* EndTAGCallback;
    bool* CHARCallback;
    bool* CommentCallback;
    char* m_pCurr;
    uint32_t m_remain;
    char* m_szError;
    uint32_t m_lString;
    char* m_szString;
    uint32_t m_maxString;
    uint32_t m_cString;
    char* m_pTempCurr;
    uint32_t m_cDump;
    char* m_szDump;
    uint32_t m_cAtt;
    char** m_szAtt;
    CoreMemory* m_pMemory;

    void CoreXMLParser();
    void ~CoreXMLParser();
    char* OpenMem();
    uint32_t Close();
    void SetMemory();
    void RegisterStartTagCallback();
    void RegisterEndTagCallback();
    void RegisterCDataCallback();
    void RegisterCommentCallback();
    void OnStartElement();
    void OnEndElement();
    void OnCharacterData();
    void OnComment();
    bool ParseFile();
    void ResizeString();
    bool SkipToValidData();
    bool SkipOneChar();
    bool HandleOpenTag();
    bool HandleExlamationData();
    bool HandleQuestionData();
    bool HandleCData();
    bool ParseError();
    bool ValidateCharAlpha();
    bool ValidateCharAlphaNumeric();
    bool GetValidToken();
    bool GetValidQuote();
    bool GetLineToEndOrTag();
};

struct CoreBezierAnimKeyDataShort
{
    uint32_t m_time;
    uint32_t m_control[3];
};

struct _PERF_COUNTER_BLOCK
{
    uint32_t ByteLength;
};

struct CAL1_DelayEntry
{
    CAL1_AudioPlayback* m_Item;
    uint32_t m_DelayLength;
    uint32_t m_DelayCount;
    bool m_WaitingToPlay;

    void CAL1_DelayEntry();
    void AddEntry();
};

struct _NT_TIB32
{
    uint32_t ExceptionList;
    uint32_t StackBase;
    uint32_t StackLimit;
    uint32_t SubSystemTib;
    uint32_t FiberData;
    uint32_t Version;
    uint32_t ArbitraryUserPointer;
    uint32_t Self;
};

struct _TAPE_PREPARE
{
    uint32_t Operation;
    uint32_t Immediate;
};

struct tagDRVCONFIGINFO
{
    uint32_t dwDCISize;
    uint32_t* lpszDCISectionName;
    uint32_t* lpszDCIAliasName;
};

struct SCARD_T0_REQUEST
{
    _SCARD_IO_REQUEST ioRequest;
    uint32_t bSw1;
    uint32_t bSw2;
    SCARD_T0_COMMAND CmdBytes;
    uint32_t rgbHeader[5];
};

struct ICatalogFileInfo : IUnknown
{
    HRESULT __stdcall GetCatalogFile();
    HRESULT __stdcall GetJavaTrust();
    void ICatalogFileInfo();
};

struct tagXFORM
{
    float eM11;
    float eM12;
    float eM21;
    float eM22;
    float eDx;
    float eDy;
};

struct CoreGsStoreImage
{
    uint32_t vifcode[4];
    CoreGifTag giftag;
    CoreGsBitbltbuf bitbltbuf;
    int32_t bitbltbufaddr;
    CoreGsTrxpos trxpos;
    int32_t trxposaddr;
    CoreGsTrxreg trxreg;
    int32_t trxregaddr;
    CoreGsFinish finish;
    int32_t finishaddr;
    CoreGsTrxdir trxdir;
    int32_t trxdiraddr;
};

struct CoreScriptCompiler : CoreScriptStore
{
    CoreScriptCompilerData* m_data;

    void CoreScriptCompiler();
    void ~CoreScriptCompiler();
    void Reset();
    bool Add();
    int32_t GetSize();
    char* GetData();
    char* GetError();
    char* GetScriptObject();
};

struct CoreScriptCompilerData
{
};

struct CoreHashElement64
{
    uint32_t ulHash;
    void* lpData;
};

struct CoreInitArg
{
    char* m_argString;
    int32_t m_argIndex;
    bool m_argUsed;

    void CoreInitArg();
    void Reset();
    void Set();
    char* Get();
    int32_t GetIndex();
    bool IsUsed();
    bool IsPartSame();
    bool IsWholeSame(char* i_argString);
    bool GetAsBool(bool& o_value, char* i_argString1, bool i_value1, char* i_argString2, bool i_value2, char* i_argString3, bool i_value3, char* i_argString4, bool i_value4);
    bool GetAsNumber();
    bool GetAsString(char* i_argString, char* o_string, int32_t i_maxStringSize);
};

struct tagEXTLOGFONTW
{
    tagLOGFONTW elfLogFont;
    uint32_t elfFullName[64];
    uint32_t elfStyle[32];
    uint32_t elfVersion;
    uint32_t elfStyleSize;
    uint32_t elfMatch;
    uint32_t elfReserved;
    uint32_t elfVendorId[4];
    uint32_t elfCulture;
    tagPANOSE elfPanose;
};

struct IOleCacheControl : IUnknown
{
    HRESULT __stdcall OnRun();
    HRESULT __stdcall OnStop();
    void IOleCacheControl();
};

struct CoreMenuSystem : CoreMenuBase
{
    CoreMenuSystemData* m_data;

    void CoreMenuSystem();
    void ~CoreMenuSystem();
    void Construct(CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory);
    void Init();
    void Reset();
    void Update(CoreObjectUpdateStruct* io_updateStruct);
    void UpdateComponent(CoreMenuComponent* i_component, float i_time);
    void Render(CoreGameRender* io_graphics);
    void RenderComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
    void DoDebug(CoreDebugInput* i_input);
    void InitMenu(CoreObjectUpdateStruct* io_updateStruct, CoreHash i_menu);
    void EndMenu(CoreObjectUpdateStruct* io_updateStruct);
    CoreHash GetCurrentMenu();
    bool IsMenuActive();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    int32_t FindComponent(CoreHash i_name);
    CoreMenuComponent* GetComponent(int32_t i_index);
    CoreTextureSet* GetTextureSet();
    CoreHash GetTextureSetID();
    void SetTextureSet(CoreTextureSet* i_textureSet, CoreHash i_textureSetID);
    void AddComponent(CoreHash i_componentName, CoreHash i_Type);
    int32_t GetNumComponents();
    void SetComponentDirection(CoreHash i_name, int32_t i_dir, CoreHash i_to, bool i_overWrite);
    void SelectComponent(CoreHash i_name);
    void SetOSKBuffer();
    char* GetOSKBuffer();
    CORE_OSK_RESULT_TAG GetLastOSKResult();
    CoreMenuSystemData* GetMenuSystemDataPtr();
    CoreScripted::CommandReturn FnMenuUpdate(CoreCommand* io_command);
    void SetCamera();
    void ClickSelectedComponent();
    CoreScripted::CommandReturn FnMenuReset(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuEnd();
    CoreScripted::CommandReturn FnMenuSelectComponent(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetComponentUp(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetComponentDown(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetComponentLeft(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetComponentRight(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetComponentSelectable(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetComponentRequireCallbacks(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetPreFadeRGBA(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetPreFadeVisibility(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetPostFadeRGBA(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetPostFadeVisibility(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetBack(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetCamera(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuSetCameraFOV(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuWaitForCamera(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuPause(CoreCommand* io_command);
    CoreScripted::CommandReturn FnMenuPlaySound(CoreCommand* io_command);
    CoreScripted::CommandReturn FnStartMusic(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn FnStopMusic();
    CoreScripted::CommandReturn FnMenuMuteSound();
    CoreScripted::CommandReturn FnMenuUmMuteSound();
    CoreScripted::CommandReturn FnMenuMuteMusic();
    CoreScripted::CommandReturn FnMenuUnMuteMusic();
    CoreScripted::CommandReturn FnDuckSFX(CoreCommand* io_command);
    CoreScripted::CommandReturn FnUnDuckSFX();
    CoreScripted::CommandReturn FnMenuStopAllSound();
    CoreScripted::CommandReturn FnChangeNameOSK(CoreCommand* io_command);
    CoreScripted::CommandReturn FnWasOSKCanceled(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentRGBABackground(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentRGBAHighlight(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentRGBANormalText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentVisibleItems(CoreCommand* io_command);
    CoreScripted::CommandReturn FnGetInternalSelection(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetInternalSelection(CoreCommand* io_command);
    CoreScripted::CommandReturn FnGetNumberOfItems(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMenuTimeScale(CoreCommand* io_command);
    CoreScripted::CommandReturn FnIsQuickStart(CoreCommand* io_command);
    CoreScripted::CommandReturn FnStartScreenTimeOut(CoreCommand* io_command);
    void UpdateScreenTimeOut();
};

struct tagEMRCREATEPALETTE
{
    tagEMR emr;
    uint32_t ihPal;
    tagLOGPALETTE lgpl;
};

struct tagEMRCREATEBRUSHINDIRECT
{
    tagEMR emr;
    uint32_t ihBrush;
    tagLOGBRUSH32 lb;
};

struct CoreWideString
{
    uint32_t* m_contents;
    int32_t m_allocSize;
    int32_t m_length;

    void CoreWideString();
    void ~CoreWideString();
    void operator+=();
    bool operator==();
    void Reset();
    void Resize();
    uint32_t* operator const unsigned short *();
    int32_t GetLength();
    void Copy();
};

struct _JOBOBJECT_BASIC_UI_RESTRICTIONS
{
    uint32_t UIRestrictionsClass;
};

struct _CERT_SIMPLE_CHAIN
{
    uint32_t cbSize;
    _CERT_TRUST_STATUS TrustStatus;
    uint32_t cElement;
    _CERT_CHAIN_ELEMENT** rgpElement;
    _CERT_TRUST_LIST_INFO* pTrustListInfo;
    int32_t fHasRevocationFreshnessTime;
    uint32_t dwRevocationFreshnessTime;
};

struct _JOB_INFO_1A
{
    uint32_t JobId;
    char* pPrinterName;
    char* pMachineName;
    char* pUserName;
    char* pDocument;
    char* pDatatype;
    char* pStatus;
    uint32_t Status;
    uint32_t Priority;
    uint32_t Position;
    uint32_t TotalPages;
    uint32_t PagesPrinted;
    _SYSTEMTIME Submitted;
};

struct IMessageFilter : IUnknown
{
    uint32_t __stdcall HandleInComingCall();
    uint32_t __stdcall RetryRejectedCall();
    uint32_t __stdcall MessagePending();
    void IMessageFilter();
};

struct ISupportErrorInfo : IUnknown
{
    HRESULT __stdcall InterfaceSupportsErrorInfo();
    void ISupportErrorInfo();
};

struct pvalueA
{
    char* pv_valuename;
    int32_t pv_valuelen;
    void* pv_value_context;
    uint32_t pv_type;
};

struct CoreMenuComponentSlider
{
    enum Modes
    {
        MODE_END = 0,
        MODE_LINEAR = 1,
        MODE_SQR = 2,
        MODE_SQRT = 3,
        MODE_SIN_PI = 4,
        MODE_SIN_2PI = 5,
        MODE_TRIANGLE_ONCE = 6,
        MODE_TRIANGLE_PLUS_MINUS = 7,
        MODE_RAW = 255,
        MODE_LOOP = 256,
        MODE_DIFF_RELATIVE = 512,
    };

    float m_from;
    float m_to;
    float m_alpha;
    float m_alphaVelocity;
    int32_t m_mode;

    float GetValue();
    void SetValue(float i_to, int32_t i_mode, float i_time);
    void Update(float i_time);
    char* DebugOutput(CoreStringBuffer<256>& o_buffer, bool i_full);
    void DebugShift(float i_diff);
};

struct _TRANSMIT_FILE_BUFFERS
{
    void* Head;
    uint32_t HeadLength;
    void* Tail;
    uint32_t TailLength;
};

struct _DATATYPES_INFO_1A
{
    char* pName;
};

struct CoreTexturePagePC : CoreTexturePage
{
    uint32_t m_uiPalette[1];

    void CoreTexturePagePC();
    void ~CoreTexturePagePC();
    uint32_t* GetPalette();
    uint32_t* GetImage32();
    uint32_t* GetImage24();
    uint32_t* GetImage8();
    uint32_t* GetImage4();
    uint32_t* GetMipMapImage32(int32_t iLevel);
    uint32_t* GetMipMapImage24(int32_t iLevel);
    uint32_t* GetMipMapImage8(int32_t iLevel);
    uint32_t* GetMipMapImage4();
    int32_t GetNumColours();
    uint32_t* GetPalettePtr();
};

struct TriBatch
{
    TriBatchStore m_store[250];
    float m_data[22000];
    uint32_t m_currentStore;
    uint32_t m_currentData;

    void TriBatch();
    void ~TriBatch();
};

struct tagBITMAPINFO
{
    tagBITMAPINFOHEADER bmiHeader;
    tagRGBQUAD bmiColors[1];
};

struct _CERT_NAME_CONSTRAINTS_INFO
{
    uint32_t cPermittedSubtree;
    _CERT_GENERAL_SUBTREE* rgPermittedSubtree;
    uint32_t cExcludedSubtree;
    _CERT_GENERAL_SUBTREE* rgExcludedSubtree;
};

struct CoreMenuSystemData
{
    CoreHash currentMenu;
    bool menuActive;
    CoreMenuComponent defaultComponents[50];
    CoreMenuComponentListBox listboxComponents[2];
    CoreMenuComponent* components[52];
    int32_t numComponentsTotal;
    int32_t numDefaultComponents;
    int32_t numListboxComponents;
    int32_t componentQueriedForGetNumberOfItems;
    uint32_t numItemsInComponentLastQueriedForGetNumberOfItems;
    int32_t componentQueriedForItemSelection;
    int32_t indexOfSelectedItemInComponentLastQueriedForSelectedItemIndex;
    bool networkConnected;
    uint32_t numberOfPlayers;
    int32_t screenTimeOut;
    int32_t componentSelected;
    uint32_t compOn;
    uint32_t compOff;
    uint32_t compSelect;
    float pauseTimer;
    CoreHash textureSetID;
    CoreTextureSet* textureSet;
    CoreHash camera;
    float cameraSpeed;
    float cameraTime;
    float cameraTarget;
    float cameraStart;
    bool cameraLoop;
    bool gameJoined;
    bool wlanSwitchOn;
    bool networkStartGame;
    CoreMenuComponent preFade;
    CoreMenuComponent postFade;
    CoreInputContext menuContext;
    CoreInputMapping menuMapping;
    float minClickDelay;
    CoreHash back;
    int32_t debugComponent;
    bool debugDarken;
    bool startPressed;
    bool squarePressed;
    float m_fTimeScale;

    void CoreMenuSystemData();
    void ~CoreMenuSystemData();
};

struct _COMMTIMEOUTS
{
    uint32_t ReadIntervalTimeout;
    uint32_t ReadTotalTimeoutMultiplier;
    uint32_t ReadTotalTimeoutConstant;
    uint32_t WriteTotalTimeoutMultiplier;
    uint32_t WriteTotalTimeoutConstant;
};

struct CAL1_SceneExporter
{
    CAL1_API* m_CAL1API;
    char* m_ProjectPath;
    char* m_ScenePath;
    char* m_OutputPath;
    char* m_ExportName;
    uint32_t m_PlatformMask;
    uint32_t m_LanguageMask;
    uint32_t m_AudioFormat;
    uint32_t m_PlatformIndex;
    CAL1_AudioItemDatabase* m_aid;

    // TODO vtable

    void CAL1_SceneExporter();
    void ~CAL1_SceneExporter();
    CAAudioError SetProjectPath();
    CAAudioError SetScenePath();
    CAAudioError SetOutputPath();
    CAAudioError SetExportName();
    CAAudioError SetPlatformMask();
    CAAudioError SetLanguageMask();
    CAAudioError SetAudioFormat();
    char* GetProjectPath();
    char* GetScenePath();
    char* GetOutputPath();
    char* GetExportName();
    uint32_t GetPlatformMask();
    uint32_t GetLanguageMask();
    uint32_t GetAudioFormat();
    CAAudioError Export();
    CAAudioError BuildScene();
    CAAudioError SaveScene();
    CAAudioError ExtractObjects();
    CAAudioError ExtractEvents();
    CAAudioError ExtractSamples();
    CAAudioError ExtractSGP();
    CAAudioError ExtractSG();
};

struct _CMSG_CMS_SIGNER_INFO
{
    uint32_t dwVersion;
    _CERT_ID SignerId;
    _CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    _CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    _CRYPTOAPI_BLOB EncryptedHash;
    _CRYPT_ATTRIBUTES AuthAttrs;
    _CRYPT_ATTRIBUTES UnauthAttrs;
};

struct IBlockingLock : IUnknown
{
    HRESULT __stdcall Lock();
    HRESULT __stdcall Unlock();
    void IBlockingLock();
};

struct _REPARSE_GUID_DATA_BUFFER
{
    uint32_t ReparseTag;
    uint32_t ReparseDataLength;
    uint32_t Reserved;
    _GUID ReparseGuid;
    _REPARSE_GUID_DATA_BUFFER::__unnamed GenericReparseBuffer;
};

struct IMAGE_AUX_SYMBOL_TOKEN_DEF
{
    uint32_t bAuxType;
    uint32_t bReserved;
    uint32_t SymbolTableIndex;
    uint32_t rgbReserved[12];
};

struct HPEN__
{
    int32_t unused;
};

struct tagLOGCOLORSPACEA
{
    uint32_t lcsSignature;
    uint32_t lcsVersion;
    uint32_t lcsSize;
    int32_t lcsCSType;
    int32_t lcsIntent;
    tagICEXYZTRIPLE lcsEndpoints;
    uint32_t lcsGammaRed;
    uint32_t lcsGammaGreen;
    uint32_t lcsGammaBlue;
    char lcsFilename[260];
};

struct _TOKEN_PRIMARY_GROUP
{
    void* PrimaryGroup;
};

struct ICreateTypeInfo : IUnknown
{
    HRESULT __stdcall SetGuid();
    HRESULT __stdcall SetTypeFlags();
    HRESULT __stdcall SetDocString();
    HRESULT __stdcall SetHelpContext();
    HRESULT __stdcall SetVersion();
    HRESULT __stdcall AddRefTypeInfo();
    HRESULT __stdcall AddFuncDesc();
    HRESULT __stdcall AddImplType();
    HRESULT __stdcall SetImplTypeFlags();
    HRESULT __stdcall SetAlignment();
    HRESULT __stdcall SetSchema();
    HRESULT __stdcall AddVarDesc();
    HRESULT __stdcall SetFuncAndParamNames();
    HRESULT __stdcall SetVarName();
    HRESULT __stdcall SetTypeDescAlias();
    HRESULT __stdcall DefineFuncAsDllEntry();
    HRESULT __stdcall SetFuncDocString();
    HRESULT __stdcall SetVarDocString();
    HRESULT __stdcall SetFuncHelpContext();
    HRESULT __stdcall SetVarHelpContext();
    HRESULT __stdcall SetMops();
    HRESULT __stdcall SetTypeIdldesc();
    HRESULT __stdcall LayOut();
    void ICreateTypeInfo();
};

struct _wireSAFEARR_DISPATCH
{
    uint32_t Size;
    IDispatch** apDispatch;
};

struct _SECURITY_QUALITY_OF_SERVICE
{
    uint32_t Length;
    _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    uint32_t ContextTrackingMode;
    uint32_t EffectiveOnly;
};

struct tagPELARRAY
{
    int32_t paXCount;
    int32_t paYCount;
    int32_t paXExt;
    int32_t paYExt;
    uint32_t paRGBs;
};

struct ITimeAndNoticeControl : IUnknown
{
    HRESULT __stdcall SuppressChanges();
    void ITimeAndNoticeControl();
};

struct CoretGS_DISPLAY2
{
    uint32_t DX : 12;
    uint32_t DY : 11;
    uint32_t MAGH : 4;
    uint32_t MAGV : 2;
    uint32_t p0 : 3;
    uint32_t DW : 12;
    uint32_t DH : 11;
    uint32_t p1 : 9;
};

struct tagCURSORSHAPE
{
    int32_t xHotSpot;
    int32_t yHotSpot;
    int32_t cx;
    int32_t cy;
    int32_t cbWidth;
    uint32_t Planes;
    uint32_t BitsPixel;
};

struct tagI_RpcProxyCallbackInterface
{
    int32_t* IsValidMachineFn;
    int32_t* GetClientAddressFn;
    int32_t* GetConnectionTimeoutFn;
};

struct _tagStartParam
{
    _GUID iid;
    IBindCtx* pIBindCtx;
    IUnknown* pItf;
};

struct _CoreGifPackSt
{
    float S;
    float T;
    float Q;
    uint32_t pad96;
};

struct CoreInitPC : CoreInit
{
    static int32_t m_debugMemoryPoolSize;
    static bool m_build;
    static bool m_useDebugAudioMemory;
    static bool m_useDebugAudioHeap;

    void CommandLineToolInit();
    int32_t GetDebugMemoryPoolSize();
    void SetDebugMemoryPoolSize();
    bool IsBuilding();
    void SetBuilding();
    bool IsUsingDebugAudioMemory();
    void SetUseDebugAudioMemory();
    bool IsUsingDebugAudioHeap();
    void SetUseDebugAudioHeap();
    void CoreInitPC();
    void YouCannotInstanceThisClass();
    void PreParseSKU();
    void ParseArgSKU();
    void PostParseSKU();
};

struct CoretGS_SMODE2
{
    uint32_t INT : 1;
    uint32_t FFMD : 1;
    uint32_t DPMS : 2;
    uint32_t p0 : 28;
    uint32_t p1;
};

struct _DEVICE_MEDIA_INFO
{
    _DEVICE_MEDIA_INFO::__unnamed DeviceSpecific;
};

struct sierra_adpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wRevision;
};

struct HCONVLIST__
{
    int32_t unused;
};

struct tagMIDIOUTCAPSW
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    uint32_t szPname[32];
    uint32_t wTechnology;
    uint32_t wVoices;
    uint32_t wNotes;
    uint32_t wChannelMask;
    uint32_t dwSupport;
};

struct _PRINTER_INFO_2A
{
    char* pServerName;
    char* pPrinterName;
    char* pShareName;
    char* pPortName;
    char* pDriverName;
    char* pComment;
    char* pLocation;
    _devicemodeA* pDevMode;
    char* pSepFile;
    char* pPrintProcessor;
    char* pDatatype;
    char* pParameters;
    void* pSecurityDescriptor;
    uint32_t Attributes;
    uint32_t Priority;
    uint32_t DefaultPriority;
    uint32_t StartTime;
    uint32_t UntilTime;
    uint32_t Status;
    uint32_t cJobs;
    uint32_t AveragePPM;
};

struct _PRINTER_INFO_7W
{
    uint32_t* pszObjectGUID;
    uint32_t dwAction;
};

struct _BIDI_REQUEST_DATA
{
    uint32_t dwReqNumber;
    uint32_t* pSchema;
    _BIDI_DATA data;
};

struct CoretGS_CSR
{
    uint32_t SIGNAL : 1;
    uint32_t FINISH : 1;
    uint32_t HSINT : 1;
    uint32_t VSINT : 1;
    uint32_t EDWINT : 1;
    uint32_t p0 : 3;
    uint32_t FLUSH : 1;
    uint32_t RESET : 1;
    uint32_t p1 : 2;
    uint32_t NFIELD : 1;
    uint32_t FIELD : 1;
    uint32_t FIFO : 2;
    uint32_t REV : 8;
    uint32_t ID : 8;
    uint32_t p2;
};

struct _IMAGE_RESOURCE_DIRECTORY_STRING
{
    uint32_t Length;
    char NameString[1];
};

struct tagICONMETRICSW
{
    uint32_t cbSize;
    int32_t iHorzSpacing;
    int32_t iVertSpacing;
    int32_t iTitleWrap;
    tagLOGFONTW lfFont;
};

struct AsyncIUnknown : IUnknown
{
    HRESULT __stdcall Begin_QueryInterface();
    HRESULT __stdcall Finish_QueryInterface();
    HRESULT __stdcall Begin_AddRef();
    uint32_t __stdcall Finish_AddRef();
    HRESULT __stdcall Begin_Release();
    uint32_t __stdcall Finish_Release();
    void AsyncIUnknown();
};

struct IDataObject : IUnknown
{
    HRESULT __stdcall GetData();
    HRESULT __stdcall GetDataHere();
    HRESULT __stdcall QueryGetData();
    HRESULT __stdcall GetCanonicalFormatEtc();
    HRESULT __stdcall SetData();
    HRESULT __stdcall EnumFormatEtc();
    HRESULT __stdcall DAdvise();
    HRESULT __stdcall DUnadvise();
    HRESULT __stdcall EnumDAdvise();
    void IDataObject();
};

struct CoreTextureInfoFlags
{
    enum CoreTextureInfoFlagsEnum
    {
        BPP_32,
        BPP_24,
        BPP_8,
        BPP_4,
        HAS_ALPHA,
        HAS_PALETTE,
        HAS_MIPMAPS,
        IS_ENVMAP,
        IS_NORMALMAP,
        IS_DRAWBUFFER,
        DOUBLE_SIDED,
        DEPTH_OFFSET,
        NO_Z_WRITE,
        ADDITIVE,
        ONE_BIT_ALPHA,
    };

    void CoreTextureInfoFlags();
    void ~CoreTextureInfoFlags();
};

struct _tagCODEBASEHOLD
{
    uint32_t cbSize;
    uint32_t* szDistUnit;
    uint32_t* szCodeBase;
    uint32_t dwVersionMS;
    uint32_t dwVersionLS;
    uint32_t dwStyle;
};

struct CoreRagdollCollisionUserData
{
    CoreHash oBoneHash1;
    CoreHash oBoneHash2;
    CoreVector vCollisionNormal;
    float fImpulse;

    void CoreRagdollCollisionUserData();
    void ~CoreRagdollCollisionUserData();
};

struct _REMOTE_NAME_INFOW
{
    uint32_t* lpUniversalName;
    uint32_t* lpConnectionName;
    uint32_t* lpRemainingPath;
};

struct _CoreGifPackUv
{
    int32_t U;
    int32_t V;
    int32_t pad64;
};

struct CoreCriticalSectionBuffersHeaders
{
    uint32_t* m_wholeBufferEnd;
    uint32_t* m_wholeBufferStore;
    uint32_t m_wholeBufferSize;
    uint32_t m_wholeBufferUsed;
    CoreCriticalSectionBufferHeader* m_buffersHeaders;
    uint32_t m_buffersCount;
    uint32_t m_lostBuffers;
    uint32_t m_lostBytes;

    void CoreCriticalSectionBuffersHeaders();
    void Init();
    uint32_t GetWholeBufferSize();
    bool AddBuffer();
    bool RemoveBuffers();
    void Reset();
    uint32_t GetBuffersCount();
    uint32_t GetLostBuffers();
    uint32_t GetLostBytes();
    void ResetLost();
    CoreCriticalSectionBufferHeader* GetBufferHeader();
};

struct IXMLDOMText : IXMLDOMCharacterData
{
    HRESULT __stdcall splitText();
    void IXMLDOMText();
};

struct _stati64
{
    uint32_t st_dev;
    uint32_t st_ino;
    uint32_t st_mode;
    int32_t st_nlink;
    int32_t st_uid;
    int32_t st_gid;
    uint32_t st_rdev;
    int32_t st_size;
    int32_t st_atime;
    int32_t st_mtime;
    int32_t st_ctime;
};

struct CoreGsPrmodecont
{
    uint32_t AC : 1;
    uint32_t pad01 : 63;
};

struct RPC_DISPATCH_TABLE
{
    uint32_t DispatchTableCount;
    void** DispatchTable;
    int32_t Reserved;
};

struct _LUID
{
    uint32_t LowPart;
    int32_t HighPart;
};

struct _CRYPT_URL_INFO
{
    uint32_t cbSize;
    uint32_t dwSyncDeltaTime;
    uint32_t cGroup;
    uint32_t* rgcGroupEntry;
};

struct _RPC_SYNTAX_IDENTIFIER
{
    _GUID SyntaxGUID;
    _RPC_VERSION SyntaxVersion;
};

struct ILockBytes : IUnknown
{
    HRESULT __stdcall ReadAt();
    HRESULT __stdcall WriteAt();
    HRESULT __stdcall Flush();
    HRESULT __stdcall SetSize();
    HRESULT __stdcall LockRegion();
    HRESULT __stdcall UnlockRegion();
    HRESULT __stdcall Stat();
    void ILockBytes();
};

struct IXMLDOMProcessingInstruction : IXMLDOMNode
{
    HRESULT __stdcall get_target();
    HRESULT __stdcall get_data();
    HRESULT __stdcall put_data();
    void IXMLDOMProcessingInstruction();
};

struct _FULL_PTR_TO_REFID_ELEMENT
{
    _FULL_PTR_TO_REFID_ELEMENT* Next;
    void* Pointer;
    uint32_t RefId;
    uint32_t State;
};

struct CAL1_ChannelManager
{
    CAL1_AudioDriver* m_AudioDriver;
    AAChannelStatus* m_ChannelStatus;
    uint32_t* m_ChannelPriority;
    uint32_t m_NumChannels;
    uint32_t m_LastChannelAllocated;

    // TODO vtable

    void CAL1_ChannelManager();
    void ~CAL1_ChannelManager();
    CAAudioError SetChannelStatus(uint32_t channel, AAChannelStatus status);
    CAAudioError UpdateChannels();
    CAAudioError AllocateChannel(uint32_t* channel, uint32_t priority);
    CAAudioError DeallocateChannel(uint32_t channel);
    AAChannelStatus GetChannelStatus(uint32_t channel);
};

struct _TAPE_GET_DRIVE_PARAMETERS
{
    uint32_t ECC;
    uint32_t Compression;
    uint32_t DataPadding;
    uint32_t ReportSetmarks;
    uint32_t DefaultBlockSize;
    uint32_t MaximumBlockSize;
    uint32_t MinimumBlockSize;
    uint32_t MaximumPartitionCount;
    uint32_t FeaturesLow;
    uint32_t FeaturesHigh;
    uint32_t EOTWarningZoneSize;
};

struct tagWAVEINCAPS2A
{
    uint32_t wMid;
    uint32_t wPid;
    uint32_t vDriverVersion;
    char szPname[32];
    uint32_t dwFormats;
    uint32_t wChannels;
    uint32_t wReserved1;
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct CoreFloorHeightInfo
{
    float height;
    CoreDetectPoly* polyInfo;
};

struct _CERT_POLICY_ID
{
    uint32_t cCertPolicyElementId;
    char** rgpszCertPolicyElementId;
};

struct IStdMarshalInfo : IUnknown
{
    HRESULT __stdcall GetClassForHandler();
    void IStdMarshalInfo();
};

struct CoreCodeFlags
{
    enum CoreCodeFlagsBitsEnum
    {
        LIT_BIT,
        ENVMAP_DISABLE_BIT,
        UNTEXTURED_BIT,
        NO_CLIP_BIT,
        REJECT_CLIP_BIT,
        FULL_CLIP_BIT,
        WIREFRAME_BIT,
        POLYGONS_BIT,
        VU_CODE_FUNCTION_BIT,
        STATIC_PARENTED_MESH_BIT,
        HARDSKINNED_MESH_BIT,
        SOFTSKINNED_MESH_BIT,
        BLENDSHAPE_MESH_BIT,
        SHADOW_MESH_BIT,
        VOLUMES_MESH_BIT,
        ENVMAP_MESH_BIT,
    };

    enum CoreCodeFlagsEnum
    {
        CODE_FLAGS_LIT = (1 << 0),
        CODE_FLAGS_ENVMAP_DISABLE = (1 << 1),
        CODE_FLAGS_UNTEXTURED = (1 << 2),
        CODE_FLAGS_NO_CLIP = (1 << 3),
        CODE_FLAGS_REJECT_CLIP = (1 << 4),
        CODE_FLAGS_FULL_CLIP = (1 << 5),
        CODE_FLAGS_WIREFRAME = (1 << 6),
        CODE_FLAGS_POLYGONS = (1 << 7),
        CODE_FLAGS_VU_CODE_FUNCTION = (1 << 8),
        CODE_FLAGS_STATIC_PARENTED_MESH = (1 << 9),
        CODE_FLAGS_HARDSKINNED_MESH = (1 << 10),
        CODE_FLAGS_SOFTSKINNED_MESH = (1 << 11),
        CODE_FLAGS_BLENDSHAPE_MESH = (1 << 12),
        CODE_FLAGS_SHADOW_MESH = (1 << 13),
        CODE_FLAGS_VOLUMES_MESH = (1 << 14),
        CODE_FLAGS_ENVMAP_MESH = (1 << 15),
    };

};

struct CoreMatrixStack
{
    enum
    {
        STACK_DEPTH = 24,
    };

    CoreMatrix m_Stack[24];
    CoreMatrix* m_pCurrent;

    void CoreMatrixStack();
    void ~CoreMatrixStack();
    CoreMatrix* Push();
    CoreMatrix* Pop();
    CoreMatrix* Get();
};

struct ISurrogateService : IUnknown
{
    HRESULT __stdcall Init();
    HRESULT __stdcall ApplicationLaunch();
    HRESULT __stdcall ApplicationFree();
    HRESULT __stdcall CatalogRefresh();
    HRESULT __stdcall ProcessShutdown();
    void ISurrogateService();
};

struct tagMONLINKSTRUCT
{
    uint32_t cb;
    uint32_t dwTime;
    void* hTask;
    int32_t fEstablished;
    int32_t fNoData;
    HSZ__* hszSvc;
    HSZ__* hszTopic;
    HSZ__* hszItem;
    uint32_t wFmt;
    int32_t fServer;
    HCONV__* hConvServer;
    HCONV__* hConvClient;
};

struct _CMC_RESPONSE_INFO
{
    uint32_t cTaggedAttribute;
    _CMC_TAGGED_ATTRIBUTE* rgTaggedAttribute;
    uint32_t cTaggedContentInfo;
    _CMC_TAGGED_CONTENT_INFO* rgTaggedContentInfo;
    uint32_t cTaggedOtherMsg;
    _CMC_TAGGED_OTHER_MSG* rgTaggedOtherMsg;
};

struct contres_vqlpcwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
};

struct _PRINTER_INFO_2W
{
    uint32_t* pServerName;
    uint32_t* pPrinterName;
    uint32_t* pShareName;
    uint32_t* pPortName;
    uint32_t* pDriverName;
    uint32_t* pComment;
    uint32_t* pLocation;
    _devicemodeW* pDevMode;
    uint32_t* pSepFile;
    uint32_t* pPrintProcessor;
    uint32_t* pDatatype;
    uint32_t* pParameters;
    void* pSecurityDescriptor;
    uint32_t Attributes;
    uint32_t Priority;
    uint32_t DefaultPriority;
    uint32_t StartTime;
    uint32_t UntilTime;
    uint32_t Status;
    uint32_t cJobs;
    uint32_t AveragePPM;
};

struct _COSERVERINFO
{
    uint32_t dwReserved1;
    uint32_t* pwszName;
    _COAUTHINFO* pAuthInfo;
    uint32_t dwReserved2;
};

struct g721_adpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t nAuxBlockSize;
};

struct RPC_IF_ID_VECTOR
{
    uint32_t Count;
    _RPC_IF_ID* IfId[1];
};

struct _RPC_CLIENT_INTERFACE
{
    uint32_t Length;
    _RPC_SYNTAX_IDENTIFIER InterfaceId;
    _RPC_SYNTAX_IDENTIFIER TransferSyntax;
    RPC_DISPATCH_TABLE* DispatchTable;
    uint32_t RpcProtseqEndpointCount;
    _RPC_PROTSEQ_ENDPOINT* RpcProtseqEndpoint;
    uint32_t Reserved;
    void* InterpreterInfo;
    uint32_t Flags;
};

struct _AppBarData
{
    uint32_t cbSize;
    HWND* hWnd;
    uint32_t uCallbackMessage;
    uint32_t uEdge;
    tagRECT rc;
    int32_t lParam;
};

struct _GENERIC_MAPPING
{
    uint32_t GenericRead;
    uint32_t GenericWrite;
    uint32_t GenericExecute;
    uint32_t GenericAll;
};

struct tagSTATSTG
{
    uint32_t* pwcsName;
    uint32_t type;
    _ULARGE_INTEGER cbSize;
    _FILETIME mtime;
    _FILETIME ctime;
    _FILETIME atime;
    uint32_t grfMode;
    uint32_t grfLocksSupported;
    _GUID clsid;
    uint32_t grfStateBits;
    uint32_t reserved;
};

struct _CTL_USAGE_MATCH
{
    uint32_t dwType;
    _CTL_USAGE Usage;
};

struct _CrtMemBlockHeader
{
};

struct _CrtMemState
{
    _CrtMemBlockHeader* pBlockHeader;
    uint32_t lCounts[5];
    uint32_t lSizes[5];
    uint32_t lHighWaterCount;
    uint32_t lTotalCount;
};

struct _TAPE_STATISTICS
{
    uint32_t Version;
    uint32_t Flags;
    _LARGE_INTEGER RecoveredWrites;
    _LARGE_INTEGER UnrecoveredWrites;
    _LARGE_INTEGER RecoveredReads;
    _LARGE_INTEGER UnrecoveredReads;
    uint32_t CompressionRatioReads;
    uint32_t CompressionRatioWrites;
};

struct _TOKEN_PRIVILEGES
{
    uint32_t PrivilegeCount;
    _LUID_AND_ATTRIBUTES Privileges[1];
};

struct DDEACK
{
    uint32_t bAppReturnCode : 8;
    uint32_t reserved : 6;
    uint32_t fBusy : 1;
    uint32_t fAck : 1;
};

struct _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA
{
    uint32_t cbSize;
    uint32_t dwRegPolicySettings;
    int32_t fCommercial;
};

struct tagRPCOLEMESSAGE
{
    void* reserved1;
    uint32_t dataRepresentation;
    void* Buffer;
    uint32_t cbBuffer;
    uint32_t iMethod;
    void* reserved2[5];
    uint32_t rpcFlags;
};

struct HDRVR__
{
    int32_t unused;
};

struct _CERTIFICATE_BLOB
{
    uint32_t dwCertEncodingType;
    uint32_t cbData;
    uint32_t* pbData;
};

struct CoreMapFileFunctionParameters
{
    uint32_t m_functionAddress;
    uint32_t m_functionSize;
    char* m_fileName;
    char* m_className;
    char* m_functionName;
    char* m_parameters[8];
    int32_t m_parametersCount;

    void CoreMapFileFunctionParameters();
    void SetFunctionAddress();
    uint32_t GetFunctionAddress();
    void SetFunctionSize();
    uint32_t GetFunctionSize();
    void SetFileName();
    char* GetFileName();
    void SetClassName();
    char* GetClassNameA();
    void SetFunctionName();
    char* GetFunctionName();
    void SetParamters();
    char* GetParameter();
    int32_t GetParametersCount();
    bool AddStringsToStringTable();
};

struct _DSCBUFFERDESC1
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwBufferBytes;
    uint32_t dwReserved;
    tWAVEFORMATEX* lpwfxFormat;
};

struct CAL1_AudioStreamer_Standard : CAL1_AudioStreamer
{
    bool m_FlagStop;
    uint32_t m_FileReadSize;
    uint32_t m_FileStartOffset;
    uint32_t m_PrimaryBufferSize;
    uint32_t m_SecondaryBufferSize;
    uint32_t m_LastFileReadPos;
    uint32_t m_LastPrimaryBufferPos;
    uint32_t m_LastSecondaryBufferPos;
    uint32_t m_LastSecondaryBufferFileStartOffset;
    uint32_t m_LastPrimaryBufferFileStartOffset;
    uint32_t m_LastPrimaryBufferSectorWritten;
    uint32_t m_LastSecondaryBufferSectorWritten;
    uint32_t m_PrimaryBufferAddress;
    uint32_t m_PrimaryBufferAddressR;
    uint32_t m_SecondaryBufferAddress;
    uint32_t m_SecondaryBufferAddressR;
    uint32_t m_NextFileReadPosition;
    bool m_Toggle;
    bool m_Stereo;
    uint32_t m_FileStartPriMemLoc;
    bool m_FileStartFlagSet;
    CAL1_Sample* m_SampleR;

    void CAL1_AudioStreamer_Standard();
    void ~CAL1_AudioStreamer_Standard();
    uint32_t GetPercentComplete();
    CAAudioError Stream();
    CAAudioError Play(CAL1_Sample* sample);
    CAAudioError Stop();
    void ResetStreamer();
    CAAudioError TransferStartBlockToMemory(uint32_t channel, uint32_t startOffset, uint32_t source, uint32_t length);
    CAAudioError TransferSectorToMemory(uint32_t sector, uint32_t channel, uint32_t startOffset, uint32_t source, uint32_t length);
    uint32_t ReadData(uint32_t fileID, void* dataBuffer, uint32_t length, uint32_t* bufferDataRead);
    void SeekData(uint32_t fileID, uint32_t fileStartOffset, uint32_t seekType);
    uint32_t GetLastFileReadPosition();
    uint32_t GetLastPrimaryBufferPosition();
    uint32_t GetLastSecondaryBufferPosition();
    uint32_t GetFileReadSize();
    uint32_t GetPrimaryBufferSize();
    uint32_t GetSecondaryBufferSize();
    bool GetStereo();
    uint32_t GetLastSecondaryBufferFileStartOffset();
    CAAudioError AllocatePrimaryBuffer();
    CAAudioError StartStream();
};

struct provider_info
{
    uint32_t* pi_R0_1val;
    uint32_t* pi_R0_allvals;
    uint32_t* pi_R3_1val;
    uint32_t* pi_R3_allvals;
    uint32_t pi_flags;
    void* pi_key_context;
};

struct CoreMeshInstanceInfo
{
    enum
    {
        VERSION = 2,
    };

    float m_positionX;
    float m_positionY;
    float m_positionZ;
    float m_rotationX;
    float m_rotationY;
    float m_rotationZ;
    float m_rotationW;
    float m_scaleX;
    float m_scaleY;
    float m_scaleZ;
    int32_t m_instanceRootIndex;
    float m_LODBboxMinX;
    float m_LODBboxMinY;
    float m_LODBboxMinZ;
    float m_LODBboxMaxX;
    float m_LODBboxMaxY;
    float m_LODBboxMaxZ;

    void CoreMeshInstanceInfo();
    void ~CoreMeshInstanceInfo();
    CoreVector GetPosition();
    CoreQuat GetRotation();
    CoreVector GetScale();
    CoreMatrix GetTransform();
    int32_t GetInstanceRootIndex();
    CoreVector GetLODBboxPos();
    CoreVector GetLODBboxSize();
    CoreVector GetLODBboxMin();
    CoreVector GetLODBboxMax();
};

struct SHELLHOOKINFO
{
    HWND* hwnd;
    tagRECT rc;
};

struct _CRYPT_SIGN_MESSAGE_PARA
{
    uint32_t cbSize;
    uint32_t dwMsgEncodingType;
    _CERT_CONTEXT* pSigningCert;
    _CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    void* pvHashAuxInfo;
    uint32_t cMsgCert;
    _CERT_CONTEXT** rgpMsgCert;
    uint32_t cMsgCrl;
    _CRL_CONTEXT** rgpMsgCrl;
    uint32_t cAuthAttr;
    _CRYPT_ATTRIBUTE* rgAuthAttr;
    uint32_t cUnauthAttr;
    _CRYPT_ATTRIBUTE* rgUnauthAttr;
    uint32_t dwFlags;
    uint32_t dwInnerContentType;
};

struct AsyncIAdviseSink : IUnknown
{
    void __stdcall Begin_OnDataChange();
    void __stdcall Finish_OnDataChange();
    void __stdcall Begin_OnViewChange();
    void __stdcall Finish_OnViewChange();
    void __stdcall Begin_OnRename();
    void __stdcall Finish_OnRename();
    void __stdcall Begin_OnSave();
    void __stdcall Finish_OnSave();
    void __stdcall Begin_OnClose();
    void __stdcall Finish_OnClose();
    void AsyncIAdviseSink();
};

struct tagMCI_ANIM_PLAY_PARMS
{
    uint32_t dwCallback;
    uint32_t dwFrom;
    uint32_t dwTo;
    uint32_t dwSpeed;
};

struct _CERT_ID
{
    uint32_t dwIdChoice;
    _CERT_ISSUER_SERIAL_NUMBER IssuerSerialNumber;
    _CRYPTOAPI_BLOB KeyId;
    _CRYPTOAPI_BLOB HashId;
};

struct _PATHNAME_BUFFER
{
    uint32_t PathNameLength;
    uint32_t Name[1];
};

struct _SCARD_IO_REQUEST
{
    uint32_t dwProtocol;
    uint32_t cbPciLength;
};

struct IHttpNegotiate2 : IHttpNegotiate
{
    HRESULT __stdcall GetRootSecurityId();
    void IHttpNegotiate2();
};

struct BATTERY_REPORTING_SCALE
{
    uint32_t Granularity;
    uint32_t Capacity;
};

struct audiofile_af36waveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct _DSEFFECTDESC
{
    uint32_t dwSize;
    uint32_t dwFlags;
    _GUID guidDSFXClass;
    uint32_t dwReserved1;
    uint32_t dwReserved2;
};

struct CoreLineFXPrimitive : CoreFXPrimitive
{
    CoreVector m_Dir;

    void CoreLineFXPrimitive();
    void ~CoreLineFXPrimitive();
};

struct _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO
{
    uint32_t cbSize;
    _CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
    void* pvKeyEncryptionAuxInfo;
    uint32_t hCryptProv;
    _CRYPT_BIT_BLOB RecipientPublicKey;
    _CERT_ID RecipientId;
};

struct _MEMORYSTATUSEX
{
    uint32_t dwLength;
    uint32_t dwMemoryLoad;
    uint32_t ullTotalPhys;
    uint32_t ullAvailPhys;
    uint32_t ullTotalPageFile;
    uint32_t ullAvailPageFile;
    uint32_t ullTotalVirtual;
    uint32_t ullAvailVirtual;
    uint32_t ullAvailExtendedVirtual;
};

struct CoreAnimSequencer
{
    enum
    {
        VERSION = 19,
    };

    static uint32_t s_animSeqID;
    uint32_t m_version;
    uint32_t m_fileID;
    int32_t m_numAnimSpecs;
    int32_t m_numSpecMappingEntries;
    int32_t m_numAnimMappingEntries;
    int32_t m_numAnimConditions;
    int32_t m_numAnimBoneSets;
    int32_t m_animSpecTableOffset;
    int32_t m_specMappingOffset;
    int32_t m_animMappingOffset;
    int32_t m_animSpecHashArrayOffset;
    int32_t m_animConditionOffset;
    int32_t m_animBoneSetOffset;

    uint32_t GetVersion();
    void CoreAnimSequencer();
    void ~CoreAnimSequencer();
    int32_t GetNumAnimSpecs();
    bool CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
    int32_t GetAnimSpecIndexByID(CoreHash i_animSpecID);
    CoreAnimSpec* GetAnimSpecByID(CoreHash i_animSpecID);
    CoreAnimSpec* GetAnimSpec();
    CoreSpecMapping* GetSpecMapping();
    CoreAnimMapping* GetAnimMapping();
    int32_t GetNumTimedBlends(int32_t i_specNumber);
    CoreAnimBlend* GetTimedBlend(int32_t i_specNumber, int32_t i_timedBlend, CoreHash& o_animSet, CoreHash& o_animSpec);
    void RemapStateByAnimPath(int32_t i_specNumber, CoreHash& i_goalState, CoreHash& o_remapState);
    int32_t GetNumAnimConditions();
    CoreAnimCondition* GetAnimCondition();
    int32_t GetNumAnimBoneSets();
    CoreAnimBoneSet* GetAnimBoneSet();
    int32_t GetAnimBoneSetIndexByHash(CoreHash i_hash);
    bool CheckVersion();
    bool CheckID();
    uint32_t GetPlatformVersion();
    uint32_t GetID();
    int32_t GetNumSpecMappings();
    int32_t GetNumAnimMappings();
    int32_t* GetAnimSpecTable();
    CoreHashArray* GetAnimSpecHashArray();
};

struct CoreAnimCondition
{
    enum
    {
        VERSION = 2,
    };

    enum CCFlags
    {
        CC_AND,
        CC_OR,
        CC_NOT,
        CC_UNUSED,
        CC_RANDOM,
    };

    uint32_t m_operatorFlags[3];
    uint32_t m_dummy;
    uint32_t m_flagHash[3];

    void CoreAnimCondition();
    void ~CoreAnimCondition();
    uint32_t GetOperators();
    uint32_t GetFlagHash();
};

struct CAL1_AudioRegistryEntry
{
    char m_guid[36];
    char m_desc[255];
    bool m_useEAX;
    bool m_useEAXReverb;
    bool m_useEAXMorphing;
    bool m_useEAXOcclusion;
    bool m_useEAXPanning;
    bool m_use3DHW;
    bool m_use2DHW;
    uint32_t m_PrimarySampleRate;
    bool m_Enabled;
    bool m_useBasic3DMode;
    bool m_useCompatiblityMode;
    bool m_useDefaultHRTF;
    bool m_useNoVirtualisation;
    bool m_useFullHRTF;
    bool m_useLiteHRTF;
    bool m_bypassEAXUnified;
    uint32_t m_MasterVolume;
    uint32_t m_SpeechVolume;
    uint32_t m_SFXVolume;
    uint32_t m_MusicVolume;
    CAL1_AudioDevice* m_Device;

    void CAL1_AudioRegistryEntry();
    void Clear();
    void ResetSettings();
    void SetCheckUse2D();
    void SetCheckUse3D();
    void SetCheckUseEAX();
    void SetCheckUseEAXMorphing();
    void SetCheckUseEAXReverb();
    void SetCheckUseEAXPanning();
    void SetCheckUseEAXOcclusion();
    void SetCheckUseHRTFDefault();
    void SetCheckUseHRTFNoVirtualisation();
    void SetCheckUseHRTFFull();
    void SetCheckUseHRTFLite();
    void SetCheckUseCompatibilityMode();
    void SetCheckEnable();
    void SetCheckUseBasic3D();
    void SetCheckBypassEAXUnified();
    void SetValueVolumeMaster();
    void SetValueVolumeSpeech();
    void SetValueVolumeMusic();
    void SetValueVolumeSFX();
    void SetDevice();
    bool GetEnableAudioSettings();
    bool GetEnableUse2D();
    bool GetEnableUse3D();
    bool GetEnableUseEAX();
    bool GetEnableUseEAXMorphing();
    bool GetEnableUseEAXReverb();
    bool GetEnableUseEAXPanning();
    bool GetEnableUseEAXOcclusion();
    bool GetEnableSWHRTFSetting();
    bool GetEnableUseBasic2D();
    bool GetEnableUseCompatibilityMode();
    bool GetEnableUseWindowsDefaultDevice();
    bool GetEnableBypassEAXUnified();
    bool Get3DHWAcceleration();
    bool Get2DHWAcceleration();
    bool GetEAXAdvancedSupport();
    bool GetEAXOcclusionSupport();
    bool GetHWAcceleration();
    char* GetEAXSupportText();
    CAL1_AudioDevice* GetDevice();
    char* GetGUID();
    bool GetCheckEnable();
    bool GetCheckUse2D();
    bool GetCheckUse3D();
    bool GetCheckUseEAX();
    bool GetCheckUseEAXMorphing();
    bool GetCheckUseEAXReverb();
    bool GetCheckUseEAXPanning();
    bool GetCheckUseEAXOcclusion();
    bool GetCheckUseHRTFDefault();
    bool GetCheckUseHRTFNoVirtualisation();
    bool GetCheckUseHRTFFull();
    bool GetCheckUseHRTFLite();
    bool GetCheckUseCompatibilityMode();
    bool GetCheckUseBasic3D();
    bool GetCheckBypassEAXUnified();
    uint32_t GetValueVolumeMaster();
    uint32_t GetValueVolumeSpeech();
    uint32_t GetValueVolumeSFX();
    uint32_t GetValueVolumeMusic();
    void OnButtonResetVolumeLevels();
    void OnButtonResetDeviceSettings();
};

struct tagCALPWSTR
{
    uint32_t cElems;
    uint32_t** pElems;
};

struct CoreGsLoadImage
{
    CoreGifTag giftag0;
    CoreGsBitbltbuf bitbltbuf;
    int32_t bitbltbufaddr;
    CoreGsTrxpos trxpos;
    int32_t trxposaddr;
    CoreGsTrxreg trxreg;
    int32_t trxregaddr;
    CoreGsTrxdir trxdir;
    int32_t trxdiraddr;
    CoreGifTag giftag1;
};

struct tagCHARSETINFO
{
    uint32_t ciCharset;
    uint32_t ciACP;
    tagFONTSIGNATURE fs;
};

struct IGlobalInterfaceTable : IUnknown
{
    HRESULT __stdcall RegisterInterfaceInGlobal();
    HRESULT __stdcall RevokeInterfaceFromGlobal();
    HRESULT __stdcall GetInterfaceFromGlobal();
    void IGlobalInterfaceTable();
};

struct IDirectWriterLock : IUnknown
{
    HRESULT __stdcall WaitForWriteAccess();
    HRESULT __stdcall ReleaseWriteAccess();
    HRESULT __stdcall HaveWriteAccess();
    void IDirectWriterLock();
};

struct tagContextProperty
{
    _GUID policyId;
    uint32_t flags;
    IUnknown* pUnk;
};

struct CoreMapFileFunctionAddress
{
    uint32_t m_address;
};

struct _NOTIFYICONDATAW
{
    uint32_t cbSize;
    HWND* hWnd;
    uint32_t uID;
    uint32_t uFlags;
    uint32_t uCallbackMessage;
    HICON__* hIcon;
    uint32_t szTip[64];
};

struct tagEMRGLSBOUNDEDRECORD
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t cbData;
    uint32_t Data[1];
};

struct CoreXMLAttributeNode : CoreXMLNode_
{
    void CoreXMLAttributeNode();
    void SetValue();
    void SetValueAsString();
    void SetValueAsInt();
    void SetValueAsBool();
    void SetValueAsFloat();
    void ~CoreXMLAttributeNode();
};

struct _IMAGE_OS2_HEADER
{
    uint32_t ne_magic;
    char ne_ver;
    char ne_rev;
    uint32_t ne_enttab;
    uint32_t ne_cbenttab;
    int32_t ne_crc;
    uint32_t ne_flags;
    uint32_t ne_autodata;
    uint32_t ne_heap;
    uint32_t ne_stack;
    int32_t ne_csip;
    int32_t ne_sssp;
    uint32_t ne_cseg;
    uint32_t ne_cmod;
    uint32_t ne_cbnrestab;
    uint32_t ne_segtab;
    uint32_t ne_rsrctab;
    uint32_t ne_restab;
    uint32_t ne_modtab;
    uint32_t ne_imptab;
    int32_t ne_nrestab;
    uint32_t ne_cmovent;
    uint32_t ne_align;
    uint32_t ne_cres;
    uint32_t ne_exetyp;
    uint32_t ne_flagsothers;
    uint32_t ne_pretthunks;
    uint32_t ne_psegrefbytes;
    uint32_t ne_swaparea;
    uint32_t ne_expver;
};

struct tagIMEMENUITEMINFOW
{
    uint32_t cbSize;
    uint32_t fType;
    uint32_t fState;
    uint32_t wID;
    HBITMAP__* hbmpChecked;
    HBITMAP__* hbmpUnchecked;
    uint32_t dwItemData;
    uint32_t szString[80];
    HBITMAP__* hbmpItem;
};

struct tagHANDLETABLE
{
    void* objectHandle[1];
};

struct CoreS128Aligned
{
    int32_t i64one;
    int32_t i64two;
};

struct _EXCEPTION_REGISTRATION_RECORD
{
};

struct _NT_TIB
{
    _EXCEPTION_REGISTRATION_RECORD* ExceptionList;
    void* StackBase;
    void* StackLimit;
    void* SubSystemTib;
    void* FiberData;
    uint32_t Version;
    void* ArbitraryUserPointer;
    _NT_TIB* Self;
};

struct _IMAGE_TLS_DIRECTORY32
{
    uint32_t StartAddressOfRawData;
    uint32_t EndAddressOfRawData;
    uint32_t AddressOfIndex;
    uint32_t AddressOfCallBacks;
    uint32_t SizeOfZeroFill;
    uint32_t Characteristics;
};

struct tagMONITORINFOEXA : tagMONITORINFO
{
    char szDevice[32];
};

struct tagMDICREATESTRUCTW
{
    uint32_t* szClass;
    uint32_t* szTitle;
    void* hOwner;
    int32_t x;
    int32_t y;
    int32_t cx;
    int32_t cy;
    uint32_t style;
    int32_t lParam;
};

struct ILayoutStorage : IUnknown
{
    HRESULT __stdcall LayoutScript();
    HRESULT __stdcall BeginMonitor();
    HRESULT __stdcall EndMonitor();
    HRESULT __stdcall ReLayoutDocfile();
    HRESULT __stdcall ReLayoutDocfileOnILockBytes();
    void ILayoutStorage();
};

struct _DRAWPATRECT
{
    tagPOINT ptPosition;
    tagPOINT ptSize;
    uint32_t wStyle;
    uint32_t wPattern;
};

struct IEncodingFilterFactory : IUnknown
{
    HRESULT __stdcall FindBestFilter();
    HRESULT __stdcall GetDefaultFilter();
    void IEncodingFilterFactory();
};

struct _POINTFLOAT
{
    float x;
    float y;
};

struct tagEMRBITBLT
{
    tagEMR emr;
    _RECTL rclBounds;
    int32_t xDest;
    int32_t yDest;
    int32_t cxDest;
    int32_t cyDest;
    uint32_t dwRop;
    int32_t xSrc;
    int32_t ySrc;
    tagXFORM xformSrc;
    uint32_t crBkColorSrc;
    uint32_t iUsageSrc;
    uint32_t offBmiSrc;
    uint32_t cbBmiSrc;
    uint32_t offBitsSrc;
    uint32_t cbBitsSrc;
};

struct tagOleMenuGroupWidths
{
    int32_t width[6];
};

struct tagCAFLT
{
    uint32_t cElems;
    float* pElems;
};

struct _SERVICE_FAILURE_ACTIONSW
{
    uint32_t dwResetPeriod;
    uint32_t* lpRebootMsg;
    uint32_t* lpCommand;
    uint32_t cActions;
    _SC_ACTION* lpsaActions;
};

struct tagMDINEXTMENU
{
    HMENU__* hmenuIn;
    HMENU__* hmenuNext;
    HWND* hwndNext;
};

struct CoreParticleFXPrimitive : CoreFXPrimitive
{
    float m_ZBias;
    uint32_t m_poolIndex;
    int32_t m_renderChainNext;
    CoreVector m_RotAdd;
    CoreVector m_RotAddAdd;

    void CoreParticleFXPrimitive();
    void ~CoreParticleFXPrimitive();
};

struct CAL1_StreamData
{
    uint32_t m_FileNextPosition;
    uint32_t m_FileLength;
    uint32_t m_FileID;
    uint32_t m_SecondaryBufferLastFillPosition;
    uint32_t m_SecondaryBufferLength;
    uint32_t m_DataOffset;
    bool m_StopNextSectorChange;
    uint32_t m_Status;
    void* m_SecondaryBuffer;

    // TODO vtable

    void CAL1_StreamData();
    void ~CAL1_StreamData();
};

struct IXMLDocument : IDispatch
{
    HRESULT __stdcall get_root();
    HRESULT __stdcall get_fileSize();
    HRESULT __stdcall get_fileModifiedDate();
    HRESULT __stdcall get_fileUpdatedDate();
    HRESULT __stdcall get_URL();
    HRESULT __stdcall put_URL();
    HRESULT __stdcall get_mimeType();
    HRESULT __stdcall get_readyState();
    HRESULT __stdcall get_charset();
    HRESULT __stdcall put_charset();
    HRESULT __stdcall get_version();
    HRESULT __stdcall get_doctype();
    HRESULT __stdcall get_dtdURL();
    HRESULT __stdcall createElement();
    void IXMLDocument();
};

struct UDATE
{
    _SYSTEMTIME st;
    uint32_t wDayOfYear;
};

struct CoreArray<CoreHashElement64>
{
    CoreHashElement64* m_lpoContents;
    int32_t m_iAllocSize;
    int32_t m_iArraySize;
    bool m_allowResize;
    int32_t m_startAllocSize;

    void CoreArray<CoreHashElement64>();
    void SetAllowResize();
    void ~CoreArray<CoreHashElement64>();
    int32_t GetSize();
    void Insert();
    void Remove();
    void operator+=();
    bool CanFit();
    void Reset();
    void SetSize();
    void Resize();
    CoreHashElement64* operator const struct CoreHashElement64 *();
    CoreHashElement64* operator struct CoreHashElement64 *();
    CoreHashElement64& GetElement();
    CoreHashElement64* GetArray();
    bool operator==();
    bool operator!=();
    CoreHashElement64& operator[]();
};

struct CoreStringBuffer<10>
{
    char m_buffer[10];

    void CoreStringBuffer<10>();
    void Clear();
    char* operator const char *();
    char* GetString();
    uint32_t GetLength();
    uint32_t GetMaxLength();
    bool IsSame();
    bool IsSameIgnoreCase();
    void operator=();
    void Copy();
    void NCopy();
    void Cat();
    void ToUpper();
    void ToLower();
    float ToFloat();
    int32_t ToInt();
    int32_t FindChar();
    int32_t ReverseFindChar();
    int32_t VSPrint();
    int32_t SPrint();
    int32_t CatPrint();
};

struct _DISK_LOGGING
{
    uint32_t Function;
    void* BufferAddress;
    uint32_t BufferSize;
};

struct _userHMETAFILEPICT
{
    union __MIDL_IWinTypes_0005
    {
        int32_t hInproc;
        _remoteMETAFILEPICT* hRemote;
        int32_t hInproc64;
    };

    int32_t fContext;
    _userHMETAFILEPICT::__MIDL_IWinTypes_0005 u;
};

struct IWrappedProtocol : IUnknown
{
    HRESULT __stdcall GetWrapperCode();
    void IWrappedProtocol();
};

struct tagCALPSTR
{
    uint32_t cElems;
    char** pElems;
};

struct CoreMapFileParser
{
    CoreMapFileParseHelper m_parse;
    CoreMapFileStringTable m_stringTable;
    uint32_t m_maxSizeRequired;
    int32_t m_maxFunctionCount;
    int32_t m_maxFunctionSize;
    CoreMapFileFunctionsHeader* m_functionsHeader;
    CoreMapFileFunctionParameters* m_functions;
    int32_t m_functionCount;

    // TODO vtable

    char* GetShortFileName();
    bool SplitClassAndFunction();
    void TruncateIfFirstPartSame();
    int32_t ReplaceParameters();
    bool ReplaceParameter();
    char* FindColons();
    bool IsSame();
    bool IsPartSame();
    bool ProcessAllFunctions();
    bool iProcessAllFunctions();
    bool cbPrepareForAllocation();
    bool PrepareForAllocation();
    bool cbStoreEverything();
    bool StoreEverything();
    bool InsertFunction();
    int32_t Shrink();
    void CoreMapFileParser();
    int32_t Parse();
    int32_t GetMaximumBufferSize();
};

struct CoreGsDthe
{
    uint32_t DTHE : 1;
    uint32_t pad01 : 63;
};

struct CoreMemorySkipListElement
{
    float m_Key;
    CoreMemorySkipListElement** m_Forward;
    CoreMemoryList m_Data;

    void CoreMemorySkipListElement();
    void ~CoreMemorySkipListElement();
    void Init();
};

struct CAL1_AudioPlayback : CAL1_AudioItem
{
    enum Playback_State
    {
        Playback_Stopped,
        Playback_WaitingToStart,
        Playback_Playing,
        Playback_PlayingOnTimer,
        Playback_WaitingToPause,
        Playback_Paused,
        Playback_WaitingToResume,
        Playback_WaitingToStop,
    };

    struct AudioParamInfo
    {
        CAL1_AudioParameter* m_Param;
        CAL1_AudioParameter::CA_AP_Type m_Type;

        void AudioParamInfo();
    };

    CAL1_AudioPlayback::Playback_State m_State;
    bool m_DelayItemWaiting;
    uint32_t m_DelayValue;
    uint32_t m_DelayCount;
    CAL1_AudioPlayback* m_DelayItem;
    uint32_t m_msInterval;
    uint32_t m_NumCounts;
    bool m_UseTimer;
    bool m_Playing;
    CAL1_AudioData* m_Data;
    CAL0_List* m_ParamList;
    CAL1_AudioPlayback* m_PlaybackTrigger;
    CAL1_AudioDriver* m_AD;
    uint32_t m_timerCount;
    bool m_TriggerSet;
    bool m_AlmostCompleteTriggerSet;
    bool m_PlayingOnTimer;

    void CAL1_AudioPlayback();
    void ~CAL1_AudioPlayback();
    CAAudioError LinkAudioParameter();
    CAAudioError OnPaused();
    CAAudioError OnResumedOnTimer();
    CAAudioError OnResumed();
    CAAudioError OnStartedOnTimer();
    CAAudioError OnStarted();
    CAAudioError OnStopped();
    CAAudioError Update();
    CAAudioError End();
    CAAudioError Start();
    CAAudioError DoTimer();
    CAAudioError StartAudioItemDelay();
    CAAudioError Trigger();
    bool IsPlaying();
    bool IsDeferred();
    uint32_t GetInterval();
    bool GetTimer();
    CAAudioError SetTimer(bool useTimer);
    CAAudioError SetInterval(uint32_t interval);
    CAAudioError Tick();
    CAAudioError CompletionTrigger(CAL1_AudioPlayback* from);
    CAAudioError AlmostCompleteTrigger(CAL1_AudioPlayback* from);
    void DoCompletionTrigger(CAL1_AudioPlayback* from);
    void DoAlmostCompleteTrigger(CAL1_AudioPlayback* from);
    void SetCompletionTrigger(CAL1_AudioPlayback* playback);
    CAL1_AudioParameter* GetParameter();
    void SetAudioData(CAL1_AudioData* data, uint32_t mixVolume);
    CAAudioError CreateAudioParameter();
    CAAudioError DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* i_AID);
    CAAudioError DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
};

struct tagMCI_OVLY_SAVE_PARMSA
{
    uint32_t dwCallback;
    char* lpfilename;
    tagRECT rc;
};

struct _CRYPT_SMIME_CAPABILITY
{
    char* pszObjId;
    _CRYPTOAPI_BLOB Parameters;
};

struct CoreMaths
{
    enum CoreMathsVersion
    {
        VERSION = 47,
    };

    static bool s_initFlag;

    // TODO vtable

    bool Init();
    uint32_t GetVersion();
    float Sin();
    float SinII();
    float Cos();
    float Tan();
    void SinCos();
    float Asin();
    float Acos();
    float Atan();
    float Atan2();
    float Pow();
    float Log10();
    float Ln();
    float Exp();
    float Sqrt();
    float RSqrt();
    float Floor();
    float Ceil();
    float Round();
    int32_t Nint();
    float Part(float i_number);
    bool IsPowerOfTwo(int32_t i_number);
    bool GetPowerOfTwo(int32_t i_number, int32_t& o_power);
    float Mod();
    float Remainder(float i_valueA, float i_divider, float i_dividerBy2);
    int32_t Min();
    uint32_t Max();
    int32_t Abs();
    float GetPi();
    float ConvertDegToRad();
    float ConvertRadToDeg();
    int32_t Rand31();
    float Rand(float i_max);
    void SeedRand();
    float LinearInterpolate();
    float CosineInterpolate();
    float CubicInterpolate();
    float ClampValueToRange(float i_value, float i_lower, float i_upper);
    bool IsZero();
    bool IsEqual();
    bool IsValid();
    void CoreMaths();
    void ~CoreMaths();
    void YouCannotInstanceThisClass();
};

struct _MALLOC_FREE_STRUCT
{
    void** pfnAllocate;
    void* pfnFree;
};

struct _tagDATAINFO
{
    uint32_t ulTotalSize;
    uint32_t ulavrPacketSize;
    uint32_t ulConnectSpeed;
    uint32_t ulProcessorSpeed;
};

struct ip_mreq
{
    in_addr imr_multiaddr;
    in_addr imr_interface;
};

struct CoreFXPrimitive : CoreFXControl
{
    uint32_t m_PrimType;
    uint32_t m_PrimContext;
    int32_t m_Life;
    uint32_t m_ScaleTime;
    uint32_t m_BlendMode;
    uint32_t m_Flags;
    uint32_t m_AnimFrame;
    uint32_t m_AnimBase;
    float m_Scale;
    CoreVector m_Vel;
    float m_ScaleAdd;
    float m_ScaleAddAdd;
    float m_Gravity;
    float m_VelScale;
    CoreFRGBA m_rgba;

    void CoreFXPrimitive();
    void ~CoreFXPrimitive();
};

struct IKsPropertySet : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall Get();
    HRESULT __stdcall Set();
    HRESULT __stdcall QuerySupport();
    void IKsPropertySet();
};

struct CONFIRMSAFETY
{
    _GUID clsid;
    IUnknown* pUnk;
    uint32_t dwFlags;
};

struct _FILE_NOTIFY_INFORMATION
{
    uint32_t NextEntryOffset;
    uint32_t Action;
    uint32_t FileNameLength;
    uint32_t FileName[1];
};

struct _EXCEPTION_RECORD64
{
    uint32_t ExceptionCode;
    uint32_t ExceptionFlags;
    uint32_t ExceptionRecord;
    uint32_t ExceptionAddress;
    uint32_t NumberParameters;
    uint32_t __unusedAlignment;
    uint32_t ExceptionInformation[15];
};

struct IXMLDocument2 : IDispatch
{
    HRESULT __stdcall get_root();
    HRESULT __stdcall get_fileSize();
    HRESULT __stdcall get_fileModifiedDate();
    HRESULT __stdcall get_fileUpdatedDate();
    HRESULT __stdcall get_URL();
    HRESULT __stdcall put_URL();
    HRESULT __stdcall get_mimeType();
    HRESULT __stdcall get_readyState();
    HRESULT __stdcall get_charset();
    HRESULT __stdcall put_charset();
    HRESULT __stdcall get_version();
    HRESULT __stdcall get_doctype();
    HRESULT __stdcall get_dtdURL();
    HRESULT __stdcall createElement();
    HRESULT __stdcall get_async();
    HRESULT __stdcall put_async();
    void IXMLDocument2();
};

struct tagEMRRESIZEPALETTE
{
    tagEMR emr;
    uint32_t ihPal;
    uint32_t cEntries;
};

struct tagCBT_CREATEWNDA
{
    tagCREATESTRUCTA* lpcs;
    HWND* hwndInsertAfter;
};

struct IOleLink : IUnknown
{
    HRESULT __stdcall SetUpdateOptions();
    HRESULT __stdcall GetUpdateOptions();
    HRESULT __stdcall SetSourceMoniker();
    HRESULT __stdcall GetSourceMoniker();
    HRESULT __stdcall SetSourceDisplayName();
    HRESULT __stdcall GetSourceDisplayName();
    HRESULT __stdcall BindToSource();
    HRESULT __stdcall BindIfRunning();
    HRESULT __stdcall GetBoundSource();
    HRESULT __stdcall UnbindSource();
    HRESULT __stdcall Update();
    void IOleLink();
};

struct _LUID_AND_ATTRIBUTES
{
    _LUID Luid;
    uint32_t Attributes;
};

struct _SID
{
    uint32_t Revision;
    uint32_t SubAuthorityCount;
    _SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    uint32_t SubAuthority[1];
};

struct _OBJECT_TYPE_LIST
{
    uint32_t Level;
    uint32_t Sbz;
    _GUID* ObjectType;
};

struct timecaps_tag
{
    uint32_t wPeriodMin;
    uint32_t wPeriodMax;
};

struct CoreGsTrxpos
{
    uint32_t SSAX : 11;
    uint32_t pad11 : 5;
    uint32_t SSAY : 11;
    uint32_t pad27 : 5;
    uint32_t DSAX : 11;
    uint32_t pad43 : 5;
    uint32_t DSAY : 11;
    uint32_t DIR : 2;
    uint32_t pad61 : 3;
};

struct _DISK_HISTOGRAM
{
    _LARGE_INTEGER DiskSize;
    _LARGE_INTEGER Start;
    _LARGE_INTEGER End;
    _LARGE_INTEGER Average;
    _LARGE_INTEGER AverageRead;
    _LARGE_INTEGER AverageWrite;
    uint32_t Granularity;
    uint32_t Size;
    uint32_t ReadCount;
    uint32_t WriteCount;
    _HISTOGRAM_BUCKET* Histogram;
};

struct OPENCARDNAMEA
{
    uint32_t dwStructSize;
    HWND* hwndOwner;
    uint32_t hSCardContext;
    char* lpstrGroupNames;
    uint32_t nMaxGroupNames;
    char* lpstrCardNames;
    uint32_t nMaxCardNames;
    _GUID* rgguidInterfaces;
    uint32_t cguidInterfaces;
    char* lpstrRdr;
    uint32_t nMaxRdr;
    char* lpstrCard;
    uint32_t nMaxCard;
    char* lpstrTitle;
    uint32_t dwFlags;
    void* pvUserData;
    uint32_t dwShareMode;
    uint32_t dwPreferredProtocols;
    uint32_t dwActiveProtocol;
    uint32_t* lpfnConnect;
    int32_t* lpfnCheck;
    void* lpfnDisconnect;
    uint32_t hCardHandle;
};

struct CoreLevel : CoreScripted
{
    enum CoreLevelDebugFlags
    {
        DRAW_CURVES,
        DRAW_CURVES_CVS,
        DRAW_CURVES_HULL,
        DRAW_CURVES_CROSSING_POINTS,
        DRAW_SET_START_POINT,
        DRAW_SET_END_POINT,
        DRAW_MARKUP_POINTS,
        DRAW_GETFLOORHEIGHT_DEBUG,
        DRAW_MOVE_LEFT,
        DRAW_MOVE_RIGHT,
        DRAW_MOVE_DOWN,
        DRAW_MOVE_UP,
        DRAW_MOVE_PAGEDOWN,
        DRAW_MOVE_PAGEUP,
        DRAW_DETECT_DEBUG,
        DRAW_MOVE_START_POINT,
        DRAW_MOVE_END_POINT,
        DRAW_ARROW,
        DRAW_OBJECT_DEBUG,
        DRAW_OBJECT_CHOOSE,
        DRAW_OBJECT_POSITION,
        DRAW_OBJECT_ORIENTATION,
        DRAW_OBJECT_SCALE,
        DRAW_ANON_DEBUG,
        DRAW_ANON_SPHERES_DEBUG,
        DRAW_GETCEILINGHEIGHT_DEBUG,
        DRAW_DETECTION_BBOX,
        DRAW_ZONE_BBOX,
        NOT_DRAW_GEOMETRY,
        DRAW_INVIEW_BBOX,
    };

    CoreLevelInternalData* m_lpoData;
    CoreLevelAsyncData* m_lpoAsyncData;
    static CoreLevel* m_instance;
    CoreCameraObject* m_lastCreatedCamera;
    static bool s_occludersValid;
    static CoreVector s_occluderClipPlane[6];
    static CoreVector s_occluderGuardPlane[6];
    static CoreOccluder* s_occluderList;
    static int32_t s_occluderValidIndexes[256];

    void CoreLevel();
    void ~CoreLevel();
    void Construct(CoreMemory* lpoGlobalMemory);
    void Destruct(CoreMemory* lpoGlobalMemory);
    void Init(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void Reset(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void UpdateObjectUpdateStruct(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    bool InitLoad(CoreHash oNewLevelHash, char* lpcLevelName, char* lpcAreaName, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    bool PostLoad(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void AsyncLoad(CoreHash oLevelHash, char* lpcLevelName, char* lpcAreaName, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void RemoveScriptFile();
    CoreFileSystem::CoreFileLoadReturn LoadClusterData(char* i_levelName, char* i_areaName, bool i_asyncLoad);
    CoreFileSystem::CoreFileLoadReturn LoadScriptData(bool i_asyncLoad);
    void UnLoad(CoreHash oNewLevelToLoad, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    bool IsLevelLoaded();
    void Update(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
    void AddToRenderList(CoreGameRender* lpoGraphics);
    void Render(uint32_t i_drawFlags);
    void PostRender();
    void LevelSpecialRender();
    void GetDetectionBBox(CoreVector& o_min, CoreVector& o_max);
    CoreLevel* GetInstance();
    CoreCurveSetData* GetCurveData(CoreHash oName);
    CoreKeyedObject* GetKeyedObject(CoreHash oName);
    CoreLevelLightSet* GetLevelLightSet();
    CoreMemory* GetMemory();
    CoreScriptStore* GetScriptStore();
    CoreObjectController* GetObjectController();
    CoreLevelCompiled* GetLevelCompiled();
    int32_t* GetLevelRTreeIndexBuffer();
    uint32_t GetClientID();
    CoreObjectUpdateStruct* GetObjectUpdateStruct();
    CoreFX* GetCoreFX();
    void GetLevelExtents();
    char* GetLevelName();
    char* GetAreaName();
    bool IsReady();
    void SetReady(bool i_ready);
    bool IsLevelNetworkComunicating();
    void PlayCutScene(CoreHash i_cutscene, CoreHash i_audio);
    bool IsCutScenePlaying();
    CoreCutScenePlayer* GetCutScenePlayer();
    CoreMenuSystem* GetMenuSystem();
    bool IsMenuWaiting();
    bool FindTriggerByType(uint32_t, bool, CoreVector&, CoreVector&);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void DoDebug(CoreDebugInput* i_input);
    void SetDetectionRoomActive(uint32_t i_roomNumber, bool i_active);
    void SetDetectionRoomFlip();
    bool GetDetectPolyListRT(CoreVector& vPosA, CoreVector& vPosB, float fMaxRadiusDetectSphere, CoreDetectPoly* lpoPolyList, int32_t iMaxNumDetectPolys, int32_t& iNumPolys);
    bool GetDetectPolyListPointInfiniteHeightRT(CoreVector& vPosA, CoreDetectPoly* lpoPolyList, int32_t iMaxNumDetectPolys, int32_t& iNumPolys, uint32_t uiDetectFlags, bool bUseFXMesh, float i_floorRadius);
    bool GetDetectCollidableList(CoreVector& vPosA, CoreVector& vPosB, CoreVector& vBoundSpherePos, float fBoundSphereRadius, CoreSingleCollidable* lpoCollidables, int32_t& iNumCollidables, uint32_t uiDetectFlags);
    bool GetDetectCollidableListPointInfiniteHeight(CoreVector& vPosA, CoreSingleCollidable* lpoCollidables, int32_t& iNumCollidables, uint32_t, float i_floorRadius);
    bool GetNumBoundedEngineData(CoreHash i_dataType, uint32_t& i_numEntries);
    bool GetBoundedEngineDataByIndex(CoreHash i_dataType, uint32_t i_index, void*& o_dataPtr);
    bool GetBoundedEngineDataByName();
    bool GetBoundedEngineData(CoreHash i_dataType, CoreVector i_centre, float i_radius, uint32_t i_dataPtrListSize, void** o_dataPtrList, uint32_t& o_numFound);
    bool GetBoundedEngineDataRTSphere();
    bool GetBoundedEngineDataRTBox(CoreHash i_dataType, CoreVector i_detectMin, CoreVector i_detectMax, uint32_t i_dataPtrListSize, void** io_dataPtrList, uint32_t& io_numFound, bool i_addToList);
    bool GetNumGlobalEngineData();
    bool GetGlobalEngineData();
    bool GetGlobalEngineDataByIndex();
    bool GetGlobalEngineDataByName();
    uint32_t GetNumNavMeshes();
    CoreNavigationMesh* GetNavMeshByIndex(uint32_t i_index);
    CoreNavigationMesh* GetNavMeshByHash();
    bool GetNavPoint(CoreNavigationMesh* i_navMesh, CoreNavPos* i_start, CoreNavPos* i_dest, CoreVector& vNavPoint, int32_t iLookAhead);
    int32_t GetNavTriangleFromPos(CoreNavigationMesh* i_navMesh, CoreVector& vPos, int32_t iLastTriangle);
    int32_t GetRandomNavTriangleWithinBounds();
    CoreNavDistance NavDistance();
    void DrawNavigationMesh(CoreNavigationMesh* i_navMesh);
    void DrawNavigationRoute(CoreNavigationMesh* i_navMesh, CoreVector& vStart, CoreVector& vDest, int32_t iLookAhead);
    uint32_t GetCollidableObjectList(CoreAnimatingObject** io_collidableObjectList, uint32_t i_maxNumItems);
    uint32_t GetDetectionDataList(CoreDetectionMeshInfo* io_detectionMeshList, uint32_t i_maxNumItems);
    void InitRender();
    void SetCutSceneHash();
    void SetScriptMenu(CoreHash hashMenu);
    void InitialiseOccluders(bool i_levelLoaded);
    void GetValidOccluders(int32_t occluderNum, CoreVector& cameraPos, CoreVector& cameraDir, float nearPlane);
    void InitialiseOccludersInternal(CoreLevelCompiled* i_levelCompiled);
    bool IsBBoxOccluded();
    void GetOcclusionPlanes();
    bool IsBBoxVisible();
    CoreSceneContainer* PointInContainer();
    int32_t PointInContainerIndex();
    void UpdateGeometry(float deltaGameTime, bool bUpdateLights);
    void RenderDebug();
    void RenderLevelCompiled(CoreLevelCompiled* i_levelCompiled, uint32_t i_drawFlags);
    void ComputeDetectionBBox();
    CoreCurveSetData* GetCurveDataByIndex(int32_t iIndex);
    int32_t GetNumCurves();
    CoreScripted::CommandReturn eFnLevelUpdate(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnResetObjects();
    CoreScripted::CommandReturn eFnInstanceObject(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnSetObjectPosAndOrient(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnInstanceNetworkObject(CoreCommand* i_Command);
    CoreScripted::CommandReturn eFnInstanceObjectIf(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnInstanceObjectIfNot(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnWaitForObject(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnCreateViewer(CoreCommand* i_command);
    CoreScripted::CommandReturn eFnFX(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetTextureFilter(CoreCommand* command);
    CoreScripted::CommandReturn eFnFXEmitter(CoreCommand* pCmd);
    CoreScripted::CommandReturn eFnNetWaitForLevelStart(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnCreateAudioLocator();
    CoreScripted::CommandReturn eFnSetGlobalReverb(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnLoadModel(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnLoadTextureSet(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnLoadAnimSet(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnLoadFont(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn fnLoadCluster(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnLoadGeometry(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnUnloadGeometry();
    CoreScripted::CommandReturn eFnPause(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn fnScrollMaterial(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn efnMaterialDepthOffset(CoreCommand* lpoCommand);
    uint32_t MaterialDepthOffset(CoreStringBuffer<256> matNameString);
    CoreScripted::CommandReturn efnMaterialDepthAlpha(CoreCommand* lpoCommand);
    uint32_t MaterialDepthAlpha(CoreStringBuffer<256> matNameString);
    CoreScripted::CommandReturn efnMaterialAdditive(CoreCommand* lpoCommand);
    uint32_t MaterialAdditive(CoreStringBuffer<256> matNameString);
    CoreScripted::CommandReturn efnMaterialEnvmap(CoreCommand* lpoCommand);
    uint32_t MaterialEnvmap(CoreStringBuffer<256> matNameString);
    CoreScripted::CommandReturn eFnStartGlobalAudioEvent(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnTriggerGlobalAudioEvent(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnStopGlobalAudioEvent(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnStartMusic(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnStopMusic();
    CoreScripted::CommandReturn eFnDuckMusic(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnUnDuckMusic();
    CoreScripted::CommandReturn eFnDuckSFX(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnUnDuckSFX();
    void LevelCycle(CoreLevelUpdateStruct* lpoUpdateStruct);
    CoreFileSystem::CoreFileLoadReturn LoadGeometry(char* i_levelName, char* i_areaName, bool i_fake);
    bool ScrollMaterial(char* i_materialName, float i_deltaS, float i_deltaT, bool i_decal);
    bool UnLoadGeometry();
    bool UnLoadScriptData();
    void SetLevelName(CoreHash oLevelHash, char* lpcLevelName, char* lpcAreaName);
    void AssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType, void* lpUsrData1, void* lpUsrData2);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType);
    void AsyncConstruct(CoreMemory* lpoGlobalMemory);
    void AsyncDestruct(CoreMemory* lpoGlobalMemory);
    void AsyncReset(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void AsyncZero();
    void AsyncUpdate(CoreLevelUpdateStruct* lpoUpdateStruct);
    void AsyncDoDebug(CoreDebugInput* i_input);
    void AsyncSetLevelName(char* lpcLevelName, char* lpcAreaName);
    void AsyncUnLoad(CoreHash oNewLevelToLoad, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
    void AsyncHandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType);
    void BindLevelCompiledData();
    CoreObjectController* CreateObjectController();
    CoreMenuSystem* CreateMenuSystem(CoreMemory* io_memory);
};

struct _TIME_ZONE_INFORMATION
{
    int32_t Bias;
    uint32_t StandardName[32];
    _SYSTEMTIME StandardDate;
    int32_t StandardBias;
    uint32_t DaylightName[32];
    _SYSTEMTIME DaylightDate;
    int32_t DaylightBias;
};

struct _CERT_POLICY95_QUALIFIER1
{
    uint32_t* pszPracticesReference;
    char* pszNoticeIdentifier;
    char* pszNSINoticeIdentifier;
    uint32_t cCPSURLs;
    _CPS_URLS* rgCPSURLs;
};

struct tagNCCALCSIZE_PARAMS
{
    tagRECT rgrc[3];
    tagWINDOWPOS* lppos;
};

struct tagJOYCAPS2A
{
    uint32_t wMid;
    uint32_t wPid;
    char szPname[32];
    uint32_t wXmin;
    uint32_t wXmax;
    uint32_t wYmin;
    uint32_t wYmax;
    uint32_t wZmin;
    uint32_t wZmax;
    uint32_t wNumButtons;
    uint32_t wPeriodMin;
    uint32_t wPeriodMax;
    uint32_t wRmin;
    uint32_t wRmax;
    uint32_t wUmin;
    uint32_t wUmax;
    uint32_t wVmin;
    uint32_t wVmax;
    uint32_t wCaps;
    uint32_t wMaxAxes;
    uint32_t wNumAxes;
    uint32_t wMaxButtons;
    char szRegKey[32];
    char szOEMVxD[260];
    _GUID ManufacturerGuid;
    _GUID ProductGuid;
    _GUID NameGuid;
};

struct OPENCARD_SEARCH_CRITERIAA
{
    uint32_t dwStructSize;
    char* lpstrGroupNames;
    uint32_t nMaxGroupNames;
    _GUID* rgguidInterfaces;
    uint32_t cguidInterfaces;
    char* lpstrCardNames;
    uint32_t nMaxCardNames;
    int32_t* lpfnCheck;
    uint32_t* lpfnConnect;
    void* lpfnDisconnect;
    void* pvUserData;
    uint32_t dwShareMode;
    uint32_t dwPreferredProtocols;
};

struct _DRIVER_INFO_2A
{
    uint32_t cVersion;
    char* pName;
    char* pEnvironment;
    char* pDriverPath;
    char* pDataFile;
    char* pConfigFile;
};

struct CoreRegistryInterface
{
    CoreStringBuffer<256> m_subKey;
    CoreStringBuffer<256> m_fileName;
    CoreMemory* m_memoryInterface;
    static bool m_emulateUsingFile;

    // TODO vtable

    CoreRegistryInterface* CreateInstance(CoreMemory* i_memoryInterface);
    CoreRegistryInterface* GetDummyInstance();
    void DeleteInstance();
    void SetFileName();
    void SetSubKey(char* i_subKey);
    void EmulateUsingFile();
    bool IsEmulatingUsingFile();
    bool ReadNumber();
    int32_t ReadString();
    int32_t ReadBinary();
    bool WriteNumber();
    bool WriteString();
    bool WriteBinary();
    bool DeleteValue();
    void CoreRegistryInterface();
    void ~CoreRegistryInterface();
    CoreRegistryInterface* CreateInstanceSKU(CoreMemory* i_memoryInterface);
    CoreRegistryInterface* CreateEmulationUsingFileInstance();
};

struct IExternalConnection : IUnknown
{
    uint32_t __stdcall AddConnection();
    uint32_t __stdcall ReleaseConnection();
    void IExternalConnection();
};

struct CoreBGLightController
{
    enum
    {
        LCON_DATA_SECTION_SIZE_INDEX,
        LCON_NUM_CONTROLLERS,
        LCON_NUM_PATTERNS,
        LCON_PATTERNS_OFFSET,
        LCON_CONTROLLER_OFFSETS,
    };

    uint32_t m_lightFlags;
    float m_posX;
    float m_posY;
    float m_posZ;
    float m_rad;
    uint32_t m_lightID;
    uint32_t m_numFrames;
    uint32_t m_blendFrameStart;
    uint32_t m_blendFrameEnd;
    uint32_t m_childContainers[8];
    uint32_t m_numchildMeshes[8];
    uint32_t m_childMeshDataOffset[8];
    uint32_t m_numChildContainers;
    uint32_t m_currentFrame;
    uint32_t m_blendTime;
    uint32_t m_blendTimeEnd;
    uint32_t m_referenceVal;
    uint32_t m_parentLightHash;
    uint32_t m_patternIndex;
    CoreLevelLight* m_coreLight;
    uint32_t m_animTime;
    uint32_t m_animDelta;
    uint32_t m_data;

    CoreBGLightController* GetLightControllerFromID(CoreLevelCompiled* iLevelCompiled, uint32_t iID);
    CoreBGLightPattern* GetLightPatternFromID();
    uint32_t GetNumLightControllers(CoreLevelCompiled* iLevelCompiled);
    uint32_t GetNumLightPatterns();
    void UpdateLight();
    void SetBlend();
    void UpdateChildMeshes();
    void RenderDebug();
};

struct CoreTexturePagePS : CoreTexturePage
{
    uint32_t m_iMaxMipMapLevel;
    int32_t m_iMipMapOffsets[7];
    CoreQWORD m_qwClutGIFTAG;
    uint32_t m_uiPalette[1];

    void CoreTexturePagePS();
    void ~CoreTexturePagePS();
    CoreQWORD* lpqwGetClutGIFTAG();
    uint32_t* GetPalette();
    CoreQWORD* lpqwGetImageGIFTAG();
    uint32_t* GetImage32();
    uint32_t* GetImage24();
    uint32_t* GetImage8();
    uint32_t* GetImage4();
    CoreQWORD* lpqwGetMipMapImageGIFTAG();
    uint32_t* GetMipMapImage32();
    uint32_t* GetMipMapImage24();
    uint32_t* GetMipMapImage8();
    uint32_t* GetMipMapImage4();
    int32_t GetNumColours();
    uint32_t GetMaxMipMapLevel();
    uint32_t* GetPalettePtr();
};

struct CoreAngle
{
    // TODO vtable

    float ClampAngle(float i_angle);
    float ClosestAngle(float i_angleFrom, float i_angleTo);
    bool MoveSourceToTarget(float& io_angleSource, float i_angleTarget, float i_speed);
    void CoreAngle();
    void ~CoreAngle();
    void YouCannotInstanceThisClass();
};

struct CoreBinaryScriptStore : CoreScriptStore
{
    uint32_t* m_data;
    CoreScriptStore* m_parent;

    void CoreBinaryScriptStore();
    void ~CoreBinaryScriptStore();
    void SetParent(CoreScriptStore* i_parent);
    void Init(uint32_t* i_data);
    char* GetScriptObject(uint32_t i_type, uint32_t i_version, CoreHash i_name);
};

struct _QUERY_SERVICE_LOCK_STATUSA
{
    uint32_t fIsLocked;
    char* lpLockOwner;
    uint32_t dwLockDuration;
};

struct CorePackedExit
{
    uint32_t m_navMesh;
    uint32_t m_triangle;
    uint32_t m_portal;
    uint32_t m_pack;
};

struct tagEMRGRADIENTFILL
{
    tagEMR emr;
    _RECTL rclBounds;
    uint32_t nVer;
    uint32_t nTri;
    uint32_t ulMode;
    _TRIVERTEX Ver[1];
};

struct ICreateTypeLib : IUnknown
{
    HRESULT __stdcall CreateTypeInfo();
    HRESULT __stdcall SetName();
    HRESULT __stdcall SetVersion();
    HRESULT __stdcall SetGuid();
    HRESULT __stdcall SetDocString();
    HRESULT __stdcall SetHelpFileName();
    HRESULT __stdcall SetHelpContext();
    HRESULT __stdcall SetLcid();
    HRESULT __stdcall SetLibFlags();
    HRESULT __stdcall SaveAllChanges();
    void ICreateTypeLib();
};

struct tagTPMPARAMS
{
    uint32_t cbSize;
    tagRECT rcExclude;
};

struct tagCABOOL
{
    uint32_t cElems;
    int32_t* pElems;
};

struct CoreMapFileFunction
{
    uint32_t m_function_STLU;
    uint32_t m_sizeToNext : 11;
    uint32_t m_parametersCount : 3;
    uint32_t m_fileNameFollows : 1;
    uint32_t m_classNameFollows : 1;
};

struct olicelpwaveformat_tag
{
    tWAVEFORMATEX wfx;
};

struct CoreCutScenePlayer : CoreScripted
{
    CoreCutScenePlayerData* m_lpoData;

    void CoreCutScenePlayer();
    void ~CoreCutScenePlayer();
    void Construct(CoreMemory* lpoMemory);
    void Destruct(CoreMemory* lpoMemory);
    void Init();
    void Reset();
    void Update(CoreObjectUpdateStruct* i_updateStruct);
    void PlayCutScene(CoreObjectUpdateStruct* i_updateStruct, CoreHash oCutScene, CoreHash cutSceneParent);
    void EndCutScene(CoreObjectUpdateStruct* i_updateStruct);
    CoreHash GetCutScenePlaying();
    bool IsCutScenePlaying();
    float GetTime();
    void SetOverrideModelName();
    void SetOverrideTextureName();
    CoreStringBuffer<256> GetOverrideModelName();
    CoreStringBuffer<256> GetOverrideTextureName();
    void SetTitleCutsceneState();
    int32_t GetTitleCutsceneState();
    bool IsRequestedPlay();
    void DoDebug(CoreDebugInput* i_input);
    float AnimTimeAdjust(float time);
    float GetFPSScaler();
    void SetCanSkipFlag();
    bool GetCanSkipFlag();
    void ForceNoSkip();
    void SetFadeInTime();
    void SetFadeOutTime();
    void SetAudioFadeInFactor();
    void SetAudioFadeOutFactor();
    void SetSpeedFactor();
    float GetSpeedFactor();
    void SetSound(CoreHash iSoundHash);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void SetCamera(CoreObjectUpdateStruct* i_updateStruct);
    CoreScripted::CommandReturn eFnWaitForFadeDown(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnStartTimer(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnWaitForTime(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetCamera(CoreCommand* i_command);
    CoreScripted::CommandReturn eFnInstanceObject(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnCopyObjectPos(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetObjectPos(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnEnd(CoreCommand* lpoCommand);
    CoreScripted::CommandReturn eFnSetSound(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnPlaySound2D(CoreCommand* io_command);
    CoreScripted::CommandReturn eFnStopSound(CoreCommand* io_command);
};

struct tMIXERCONTROLDETAILS
{
    uint32_t cbStruct;
    uint32_t dwControlID;
    uint32_t cChannels;
    HWND* hwndOwner;
    uint32_t cMultipleItems;
    uint32_t cbDetails;
    void* paDetails;
};

struct _CMC_STATUS_INFO
{
    uint32_t dwStatus;
    uint32_t cBodyList;
    uint32_t* rgdwBodyList;
    uint32_t* pwszStatusString;
    uint32_t dwOtherInfoChoice;
    uint32_t dwFailInfo;
    _CMC_PEND_INFO* pPendInfo;
};

struct IFillLockBytes : IUnknown
{
    HRESULT __stdcall FillAppend();
    HRESULT __stdcall FillAt();
    HRESULT __stdcall SetFillSize();
    HRESULT __stdcall Terminate();
    void IFillLockBytes();
};

struct tagFORMATETC
{
    uint32_t cfFormat;
    tagDVTARGETDEVICE* ptd;
    uint32_t dwAspect;
    int32_t lindex;
    uint32_t tymed;
};

struct _IMAGE_ROM_OPTIONAL_HEADER
{
    uint32_t Magic;
    uint32_t MajorLinkerVersion;
    uint32_t MinorLinkerVersion;
    uint32_t SizeOfCode;
    uint32_t SizeOfInitializedData;
    uint32_t SizeOfUninitializedData;
    uint32_t AddressOfEntryPoint;
    uint32_t BaseOfCode;
    uint32_t BaseOfData;
    uint32_t BaseOfBss;
    uint32_t GprMask;
    uint32_t CprMask[4];
    uint32_t GpValue;
};

struct _INPUT_RECORD
{
    uint32_t EventType;
    _INPUT_RECORD::__unnamed Event;
};

struct _CERT_USAGE_MATCH
{
    uint32_t dwType;
    _CTL_USAGE Usage;
};

struct CoreGsClamp
{
    uint32_t WMS : 2;
    uint32_t WMT : 2;
    uint32_t MINU : 10;
    uint32_t MAXU : 10;
    uint32_t MINV : 10;
    uint32_t MAXV : 10;
    uint32_t pad44 : 20;
};

struct _RPC_HTTP_TRANSPORT_CREDENTIALS_W
{
    _SEC_WINNT_AUTH_IDENTITY_W* TransportCredentials;
    uint32_t Flags;
    uint32_t AuthenticationTarget;
    uint32_t NumberOfAuthnSchemes;
    uint32_t* AuthnSchemes;
    uint32_t* ServerCertificateSubject;
};

struct CoreXMLDocString
{
    CoreXMLDocString* m_pNext;
    uint32_t m_Ref;
    uint32_t m_Len;
    uint32_t m_Hash;
    char* m_pString;
    char m_padString[19];
    uint32_t m_Flags;
    CoreMemory* m_pMemory;

    void CoreXMLDocString();
    void ~CoreXMLDocString();
    CoreXMLDocString* Next();
    void Set();
    void SetNext();
    char* GetString();
    int32_t Length();
    bool CompareStringA();
    int32_t Append();
};

struct CoreFXEmitter : CoreFXControl
{
    CoreVector m_oldPos;
    CoreVector m_BoxMin;
    CoreVector m_BoxMax;
    CoreVector m_Pos1;
    float m_Radius;
    TRNode* m_pOwnerNode;
    CoreHash m_ID;
    uint32_t m_Flags;
    uint32_t m_Shape;
    float m_GlobalRate;
    uint32_t m_nItems;
    uint32_t m_iItem;
    uint32_t m_nVars;
    uint32_t m_iVar;
    CoreObject* m_pAttachObject[2];
    CoreHash m_iAttachBone[2];
    CoreHash m_GlobalEvent;
    CoreHash m_Class;
    CoreFXEmitterItem* m_pItems;
    CoreFXMappedVariable* m_pVarMaps;
    int32_t m_generalInts[4];
    float m_generalFloats[4];
    void* m_controlFunc;

    void CoreFXEmitter();
    void ~CoreFXEmitter();
};

struct _ACL_SIZE_INFORMATION
{
    uint32_t AceCount;
    uint32_t AclBytesInUse;
    uint32_t AclBytesFree;
};

struct _TAPE_WRITE_MARKS
{
    uint32_t Type;
    uint32_t Count;
    uint32_t Immediate;
};

struct _PERF_COUNTER_DEFINITION
{
    uint32_t ByteLength;
    uint32_t CounterNameTitleIndex;
    uint32_t* CounterNameTitle;
    uint32_t CounterHelpTitleIndex;
    uint32_t* CounterHelpTitle;
    int32_t DefaultScale;
    uint32_t DetailLevel;
    uint32_t CounterType;
    uint32_t CounterSize;
    uint32_t CounterOffset;
};

struct HRSRC__
{
    int32_t unused;
};

struct _CERT_CRL_CONTEXT_PAIR
{
    _CERT_CONTEXT* pCertContext;
    _CRL_CONTEXT* pCrlContext;
};

struct CoreXMLSchemaNode : CoreXMLNode_
{
    char* m_szVarName;
    CORE_XML_TYPE m_VarType;
    bool m_bMinSet;
    bool m_bMaxSet;
    int32_t m_sMin;
    uint32_t m_uMin;
    float m_fMin;
    int32_t m_sMax;
    uint32_t m_uMax;
    float m_fMax;

    void CoreXMLSchemaNode();
    void ~CoreXMLSchemaNode();
    void SetValName();
    void SetValType();
    CORE_XML_TYPE GetValType();
    char* GetValName();
    void SetValMin();
    void SetValMax();
    void CreateSchemaNode();
    void Initialize();
};

struct _SHQUERYRBINFO
{
    uint32_t cbSize;
    int32_t i64Size;
    int32_t i64NumItems;
};

struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT
{
    void* CompletionKey;
    void* CompletionPort;
};

struct IInternetProtocol : IInternetProtocolRoot
{
    HRESULT __stdcall Read();
    HRESULT __stdcall Seek();
    HRESULT __stdcall LockRequest();
    HRESULT __stdcall UnlockRequest();
    void IInternetProtocol();
};

struct tagELEMDESC
{
    tagTYPEDESC tdesc;
    tagIDLDESC idldesc;
    tagPARAMDESC paramdesc;
};

struct _IMAGE_BOUND_IMPORT_DESCRIPTOR
{
    uint32_t TimeDateStamp;
    uint32_t OffsetModuleName;
    uint32_t NumberOfModuleForwarderRefs;
};

struct IStorage : IUnknown
{
    HRESULT __stdcall CreateStream();
    HRESULT __stdcall OpenStream();
    HRESULT __stdcall CreateStorage();
    HRESULT __stdcall OpenStorage();
    HRESULT __stdcall CopyTo();
    HRESULT __stdcall MoveElementTo();
    HRESULT __stdcall Commit();
    HRESULT __stdcall Revert();
    HRESULT __stdcall EnumElements();
    HRESULT __stdcall DestroyElement();
    HRESULT __stdcall RenameElement();
    HRESULT __stdcall SetElementTimes();
    HRESULT __stdcall SetClass();
    HRESULT __stdcall SetStateBits();
    HRESULT __stdcall Stat();
    void IStorage();
};

struct CoreCriticalSectionString
{
    char* m_buffer;
    uint32_t m_bufferSize;
    uint32_t m_bufferUsed;

    void CoreCriticalSectionString();
    void Init();
    int32_t GetBufferSize();
    int32_t AddString();
    int32_t CopyAndReset();
    void Reset();
};

struct pvalueW
{
    uint32_t* pv_valuename;
    int32_t pv_valuelen;
    void* pv_value_context;
    uint32_t pv_type;
};

struct IBindStatusCallback : IUnknown
{
    HRESULT __stdcall OnStartBinding();
    HRESULT __stdcall GetPriority();
    HRESULT __stdcall OnLowResource();
    HRESULT __stdcall OnProgress();
    HRESULT __stdcall OnStopBinding();
    HRESULT __stdcall GetBindInfo();
    HRESULT __stdcall OnDataAvailable();
    HRESULT __stdcall OnObjectAvailable();
    void IBindStatusCallback();
};

struct tag_s_RIFFWAVE_inst
{
    uint32_t bUnshiftedNote;
    char chFineTune;
    char chGain;
    uint32_t bLowNote;
    uint32_t bHighNote;
    uint32_t bLowVelocity;
    uint32_t bHighVelocity;
};

struct CoreInputMapping
{
    CoreInputContext* m_context;
    CoreInputAction* m_actions;
    float m_frameTime;
    bool m_updated;

    void CoreInputMapping();
    bool Construct(CoreInputContext* i_context, CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory);
    uint32_t GetNumberActions();
    CoreInputContext* GetContext();
    void SetMapping();
    void SetActionMapping(CoreHash i_action, uint32_t i_slot, CoreInputID i_id);
    CoreInputID GetMapping();
    CoreInputID GetActionMapping();
    bool AreConflicts();
    int32_t GetConflict();
    bool CopyMapping();
    void Update(CoreInput* i_input);
    void ManualUpdate(CoreInput* i_input);
    void ManualUpdateAction(CoreHash i_action, float i_value);
    CoreInputAction* GetAction(CoreHash i_action);
    float GetAxisValue(CoreHash i_positive, CoreHash i_negative, float i_deadZone);
    float GetDirection(CoreHash i_up, CoreHash i_down, CoreHash i_left, CoreHash i_right, float i_deadZone, float& o_speed);
};

struct CoreInputContext
{
    struct ContextAction
    {
        CoreHash action;
        CoreHash name;

        void ContextAction();
        void ~ContextAction();
    };

    CoreInputContext::ContextAction* m_actions;
    uint32_t m_numActions;
    uint32_t m_maxActions;

    void CoreInputContext();
    bool Construct(uint32_t i_maxActions, CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory);
    bool RegisterAction(CoreHash i_action, CoreHash i_text);
    uint32_t GetNumberActions();
    CoreHash GetAction(uint32_t i_index);
    CoreHash GetActionText();
};

struct _FORM_INFO_1W
{
    uint32_t Flags;
    uint32_t* pName;
    tagSIZE Size;
    _RECTL ImageableArea;
};

struct IEnumMoniker : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumMoniker();
};

struct CoreMapNode
{
    enum RedBlackColor
    {
        RED,
        BLACK,
    };

    CoreMapNode* m_left;
    CoreMapNode* m_right;
    CoreMapNode* m_parent;
    CoreMapNode::RedBlackColor m_colour;
    CoreHash m_key;
    void* m_data;

    void CoreMapNode();
    void ~CoreMapNode();
};

struct CoreGsTexEnv2
{
    CoreGsTexflush texflush;
    int32_t texflushaddr;
    CoreGsTex1 tex12;
    int32_t tex12addr;
    CoreGsTex0 tex02;
    int32_t tex02addr;
    CoreGsClamp clamp2;
    int32_t clamp2addr;
};

struct CoreHashGroup : CoreHashElementTable
{
    uint32_t m_iTableSize;
    CoreArray<CoreHashElement> m_oElements;

    void CoreHashGroup();
    void ~CoreHashGroup();
    void Construct();
    void Destruct();
    bool bAdd();
    bool bRemove();
    bool Find();
    bool bUpdate();
    void RemoveAll();
    int32_t GetMaxNumItems();
    bool Write();
    CoreHashElement* GetElementPtr();
    bool bCompareHashArray();
    bool FindIndex();
    void Zero();
};

struct _CMC_TAGGED_OTHER_MSG
{
    uint32_t dwBodyPartID;
    char* pszObjId;
    _CRYPTOAPI_BLOB Value;
};

struct IMultiQI : IUnknown
{
    HRESULT __stdcall QueryMultipleInterfaces();
    void IMultiQI();
};

struct CoreGsPabe
{
    uint32_t PABE : 1;
    uint32_t pad01 : 63;
};

struct CoreNamedPipeInterface
{
    struct MessageHeader
    {
        enum
        {
            HEADER = 1479100260,
        };

        uint32_t m_messageHeader;
        uint32_t m_messageID;
        int32_t m_messageSize;

        void MessageHeader();
        void Reset();
        void Set();
        bool IsValid();
        uint32_t GetID();
        int32_t GetSize();
    };

    struct MessageFooter
    {
        enum
        {
            HEADER = 1182044805,
        };

        uint32_t m_messageHeader;

        void MessageFooter();
        bool IsValid();
    };

    static CoreNamedPipeInterface* m_defaultInstance;
    CoreMemory* m_memoryInterface;
    float m_lastMessageRead;
    float m_lastMessageSent;

    // TODO vtable

    CoreNamedPipeInterface* CreateInstance(CoreMemory* i_memoryInterface);
    CoreNamedPipeInterface* GetDummyInstance();
    CoreNamedPipeInterface* GetDefaultInstance();
    void SetDefaultInstance();
    void DeleteInstance();
    bool Create();
    bool Open();
    bool IsReady();
    bool IsDataReady();
    void Close();
    bool ReadMessage(void* o_buffer, int32_t i_bufferSize, int32_t& o_messageSize, uint32_t& o_messageID);
    bool SendMessageA();
    bool SendMessageString(uint32_t i_messageID, char* i_fmtString);
    float GetTimeSinceLastMessageRead();
    float GetTimeSinceLastMessageSent();
    float GetTimeSinceLastMessage();
    void ResetTimeSinceLastRead();
    void ResetTimeSinceLastSent();
    void ResetTimeSinceLastMessage();
    void CoreNamedPipeInterface();
    void ~CoreNamedPipeInterface();
    CoreNamedPipeInterface* CreateInstanceSKU(CoreMemory* i_memoryInterface);
    bool Read();
    bool Send();
    bool TrickleRead(void* o_buffer, int32_t i_bufferSize, CoreTimingSeconds& io_timeout);
    bool ReadHeader(CoreNamedPipeInterface::MessageHeader& o_header, CoreTimingSeconds& io_timeout);
    bool ReadFooter(CoreNamedPipeInterface::MessageFooter& o_footer, CoreTimingSeconds& io_timeout);
};

struct IXMLDOMDocument : IXMLDOMNode
{
    HRESULT __stdcall get_doctype();
    HRESULT __stdcall get_implementation();
    HRESULT __stdcall get_documentElement();
    HRESULT __stdcall putref_documentElement();
    HRESULT __stdcall createElement();
    HRESULT __stdcall createDocumentFragment();
    HRESULT __stdcall createTextNode();
    HRESULT __stdcall createComment();
    HRESULT __stdcall createCDATASection();
    HRESULT __stdcall createProcessingInstruction();
    HRESULT __stdcall createAttribute();
    HRESULT __stdcall createEntityReference();
    HRESULT __stdcall getElementsByTagName();
    HRESULT __stdcall createNode();
    HRESULT __stdcall nodeFromID();
    HRESULT __stdcall load();
    HRESULT __stdcall get_readyState();
    HRESULT __stdcall get_parseError();
    HRESULT __stdcall get_url();
    HRESULT __stdcall get_async();
    HRESULT __stdcall put_async();
    HRESULT __stdcall abort();
    HRESULT __stdcall loadXML();
    HRESULT __stdcall save();
    HRESULT __stdcall get_validateOnParse();
    HRESULT __stdcall put_validateOnParse();
    HRESULT __stdcall get_resolveExternals();
    HRESULT __stdcall put_resolveExternals();
    HRESULT __stdcall get_preserveWhiteSpace();
    HRESULT __stdcall put_preserveWhiteSpace();
    HRESULT __stdcall put_onreadystatechange();
    HRESULT __stdcall put_ondataavailable();
    HRESULT __stdcall put_ontransformnode();
    void IXMLDOMDocument();
};

struct tm
{
    int32_t tm_sec;
    int32_t tm_min;
    int32_t tm_hour;
    int32_t tm_mday;
    int32_t tm_mon;
    int32_t tm_year;
    int32_t tm_wday;
    int32_t tm_yday;
    int32_t tm_isdst;
};

struct linger
{
    uint32_t l_onoff;
    uint32_t l_linger;
};

struct _EFS_HASH_BLOB
{
    uint32_t cbData;
    uint32_t* pbData;
};

struct IBinding : IUnknown
{
    HRESULT __stdcall Abort();
    HRESULT __stdcall Suspend();
    HRESULT __stdcall Resume();
    HRESULT __stdcall SetPriority();
    HRESULT __stdcall GetPriority();
    HRESULT __stdcall GetBindResult();
    void IBinding();
};

struct CoreBezierFXPrimitive : CoreFXPrimitive
{
    CoreVector m_Ctl[4];
    CoreVector m_Vel[4];
    float m_Jitter;
    float m_StartWidth;
    float m_MidWidth;
    float m_EndWidth;
    uint32_t m_nSegs;
    uint32_t m_Step;
    uint32_t m_StepAdd;
    uint32_t m_Empty;
    int32_t m_RandSeed;

    void CoreBezierFXPrimitive();
    void ~CoreBezierFXPrimitive();
};

struct _IMAGE_DATA_DIRECTORY
{
    uint32_t VirtualAddress;
    uint32_t Size;
};

struct _PSFEATURE_CUSTPAPER
{
    int32_t lOrientation;
    int32_t lWidth;
    int32_t lHeight;
    int32_t lWidthOffset;
    int32_t lHeightOffset;
};

struct tagCUSTDATAITEM
{
    _GUID guid;
    tagVARIANT varValue;
};

struct CoretGS_SIGLBLID
{
    uint32_t SIGID : 32;
    uint32_t LBLID : 32;
};

struct _RGNDATAHEADER
{
    uint32_t dwSize;
    uint32_t iType;
    uint32_t nCount;
    uint32_t nRgnSize;
    tagRECT rcBound;
};

struct _JOB_INFO_2W
{
    uint32_t JobId;
    uint32_t* pPrinterName;
    uint32_t* pMachineName;
    uint32_t* pUserName;
    uint32_t* pDocument;
    uint32_t* pNotifyName;
    uint32_t* pDatatype;
    uint32_t* pPrintProcessor;
    uint32_t* pParameters;
    uint32_t* pDriverName;
    _devicemodeW* pDevMode;
    uint32_t* pStatus;
    void* pSecurityDescriptor;
    uint32_t Status;
    uint32_t Priority;
    uint32_t Position;
    uint32_t StartTime;
    uint32_t UntilTime;
    uint32_t TotalPages;
    uint32_t Size;
    _SYSTEMTIME Submitted;
    uint32_t Time;
    uint32_t PagesPrinted;
};

struct _BIDI_RESPONSE_CONTAINER
{
    uint32_t Version;
    uint32_t Flags;
    uint32_t Count;
    _BIDI_RESPONSE_DATA aData[1];
};

struct tagEMRFORMAT
{
    uint32_t dSignature;
    uint32_t nVersion;
    uint32_t cbData;
    uint32_t offData;
};

struct SCARD_READERSTATEA
{
    char* szReader;
    void* pvUserData;
    uint32_t dwCurrentState;
    uint32_t dwEventState;
    uint32_t cbAtr;
    uint32_t rgbAtr[36];
};

struct CAL0_AudioWadEntry
{
    char m_FileName[16];
    uint32_t m_OriginalLength;
    uint32_t m_WadFileOffset;
    uint32_t m_LanguageMask;
    uint32_t m_SeekPosition;
    CAL0_AudioWadManager* m_WadManager;

    void CAL0_AudioWadEntry();
    bool ReadEntry();
    uint32_t ReadData();
    uint32_t Seek();
    uint32_t GetPos();
};

struct CoreGsRgbaq
{
    uint32_t R : 8;
    uint32_t G : 8;
    uint32_t B : 8;
    uint32_t A : 8;
    float Q;
};

struct HFONT__
{
    int32_t unused;
};

struct tagLOGBRUSH
{
    uint32_t lbStyle;
    uint32_t lbColor;
    uint32_t lbHatch;
};

struct CoreMessageBoxInterface : CoreCommonDialogStatus
{
    enum CoreMessageBoxTypeTag
    {
        CORE_MB_TYPE_NO_BUTTONS,
        CORE_MB_TYPE_DEFAULT,
        CORE_MB_TYPE_YES_NO,
        CORE_MB_TYPE_NO_YES,
        CORE_MB_TYPE_RETRY,
        CORE_MB_TYPE_CANCEL,
        CORE_MB_TYPE_RETRY_CANCEL,
        CORE_MB_TYPE_CANCEL_RETRY,
        CORE_MB_TYPE_OK_CANCEL,
        CORE_MB_TYPE_CANCEL_OK,
        CORE_MB_TYPE_INVALID = 255,
    };

    enum CoreMessageBoxType
    {
        CORE_MB_TYPE_NO_BUTTONS,
        CORE_MB_TYPE_DEFAULT,
        CORE_MB_TYPE_YES_NO,
        CORE_MB_TYPE_NO_YES,
        CORE_MB_TYPE_RETRY,
        CORE_MB_TYPE_CANCEL,
        CORE_MB_TYPE_RETRY_CANCEL,
        CORE_MB_TYPE_CANCEL_RETRY,
        CORE_MB_TYPE_OK_CANCEL,
        CORE_MB_TYPE_CANCEL_OK,
        CORE_MB_TYPE_INVALID = 255,
    };

    CoreMessageBoxInterface::CoreMessageBoxTypeTag m_type;
    bool m_useGameRendered;
    int32_t m_selectedButtonIndex;
    static CoreMessageBoxInterface* m_dummyInstance;
    static CoreMessageBoxInterface* m_defaultInstance;
    static CoreMessageBoxInterface* m_gameInstance;

    CoreMessageBoxInterface* CreateInstance(CoreMemory* i_memoryInterface);
    CoreMessageBoxInterface* GetDummyInstance();
    CoreMessageBoxInterface* GetDefaultInstance();
    void SetDefaultInstance();
    void DeleteInstance();
    bool Prepare(CoreMessageBoxInterface::CoreMessageBoxTypeTag i_type, int32_t i_defaultButtonIndex, bool i_useGameRendered);
    bool PrepareDefault();
    bool PrepareNoButtons();
    bool PrepareYesNo();
    bool PrepareNoYes();
    bool PrepareRetry();
    bool PrepareCancel();
    bool PrepareRetryCancel();
    bool PrepareCancelRetry();
    bool PrepareOkCancel();
    bool PrepareCancelOk();
    bool Start();
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    bool IsReady();
    void CoreMessageBoxInterface();
};

struct CoreAnimUtils
{
    // TODO vtable

    bool ParseValidJointNamesFile();
    void CoreAnimUtils();
    void ~CoreAnimUtils();
    void YouCannotInstanceThisClass();
};

struct IProgressNotify : IUnknown
{
    HRESULT __stdcall OnProgress();
    void IProgressNotify();
};

struct _xml_error
{
    uint32_t _nLine;
    uint32_t* _pchBuf;
    uint32_t _cchBuf;
    uint32_t _ich;
    uint32_t* _pszFound;
    uint32_t* _pszExpected;
    uint32_t _reserved1;
    uint32_t _reserved2;
};

struct IInternetSession : IUnknown
{
    HRESULT __stdcall RegisterNameSpace();
    HRESULT __stdcall UnregisterNameSpace();
    HRESULT __stdcall RegisterMimeFilter();
    HRESULT __stdcall UnregisterMimeFilter();
    HRESULT __stdcall CreateBinding();
    HRESULT __stdcall SetSessionOption();
    HRESULT __stdcall GetSessionOption();
    void IInternetSession();
};

struct _OVERLAPPED
{
    uint32_t Internal;
    uint32_t InternalHigh;
    uint32_t Offset;
    uint32_t OffsetHigh;
    void* Pointer;
    void* hEvent;
};

struct tagOIFI
{
    uint32_t cb;
    int32_t fMDIApp;
    HWND* hwndFrame;
    HACCEL__* haccel;
    uint32_t cAccelEntries;
};

struct HDESK__
{
    int32_t unused;
};

struct CoreGsLabel
{
    uint32_t ID;
    uint32_t IDMSK;
};

struct CoreGsAlpha
{
    uint32_t A : 2;
    uint32_t B : 2;
    uint32_t C : 2;
    uint32_t D : 2;
    uint32_t pad8 : 24;
    uint32_t FIX : 8;
    uint32_t pad40 : 24;
};

struct CoreGsColclamp
{
    uint32_t CLAMP : 1;
    uint32_t pad01 : 63;
};

struct CoreGsDimx
{
    uint32_t DIMX00 : 3;
    uint32_t pad00 : 1;
    uint32_t DIMX01 : 3;
    uint32_t pad01 : 1;
    uint32_t DIMX02 : 3;
    uint32_t pad02 : 1;
    uint32_t DIMX03 : 3;
    uint32_t pad03 : 1;
    uint32_t DIMX10 : 3;
    uint32_t pad10 : 1;
    uint32_t DIMX11 : 3;
    uint32_t pad11 : 1;
    uint32_t DIMX12 : 3;
    uint32_t pad12 : 1;
    uint32_t DIMX13 : 3;
    uint32_t pad13 : 1;
    uint32_t DIMX20 : 3;
    uint32_t pad20 : 1;
    uint32_t DIMX21 : 3;
    uint32_t pad21 : 1;
    uint32_t DIMX22 : 3;
    uint32_t pad22 : 1;
    uint32_t DIMX23 : 3;
    uint32_t pad23 : 1;
    uint32_t DIMX30 : 3;
    uint32_t pad30 : 1;
    uint32_t DIMX31 : 3;
    uint32_t pad31 : 1;
    uint32_t DIMX32 : 3;
    uint32_t pad32 : 1;
    uint32_t DIMX33 : 3;
    uint32_t pad33 : 1;
};

struct CoreGsFinish
{
    uint32_t pad00;
};

struct CoreGsMiptbp1
{
    uint32_t TBP1 : 14;
    uint32_t TBW1 : 6;
    uint32_t TBP2 : 14;
    uint32_t TBW2 : 6;
    uint32_t TBP3 : 14;
    uint32_t TBW3 : 6;
    uint32_t pad60 : 4;
};

struct CoreGsPrim
{
    uint32_t PRIM : 3;
    uint32_t IIP : 1;
    uint32_t TME : 1;
    uint32_t FGE : 1;
    uint32_t ABE : 1;
    uint32_t AA1 : 1;
    uint32_t FST : 1;
    uint32_t CTXT : 1;
    uint32_t FIX : 1;
    uint32_t pad11 : 53;
};

struct CoreGsScissor
{
    uint32_t SCAX0 : 11;
    uint32_t pad11 : 5;
    uint32_t SCAX1 : 11;
    uint32_t pad27 : 5;
    uint32_t SCAY0 : 11;
    uint32_t pad43 : 5;
    uint32_t SCAY1 : 11;
    uint32_t pad59 : 5;
};

struct CoreGsSignal
{
    uint32_t ID;
    uint32_t IDMSK;
};

struct CoreGsTexa
{
    uint32_t TA0 : 8;
    uint32_t pad08 : 7;
    uint32_t AEM : 1;
    uint32_t pad16 : 16;
    uint32_t TA1 : 8;
    uint32_t pad40 : 24;
};

struct CoreGsTrxreg
{
    uint32_t RRW : 12;
    uint32_t pad12 : 20;
    uint32_t RRH : 12;
    uint32_t pad44 : 20;
};

struct CoreGsXyoffset
{
    uint32_t OFX : 16;
    uint32_t pad16 : 16;
    uint32_t OFY : 16;
    uint32_t pad48 : 16;
};

struct CoreGsZbuf
{
    uint32_t ZBP : 9;
    uint32_t pad09 : 15;
    uint32_t PSM : 4;
    uint32_t pad28 : 4;
    uint32_t ZMSK : 1;
    uint32_t pad33 : 31;
};

struct CoretGS_PMODE
{
    uint32_t EN1 : 1;
    uint32_t EN2 : 1;
    uint32_t CRTMD : 3;
    uint32_t MMOD : 1;
    uint32_t AMOD : 1;
    uint32_t SLBG : 1;
    uint32_t ALP : 8;
    uint32_t p0 : 16;
    uint32_t p1;
};

struct CoretGS_DISPLAY1
{
    uint32_t DX : 12;
    uint32_t DY : 11;
    uint32_t MAGH : 4;
    uint32_t MAGV : 2;
    uint32_t p0 : 3;
    uint32_t DW : 12;
    uint32_t DH : 11;
    uint32_t p1 : 9;
};

struct CoretGS_IMR
{
    uint32_t p0 : 8;
    uint32_t SIGMSK : 1;
    uint32_t FINISHMSK : 1;
    uint32_t HSMSK : 1;
    uint32_t VSMSK : 1;
    uint32_t EDWMSK : 1;
    uint32_t p1 : 19;
    uint32_t p2;
};

struct CoreGsDrawEnv1
{
    CoreGsFrame frame1;
    uint32_t frame1addr;
    CoreGsZbuf zbuf1;
    int32_t zbuf1addr;
    CoreGsXyoffset xyoffset1;
    int32_t xyoffset1addr;
    CoreGsScissor scissor1;
    int32_t scissor1addr;
    CoreGsPrmodecont prmodecont;
    int32_t prmodecontaddr;
    CoreGsColclamp colclamp;
    int32_t colclampaddr;
    CoreGsDthe dthe;
    int32_t dtheaddr;
    CoreGsTest test1;
    int32_t test1addr;
};

struct CoreGsClear
{
    CoreGsTest testa;
    int32_t testaaddr;
    CoreGsPrim prim;
    int32_t primaddr;
    CoreGsRgbaq rgbaq;
    int32_t rgbaqaddr;
    CoreGsXyz xyz2a;
    int32_t xyz2aaddr;
    CoreGsXyz xyz2b;
    int32_t xyz2baddr;
    CoreGsTest testb;
    int32_t testbaddr;
};

struct CoreGsDBuffDc
{
    CoreGsDispEnv disp[2];
    CoreGifTag giftag0;
    CoreGsDrawEnv1 draw01;
    CoreGsDrawEnv2 draw02;
    CoreGsClear clear0;
    CoreGifTag giftag1;
    CoreGsDrawEnv1 draw11;
    CoreGsDrawEnv2 draw12;
    CoreGsClear clear1;
};

struct CoreGsAlphaEnv
{
    CoreGsAlpha alpha1;
    int32_t alpha1addr;
    CoreGsPabe pabe;
    int32_t pabeaddr;
    CoreGsTexa texa;
    int32_t texaaddr;
    CoreGsFba fba1;
    int32_t fba1addr;
};

struct CoreGsAlphaEnv2
{
    CoreGsAlpha alpha2;
    int32_t alpha2addr;
    CoreGsPabe pabe;
    int32_t pabeaddr;
    CoreGsTexa texa;
    int32_t texaaddr;
    CoreGsFba fba2;
    int32_t fba2addr;
};

struct POWER_ACTION_POLICY
{
    POWER_ACTION Action;
    uint32_t Flags;
    uint32_t EventCode;
};

struct SYSTEM_POWER_CAPABILITIES
{
    uint32_t PowerButtonPresent;
    uint32_t SleepButtonPresent;
    uint32_t LidPresent;
    uint32_t SystemS1;
    uint32_t SystemS2;
    uint32_t SystemS3;
    uint32_t SystemS4;
    uint32_t SystemS5;
    uint32_t HiberFilePresent;
    uint32_t FullWake;
    uint32_t VideoDimPresent;
    uint32_t ApmPresent;
    uint32_t UpsPresent;
    uint32_t ThermalControl;
    uint32_t ProcessorThrottle;
    uint32_t ProcessorMinThrottle;
    uint32_t ProcessorMaxThrottle;
    uint32_t spare2[4];
    uint32_t DiskSpinDown;
    uint32_t spare3[8];
    uint32_t SystemBatteriesPresent;
    uint32_t BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];
    _SYSTEM_POWER_STATE AcOnLineWake;
    _SYSTEM_POWER_STATE SoftLidWake;
    _SYSTEM_POWER_STATE RtcWake;
    _SYSTEM_POWER_STATE MinDeviceWakeState;
    _SYSTEM_POWER_STATE DefaultLowLatencyWake;
};

struct BITMAPV4HEADER
{
    uint32_t bV4Size;
    int32_t bV4Width;
    int32_t bV4Height;
    uint32_t bV4Planes;
    uint32_t bV4BitCount;
    uint32_t bV4V4Compression;
    uint32_t bV4SizeImage;
    int32_t bV4XPelsPerMeter;
    int32_t bV4YPelsPerMeter;
    uint32_t bV4ClrUsed;
    uint32_t bV4ClrImportant;
    uint32_t bV4RedMask;
    uint32_t bV4GreenMask;
    uint32_t bV4BlueMask;
    uint32_t bV4AlphaMask;
    uint32_t bV4CSType;
    tagICEXYZTRIPLE bV4Endpoints;
    uint32_t bV4GammaRed;
    uint32_t bV4GammaGreen;
    uint32_t bV4GammaBlue;
};

struct BITMAPV5HEADER
{
    uint32_t bV5Size;
    int32_t bV5Width;
    int32_t bV5Height;
    uint32_t bV5Planes;
    uint32_t bV5BitCount;
    uint32_t bV5Compression;
    uint32_t bV5SizeImage;
    int32_t bV5XPelsPerMeter;
    int32_t bV5YPelsPerMeter;
    uint32_t bV5ClrUsed;
    uint32_t bV5ClrImportant;
    uint32_t bV5RedMask;
    uint32_t bV5GreenMask;
    uint32_t bV5BlueMask;
    uint32_t bV5AlphaMask;
    uint32_t bV5CSType;
    tagICEXYZTRIPLE bV5Endpoints;
    uint32_t bV5GammaRed;
    uint32_t bV5GammaGreen;
    uint32_t bV5GammaBlue;
    uint32_t bV5Intent;
    uint32_t bV5ProfileData;
    uint32_t bV5ProfileSize;
    uint32_t bV5Reserved;
};

struct MENUITEMTEMPLATE
{
    uint32_t mtOption;
    uint32_t mtID;
    uint32_t mtString[1];
};

struct DDEPOKE
{
    uint32_t unused : 13;
    uint32_t fRelease : 1;
    uint32_t fReserved : 2;
    int32_t cfFormat;
    uint32_t Value[1];
};

struct DDELN
{
    uint32_t unused : 13;
    uint32_t fRelease : 1;
    uint32_t fDeferUpd : 1;
    uint32_t fAckReq : 1;
    int32_t cfFormat;
};

struct DDEUP
{
    uint32_t unused : 12;
    uint32_t fAck : 1;
    uint32_t fRelease : 1;
    uint32_t fReserved : 1;
    uint32_t fAckReq : 1;
    int32_t cfFormat;
    uint32_t rgb[1];
};

struct RPC_STATS_VECTOR
{
    uint32_t Count;
    uint32_t Stats[1];
};

struct RPC_CLIENT_INFORMATION1
{
    uint32_t* UserName;
    uint32_t* ComputerName;
    uint32_t Privilege;
    uint32_t AuthFlags;
};

struct RPC_IMPORT_CONTEXT_P
{
    void* LookupContext;
    void* ProposedHandle;
    _RPC_BINDING_VECTOR* Bindings;
};

struct SCARD_READERSTATEW
{
    uint32_t* szReader;
    void* pvUserData;
    uint32_t dwCurrentState;
    uint32_t dwEventState;
    uint32_t cbAtr;
    uint32_t rgbAtr[36];
};

struct OPENCARD_SEARCH_CRITERIAW
{
    uint32_t dwStructSize;
    uint32_t* lpstrGroupNames;
    uint32_t nMaxGroupNames;
    _GUID* rgguidInterfaces;
    uint32_t cguidInterfaces;
    uint32_t* lpstrCardNames;
    uint32_t nMaxCardNames;
    int32_t* lpfnCheck;
    uint32_t* lpfnConnect;
    void* lpfnDisconnect;
    void* pvUserData;
    uint32_t dwShareMode;
    uint32_t dwPreferredProtocols;
};

struct OPENCARDNAME_EXW
{
    uint32_t dwStructSize;
    uint32_t hSCardContext;
    HWND* hwndOwner;
    uint32_t dwFlags;
    uint32_t* lpstrTitle;
    uint32_t* lpstrSearchDesc;
    HICON__* hIcon;
    OPENCARD_SEARCH_CRITERIAW* pOpenCardSearchCriteria;
    uint32_t* lpfnConnect;
    void* pvUserData;
    uint32_t dwShareMode;
    uint32_t dwPreferredProtocols;
    uint32_t* lpstrRdr;
    uint32_t nMaxRdr;
    uint32_t* lpstrCard;
    uint32_t nMaxCard;
    uint32_t dwActiveProtocol;
    uint32_t hCardHandle;
};

struct EAXUNIFIEDCAPS
{
    uint32_t ulSize;
    uint32_t ulEAXVersionsSupported;
};

struct CoreFontStringSpecial
{
    char m_char;
    CoreVector m_preStep;
    CoreVector m_postStep;
    float m_width;
    float m_height;

    void CoreFontStringSpecial();
};

struct _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA
{
    uint32_t cbSize;
    uint32_t hCryptProv;
    _CMSG_MAIL_LIST_RECIPIENT_INFO* pMailList;
    uint32_t dwRecipientIndex;
    uint32_t dwKeyChoice;
    uint32_t hKeyEncryptionKey;
    void* pvKeyEncryptionKey;
};

struct tagEMRSETMAPPERFLAGS
{
    tagEMR emr;
    uint32_t dwFlags;
};

struct HMETAFILE__
{
    int32_t unused;
};

struct _SYSTEM_POWER_STATUS
{
    uint32_t ACLineStatus;
    uint32_t BatteryFlag;
    uint32_t BatteryLifePercent;
    uint32_t Reserved1;
    uint32_t BatteryLifeTime;
    uint32_t BatteryFullLifeTime;
};

struct CoreMemoryPoolBlock
{
    void* m_ownerPtr;
    uint32_t m_lineNumber;
    CoreStringBuffer<6> m_fileName;

    void CoreMemoryPoolBlock();
    void ~CoreMemoryPoolBlock();
    bool IsFree();
    bool Alloc(void* i_newPtr, char* i_fileName, int32_t i_lineNumber);
    void Free();
    void* Ptr();
    char* GetFileName();
    int32_t GetLineNumber();
};

struct _IO_COUNTERS
{
    uint32_t ReadOperationCount;
    uint32_t WriteOperationCount;
    uint32_t OtherOperationCount;
    uint32_t ReadTransferCount;
    uint32_t WriteTransferCount;
    uint32_t OtherTransferCount;
};

struct HDDEDATA__
{
    int32_t unused;
};

struct tagPDEXW
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    void* hDevMode;
    void* hDevNames;
    HDC__* hDC;
    uint32_t Flags;
    uint32_t Flags2;
    uint32_t ExclusionFlags;
    uint32_t nPageRanges;
    uint32_t nMaxPageRanges;
    tagPRINTPAGERANGE* lpPageRanges;
    uint32_t nMinPage;
    uint32_t nMaxPage;
    uint32_t nCopies;
    HINSTANCE__* hInstance;
    uint32_t* lpPrintTemplateName;
    IUnknown* lpCallback;
    uint32_t nPropertyPages;
    _PSP** lphPropertyPages;
    uint32_t nStartPage;
    uint32_t dwResultAction;
};

struct _PUBLICKEYSTRUC
{
    uint32_t bType;
    uint32_t bVersion;
    uint32_t reserved;
    uint32_t aiKeyAlg;
};

struct _CTL_FIND_USAGE_PARA
{
    uint32_t cbSize;
    _CTL_USAGE SubjectUsage;
    _CRYPTOAPI_BLOB ListIdentifier;
    _CERT_INFO* pSigner;
};

struct IOleInPlaceSite : IOleWindow
{
    HRESULT __stdcall CanInPlaceActivate();
    HRESULT __stdcall OnInPlaceActivate();
    HRESULT __stdcall OnUIActivate();
    HRESULT __stdcall GetWindowContext();
    HRESULT __stdcall Scroll();
    HRESULT __stdcall OnUIDeactivate();
    HRESULT __stdcall OnInPlaceDeactivate();
    HRESULT __stdcall DiscardUndoState();
    HRESULT __stdcall DeactivateAndUndo();
    HRESULT __stdcall OnPosRectChange();
    void IOleInPlaceSite();
};

struct CoreMenuBase : CoreScripted
{
    void UpdateAssets(CoreHash i_assetID, CoreHash i_assetType);
    void UpdateComponentTexture(uint32_t i_index);
    void UpdateComponentFont(uint32_t i_index);
    void AddComponent();
    CoreMenuComponent* FindComponent(CoreCommand* io_command, int32_t i_paramIndex);
    int32_t GetNumComponents();
    CoreMenuComponent* GetComponent();
    CoreTextureSet* GetTextureSet();
    CoreHash GetTextureSetID();
    void SetTextureSet();
    CoreScripted::CommandReturn FnAddComponent(CoreCommand* io_command);
    CoreScripted::CommandReturn FnGetComponentX(CoreCommand* io_command);
    CoreScripted::CommandReturn FnGetComponentY(CoreCommand* io_command);
    CoreScripted::CommandReturn FnGetComponentW(CoreCommand* io_command);
    CoreScripted::CommandReturn FnGetComponentH(CoreCommand* io_command);
    CoreScripted::CommandReturn FnGetComponentRotation(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentRotation(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentAnchor(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentHorizontalSplitScreenXY(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentVerticalSplitScreenXY(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentXY(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentWH(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentUV0(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentUV1(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentCentreScale(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentNoPlatformScale(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentRGBA(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentVisibility(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentVisibilityUpHoldFade(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentTexture(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentFont(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentText(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentTextMode(CoreCommand* io_command);
    CoreScripted::CommandReturn FnLoadTextureSet(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetAllComponentVisibility(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentFrameCornerTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentFrameStraightTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentFrameBackGroundTextures(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentFrameCornerSizes(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentFrameBackGroundOffsets(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetComponentSpaceTextEvenly(CoreCommand* io_command);
    void CoreMenuBase();
    void ~CoreMenuBase();
};

struct _userHPALETTE
{
    union __MIDL_IWinTypes_0008
    {
        int32_t hInproc;
        tagLOGPALETTE* hRemote;
        int32_t hInproc64;
    };

    int32_t fContext;
    _userHPALETTE::__MIDL_IWinTypes_0008 u;
};

struct _userBITMAP
{
    int32_t bmType;
    int32_t bmWidth;
    int32_t bmHeight;
    int32_t bmWidthBytes;
    uint32_t bmPlanes;
    uint32_t bmBitsPixel;
    uint32_t cbSize;
    uint32_t pBuffer[1];
};

struct IRpcChannelBuffer2 : IRpcChannelBuffer
{
    HRESULT __stdcall GetProtocolVersion();
    void IRpcChannelBuffer2();
};

struct AsyncIPipeByte : IUnknown
{
    HRESULT __stdcall Begin_Pull();
    HRESULT __stdcall Finish_Pull();
    HRESULT __stdcall Begin_Push();
    HRESULT __stdcall Finish_Push();
    void AsyncIPipeByte();
};

struct _CRYPT_CONTENT_INFO
{
    char* pszObjId;
    _CRYPTOAPI_BLOB Content;
};

struct CAL1_AudioStreamer
{
    CAL1_Sample* m_Sample;
    CAL1_AudioDriver* m_AudioDriver;
    bool m_Playing;
    bool m_Allocated;
    bool m_StartFlag;
    uint32_t m_FileID;
    uint32_t m_FileOffset;
    bool m_GlobalStreamFile;
    bool m_loop;

    // TODO vtable

    void CAL1_AudioStreamer();
    void ~CAL1_AudioStreamer();
    CAAudioError Stream();
    CAAudioError Play(CAL1_Sample* sample);
    CAAudioError Stop();
    CAAudioError AllocateStreamer();
    CAAudioError DeallocateStreamer();
    void ResetStreamer();
    uint32_t GetPercentComplete();
    CAL1_Sample* GetSample();
    bool IsAllocated();
    bool IsPlaying();
};

struct CoreMemoryPool : CoreMemory
{
    CoreMemoryPoolBlock* m_blocks;
    int32_t m_numBlocks;
    int32_t m_blockSize;
    uint32_t* m_baseMem;

    void Construct();
    void Destruct();
    void* Alloc(uint32_t i_bytes, uint32_t i_alignment, char* i_fileName, uint32_t i_lineNumber);
    void Free(void* i_memory, char* i_fileName, int32_t i_lineNumber);
    int32_t GetMemoryAvailable();
    int32_t GetMemoryUsed();
    char* GetDebugTypeName();
    void CoreMemoryPool();
    void ~CoreMemoryPool();
    bool Init(int32_t i_poolSize, int32_t i_numBlocks, int32_t i_maxAlignment, CoreMemory* i_memory);
    bool Destroy();
    int32_t GetMaxSingleFree();
    bool Reset();
    int32_t DebugString(char* i_buffer);
    void DebugDetails();
    int32_t ComputeMemNeeded(int32_t i_poolSize, int32_t i_numBlocks);
    void Zero();
    bool IsValid();
    void* BlockPtr();
    int32_t GetBlockSize();
    void ComputeBlockSize();
};

struct IBindHost : IUnknown
{
    HRESULT __stdcall CreateMoniker();
    HRESULT __stdcall MonikerBindToStorage();
    HRESULT __stdcall MonikerBindToObject();
    void IBindHost();
};

struct CAL1_AudioItem
{
    static char* m_TypeNames[19];
    static char* m_TypeHeaders[19];
    uint32_t m_ID;
    uint32_t m_Instance;
    char* m_Name;
    uint32_t m_MixVolume;
    CA_AI_Type m_Type;

    // TODO vtable

    void CAL1_AudioItem();
    void ~CAL1_AudioItem();
    uint32_t GetID();
    char* GetName();
    CA_AI_Type GetType();
    uint32_t GetInstance();
    uint32_t GetMixVolume();
    void SetMixVolume();
    void SetName(char* name);
    void SetID();
    void SetInstance();
    uint32_t SaveData(uint32_t* memPtr);
    uint32_t GetSaveDataCount();
    uint32_t RestoreData(uint32_t* memPtr);
    CAAudioError LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
    CAAudioError SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
    CAAudioError DuplicateItem(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* i_AID);
    CAAudioError DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* i_AID);
    CAAudioError DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
};

struct _SE_IMPERSONATION_STATE
{
    void* Token;
    uint32_t CopyOnOpen;
    uint32_t EffectiveOnly;
    _SECURITY_IMPERSONATION_LEVEL Level;
};

struct tagPDA
{
    uint32_t lStructSize;
    HWND* hwndOwner;
    void* hDevMode;
    void* hDevNames;
    HDC__* hDC;
    uint32_t Flags;
    uint32_t nFromPage;
    uint32_t nToPage;
    uint32_t nMinPage;
    uint32_t nMaxPage;
    uint32_t nCopies;
    HINSTANCE__* hInstance;
    int32_t lCustData;
    uint32_t* lpfnPrintHook;
    uint32_t* lpfnSetupHook;
    char* lpPrintTemplateName;
    char* lpSetupTemplateName;
    void* hPrintTemplate;
    void* hSetupTemplate;
};

struct CorePerlinNoise
{
    float m_persistence;
    uint32_t m_octaveCount;

    void CorePerlinNoise();
    float GetPersistence();
    void SetPersistence();
    uint32_t GetOctaveCount();
    void SetOctaveCount();
    float GetPerlin();
    float GetInterpolatedNoise();
    float GetNoise();
    void CopyMembers();
    void __dflt_ctor_closure();
};

struct HBITMAP__
{
    int32_t unused;
};

struct tagDRAWITEMSTRUCT
{
    uint32_t CtlType;
    uint32_t CtlID;
    uint32_t itemID;
    uint32_t itemAction;
    uint32_t itemState;
    HWND* hwndItem;
    HDC__* hDC;
    tagRECT rcItem;
    uint32_t itemData;
};

struct _TypeDescriptor
{
    void* pVFTable;
    void* spare;
    char name[0];
};

struct tagMCI_INFO_PARMSA
{
    uint32_t dwCallback;
    char* lpstrReturn;
    uint32_t dwRetSize;
};

struct _DOC_INFO_3W
{
    uint32_t* pDocName;
    uint32_t* pOutputFile;
    uint32_t* pDatatype;
    uint32_t dwFlags;
};

struct IOplockStorage : IUnknown
{
    HRESULT __stdcall CreateStorageEx();
    HRESULT __stdcall OpenStorageEx();
    void IOplockStorage();
};

struct tagNEWTEXTMETRICEXW
{
    tagNEWTEXTMETRICW ntmTm;
    tagFONTSIGNATURE ntmFontSig;
};

struct IEnumContextProps : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    HRESULT __stdcall Count();
    void IEnumContextProps();
};

struct CoreCameraEffect
{
    enum CameraEffectType
    {
        CameraEffectTypeNull,
        CameraEffectTypeSteadycam,
        CameraEffectShake,
    };

    CoreCameraEffect::CameraEffectType m_type;
    float m_timer;
    int32_t m_stackPos;
    CoreVector m_posOffset;
    CoreVector m_lookAtOffset;
    CoreCameraEffect::CameraEffectType m_effectStack[16];
    CoreVector m_steadicam_NewOffset;
    CoreVector m_steadicam_OldOffset;
    float m_steadicam_Timer;
    float m_steadicam_MaxTime;
    CoreVector m_steadicam_NewAtOffset;
    CoreVector m_steadicam_OldAtOffset;
    float m_steadicam_AtTimer;
    float m_steadicam_AtMaxTime;
    float m_shakecam_Timer;
    float m_shakecam_MaxTimer;
    float m_shakecam_MinShake;
    float m_shakecam_MaxShake;

    void Init();
    void Update(float ut);
    void PushType(CoreCameraEffect::CameraEffectType i_type);
    void PopType();
    CoreVector GetOffset();
    CoreVector GetLookAtOffset();
    void SetupType();
    void SetupCommon();
    void CoreCameraEffect();
};

struct ITypeInfo : IUnknown
{
    HRESULT __stdcall GetTypeAttr();
    HRESULT __stdcall GetTypeComp();
    HRESULT __stdcall GetFuncDesc();
    HRESULT __stdcall GetVarDesc();
    HRESULT __stdcall GetNames();
    HRESULT __stdcall GetRefTypeOfImplType();
    HRESULT __stdcall GetImplTypeFlags();
    HRESULT __stdcall GetIDsOfNames();
    HRESULT __stdcall Invoke();
    HRESULT __stdcall GetDocumentation();
    HRESULT __stdcall GetDllEntry();
    HRESULT __stdcall GetRefTypeInfo();
    HRESULT __stdcall AddressOfMember();
    HRESULT __stdcall CreateInstance();
    HRESULT __stdcall GetMops();
    HRESULT __stdcall GetContainingTypeLib();
    void __stdcall ReleaseTypeAttr();
    void __stdcall ReleaseFuncDesc();
    void __stdcall ReleaseVarDesc();
    void ITypeInfo();
};

struct tagGCP_RESULTSW
{
    uint32_t lStructSize;
    uint32_t* lpOutString;
    uint32_t* lpOrder;
    int32_t* lpDx;
    int32_t* lpCaretPos;
    char* lpClass;
    uint32_t* lpGlyphs;
    uint32_t nGlyphs;
    int32_t nMaxFit;
};

struct IXMLElement : IDispatch
{
    HRESULT __stdcall get_tagName();
    HRESULT __stdcall put_tagName();
    HRESULT __stdcall get_parent();
    HRESULT __stdcall setAttribute();
    HRESULT __stdcall getAttribute();
    HRESULT __stdcall removeAttribute();
    HRESULT __stdcall get_children();
    HRESULT __stdcall get_type();
    HRESULT __stdcall get_text();
    HRESULT __stdcall put_text();
    HRESULT __stdcall addChild();
    HRESULT __stdcall removeChild();
    void IXMLElement();
};

struct CoreGeometryCompiledPSPUnlitMeshVertex
{
    uint32_t u16;
    uint32_t v16;
    float x32;
    float y32;
    float z32;
};

struct IPrintDialogCallback : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall InitDone();
    HRESULT __stdcall SelectionChange();
    HRESULT __stdcall HandleMessage();
    void IPrintDialogCallback();
};

struct _QUOTA_LIMITS_EX
{
    uint32_t PagedPoolLimit;
    uint32_t NonPagedPoolLimit;
    uint32_t MinimumWorkingSetSize;
    uint32_t MaximumWorkingSetSize;
    uint32_t PagefileLimit;
    _LARGE_INTEGER TimeLimit;
    uint32_t Reserved1;
    uint32_t Reserved2;
    uint32_t Reserved3;
    uint32_t Reserved4;
    uint32_t Flags;
    uint32_t Reserved5;
};

struct _IMAGE_IMPORT_BY_NAME
{
    uint32_t Hint;
    uint32_t Name[1];
};

struct tagEMREXTSELECTCLIPRGN
{
    tagEMR emr;
    uint32_t cbRgnData;
    uint32_t iMode;
    uint32_t RgnData[1];
};

struct ISynchronizeHandle : IUnknown
{
    HRESULT __stdcall GetHandle();
    void ISynchronizeHandle();
};

struct CoreMeshGroupXB
{
    uint32_t m_uiNumMeshes;
    int32_t m_iModelMeshIndexTable[1];

    void CoreMeshGroupXB();
    void ~CoreMeshGroupXB();
    CoreModelMesh* GetModelMeshPtr();
    uint32_t GetNumMeshes();
    int32_t* GetModelMeshIndexTable();
};

struct _IMAGE_BASE_RELOCATION
{
    uint32_t VirtualAddress;
    uint32_t SizeOfBlock;
};

struct IRpcChannelBuffer3 : IRpcChannelBuffer2
{
    HRESULT __stdcall Send();
    HRESULT __stdcall Receive();
    HRESULT __stdcall Cancel();
    HRESULT __stdcall GetCallContext();
    HRESULT __stdcall GetDestCtxEx();
    HRESULT __stdcall GetState();
    HRESULT __stdcall RegisterAsync();
    void IRpcChannelBuffer3();
};

struct IStream : ISequentialStream
{
    HRESULT __stdcall Seek();
    HRESULT __stdcall SetSize();
    HRESULT __stdcall CopyTo();
    HRESULT __stdcall Commit();
    HRESULT __stdcall Revert();
    HRESULT __stdcall LockRegion();
    HRESULT __stdcall UnlockRegion();
    HRESULT __stdcall Stat();
    HRESULT __stdcall Clone();
    void IStream();
};

struct IPipeByte : IUnknown
{
    HRESULT __stdcall Pull();
    HRESULT __stdcall Push();
    void IPipeByte();
};

struct IOleObject : IUnknown
{
    HRESULT __stdcall SetClientSite();
    HRESULT __stdcall GetClientSite();
    HRESULT __stdcall SetHostNames();
    HRESULT __stdcall Close();
    HRESULT __stdcall SetMoniker();
    HRESULT __stdcall GetMoniker();
    HRESULT __stdcall InitFromData();
    HRESULT __stdcall GetClipboardData();
    HRESULT __stdcall DoVerb();
    HRESULT __stdcall EnumVerbs();
    HRESULT __stdcall Update();
    HRESULT __stdcall IsUpToDate();
    HRESULT __stdcall GetUserClassID();
    HRESULT __stdcall GetUserType();
    HRESULT __stdcall SetExtent();
    HRESULT __stdcall GetExtent();
    HRESULT __stdcall Advise();
    HRESULT __stdcall Unadvise();
    HRESULT __stdcall EnumAdvise();
    HRESULT __stdcall GetMiscStatus();
    HRESULT __stdcall SetColorScheme();
    void IOleObject();
};

struct tagEMRSETPALETTEENTRIES
{
    tagEMR emr;
    uint32_t ihPal;
    uint32_t iStart;
    uint32_t cEntries;
    tagPALETTEENTRY aPalEntries[1];
};

struct IEnumSTATDATA : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumSTATDATA();
};

struct CoreFXWaterControl
{
    float m_xs;
    float m_zs;
    float m_UnitSize;
    CoreVector m_Pos;
    CoreVector* m_Points;

    void CoreFXWaterControl();
};

struct _CMSG_CMS_RECIPIENT_INFO
{
    uint32_t dwRecipientChoice;
    _CMSG_KEY_TRANS_RECIPIENT_INFO* pKeyTrans;
    _CMSG_KEY_AGREE_RECIPIENT_INFO* pKeyAgree;
    _CMSG_MAIL_LIST_RECIPIENT_INFO* pMailList;
};

struct _TAPE_GET_STATISTICS
{
    uint32_t Operation;
};

struct IXTLRuntime : IXMLDOMNode
{
    HRESULT __stdcall uniqueID();
    HRESULT __stdcall depth();
    HRESULT __stdcall childNumber();
    HRESULT __stdcall ancestorChildNumber();
    HRESULT __stdcall absoluteChildNumber();
    HRESULT __stdcall formatIndex();
    HRESULT __stdcall formatNumber();
    HRESULT __stdcall formatDate();
    HRESULT __stdcall formatTime();
    void IXTLRuntime();
};

struct _FORMAT_PARAMETERS
{
    _MEDIA_TYPE MediaType;
    uint32_t StartCylinderNumber;
    uint32_t EndCylinderNumber;
    uint32_t StartHeadNumber;
    uint32_t EndHeadNumber;
};

struct _CERT_TRUST_LIST_INFO
{
    uint32_t cbSize;
    _CTL_ENTRY* pCtlEntry;
    _CTL_CONTEXT* pCtlContext;
};

struct _PRINTER_DEFAULTSW
{
    uint32_t* pDatatype;
    _devicemodeW* pDevMode;
    uint32_t DesiredAccess;
};

struct CoreUseful
{
    static char* m_defaultFilePrefix;

    // TODO vtable

    void* AlignNextAddress();
    void* AlignPreviousAddress();
    void* GetUncachedAddress();
    bool ExecuteApplicationOnPC(char* i_applicationName, char* i_commandLineArguments, bool i_waitUntilFinished);
    void ReportSystemMemory(char* i_title);
    char* GetDefaultFilePrefix();
    void SetDefaultFilePrefix();
    int32_t ReadDirectory();
    int32_t ShowDirectory();
    int32_t ReadFile(char* i_fileName, void* o_buffer, int32_t i_bufferSize, int32_t i_fromFilePosition);
    int32_t WriteFile(char* i_fileName, void* i_buffer, int32_t i_bufferSize);
    int32_t AppendToFile();
    void YouCannotInstanceThisClass();
    void CoreUseful();
    bool ShowDirectoryCallBack();
};

struct tagMSGBOXPARAMSW
{
    uint32_t cbSize;
    HWND* hwndOwner;
    HINSTANCE__* hInstance;
    uint32_t* lpszText;
    uint32_t* lpszCaption;
    uint32_t dwStyle;
    uint32_t* lpszIcon;
    uint32_t dwContextHelpId;
    void* lpfnMsgBoxCallback;
    uint32_t dwLanguageId;
};

struct _WINDOW_BUFFER_SIZE_RECORD
{
    _COORD dwSize;
};

struct CorePlatformVersion
{
    enum CorePlatformVersionEnum
    {
        UNKNOWN_PLATFORM = 255,
        PC_PLATFORM = 0,
        PS_PLATFORM = 1,
        GC_PLATFORM = 2,
        XB_PLATFORM = 3,
        PSP_PLATFORM = 4,
        COMMON_PLATFORM = 5,
    };

    // TODO vtable

    void ~CorePlatformVersion();
    void CorePlatformVersion();
    void YouCannotInstanceThisClass();
};

struct IRpcSyntaxNegotiate : IUnknown
{
    HRESULT __stdcall NegotiateSyntax();
    void IRpcSyntaxNegotiate();
};

struct ISynchronizeContainer : IUnknown
{
    HRESULT __stdcall AddSynchronize();
    HRESULT __stdcall WaitMultiple();
    void ISynchronizeContainer();
};

struct _SC_ACTION
{
    _SC_ACTION_TYPE Type;
    uint32_t Delay;
};

struct _wireBRECORD
{
    uint32_t fFlags;
    uint32_t clSize;
    IRecordInfo* pRecInfo;
    uint32_t* pRecord;
};

struct IDirectSoundFullDuplex : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall Initialize();
    void IDirectSoundFullDuplex();
};

struct CoreAudioObjectData
{
    CoreHash m_AudioObjectHash;
    uint32_t m_ObjectInstance;
    float m_MinDist;
    float m_MaxDist;
    uint32_t m_Attenuation;
    CoreVector m_Location;
    COREAUDIO_PROCESSING_TYPE m_ProcessingType;
    COREAUDIO_SOURCE_TYPE m_SourceType;
    uint32_t m_Occlusion;
    float m_FreqFactor;
    bool m_Update;
    uint32_t m_LoopingEventIDTable[8];

    void Reset();
    void CoreAudioObjectData();
    void ~CoreAudioObjectData();
};

struct tagCABSTRBLOB
{
    uint32_t cElems;
    tagBSTRBLOB* pElems;
};

struct IHttpSecurity : IWindowForBindingUI
{
    HRESULT __stdcall OnSecurityProblem();
    void IHttpSecurity();
};

struct tagSTATPROPSETSTG
{
    _GUID fmtid;
    _GUID clsid;
    uint32_t grfFlags;
    _FILETIME mtime;
    _FILETIME ctime;
    _FILETIME atime;
    uint32_t dwOSVersion;
};

struct ICreateTypeInfo2 : ICreateTypeInfo
{
    HRESULT __stdcall DeleteFuncDesc();
    HRESULT __stdcall DeleteFuncDescByMemId();
    HRESULT __stdcall DeleteVarDesc();
    HRESULT __stdcall DeleteVarDescByMemId();
    HRESULT __stdcall DeleteImplType();
    HRESULT __stdcall SetCustData();
    HRESULT __stdcall SetFuncCustData();
    HRESULT __stdcall SetParamCustData();
    HRESULT __stdcall SetVarCustData();
    HRESULT __stdcall SetImplTypeCustData();
    HRESULT __stdcall SetHelpStringContext();
    HRESULT __stdcall SetFuncHelpStringContext();
    HRESULT __stdcall SetVarHelpStringContext();
    HRESULT __stdcall Invalidate();
    HRESULT __stdcall SetName();
    void ICreateTypeInfo2();
};

struct _ZONEATTRIBUTES
{
    uint32_t cbSize;
    uint32_t szDisplayName[260];
    uint32_t szDescription[200];
    uint32_t szIconPath[260];
    uint32_t dwTemplateMinLevel;
    uint32_t dwTemplateRecommended;
    uint32_t dwTemplateCurrentLevel;
    uint32_t dwFlags;
};

struct CoreCluster
{
    CoreFileHandle m_clusterHandle;
    int32_t m_fileStart;
    int32_t m_fileSize;
    int32_t m_filePosition;
    uint32_t m_fileHash;
    uint32_t m_clusterHash;
    uint32_t m_clusterDataHeaderSize;
    CoreClusterData* m_clusterData;
    static CoreFileDevice* s_device;

    void CoreCluster();
    void ~CoreCluster();
    void Reset();
    CoreClusterData* GetClusterDataPtr();
    void SetClusterDataPtr(CoreClusterData* i_clusterData);
    void SetFileDevicePtr(CoreFileDevice* i_device);
    uint32_t GetClusterHeaderSize();
    bool Open(char* i_clusterName);
    bool CloseActive();
    bool Close();
    uint32_t OpenFile(char* i_fileName);
    bool CloseFile(uint32_t i_fileHash);
    int32_t ReadFile(uint32_t i_fileHash, void* i_dest, int32_t i_size);
    bool SeekFile(uint32_t i_fileHash, int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin);
    int32_t FileSize(uint32_t i_fileHash);
    int32_t GetFileSize(char* i_fileName);
    int32_t GetFileOffset(char* i_fileName);
    bool IsActive();
    uint32_t GetClusterHash();
    CoreClusterFileHeader* GetOpenInfo(char* i_fileName);
    bool DoesFileExist(char* i_fileName);
};

struct _CHAR_INFO
{
    _CHAR_INFO::__unnamed Char;
    uint32_t Attributes;
};

struct timeval
{
    int32_t tv_sec;
    int32_t tv_usec;
};

struct CoreKernelTimer
{
    int32_t iIntervalInTimerUnits;
    int32_t iTimerCount;
    int32_t iCyclesToRun;
    int32_t iMaxCyclesToRun;
    void* Function;
    void* lpData;
    bool bSet;
};

struct protoent
{
    char* p_name;
    char** p_aliases;
    int32_t p_proto;
};

struct IDirectSound : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall CreateSoundBuffer();
    HRESULT __stdcall GetCaps();
    HRESULT __stdcall DuplicateSoundBuffer();
    HRESULT __stdcall SetCooperativeLevel();
    HRESULT __stdcall Compact();
    HRESULT __stdcall GetSpeakerConfig();
    HRESULT __stdcall SetSpeakerConfig();
    HRESULT __stdcall Initialize();
    void IDirectSound();
};

struct _PROPSHEETHEADERA
{
    uint32_t dwSize;
    uint32_t dwFlags;
    HWND* hwndParent;
    HINSTANCE__* hInstance;
    HICON__* hIcon;
    char* pszIcon;
    char* pszCaption;
    uint32_t nPages;
    uint32_t nStartPage;
    char* pStartPage;
    _PROPSHEETPAGEA* ppsp;
    _PSP** phpage;
    int32_t* pfnCallback;
    HBITMAP__* hbmWatermark;
    char* pszbmWatermark;
    HPALETTE__* hplWatermark;
    HBITMAP__* hbmHeader;
    char* pszbmHeader;
};

struct CAL0_FileLoader
{
    bool m_Loaded;
    CAL0_File* m_File;
    uint32_t m_Offset;
    uint32_t m_Position;
    uint32_t m_CurrentSection;
    CAL0_HeaderData* m_HeaderData;

    // TODO vtable

    void CAL0_FileLoader();
    void ~CAL0_FileLoader();
    CAAudioError LoadFile(CAL0_File* file, uint32_t offset);
    CAAudioError ReadHeader();
    CAAudioError ParseChunks();
    CAAudioError LoadSection(uint32_t sectionIndex);
    CAAudioError LoadTheSection(char* type, uint32_t version, uint32_t dataSize);
    CAAudioError CheckHeader();
    CAAudioError ReadIDName();
};

struct _TAPE_SET_MEDIA_PARAMETERS
{
    uint32_t BlockSize;
};

struct HCOLORSPACE__
{
    int32_t unused;
};

struct IOleCache : IUnknown
{
    HRESULT __stdcall Cache();
    HRESULT __stdcall Uncache();
    HRESULT __stdcall EnumCache();
    HRESULT __stdcall InitCache();
    HRESULT __stdcall SetData();
    void IOleCache();
};

struct drmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wReserved;
    uint32_t ulContentId;
    tWAVEFORMATEX wfxSecure;
};

struct CoreOccluder
{
    CoreVector m_v[4];
    CoreVector m_p[5];
    uint32_t m_flag;
    float m_activationDistance;
    int32_t m_pad0;
    int32_t m_pad1;

    void CoreOccluder();
    void ~CoreOccluder();
    void setup();
    void setActivationDistanceFromMaterialName();
    float getActivationDistance();
    bool matches();
    CoreVector getVert();
    void calcPlanes(CoreVector& pos);
    bool isEdgeInview();
    bool isReallyInView(CoreVector* clipPlane, CoreVector& pos, float nearClip);
    bool isSphereOccluded(CoreVector& pos, float sqRadius);
    bool isSphereIntersects(CoreVector& pos, float sqRadius);
    bool isBBOccluded(CoreVector& min, CoreVector& max);
    void debugDraw();
    uint32_t debugGetFlag();
    uint32_t GetFlag();
    void SetFlag();
};

struct CAL1_ReverbPreset
{
    int32_t m_Name[20];

    // TODO vtable

    void CAL1_ReverbPreset();
    void ~CAL1_ReverbPreset();
};

struct tagINTERFACEINFO
{
    IUnknown* pUnk;
    _GUID iid;
    uint32_t wMethod;
};

struct _CHANGER_SET_POSITION
{
    _CHANGER_ELEMENT Transport;
    _CHANGER_ELEMENT Destination;
    uint32_t Flip;
};

struct IReferenceClock : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetTime();
    HRESULT __stdcall AdviseTime();
    HRESULT __stdcall AdvisePeriodic();
    HRESULT __stdcall Unadvise();
    void IReferenceClock();
};

struct cSchemaFile
{
    enum eDoNotAlloc
    {
        kDoNotAlloc,
    };

    struct sSchemaTextEntry
    {
        uint32_t m_tagOffs;
        uint32_t m_textOffs;
        uint32_t m_audioOffs;

        int32_t compare();
    };

    float m_version;
    bool m_valid;
    bool m_ownMemory;
    char m_fileName[64];
    int32_t m_numEntries;
    cSchemaFile::sSchemaTextEntry* m_entries;
    uint32_t m_dataSize;
    char* m_pDataSpace;
    int32_t m_numAuxLines;
    uint32_t m_auxSize;
    uint32_t* m_auxLines;
    uint32_t m_speakerOffs;
    uint32_t m_listenerOffs;

    // TODO vtable

    void ~cSchemaFile();
    void cSchemaFile();
    int32_t getStoredSize();
    int32_t store();
    bool load();
    bool isValid();
    char* getFileName();
    eSchemaLanguage getLanguage();
    float getVersion();
    char* getSpeaker();
    char* getListener();
    int32_t getNumTags();
    char* getTagByIndex();
    char* getTextByIndex();
    char* getWavByIndex();
    char* getTextForTag();
    char* getWavForTag();
    bool isAuxDataLoaded();
    int32_t getNumAuxLines();
    char* getAuxLine();
    bool operator==();
    void emitDebugData();
    int32_t find_tag();
};

struct CoreMutex
{
    enum
    {
        MAXIMUM_MUTEX_NAME_LENGTH = 256,
    };

    static bool m_fixedCase;

    // TODO vtable

    bool ValidateName();
    bool IsFixedCase();
    void SetFixedCase();
    bool DoesExist();
    void* Create();
    void* CreateOrOpen();
    bool Close();
    void YouCannotInstanceThisClass();
    void CoreMutex();
};

struct CAL0_FormatConverter
{
    uint32_t GetConvertedDataSize();
    CAAudioError ConvertData();
    CAAudioError ConvertDataToPCADPCM();
    CAAudioError ConvertDataToPCPCM();
    CAAudioError ConvertDataToPS2ADPCM();
    CAAudioError ConvertDataToXBOXPCM();
    CAAudioError ConvertDataToXBOXADPCM();
    CAAudioError ConvertDataToPSPATRAC3();
    CAAudioError ConvertDataToPSPATRAC3Plus();
};

struct __s_GUID
{
    uint32_t Data1;
    uint32_t Data2;
    uint32_t Data3;
    uint32_t Data4[8];
};

struct CoreTimingMicroSeconds
{
    int32_t m_start64;
    int32_t m_timeOut64;

    void CoreTimingMicroSeconds();
    int32_t Get64();
    uint32_t Get();
    void Start();
    int32_t GetTaken64();
    uint32_t GetTaken();
    void StartTimeOut64();
    void StartTimeOut();
    bool HasTimedOut();
    void Sync();
    void Wait64();
    void Wait();
};

struct IAddrTrackingControl : IUnknown
{
    HRESULT __stdcall EnableCOMDynamicAddrTracking();
    HRESULT __stdcall DisableCOMDynamicAddrTracking();
    void IAddrTrackingControl();
};

struct _MESSAGE_RESOURCE_DATA
{
    uint32_t NumberOfBlocks;
    _MESSAGE_RESOURCE_BLOCK Blocks[1];
};

struct _TOKEN_GROUPS
{
    uint32_t GroupCount;
    _SID_AND_ATTRIBUTES Groups[1];
};

struct CoreChaseCamera : CoreCameraObject
{
    enum TurnMode
    {
        TURN_EITHER,
        TURN_LEFT,
        TURN_RIGHT,
        TURN_NEITHER,
    };

    CoreGeometryObject* m_target;
    CoreVector m_targetPos;
    CoreVector m_offset;
    float m_idealDistance;
    float m_distance;
    float m_lastDistance;
    CoreEulerAngle m_angle;
    float m_angleVel;
    CoreChaseCamera::TurnMode m_turnMode;
    bool m_cameraOverride;
    float m_distanceCatchupSpeed;
    CoreS128Aligned m_memoryPot[256];

    void CoreChaseCamera();
    void ~CoreChaseCamera();
    void Construct(CoreMemory* io_memory);
    void AdjustCameraAngle(float i_deltaAngle, float i_deltaPitch, float i_deltaRoll);
    void AdjustCameraDistance(float i_requiredDistance);
    void OnSwitchedFrom(CoreCameraObject* io_toCam);
    void OnSwitchedTo(CoreCameraObject* io_fromCam);
    void UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
    void SetTarget();
    void SetOffset();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void ExpandRegion(CoreVector& i_target, float i_distance, float i_angle, float i_pitch, CoreVector& io_min, CoreVector& io_max);
    float TestRay(CoreVector& i_target, float i_distance, float i_angle, float i_pitch);
    CoreVector GetTargetPosition(float i_time, CoreObjectUpdateStruct* updateStruct);
    float GetAutoMove(float i_centreDistance, float i_rightDistance, float i_leftDistance);
    void UpdateDistance(float i_distance, float i_time);
    void UpdateAngleVelocity(float i_angleDelta, float i_time);
    CoreScripted::CommandReturn FnDefaultCameraLogic();
    CoreScripted::CommandReturn DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
};

struct _CERT_EXTENSIONS
{
    uint32_t cExtension;
    _CERT_EXTENSION* rgExtension;
};

struct IXMLDOMNotation : IXMLDOMNode
{
    HRESULT __stdcall get_publicId();
    HRESULT __stdcall get_systemId();
    void IXMLDOMNotation();
};

struct CoreWildCardFileSearch
{
    static bool m_bSearchSubDirs;
    static bool m_bReturnFullPath;

    // TODO vtable

    void SetSearchSubDirectory();
    bool WillSearchSubDirectorySet();
    void SetReturnFullPath();
    bool WillReturnFullPath();
    void GetFilenamesFromPath();
    bool IsStringWildcard();
    void YouCannotInstanceThisClass();
    void CoreWildCardFileSearch();
    void CorrectBackslashes();
};

struct CAL1_API_PC : CAL1_API
{
    uint32_t* m_SRAMBuffer;
    uint32_t m_SRAMSize;
    HWND* m_hWnd;
    _GUID m_GUID;

    void CAL1_API_PC();
    void ~CAL1_API_PC();
    CAAudioError Initialise_Platform(uint32_t i_heapSize, void* i_address, bool i_useSysMemory, uint32_t i_numChannels, uint32_t i_numStreams, uint32_t i_numEffects, uint32_t i_numDBItems, uint32_t i_creationFlags, uint32_t i_maxInstances, uint32_t i_SRAMSize, HWND* i_hWnd, _GUID* i_GUID);
    CAAudioError CreatePlatformObjects();
    CAAudioError DestroyPlatformObjects();
    CAAudioError ResetPlatformObjects();
};

struct IXMLDOMEntity : IXMLDOMNode
{
    HRESULT __stdcall get_publicId();
    HRESULT __stdcall get_systemId();
    HRESULT __stdcall get_notationName();
    void IXMLDOMEntity();
};

struct _CMSG_MAIL_LIST_RECIPIENT_INFO
{
    uint32_t dwVersion;
    _CRYPTOAPI_BLOB KeyId;
    _CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
    _CRYPTOAPI_BLOB EncryptedKey;
    _FILETIME Date;
    _CRYPT_ATTRIBUTE_TYPE_VALUE* pOtherAttr;
};

struct _CERT_SYSTEM_STORE_RELOCATE_PARA
{
    HKEY__* hKeyBase;
    void* pvBase;
    void* pvSystemStore;
    char* pszSystemStore;
    uint32_t* pwszSystemStore;
};

struct _CERT_POLICY_INFO
{
    char* pszPolicyIdentifier;
    uint32_t cPolicyQualifier;
    _CERT_POLICY_QUALIFIER_INFO* rgPolicyQualifier;
};

struct _CRYPT_KEY_VERIFY_MESSAGE_PARA
{
    uint32_t cbSize;
    uint32_t dwMsgEncodingType;
    uint32_t hCryptProv;
};

struct CAL1_SampleGroup : CAL1_AudioItem
{
    CAL0_List* m_ItemList;

    void CAL1_SampleGroup();
    void ~CAL1_SampleGroup();
    CAAudioError AddEntry();
    CAAudioError SetEntry();
    CAAudioError RemoveEntry();
    CAAudioError RemoveAllEntries();
    CAAudioError SwapSamples();
    CAAudioError Shuffle();
    CAL1_AudioItem* GetItem(uint32_t entry);
    uint32_t GetNumberOfItems();
    CAL0_List* GetList();
    CAAudioError SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
    CAAudioError LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
    CAAudioError DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* aid);
    CAAudioError DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
};

struct _TOKEN_AUDIT_POLICY
{
    uint32_t PolicyCount;
    _TOKEN_AUDIT_POLICY_ELEMENT Policy[1];
};

struct IRootStorage : IUnknown
{
    HRESULT __stdcall SwitchToFile();
    void IRootStorage();
};

struct tagRemSNB
{
    uint32_t ulCntStr;
    uint32_t ulCntChar;
    uint32_t rgString[1];
};

struct CoreFlexibleCamera : CoreCameraObject
{
    enum FlexCamInputType
    {
        FlexCamInputTypeNull,
        FlexCamInputTypeTime,
        FlexCamInputTypeTargetRail,
        FlexCamInputTypeObjectListRail,
    };

    enum FlexCamPosType
    {
        FlexCamPosTypeNull,
        FlexCamPosTypePoint,
        FlexCamPosTypeRail,
    };

    enum FlexCamLookAtType
    {
        FlexCamLookAtTypeNull,
        FlexCamLookAtTypeObject,
        FlexCamLookAtTypeRail,
        FlexCamLookAtTypeFixed,
        FlexCamLookAtTypePlayer,
        FlexCamLookAtTypeObjectList,
    };

    enum FlexCamZoomType
    {
        FlexCamZoomTypeNull,
        FlexCamZoomTypeKeepObjectListInView,
        FlexCamZoomTypeKeepShot,
    };

    CoreFlexibleCamera::FlexCamPosType m_positionType;
    CoreFlexibleCamera::FlexCamInputType m_inputType;
    float m_inputTime0;
    float m_inputTime1;
    float m_inputTotalTime;
    float m_inputTimer;
    CoreHash m_inputTarget;
    CoreCurveSetData* m_inputTargetRail;
    CoreCurveSetData* m_lookAtRail;
    CoreVector m_inputNearestPointOnTargetRail;
    CoreCommand* m_command;
    float m_currentPosOnPosRail;
    float m_posRailCatchupCoefficient;
    float m_lookAtCatchupCoefficient;
    float m_maxUpdateDistance;
    CoreFlexibleCamera::FlexCamZoomType m_zoomType;
    CoreVector m_zoomShotOffset;
    float m_zoomShotHeight;
    CoreHash m_lookAtBoneOffsetName;
    bool m_offsetRelativeFlag;
    CoreObject* m_lookAtObjectList[8];
    int32_t m_lookAtObjectNumber;
    float m_inputValue;
    CoreFlexibleCamera::FlexCamLookAtType m_lookAtType;
    CoreVector m_lookAtPos;
    float m_zoom;
    float m_zoom0;
    float m_zoom1;
    void* m_functionCalculateInputValue;
    void* m_functionCalculatePosition;
    void* m_functionCalculateLookAtPosition;
    void* m_functionCalculateZoom;
    CoreObject* m_target;
    CoreVector m_offset;
    float m_idealDistance;
    CoreCurveSetData* m_rail;
    CoreObjectUpdateStruct* m_updateStruct;
    CoreS128Aligned m_memoryPot[256];

    void CoreFlexibleCamera();
    void Construct(CoreMemory* io_memory);
    void OnSwitchedFrom(CoreCameraObject* io_toCam);
    void OnSwitchedTo(CoreCameraObject* io_fromCam);
    void UpdateTriggerJustEntered();
    void UpdateTriggerJustLeft();
    void UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
    void SetIdealDistance();
    void SetTarget();
    void SetRail(CoreHash i_name);
    void SetInputValue();
    void SetCalculateInputPositionCallback();
    void SetCalculatePositionCallback();
    void SetCalculateLookAtPositionCallback();
    void SetCalculateZoomCallback();
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void SetRollDeg();
    void SetZoomShotHeight();
    void SetZoomShotOffset();
    void AddLookAtObject();
    void ResetLookAtObjects();
    void SetLookAtBoneNameHash(CoreHash i_boneHash);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    void GetUnitPointOnRail(float& i_result, CoreVector& vPoint, CoreCurveSetData* i_rail);
    void GetObjectListAveragePos(CoreVector& o_finalpos);
    CoreVector GetLookAtBonePosition(CoreGeometryObject* i_object);
    CoreScripted::CommandReturn FnSetPositionRail();
    CoreScripted::CommandReturn FnSetInputTargetRail(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetInputTarget();
    CoreScripted::CommandReturn FnSetInputType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetInputTime(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetPositionType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetLookAtType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetPositionRailCatchupCoefficient(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetStateType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetMaxUpdateDistance(CoreCommand* io_command);
    CoreScripted::CommandReturn FnAddLookatObject(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetZoomType(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetZoomShotOffset(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetZoomShotHeight(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetRoll(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetLookAtBoneName(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetLookAtRail(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetLookAtCatchupCoefficient(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetLookAtOffset(CoreCommand* io_command);
    CoreScripted::CommandReturn FnSetLookAtOffsetRelativeFlag(CoreCommand* io_command);
    void CalculateInputValue();
    void CalculatePosition();
    void CalculateLookAtPosition();
    void CalculateZoom();
    void RenderDebug();
    CoreScripted::CommandReturn FnDefaultCameraLogic();
    CoreScripted::CommandReturn DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
    CoreScripted::CommandReturn FnSetRail(CoreCommand* i_command);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    void ~CoreFlexibleCamera();
};

struct CoreBezierAnimKeyDataLong
{
    float m_time;
    float m_control[3];
};

struct CoreDetectEvent
{
    CoreDetectEventType eType;
};

struct HMIXER__
{
    int32_t unused;
};

struct _DISK_PERFORMANCE
{
    _LARGE_INTEGER BytesRead;
    _LARGE_INTEGER BytesWritten;
    _LARGE_INTEGER ReadTime;
    _LARGE_INTEGER WriteTime;
    _LARGE_INTEGER IdleTime;
    uint32_t ReadCount;
    uint32_t WriteCount;
    uint32_t QueueDepth;
    uint32_t SplitCount;
    _LARGE_INTEGER QueryTime;
    uint32_t StorageDeviceNumber;
    uint32_t StorageManagerName[8];
};

struct IClassFactory : IUnknown
{
    HRESULT __stdcall CreateInstance();
    HRESULT __stdcall LockServer();
    void IClassFactory();
};

struct tagCACLIPDATA
{
    uint32_t cElems;
    tagCLIPDATA* pElems;
};

struct CoreGameController : CoreScripted
{
    enum CoreGameControllerDebugFlags
    {
        DISPLAY_FRAMERATE,
        SINGLE_STEP_MODE,
        MOVE_TO_NEXT_FRAME,
    };

    CoreGameControllerInternalData* m_lpoData;
    CoreMemoryStack m_oGlobalStaticMemory;
    CoreMemoryPool m_oGlobalDynamicMemory;
    static CoreGameController* m_instance;
    static int32_t m_disableSoftResetLevel;

    void GameInit(int32_t iNumParams, char** lplpcParams, int32_t MemSize, uint32_t* lpucMemory, CoreHash i_graphicsType, CoreHash i_inputType, CoreHash i_audioType, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize, CoreHash i_networkType, CoreNet::DeviceInitialisationData* io_CoreNetInit);
    void GameMain(void*);
    void SetGameController(CoreGameController* io_gameController);
    void CoreGameController();
    void ~CoreGameController();
    void Construct(int32_t iNumParams, char** lplpcParams, CoreHash i_graphicsType, CoreHash i_inputType, CoreHash i_audioType, CoreHash i_networkType, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize);
    void Destruct();
    uint32_t GetVersion();
    void Init(CoreNet::DeviceInitialisationData* io_CoreNetInit);
    void Reset();
    void OneCycle();
    void Update();
    void UpdateInput(float i_deltaTime);
    void Render();
    CoreGameController* GetInstance();
    CoreMemory* GetStaticMemory();
    CoreMemory* GetDynamicMemory();
    CoreVariableStore* GetVariableStore();
    CoreScriptStore* GetScriptStore();
    CoreWorld* GetWorld();
    CoreConsole* GetConsole();
    CoreGameRender* GetGraphics();
    CoreGraphicsDevice* GetGraphicsDevice();
    CoreInput* GetInput();
    CoreWorldUpdateStruct* GetUpdateStruct();
    CoreGameTextUnit* GetGameText();
    CoreNet* GetNet();
    bool bHasQuit();
    void SetQuit(bool bQuit);
    int32_t GetGameCycle();
    float GetDeltaFrameTime();
    void OutputTGAs(bool i_onOff);
    void ToggleSingleStep();
    bool IsSingleStepActive();
    void DumpVariableStore();
    bool SetLanguageByHash(CoreHash i_language);
    void SetLanguage(CoreInit::CoreLanguageEnum i_language);
    CoreInit::CoreLanguageEnum GetLanguage();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    uint32_t GetClientID();
    void DisableSoftReset();
    void EnableSoftReset();
    void DoDebug(CoreDebugInput* i_debugInput);
    void DoLogicDebug(CoreDebugInput* i_debugInput);
    void DoInputDebug(CoreDebugInput* i_debugInput);
    void DoAudioLocDebug(CoreDebugInput* i_debugInput);
    void DoMemoryDebug(CoreDebugInput* i_debugInput);
    CoreScripted::CommandReturn eFnGameUpdate();
    CoreScripted::CommandReturn eFnWorldReset();
    void DeleteGlobalLinkedScripts();
    void GetGlobalLinkedScripts();
    void LoadGlobalTextFile();
    void LoadFonts();
    void GetGlobalTextFile();
    void GetGlobalTextFileName(CoreStringBuffer<256>& o_fileName);
    void EnterAssetManagerPanicMode();
    void RunAssetManagerPanicMode();
    void ExitAssetManagerPanicMode();
    void AssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType, void* lpUsrData1, void* lpUsrData2);
    void HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType);
    void DoDebugCallback(CoreDebugInput* lpoDebugInput, CoreWorldUpdateStruct* lpoWorldUpdateStruct, int32_t iLevel, void* lpUserData);
    CoreWorld* CreateWorld();
    CoreConsole* CreateConsole(CoreMemory* io_memory);
};

struct CoreBodyMarker
{
    CoreBodyMarkerType eBodyType;
    CoreCombatMarkerGeometryType eGeometryType;
    CoreVector vPoint[2];
    float fRadius;
    float fDamageMultiplier;
    uint32_t uiBoneHash;
    bool bActive;
    CoreVector vTransformedPoint[2];
    float fTransformedRadius;

    void CoreBodyMarker();
};

struct IAsyncRpcChannelBuffer : IRpcChannelBuffer2
{
    HRESULT __stdcall Send();
    HRESULT __stdcall Receive();
    HRESULT __stdcall GetDestCtxEx();
    void IAsyncRpcChannelBuffer();
};

struct CoreRailCamera : CoreCameraObject
{
    CoreObject* m_target;
    CoreVector m_offset;
    float m_idealDistance;
    CoreCurveSetData* m_rail;
    CoreS128Aligned m_memoryPot[256];

    void CoreRailCamera();
    void Construct(CoreMemory* io_memory);
    void SetIdealDistance();
    void SetTarget();
    void SetRail(CoreHash i_name);
    CoreObject* Create(CoreMemory* io_memory);
    CoreHash GetTypeID();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreScripted::CommandReturn FnDefaultCameraLogic();
    CoreScripted::CommandReturn DefaultCameraLogic(CoreCommand* i_command);
    CoreScripted::CommandReturn FnSetRail(CoreCommand* i_command);
    void* GetMemoryStack();
    int32_t GetMemoryStackSize();
    void ~CoreRailCamera();
};

struct tagCOLORADJUSTMENT
{
    uint32_t caSize;
    uint32_t caFlags;
    uint32_t caIlluminantIndex;
    uint32_t caRedGamma;
    uint32_t caGreenGamma;
    uint32_t caBlueGamma;
    uint32_t caReferenceBlack;
    uint32_t caReferenceWhite;
    int32_t caContrast;
    int32_t caBrightness;
    int32_t caColorfulness;
    int32_t caRedGreenTint;
};

struct IThumbnailExtractor : IUnknown
{
    HRESULT __stdcall ExtractThumbnail();
    HRESULT __stdcall OnFileUpdated();
    void IThumbnailExtractor();
};

struct CoreAssetManager : CoreMemory
{
    enum CoreAssetManagerReturnCode
    {
        CORE_RETURN_NEED_DEFRAG,
        CORE_RETURN_NEED_PURGE,
        CORE_RETURN_OK,
        CORE_RETURN_NOT_ENOUGH_MEMORY,
        CORE_RETURN_ERROR,
        CORE_RETURN_NOT_ENOUGH_BLOCKS,
        CORE_RETURN_NOT_ALLOCATED,
        CORE_RETURN_CAN_I_CREATE_FAILED,
        CORE_RETURN_NOT_READY,
    };

    enum CoreAssetManagerState
    {
        CORE_STATE_UNKNOWN,
        CORE_STATE_ERROR,
        CORE_STATE_NOTINIT,
        CORE_STATE_READY,
        CORE_STATE_LOADING,
        CORE_STATE_FINISHED_LOADING,
        CORE_STATE_START_DEFRAG_SINGLE,
        CORE_STATE_IN_DEFRAG_SINGLE,
        CORE_STATE_DONE_DEFRAG_SINGLE,
        CORE_STATE_START_DEFRAG_ALL,
        CORE_STATE_IN_DEFRAG_ALL,
        CORE_STATE_DONE_DEFRAG_ALL,
        CORE_STATE_START_UPDATE_CLIENTS_SINGLE,
        CORE_STATE_IN_UPDATE_CLIENTS_SINGLE,
        CORE_STATE_DONE_UPDATE_CLIENTS_SINGLE,
        CORE_STATE_START_UPDATE_CLIENTS_ALL,
        CORE_STATE_IN_UPDATE_CLIENTS_ALL,
        CORE_STATE_DONE_UPDATE_CLIENTS_ALL,
        CORE_STATE_START_PURGE_SINGLE,
        CORE_STATE_IN_PURGE_SINGLE,
        CORE_STATE_DONE_PURGE_SINGLE,
        CORE_STATE_START_PURGE_ALL,
        CORE_STATE_IN_PURGE_ALL,
        CORE_STATE_DONE_PURGE_ALL,
    };

    CoreAssetManagerData* m_lpoData;
    static CoreHash m_memoryAssetTypeHash;
    static CoreHash m_fileAssetTypeHash;

    void* Alloc(uint32_t iBytes, uint32_t iByteAlignment, char* lpcFileName, uint32_t iLineNumber);
    void* TryAlloc();
    void Free(void* lpPtr, char* lpcFileName, int32_t iLineNumber);
    int32_t GetMemoryAvailable();
    int32_t GetMemoryUsed();
    char* GetDebugTypeName();
    void Construct(CoreMemory* lpoMemory, uint32_t iMemoryArenaSizeInBytes, uint32_t iMaxNumBlocks, uint32_t iMaxNumClients);
    void Destruct(CoreMemory* lpoMemory);
    char* lpcReturnCode(CoreAssetManager::CoreAssetManagerReturnCode eReturnCode);
    char* lpcState(CoreAssetManager::CoreAssetManagerState eState);
    int32_t ComputeMemNeeded(int32_t iMaxNumBlocks, int32_t iMaxNumClients);
    void CoreAssetManager();
    void ~CoreAssetManager();
    void Init(bool* bCanICreateAssetFunction, bool* bCreateAssetFunction, bool* bDeleteAssetFunction, bool* moveAssetFunction, void* lpCreateDeleteUserData);
    void Update();
    void DoDebug(CoreDebugInput* i_input);
    void Reset();
    bool CancelAssetLoading();
    bool Validate();
    bool IsStartPanicMode();
    bool IsInPanicMode();
    bool IsExitPanicMode();
    bool StartPanicMode();
    bool ExitPanicMode();
    void* GetAsset(uint32_t i_clientID, CoreHash i_assetID, CoreHash i_assetType);
    void* TryAllocAsset(uint32_t i_clientID, CoreHash i_assetID, CoreHash i_assetType);
    bool RemoveAsset(uint32_t i_clientID, CoreHash i_assetID, CoreHash i_assetType);
    void* LoadAsset(uint32_t i_clientID, char* i_assetName, CoreHash i_assetID, CoreHash i_assetType, bool i_asyncLoad);
    int32_t GetAssetSizeInBytes(char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType);
    void* AllocAsset(uint32_t i_clientID, char* i_assetName, CoreHash i_assetID, CoreHash i_assetType, bool i_asyncLoad);
    bool DeAllocAsset(uint32_t i_clientID, CoreHash i_assetID, CoreHash i_assetType);
    bool SetAssetMemoryLocked();
    bool SetAssetNotMemoryLocked();
    bool IsAssetMemoryLocked();
    bool SetAssetActive();
    bool SetAssetInActive();
    bool IsAssetActive(CoreHash i_assetID, CoreHash i_assetType);
    bool IsReady();
    bool LoadCluster(char* i_fileName, CoreHash i_assetID, CoreHash i_assetType, CoreClusterData* i_clusterData);
    void* lpAsyncLoadFile();
    void* lpHardLoadFile();
    bool AsyncLoadFile();
    bool HardLoadFile();
    bool RegisterClient(uint32_t i_clientID, void* lpClientCallbackFunc, void* lpUsrData1, void* lpUsrData2);
    bool UnRegisterClient(uint32_t i_clientID);
    bool RegisterAssetType(CoreHash i_assetType, char* i_assetTypeName, bool i_memoryLocked);
    void PurgeAllUnused();
    void CheckAllUpToDate(bool markAsDirty);
    int32_t CountOutOfDate();
    bool MarkAllOutOfDateAsDirty();
    int32_t CountTotalFreeBytes();
    int32_t GetPoolSizeBytes();
    int32_t CountMaxSingleFreeInactive();
    bool RawRemoveAsset(CoreHash i_assetID, CoreHash i_assetType);
    void* lpAsyncLoadAsset(uint32_t i_clientID, char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType);
    void* lpHardLoadAsset(uint32_t i_clientID, char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType);
    void* InternalTryAllocAsset(CoreAssetManagerMemoryBlock* i_memBlock, CoreHash i_assetID, CoreHash i_assetType, bool i_allocAsset);
    CoreAssetManagerMemoryBlock* FindAllocation(char* i_name, CoreHash i_assetID, CoreHash i_assetType);
    CoreAssetManagerMemoryBlock* FindUnusedMemBlock();
    CoreAssetManagerMemoryBlock* FindSpace(int32_t iSizeInBytes, int32_t& o_maxSingleFreeSpace, int32_t& o_maxSingleFreeInactiveSpace, int32_t& o_totalFreeSpace);
    CoreAssetManager::CoreAssetManagerReturnCode eAllocateMemory(CoreHash i_assetID, CoreHash i_assetType, int32_t iSizeInBytes, CoreAssetManagerMemoryBlock*& lpoMemBlock, CoreDateTime& i_fileTime, char* i_name);
    void HandleReturnCode(CoreAssetManager::CoreAssetManagerReturnCode eReturnCode);
    CoreAssetManager::CoreAssetManagerReturnCode eTryAllocateMemory(CoreHash i_assetID, CoreHash i_assetType, int32_t iSizeInBytes, CoreAssetManagerMemoryBlock*& o_memBlock, CoreDateTime& i_fileTime, char* i_name);
    CoreAssetManager::CoreAssetManagerReturnCode eDeAllocateMemory(CoreHash i_assetID, CoreHash i_assetType, void* lpMemoryPtr);
    CoreAssetManager::CoreAssetManagerReturnCode eDeAllocateMemoryBlock(CoreAssetManagerMemoryBlock* lpoMemBlock);
    CoreAssetManager::CoreAssetManagerReturnCode AllocateBlock(CoreAssetManagerMemoryBlock* i_memBlock, uint32_t i_SizeInBytes, CoreDateTime& i_fileTime, char* i_name, CoreHash i_assetID, CoreHash i_assetType, CoreAssetManagerMemoryBlock*& o_memBlock);
    CoreAssetManager::CoreAssetManagerState eRunOneCycle(CoreAssetManager::CoreAssetManagerState i_eRequestState);
    CoreAssetManager::CoreAssetManagerState eRunStartDefragSingle();
    CoreAssetManager::CoreAssetManagerState eRunInDefragSingle();
    CoreAssetManager::CoreAssetManagerState eRunDoneDefragSingle();
    CoreAssetManager::CoreAssetManagerState eRunStartDefragAll();
    CoreAssetManager::CoreAssetManagerState eRunInDefragAll();
    CoreAssetManager::CoreAssetManagerState eRunDoneDefragAll();
    CoreAssetManager::CoreAssetManagerState eRunStartPurgeSingle();
    CoreAssetManager::CoreAssetManagerState eRunInPurgeSingle();
    CoreAssetManager::CoreAssetManagerState eRunDonePurgeSingle();
    CoreAssetManager::CoreAssetManagerState eRunStartPurgeAll();
    CoreAssetManager::CoreAssetManagerState eRunInPurgeAll();
    CoreAssetManager::CoreAssetManagerState eRunDonePurgeAll();
    CoreAssetManager::CoreAssetManagerState eRunStartUpdateClientsSingle();
    CoreAssetManager::CoreAssetManagerState eRunInUpdateClientsSingle();
    CoreAssetManager::CoreAssetManagerState eRunDoneUpdateClientsSingle();
    CoreAssetManager::CoreAssetManagerState eRunStartUpdateClientsAll();
    CoreAssetManager::CoreAssetManagerState eRunInUpdateClientsAll();
    CoreAssetManager::CoreAssetManagerState eRunDoneUpdateClientsAll();
    void ComputeDebugStats();
    void DumpDebugInfo();
    bool RemoveAssetMemoryBlock(CoreAssetManagerMemoryBlock* lpoMemBlock);
    bool SetAssetActiveState(bool bActive, CoreHash i_assetID, CoreHash i_assetType);
    bool SetAssetMemoryLockedState();
    void ClearFileLoadingDetails();
    void ClearCreateAssetDetails();
    void* lpLoadAsset(char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType, bool bAsync, bool& o_failedToLoad);
    void* lpPostLoadAsset(char* lpcFileName, CoreAssetManagerMemoryBlock* lpoMemBlock, CoreHash i_assetID, CoreHash i_assetType, bool bAsync);
    void SetAssetLoadingDetails(char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType);
    void* LoadFile();
    void* lpPostLoadFile(char* lpcFileName);
    void SetFileLoadingDetails();
    CoreAssetManagerClientInfo* FindFreeClientInfo();
    CoreAssetManagerAssetTypeInfo* FindFreeAssetTypeName();
    int32_t CountNumClientInfos();
    bool ValidClient();
    CoreAssetManagerAssetTypeInfo* GetAssetTypeInfo(CoreHash i_assetType);
    char* GetAssetTypeName(CoreHash i_assetType);
    bool GetAssetTypeMemoryLocked(CoreHash i_assetType);
    void SetMemoryLocked(CoreAssetManagerMemoryBlock* io_memBlock, CoreHash i_assetType);
    void RequestStartPanicMode();
    void RequestExitPanicMode();
    void ClearPanicMode();
    int32_t CountLargestFreeBlock();
    int32_t CopyMemBlockToFreeMemBlock(CoreAssetManagerMemoryBlock* i_assetMemBlock, CoreAssetManagerMemoryBlock* i_freeMemBlock);
};

struct CoreAssetManagerAssetTypeInfo
{
    CoreStringBuffer<256> name;
    bool memoryLocked;
    bool inUse;
    uint32_t index;
    uint32_t padding;

    void CoreAssetManagerAssetTypeInfo();
};

struct CoreTypes
{
    static char MinInt8;
    static char MaxInt8;
    static uint32_t MaxUInt8;
    static int32_t MinInt16;
    static int32_t MaxInt16;
    static uint32_t MaxUInt16;
    static int32_t MinInt32;
    static int32_t MaxInt32;
    static uint32_t MaxUInt32;
    static int32_t MinInt64;
    static int32_t MaxInt64;
    static uint32_t MaxUInt64;
    static float MaxFloat32;
    static float MinFloat32;
    static float MaxFloat64;
    static float MinFloat64;
    static uint32_t EmptyString16[0];

    // TODO vtable

    void CoreTypes();
    void ~CoreTypes();
    void YouCannotInstanceThisClass();
};

struct _MENU_EVENT_RECORD
{
    uint32_t dwCommandId;
};

struct CoreCriticalSectionBufferHeader
{
    void* m_buffer;
    uint32_t m_bufferSize;
    void* m_userValue;

    void Set();
    void* GetBuffer();
    uint32_t GetBufferSize();
    void* GetUserValue();
};

struct CAL0_List
{
    uint32_t m_numItems;
    uint32_t m_maxItems;
    void** m_list;
    uint32_t* m_IDList;

    // TODO vtable

    void CAL0_List();
    void ~CAL0_List();
    bool DoesEntryExist();
    CAAudioError DeleteItemByID(uint32_t i_ID);
    CAAudioError DeleteItemByPosition(uint32_t i_position);
    CAAudioError GetItem(uint32_t i_position, void** i_item, uint32_t* o_ID);
    CAAudioError GetItemFromID(uint32_t i_ID, void** o_item, uint32_t* o_position);
    CAAudioError SetItem(void* i_item, uint32_t i_ID, uint32_t i_position);
    CAAudioError AddItem(void* i_item, uint32_t i_ID, uint32_t* o_entryPoint);
    CAAudioError InsertItemBeforeItem(void* i_item, uint32_t i_ID, void* i_searchItem);
    CAAudioError Shuffle();
    CAAudioError GetIndexFromID(uint32_t i_ID, uint32_t* o_index);
    CAAudioError GetIDFromIndex(uint32_t i_index, uint32_t* o_ID);
    CAAudioError ClearAll();
    CAAudioError CopyItems(CAL0_List* fromList);
    uint32_t GetNumberOfItems();
    uint32_t GetMaximumNumberOfItems();
    void** GetListData();
    uint32_t* GetIDList();
    uint32_t CountItems();
};

struct _IMAGE_THUNK_DATA64
{
    _IMAGE_THUNK_DATA64::__unnamed u1;
};

struct _CERT_CHAIN_ENGINE_CONFIG
{
    uint32_t cbSize;
    void* hRestrictedRoot;
    void* hRestrictedTrust;
    void* hRestrictedOther;
    uint32_t cAdditionalStore;
    void** rghAdditionalStore;
    uint32_t dwFlags;
    uint32_t dwUrlRetrievalTimeout;
    uint32_t MaximumCachedCertificates;
    uint32_t CycleDetectionModulus;
};

struct CoreTiming
{
    static int32_t m_lastTimer64;
    static uint32_t m_timerCount;
    static int32_t m_lockedLevel;
    static uint32_t m_lockedCount;

    // TODO vtable

    int32_t Get64();
    int32_t GetLast64();
    void Wait64();
    uint32_t GetTimerCount();
    uint32_t GetLockedCount();
    uint32_t GetRandomSeed();
    void TestTimer();
    void YouCannotInstanceThisClass();
    void CoreTiming();
};

struct CoreGameDialogs
{
    static int32_t m_defaultRenderFlags;
    static CoreRGBA ScreenOverlayRGBA;
    static CoreFader ScreenOverlayFader;

    int32_t GetDefaultRenderFlags();
    void Render(CoreGameRender* io_graphics, int32_t i_renderFlags);
    bool RenderFlat(CoreGameRender* io_graphics, float i_x1, float i_y1, float i_x2, float i_y2, CoreRGBA i_rgba, float i_alphaScaler, int32_t i_renderFlags);
    bool RenderFlatWholeScreen(CoreGameRender* io_graphics, CoreRGBA i_rgba, float i_alphaScaler, int32_t i_renderFlags);
    bool RenderTexture(CoreGameRender* io_graphics, CoreTextureSet* i_textureSet, CoreHash i_textureHash, float i_x1, float i_y1, float i_x2, float i_y2, CoreRGBA i_rgba, float i_alphaScaler, int32_t i_renderFlags);
    bool RenderTextureOrFlat(CoreGameRender* io_graphics, CoreTextureSet* i_textureSet, CoreHash i_textureHash, float i_x1, float i_y1, float i_x2, float i_y2, CoreRGBA i_rgba, float i_alphaScaler, int32_t i_renderFlags);
};

struct tMIXERCONTROLDETAILS_UNSIGNED
{
    uint32_t dwValue;
};

struct IDispatch : IUnknown
{
    HRESULT __stdcall GetTypeInfoCount();
    HRESULT __stdcall GetTypeInfo();
    HRESULT __stdcall GetIDsOfNames();
    HRESULT __stdcall Invoke();
    void IDispatch();
};

struct CoreNonAnimatingObject : CoreGeometryObject
{
    void CoreNonAnimatingObject();
    void ~CoreNonAnimatingObject();
    void Construct();
    void Destruct();
    void Init();
    void Reset();
};

struct IInternetBindInfo : IUnknown
{
    HRESULT __stdcall GetBindInfo();
    HRESULT __stdcall GetBindString();
    void IInternetBindInfo();
};

struct CAL1_AudioDevice
{
    _GUID m_Guid;
    char m_Module[256];
    char m_Desc[256];
    char m_ModuleDesc[256];
    char m_ModuleVersion[256];
    int32_t m_Max3DChannels;
    int32_t m_Max2DChannels;
    int32_t m_Max2DThen3DChannels;
    int32_t m_Max3DThen2DChannels;
    CAAudioError m_CreationError;
    CAAudioError m_EAXCreationError;
    IDirectSound8* m_DS;
    IDirectSoundBuffer* m_DSPrimaryBuffer;
    IDirectSound3DListener* m_DSListener;
    IDirectSoundBuffer* m_EAXDSBuffer;
    IDirectSound3DBuffer* m_EAXDS3DBuffer;
    IKsPropertySet* m_EAXListener;
    _DSCAPS m_DSCaps;
    IEAXUnified* lpEAXUnified;
    EAXUNIFIEDCAPS m_EAXCaps;
    uint32_t m_EAXEmluated;
    uint32_t m_EAXNative;
    bool m_Certified;

    void CAL1_AudioDevice();
};

struct AsyncIPipeLong : IUnknown
{
    HRESULT __stdcall Begin_Pull();
    HRESULT __stdcall Finish_Pull();
    HRESULT __stdcall Begin_Push();
    HRESULT __stdcall Finish_Push();
    void AsyncIPipeLong();
};

struct CoreWeaponMarkerData
{
    int32_t iNumWeaponMarkers;
    CoreWeaponMarker* lpoWeaponMarkerArray;
    CoreVector vBoundSpherePos;
    float fBoundSphereRadius;
    int32_t iActiveMarkerCount;
    int32_t iLastValid;

    void CoreWeaponMarkerData();
};

struct HBRUSH__
{
    int32_t unused;
};

struct ITypeFactory : IUnknown
{
    HRESULT __stdcall CreateFromTypeInfo();
    void ITypeFactory();
};

struct _PRINTER_INFO_5W
{
    uint32_t* pPrinterName;
    uint32_t* pPortName;
    uint32_t Attributes;
    uint32_t DeviceNotSelectedTimeout;
    uint32_t TransmissionRetryTimeout;
};

struct CoreLED
{
    static uint32_t m_nestStack[32];
    static uint32_t m_lastPopped;
    static uint32_t m_nestLevel;

    void Push();
    void Pop();
    void Init();
    void Set();
};

struct CAL1_AudioParameter : CAL1_AudioItem
{
    enum CA_AP_Type
    {
        Audio_Parameter_Type_none,
        Audio_Parameter_Type_uint8,
        Audio_Parameter_Type_int8,
        Audio_Parameter_Type_uint16,
        Audio_Parameter_Type_int16,
        Audio_Parameter_Type_uint32,
        Audio_Parameter_Type_int32,
        Audio_Parameter_Type_fixed,
        Audio_Parameter_Type_fixedhp,
        Audio_Parameter_Type_bool,
    };

    CAL1_AudioParameter::CA_AP_Type m_Type;
    void* m_Variable;

    void CAL1_AudioParameter();
    void ~CAL1_AudioParameter();
    CAAudioError SetVariable(CAL1_AudioParameter::CA_AP_Type type, void* valuePtr);
    CAAudioError CreateVariable(CAL1_AudioParameter::CA_AP_Type type);
    CAAudioError ValidateVariableType();
};

struct IDirectSoundBuffer : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetCaps();
    HRESULT __stdcall GetCurrentPosition();
    HRESULT __stdcall GetFormat();
    HRESULT __stdcall GetVolume();
    HRESULT __stdcall GetPan();
    HRESULT __stdcall GetFrequency();
    HRESULT __stdcall GetStatus();
    HRESULT __stdcall Initialize();
    HRESULT __stdcall Lock();
    HRESULT __stdcall Play();
    HRESULT __stdcall SetCurrentPosition();
    HRESULT __stdcall SetFormat();
    HRESULT __stdcall SetVolume();
    HRESULT __stdcall SetPan();
    HRESULT __stdcall SetFrequency();
    HRESULT __stdcall Stop();
    HRESULT __stdcall Unlock();
    HRESULT __stdcall Restore();
    void IDirectSoundBuffer();
};

struct _IMAGE_RESOURCE_DIRECTORY
{
    uint32_t Characteristics;
    uint32_t TimeDateStamp;
    uint32_t MajorVersion;
    uint32_t MinorVersion;
    uint32_t NumberOfNamedEntries;
    uint32_t NumberOfIdEntries;
};

struct IInternetHostSecurityManager : IUnknown
{
    HRESULT __stdcall GetSecurityId();
    HRESULT __stdcall ProcessUrlAction();
    HRESULT __stdcall QueryCustomPolicy();
    void IInternetHostSecurityManager();
};

struct IEnumSTATPROPSETSTG : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumSTATPROPSETSTG();
};

struct _GDI_NONREMOTE
{
    union __MIDL_IWinTypes_0002
    {
        int32_t hInproc;
        _DWORD_BLOB* hRemote;
    };

    int32_t fContext;
    _GDI_NONREMOTE::__MIDL_IWinTypes_0002 u;
};

struct tagCWPSTRUCT
{
    int32_t lParam;
    uint32_t wParam;
    uint32_t message;
    HWND* hwnd;
};

struct CoreCommon
{
    enum
    {
        META_VERSION = 47,
    };

    // TODO vtable

    uint32_t GetVersion();
    void CoreCommon();
    void ~CoreCommon();
    void YouCannotInstanceThisClass();
};

struct IXMLElementCollection : IDispatch
{
    HRESULT __stdcall put_length();
    HRESULT __stdcall get_length();
    HRESULT __stdcall get__newEnum();
    HRESULT __stdcall item();
    void IXMLElementCollection();
};

struct CoreMemory
{
    enum CoreMemoryDebugFlagsBits
    {
        OUTPUT_ALLOCS_TO_FILE_BIT,
        OUTPUT_ALLOCS_TO_STDOUT_BIT,
        OUTPUT_DEALLOCS_TO_FILE_BIT,
        OUTPUT_DEALLOCS_TO_STDOUT_BIT,
    };

    enum CoreMemoryDebugFlags
    {
        OUTPUT_ALLOCS_TO_FILE = (1 << 0),
        OUTPUT_ALLOCS_TO_STDOUT = (1 << 1),
        OUTPUT_DEALLOCS_TO_FILE = (1 << 2),
        OUTPUT_DEALLOCS_TO_STDOUT = (1 << 3),
    };

    int32_t m_containerSize;
    CoreStringBuffer<10> m_debugName;
    uint32_t m_debugFlags;

    // TODO vtable

    void Construct();
    void Destruct();
    void* Alloc();
    void Free();
    int32_t GetMemoryAvailable();
    int32_t GetMemoryUsed();
    char* GetDebugTypeName();
    int32_t DebugString(char* o_buffer);
    void DebugDetails(char* i_fileName);
    int32_t GetContainerSize();
    void SetDebugName(char* i_name);
    void ZeroDebugFlags();
    char* GetDebugName();
    void SetDebugFlags();
    void SetDebugFlagsBit();
    uint32_t GetDebugFlags();
    void ~CoreMemory();
    void SetContainerSize();
    void CoreMemory();
};

struct _CERT_POLICY_QUALIFIER_INFO
{
    char* pszPolicyQualifierId;
    _CRYPTOAPI_BLOB Qualifier;
};

struct LIST_ENTRY64
{
    uint32_t Flink;
    uint32_t Blink;
};

struct CAL1_WaveSoundReadPC
{
    tWAVEFORMATEX* m_pwfx;
    HMMIO__* m_hmmioIn;
    _MMCKINFO m_ckIn;
    _MMCKINFO m_ckInRiff;
    static pcmwaveformat_tag m_pcmWaveFormat;

    void CAL1_WaveSoundReadPC();
    void ~CAL1_WaveSoundReadPC();
    HRESULT Open();
    HRESULT Reset();
    HRESULT Read();
    HRESULT Close();
    CAAudioError ReadSample();
    HRESULT ReadMMIO();
    HRESULT WaveOpenFile();
    HRESULT WaveStartDataRead();
    HRESULT WaveReadFile();
};

struct CAL1_InstanceTable
{
    CAL0_List* m_List;
    CAL1_AudioItemDatabase* m_AID;
    CAL1_AudioItemDatabase* m_DuplicateList;

    // TODO vtable

    void CAL1_InstanceTable();
    void ~CAL1_InstanceTable();
    CAAudioError CreateInstance(uint32_t i_audioItemID, uint32_t& instance);
    CAAudioError DestroyInstance();
    CAAudioError GetInstanceRuntimeID(uint32_t i_audioItemID, uint32_t i_instance, uint32_t& o_runtimeID);
    CAAudioError ClearAllInstances();
    uint32_t GetNumInstances();
    CAAudioError CreateItemInstance(CAL1_AudioItem* i_item, uint32_t i_AudioItemID, uint32_t i_newInstance);
};

struct HMIDIOUT__
{
    int32_t unused;
};

struct _CoreGifPackFog
{
    uint32_t pad[3];
    uint32_t F;
};

struct CAL0_FileSaver
{
    CAL0_File* m_File;
    uint32_t m_Offset;
    uint32_t m_NumSections;
    CAL0_HeaderData m_HeaderData;
    CAL0_SectionInfoExtended** m_SectionInfo;
    bool m_DebugSave;

    // TODO vtable

    void CAL0_FileSaver();
    void ~CAL0_FileSaver();
    CAAudioError SaveFile();
    void SetDebugSave();
    CAAudioError SetSubFormat();
    CAAudioError WriteHeader();
    CAAudioError WriteSections();
    CAAudioError WriteIDName();
    CAAudioError AddSection();
    CAAudioError AssembleSections();
    CAAudioError DestroySections();
};

struct IHttpNegotiate : IUnknown
{
    HRESULT __stdcall BeginningTransaction();
    HRESULT __stdcall OnResponse();
    void IHttpNegotiate();
};

struct tagOLEVERB
{
    int32_t lVerb;
    uint32_t* lpszVerbName;
    uint32_t fuFlags;
    uint32_t grfAttribs;
};

struct CoreDetectionTriangle
{
    uint32_t m_usIndex[3];
    uint32_t m_ucType;
    uint32_t m_ucSubType1Index;
    uint32_t m_ucSubType2Index;
    uint32_t m_edgeFlag;
    uint32_t m_vertFlag;
    uint32_t m_padding;
};

struct _COAUTHIDENTITY
{
    uint32_t* User;
    uint32_t UserLength;
    uint32_t* Domain;
    uint32_t DomainLength;
    uint32_t* Password;
    uint32_t PasswordLength;
    uint32_t Flags;
};

struct CoreFXMaterial
{
    CoreTextureSet* m_pTextureSets[2];
    CoreTextureInfo* m_pTextureInfos[2];
    uint32_t m_TextureID[2];
    uint32_t m_nTextures;
    CoreVector m_Offsets[4];
    CoreUV m_UV[8];
    float m_PixelSize;
    uint32_t m_platformUV[16];
    uint32_t m_texLoadWidth;
    uint32_t m_texLoadHeight;
    int32_t m_particleChainStart[3];
    uint32_t m_particleCount;

    // TODO vtable

    void CoreFXMaterial();
    void ~CoreFXMaterial();
    CoreVector* GetOffsets();
    CoreUV* GetUV();
    uint32_t* GetPlatformUV();
    CoreTextureInfo* GetTextureInfo();
    CoreTextureSet* GetTextureSet();
    uint32_t GetTextureHash();
    void BuildMaterial(CoreFX* pFX, CoreFX::RawMaterial* pMat, CoreTextureSet* pTexSetOverride, CoreTextureInfo* pTexInfoOverride, uint32_t textureID);
    void GetIntegerUVWH();
};

struct CoreInit
{
    enum CoreLanguageEnum
    {
        CORE_UNKNOWN_LANGUAGE,
        CORE_ENGLISH_LANG,
        CORE_FRENCH_LANG,
        CORE_GERMAN_LANG,
        CORE_ITALIAN_LANG,
        CORE_SPANISH_LANG,
        CORE_JAPANESE_LANG,
        CORE_KOREAN_LANG,
        CORE_PORTUGUESE_LANG,
        CORE_POLISH_LANG,
    };

    enum CoreVersionEnum
    {
        CORE_UNKNOWN_VERSION,
        CORE_JAPANESE_VERSION,
        CORE_US_VERSION,
        CORE_EUROPEAN_VERSION,
    };

    static CoreRegistryInterface* m_registryInterface;
    static bool m_local;
    static bool m_useClusters;
    static bool m_useAudio;
    static bool m_useGraphics;
    static bool m_useInput;
    static bool m_useNetwork;
    static bool m_useNetworkTimeouts;
    static uint32_t m_maxNetworkPlayers;
    static uint32_t m_fillMemoryWith;
    static bool m_enableMoviePlayback;
    static bool m_movieTestLoop;
    static bool m_enableCutScenes;
    static bool m_quickStart;
    static bool m_meshWrapOnly;
    static bool m_meshClampOnly;
    static bool m_useOldFormat;
    static int32_t m_argc;
    static char* m_argv[257];
    static bool m_argvUsed[256];
    static char m_exeName[256];
    static bool m_firstArgIsExeName;
    static void* m_idleCallBacks[4];
    static void* m_idleCallBacksUserData[4];
    static void* m_exitCallBacks[4];
    static void* m_exitCallBacksUserData[4];
    static bool m_isExiting;
    static void* m_powerCallBacks[4];
    static void* m_powerCallBacksUserData[4];
    static bool m_isPoweringOff;
    static bool m_isPoweringOn;
    static bool m_isPowerOffPending;
    static bool m_isHoldSwitchOn;
    static bool m_isPowerSwitchOn;
    static int32_t m_memoryStickAttachedCounter;
    static int32_t m_memoryStickDetachedCounter;
    static int32_t m_memoryStickAttachedCounterPowerOff;
    static int32_t m_memoryStickDetachedCounterPowerOff;
    static bool m_memoryStickReady;
    static int32_t m_latchMemoryStickAttachedCounter;
    static int32_t m_latchMemoryStickDetachedCounter;
    static int32_t m_latchMemoryStickAttachedCounterPowerOff;
    static int32_t m_latchMemoryStickDetachedCounterPowerOff;
    static CoreInit::CoreVersionEnum m_version;
    static CoreInit::CoreLanguageEnum m_language;
    static bool m_forceEnglish;
    static bool m_forceFrench;
    static bool m_forceGerman;
    static bool m_forceItalian;
    static bool m_forceSpanish;
    static bool m_forceJapanese;
    static bool m_forceKorean;
    static bool m_forcePortuguese;
    static bool m_forcePolish;
    static bool m_forceEUR;
    static bool m_forceUSA;
    static bool m_forceJAP;

    // TODO vtable

    bool RegistryInit(CoreMemory* i_memoryInterface, char* i_subKeyName);
    CoreRegistryInterface* GetRegistryInterface();
    bool Init();
    bool Add(int32_t i_argc, char** i_argv, bool i_firstArgIsExeName, bool i_insert);
    bool AddFromRegistry();
    bool Insert(char* i_commandLine, char* o_buffer, int32_t i_bufferSize, bool i_firstArgIsExeName);
    bool InsertFromRegistry(char* i_valueName, char* o_buffer, int32_t i_bufferSize);
    void Parse();
    void DisplayCommandLine();
    void DisplayUnusedArguments();
    int32_t SplitCommandLine(char* i_commandLine, char* o_buffer, int32_t i_bufferSize, char**& o_argv, int32_t i_maxArgs);
    bool FindPartArg();
    bool FindWholeArg();
    bool FindArgAsBool(bool& o_value, char* i_argString1, bool i_value1, char* i_argString2, bool i_value2, char* i_argString3, bool i_value3, char* i_argString4, bool i_value4);
    bool FindArgAsNumber(int32_t& o_value, char* i_argString, int32_t i_minValue, int32_t i_maxValue);
    bool FindArgAsString(char* i_argString, char* o_string, int32_t i_maxStringSize);
    char* GetExeName();
    void SetExeName();
    int32_t GetArgC();
    char** GetArgV();
    bool WasAnyArgFound();
    bool IsLocal();
    void SetLocal();
    bool IsUsingClusters();
    void SetUseClusters();
    bool IsUsingAudio();
    void SetUseAudio();
    bool IsUsingGraphics();
    void SetUseGraphics();
    bool IsUsingInput();
    void SetUseInput();
    bool IsUsingNetwork();
    void SetUseNetwork();
    bool IsUsingNetworkTimeouts();
    void SetUseNetworkTimeouts();
    uint32_t GetMaxNetworkPlayers();
    void SetMaxNetworkPlayers();
    uint32_t GetFillMemoryWith();
    void SetFillMemoryWith();
    bool IsQuickStart();
    void CheckForQuickStart();
    bool IsMoviePlaybackEnabled();
    void EnableMoviePlayback();
    bool IsMovieTestLoop();
    void SetMovieTestLoop();
    bool IsCutScenePlaybackEnabled();
    void EnableCutScenePlayback();
    bool AddIdleCallBack(void* i_callBack, void* i_callBackUserData);
    bool RemoveIdleCallBack();
    void DoIdleCallBacks();
    bool AddExitCallBack(void* i_callBack, void* i_callBackUserData);
    bool RemoveExitCallBack();
    void DoExitCallBacks();
    bool IsExiting();
    bool AddPowerCallBack();
    bool RemovePowerCallBack();
    void DoPowerCallBacks();
    bool IsPoweringOff();
    bool IsPoweringOn();
    bool IsPoweringOffOrOn();
    bool IsPowerOffPending();
    bool IsHoldSwitchOn();
    bool IsPowerSwitchOn();
    int32_t GetMemoryStickAttachedCounter();
    int32_t GetMemoryStickDetachedCounter();
    int32_t GetMemoryStickAttachedCounterPowerOff();
    int32_t GetMemoryStickDetachedCounterPowerOff();
    int32_t GetMemoryStickCountersTotal();
    bool IsMemoryStickReady();
    int32_t LatchMemoryStickCounters();
    bool AreLatchedMemoryStickCountersCurrent();
    bool HaveMemoryStickCountersBeenLatched();
    void LoadVersionFile(char* i_basePath);
    void SetVersion(CoreInit::CoreVersionEnum i_version);
    void SetUSVersion();
    void SetEuropeanVersion();
    void SetJapaneseVersion();
    uint32_t GetVersion();
    bool IsJapaneseVersion();
    bool IsUSVersion();
    bool IsEuropeanVersion();
    char* GetRegionExtension();
    void SetLanguage(CoreInit::CoreLanguageEnum i_language);
    bool SetLanguageFromSystem();
    CoreInit::CoreLanguageEnum GetLanguage();
    CoreInit::CoreLanguageEnum ConvertLanguage();
    char* MakeLangName();
    CoreInit::CoreLanguageEnum ConvertLanguageFromHash(CoreHash i_languageHash);
    void SetLanguageAndVersionOverrides();
    bool IsForcedEnglish();
    void ForceEnglish();
    bool IsForcedFrench();
    void ForceFrench();
    bool IsForcedGerman();
    void ForceGerman();
    bool IsForcedItalian();
    void ForceItalian();
    bool IsForcedSpanish();
    void ForceSpanish();
    bool IsForcedJapanese();
    void ForceJapanese();
    bool IsForcedKorean();
    void ForceKorean();
    bool IsForcedPortuguese();
    void ForcePortuguese();
    bool IsForcedPolish();
    void ForcePolish();
    bool IsForcedEUR();
    void ForceEUR();
    bool IsForcedUSA();
    void ForceUSA();
    bool IsForcedJAP();
    void ForceJAP();
    bool IsMeshClampOnly();
    bool IsMeshWrapOnly();
    bool IsOldFormat();
    void CoreInit();
    void YouCannotInstanceThisClass();
    bool MakeSpaceForArgs(int32_t i_argc, int32_t i_where);
    void ParseArg(CoreInitArg& io_arg);
    void PreParseSKU();
    void ParseArgSKU(CoreInitArg& io_arg);
    void PostParseSKU();
    bool FindVersionFileParameter(char* i_versionFile, char* i_parameter, char* o_parameterBuffer, int32_t i_parameterBufferSize);
    void ParseVersionFileSKU(char* i_versionFile);
};

struct _ImageArchitectureHeader
{
    uint32_t AmaskValue : 1;
    uint32_t AmaskShift : 8;
    uint32_t FirstEntryRVA;
};

struct _ENCRYPTION_CERTIFICATE_HASH
{
    uint32_t cbTotalLength;
    _SID* pUserSid;
    _EFS_HASH_BLOB* pHash;
    uint32_t* lpDisplayInformation;
};

struct _IMAGE_TLS_DIRECTORY64
{
    uint32_t StartAddressOfRawData;
    uint32_t EndAddressOfRawData;
    uint32_t AddressOfIndex;
    uint32_t AddressOfCallBacks;
    uint32_t SizeOfZeroFill;
    uint32_t Characteristics;
};

struct _CMSG_KEY_AGREE_ENCRYPT_INFO
{
    uint32_t cbSize;
    uint32_t dwRecipientIndex;
    _CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
    _CRYPTOAPI_BLOB UserKeyingMaterial;
    uint32_t dwOriginatorChoice;
    _CERT_ID OriginatorCertId;
    _CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
    uint32_t cKeyAgreeKeyEncryptInfo;
    _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO** rgpKeyAgreeKeyEncryptInfo;
    uint32_t dwFlags;
};

struct CAL1_SceneData
{
    char m_Name[16];
    uint32_t m_SRAMMemoryBlock;
    CAL1_AudioItemDatabase* m_AID;

    void Init();
    void CAL1_SceneData();
};

struct IDirectSoundFXI3DL2Reverb : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    HRESULT __stdcall SetPreset();
    HRESULT __stdcall GetPreset();
    HRESULT __stdcall SetQuality();
    HRESULT __stdcall GetQuality();
    void IDirectSoundFXI3DL2Reverb();
};

struct HSTR__
{
    int32_t unused;
};

struct CoreConsole
{
    CoreConsoleData* m_lpoData;
    static CoreConsole* m_instance;

    // TODO vtable

    void CoreConsole();
    void ~CoreConsole();
    void Construct(CoreMemory* lpoMemory);
    void Destruct(CoreMemory* lpoMemory);
    void Init();
    void Clear();
    void Update(CoreWorldUpdateStruct* lpoUpdateStruct);
    bool IsActive();
    void SetActive();
    void ConPrint(char* lpcText);
    void AddToRenderList(CoreGameRender* lpoGraphics);
    void Render(CoreGameRender* lpoGraphics);
    CoreConsole* GetInstance();
    void ConPositionSave(CoreConsole* lpoCon, char** lplpcParams);
    void ConPositionLoad(CoreConsole* lpoCon, char** lplpcParams);
    void RegisterGameCommands();
    bool bAddCharacter(char cChar);
    bool bParse(char* lpcCommand);
    bool bRunCommand(char* lpcCommandName, char** lplpcParams);
    void ConHelp(CoreConsole* lpoCon, char**);
    void ConVersion(CoreConsole* lpoCon, char**);
    void ConClear(CoreConsole* lpoCon, char**);
    void ConSetColour(CoreConsole* lpoCon, char** lplpcParams);
    void ConQuit(CoreConsole* lpoCon, char**);
    void ConListObjects(CoreConsole* lpoCon, char**);
    void ConListObjectVars(CoreConsole* lpoCon, char** lplpcParams);
    void ConSetVar(CoreConsole* lpoCon, char** lplpcParams);
    void ConHash(CoreConsole* lpoCon, char** lplpcParams);
    void ConResetGame(CoreConsole* lpoCon, char**);
    void ConResetWorld(CoreConsole* lpoCon, char**);
    void ConResetLevel(CoreConsole* lpoCon, char**);
    void ConResetLevelLong();
    void ConDebug(CoreConsole* lpoCon, char** lplpcParams);
    void ConSetTimeScale(CoreConsole* lpoCon, char** lplpcParams);
    void ConLoadLevel(CoreConsole* lpoCon, char** lplpcParams);
    void ConMemory(CoreConsole* lpoCon, char** lplpcParams);
    void ConSingleStep(CoreConsole* lpoCon, char** lplpcParams);
    void ConGraphics(CoreConsole* lpoCon, char** lplpcParams);
    void ConSoakTest(CoreConsole* lpoCon, char** lplpcParams);
    void ConTestMessage(CoreConsole* Con, char** Params);
    void ConSimulatePSP(CoreConsole* lpoCon, char** lplpcParams);
    void ConProfile(CoreConsole* Con, char** Params);
    void ConLanguage(CoreConsole* i_con, char** i_params);
    void RegisterCommand(char* lpcName, char* lpcShortName, char* lpcDesc, void* Function);
    void PrintChar(char cChar);
    void NewLine();
    int32_t GetNumCommands();
    CoreConsoleCommand* GetCommand();
    bool bWhiteSpace();
    CoreScripted* GetObjectA(char* lpcString);
    bool GetOnOff();
    void SetColour();
};

struct CoreConsoleCommand
{
    void* Function;
    char lpcName[20];
    char lpcShortName[4];
    char lpcDesc[80];
};

struct CoreTimeMarker
{
    enum
    {
        VERSION = 1,
    };

    uint32_t m_uiName;
    float m_fStartTime;
    float m_fEndTime;
    uint32_t m_uiPadding;

    void CoreTimeMarker();
    void ~CoreTimeMarker();
    uint32_t GetName();
    float GetStartTime();
    float GetEndTime();
};

struct _RPC_BINDING_VECTOR
{
    uint32_t Count;
    void* BindingH[1];
};

struct CoreMemoryListEntry
{
    CoreMemoryListEntry* m_Next;
    CoreMemoryListEntry* m_Prev;
    void* m_Data;

    void CoreMemoryListEntry();
    void ~CoreMemoryListEntry();
};

struct IMAGE_COR20_HEADER
{
    uint32_t cb;
    uint32_t MajorRuntimeVersion;
    uint32_t MinorRuntimeVersion;
    _IMAGE_DATA_DIRECTORY MetaData;
    uint32_t Flags;
    uint32_t EntryPointToken;
    _IMAGE_DATA_DIRECTORY Resources;
    _IMAGE_DATA_DIRECTORY StrongNameSignature;
    _IMAGE_DATA_DIRECTORY CodeManagerTable;
    _IMAGE_DATA_DIRECTORY VTableFixups;
    _IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
    _IMAGE_DATA_DIRECTORY ManagedNativeHeader;
};

struct servent
{
    char* s_name;
    char** s_aliases;
    int32_t s_port;
    char* s_proto;
};

struct CAL1_IDManagerPC
{
    static char* m_IDFileName[260];

    void CAL1_IDManagerPC();
    void ~CAL1_IDManagerPC();
    CAAudioError SetIDFile();
    CAAudioError Audio_GetUniqueID();
};

struct CorePhysicsCollision
{
    int32_t m_materialA;
    int32_t m_materialB;
    int32_t m_objectIDA;
    int32_t m_objectIDB;
    float m_impactStrength;
    float m_scrapeAmount;
    int32_t m_limbID;
    float m_data0;
    CoreVector m_position;
    CoreVector m_normal;

    void CorePhysicsCollision();
};

struct CoreGameOnScreenKeyboard : CoreOnScreenKeyboardInterface
{
    static CoreGameButtonText SpaceButtonText;
    static CoreGameButtonText DeleteButtonText;
    static CoreGameButtonText CancelButtonText;
    static CoreGameButtonText DoneButtonText;
    CoreOnScreenKeyboardInputFieldInfo m_oskInputFields[1];
    void* m_finishedCallBack;
    void* m_callBackUserData;
    bool m_failed;
    bool m_canceled;
    bool m_finished;
    float m_timeStarted;
    float m_timeStopping;
    float m_alphaScaler;
    float m_fadeDownTimeScaler;
    float m_timerValue;
    int32_t m_inputIndex;

    void CoreGameOnScreenKeyboard();
    void ~CoreGameOnScreenKeyboard();
    void DeleteInstance();
    bool Prepare(char* i_title, char* i_string, int32_t i_maximumLength, int32_t i_inputLines, int32_t i_inputIndex);
    bool Start(void* i_finishedCallBack, void* i_callBackUserData);
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    void Render(CoreGameRender* io_graphics, int32_t i_renderFlags);
    CoreOnScreenKeyboardInputFieldInfo* GetInputFieldInfo(int32_t i_inputIndex);
    char* GetCommonDialogTitle();
    int32_t GetFirstInputIndex();
    int32_t GetNextInputIndex(int32_t i_inputIndex);
    int32_t GetPreviousInputIndex(int32_t i_inputIndex);
    CoreGameOnScreenKeyboardParameters* GetOnScreenKeyboardParameters();
    void Finished();
};

struct IDirectSoundFXWavesReverb : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall SetAllParameters();
    HRESULT __stdcall GetAllParameters();
    void IDirectSoundFXWavesReverb();
};

struct CoreSceneContainer
{
    enum
    {
        MAX_SCENE_CONTAINERS = 256,
    };

    struct meshPartition
    {
        CoreVector m_boundsMin;
        CoreVector m_boundsMax;
        CoreModelMaterial* m_pMaterialMesh;
        uint32_t mPad[3];

        void meshPartition();
    };

    static CoreVector m_dynamicLightPos[2];
    static CoreVector m_dynamicLightRGB[2];
    static float m_dynamicLightRad[2];
    static bool m_dynamicLightState[2];
    static CoreSceneClip m_sceneClip[0];
    static uint32_t m_maxContainers;
    static int32_t m_containerListStart;
    static uint32_t m_currentContainer;
    static uint32_t m_visibleIndexList[0];
    static uint32_t m_visibleIndexCount;
    static uint32_t m_sceneFlipped;
    static bool m_viewRoomCentric;
    static uint32_t m_viewRoomCentricDepth;
    static CoreSceneContainer::meshPartition* m_meshPartitionTable;
    static CoreModelMaterial** m_meshListTable;
    static CoreModelMaterial** m_meshDynamicListTable;
    static uint32_t m_meshGlobalPartitionIndex;
    static CoreLevelLight** m_lightListTable;
    static uint32_t m_lightGlobalListIndex;
    static CoreVector m_globalBoundsMin;
    static CoreVector m_globalBoundsMax;
    CoreVector m_boundsMin;
    CoreVector m_boundsMax;
    uint32_t m_meshIndex;
    uint32_t m_numPortals;
    uint32_t m_numLightControllers;
    uint32_t m_idxLightControllers[8];
    CoreNodeChain* m_nodeChains;
    uint32_t m_roomFlags;
    uint32_t m_flipIndex;
    int32_t m_hitIndex;
    uint32_t m_fogRGBA;
    uint32_t m_logicalIndex;
    uint32_t m_numMeshes;
    uint32_t m_meshPartitionIndex;
    uint32_t m_meshListIndex;
    uint32_t m_numLights;
    uint32_t m_lightIndex;
    uint32_t m_padAlign[2];
    CoreScenePortal m_Portals[16];

    void CoreSceneContainer();
    void ~CoreSceneContainer();
    void BindData();
    void ReleaseData();
    void RenderBounds(CoreRGBA iRGBA);
    void BindLocalData();
    void ReleaseLocalData();
    void BuildMeshPartitionList(uint32_t iConIndex);
    void SetHitIndex();
    int32_t GetHitIndex();
    void calcVisibleContainers(CoreLevelCompiled* iLevelCompiled, int32_t iContainer, float* iClip);
    bool calcClipBounds(float* iClipRect, CoreVector* iChkPortal, float* iDstRect);
    bool cullPortal(CoreVector* pBounds);
    void calcCurrentContainer();
    uint32_t calculateScene(CoreLevelCompiled* iLevelCompiled, CoreModelMaterial*** iMeshList, uint32_t* iMeshCounts, uint32_t* iMeshFlags);
    void updateLightMeshes();
    uint32_t getVisibleRoomList(uint32_t*& ilistPtr);
    void renderDebug(CoreLevelCompiled* iLevelCompiled, uint32_t useContainer);
    void renderGlobalDebug();
    int32_t PointInContainerIndex();
    CoreSceneContainer* GetSceneContainer(uint32_t iIndex);
    CoreSceneContainer* GetLogicalSceneContainer();
    CoreSceneContainer* GetPhysicalSceneContainer(CoreVector iPoint, bool iFlipped);
    int32_t GetPhysicalSceneContainerIndex(CoreVector iPoint, bool iFlipped);
    int32_t GetLogicalSceneContainerIndex(CoreVector iPoint, bool iFlipped);
    uint32_t GetLogicalSceneContainerBoundedList();
    uint32_t GetBoundedMeshList();
    bool GetWaterHeightBelowPoint();
    bool GetWaterHeightAbovePoint(CoreVector i_pos, float& oWaterHeight, bool iFlipped);
    bool PointInWater(CoreVector iPos, bool iFlipped);
    int32_t GetFlipContainerIndex();
    void SetFlipStatus(uint32_t iFlip);
    uint32_t GetFlipStatus();
    void SetRoomCentricView(bool iStatus, uint32_t iRoomNumber, uint32_t iDepth);
    void RecurseRoomCentricView(uint32_t iRoomNumber, uint32_t& iRootDepth, uint32_t& iListIndex);
    void RenderVisibleListBounds();
    bool IsPointVisible(CoreVector iPoint, uint32_t iRoom);
    bool IsSphereVisible(CoreVector iPoint, float iRadius, uint32_t iRoom);
    void SetDynamicLight();
    uint32_t GetLightList(CoreVector iPos, CoreLevelLight**& ioList);
};

struct CoreImage
{
    struct Image
    {
        uint32_t m_sizeX;
        uint32_t m_sizeY;
        uint32_t m_sizeZ;
        uint32_t m_bitsPerPixel;
        uint32_t m_dataSizeX;
        uint32_t m_dataSizeXY;
        uint32_t m_dataSizeXYZ;
        uint32_t* m_pdata;
        CoreMemory* m_pmemory;

        void FlipY();
        uint32_t GetSizeX();
        uint32_t GetSizeY();
        uint32_t GetBitsPerPixel();
        uint32_t GetDataSize();
        void* GetData();
        uint32_t GetOffsetY();
        uint32_t GetOffsetZ();
        void SetPixel();
        void SetIndex();
        CoreRGBA GetPixel();
        uint32_t GetIndex();
        void Create();
        void Init();
        void Clear();
        void Copy();
        void Image();
        void ~Image();
    };

    CoreImage::Image m_palette;
    CoreImage::Image m_pixels;

    void CoreImage();
    void ~CoreImage();
    bool Load();
    bool Save();
    void Create();
    void Clear();
    void SetPixel();
    void SetPalette();
    CoreRGBA GetPixel();
    int32_t GetIndex();
    int32_t GetWidth();
    int32_t GetHeight();
    int32_t GetPaletteEntries();
    CoreRGBA GetPaletteEntry();
    bool IsColourPalletized();
    bool Is256ColourPalletized();
    bool Is16ColourPalletized();
    bool Is24bitColour();
    bool Is32bitColour();
    bool HasAlpha();
    bool operator==();
    void Init();
    bool LoadDevIL();
    bool LoadGDIPlus();
    bool LoadTGA();
    bool SaveDevILGray8();
    bool SaveDevILRGBA();
    bool SaveDevILPalletized8();
    bool SaveDevIL();
    bool SaveGDIPlus();
    bool SaveTGA();
};

struct tagMSG
{
    HWND* hwnd;
    uint32_t message;
    uint32_t wParam;
    int32_t lParam;
    uint32_t time;
    tagPOINT pt;
};

struct tagCANDIDATELIST
{
    uint32_t dwSize;
    uint32_t dwStyle;
    uint32_t dwCount;
    uint32_t dwSelection;
    uint32_t dwPageStart;
    uint32_t dwPageSize;
    uint32_t dwOffset[1];
};

struct CAL0_Heap
{
    uint32_t m_HeapSize;
    void* m_MemoryPointer;
    bool m_OwnedMemory;
    bool m_Initialised;
    void* m_AllocPoint;
    uint32_t m_ByteAlignment;
    bool m_ShowHeapLogging;
    bool m_UseSysMemory;
    bool m_Locked;
    char m_HeapName[16];
    char m_HeapColour[16];
    void* m_HeapMarker;

    // TODO vtable

    void CAL0_Heap();
    void ~CAL0_Heap();
    void ResetParams();
    CAAudioError Initialise(uint32_t heapSize, void* memoryPointer, bool useSysMemory);
    void* Alloc(uint32_t size);
    void Dealloc(void* blockPointer);
    CAAudioError Release();
    bool IsInitialised();
    void SetHeapLogging(bool log);
    uint32_t GetTotalHeapSize();
    uint32_t GetUsedHeapSize();
    uint32_t GetFreeHeapSize();
    CAAudioError Lock();
    void* GetStartAddress();
    CAAudioError Reset();
    void SetHeapName(char* name);
    void SetHeapColour(char* colour);
    CAAudioError SetHeapMarker();
    CAAudioError ResetHeapMarker();
    CAAudioError ResetHeapToMarker();
    uint32_t Align();
    bool CheckHeapInit();
};

struct _ACL_REVISION_INFORMATION
{
    uint32_t AclRevision;
};

struct IInternalUnknown : IUnknown
{
    HRESULT __stdcall QueryInternalInterface();
    void IInternalUnknown();
};

struct CorePSPModelDefs
{
    enum
    {
        MF_LIT = 1,
        MF_HAS_STRIPS = 2,
        MF_HAS_NORMALS = 4,
        MF_ENVMAP = 8,
        MF_UNTEXTURED = 16,
        MF_VRAM = 32,
        MF_LEVEL_MESH = 64,
        MF_TEXTURE_WRAP = 128,
        MF_SCALE0_MESH = 8,
        MF_SCALE1_MESH = 9,
    };

};

struct CoreStr
{
    // TODO vtable

    int32_t GetLength(char* i_string);
    void Copy(char* o_to, char* i_from);
    void NCopy(char* o_to, char* i_from, uint32_t i_maxLength);
    bool IsSame(char* i_string, char* i_compare);
    bool IsNSame(char* i_string, char* i_compare, uint32_t i_maxLength);
    bool IsSameIgnoreCase(char* i_string, char* i_compare);
    bool IsNSameIgnoreCase(char* i_string, char* i_compare, uint32_t i_maxLength);
    char ToUpper();
    char ToLower();
    int32_t FindChar(char* i_string, char i_char);
    int32_t ReverseFindChar(char* i_string, char i_char);
    void Cat(char* o_to, char i_char);
    void NCat(char* o_to, char* i_from, uint32_t i_maxLength);
    float ToFloat(char* i_string);
    int32_t ToInt(char* i_string);
    int32_t VSPrint(char* o_to, uint32_t i_maxLength, char* i_format, char*& i_list);
    int32_t SPrint(char* o_to, uint32_t i_maxLength, char* i_format);
    bool IsHex(char* i_string, uint32_t& o_value);
    bool IsInt(char* i_string, int32_t& o_value);
    int32_t FindTextIndex();
    int32_t FindTextIgnoreCaseIndex(char* i_string, char* i_find);
    bool FindTextA();
    bool FindTextIgnoreCase(char* i_string, char* i_find);
    int32_t Compare(char* i_string, char* i_compare);
    uint32_t ReadUTF8(char*& io_char);
    uint32_t WriteUTF8(char*& io_char, uint32_t i_unicode);
    int32_t GetLengthUTF8(char* i_string);
    bool CopyAfterMatchIgnoreCase(char* i_string, char* i_compare, char* o_buffer);
    bool IsFirstPartSame();
    bool IsFirstPartSameIgnoreCase(char* i_string, char* i_compare);
    bool SkipString();
    bool SkipStringIgnoreCase(char*& i_string, char* i_stringToSkip);
    bool IsLastPartSame();
    bool IsLastPartSameIgnoreCase();
    bool IsSlash();
    bool IsAlpha();
    bool IsUpper();
    bool IsLower();
    bool IsDigit();
    bool IsHexDigit();
    char GetLastChar();
    void SetLastChar();
    void AppendChar();
    bool IsLastCharSlash();
    char GetSlashToUse();
    int32_t ConvertSlashes(char* io_string, char i_slash);
    char* SkipSlashes(char* i_string);
    void RemoveSlashesFromEnd(char* io_string);
    void MakeSureEndsWithSlash(char* io_string, char i_slash);
    char* FindFirstSlash();
    char* FindLastSlash(char* i_string);
    bool RemoveAfterLastSlash();
    bool HasSlash();
    void CoreStr();
    void ~CoreStr();
    void YouCannotInstanceThisClass();
};

struct IEnumFORMATETC : IUnknown
{
    HRESULT __stdcall Next();
    HRESULT __stdcall Skip();
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone();
    void IEnumFORMATETC();
};

struct _IMAGE_IMPORT_DESCRIPTOR
{
    uint32_t Characteristics;
    uint32_t OriginalFirstThunk;
    uint32_t TimeDateStamp;
    uint32_t ForwarderChain;
    uint32_t Name;
    uint32_t FirstThunk;
};

struct IMarshal2 : IMarshal
{
    void IMarshal2();
};

struct CoreMeshGroupPC
{
    uint32_t m_uiNumMeshes;
    int32_t m_iModelMeshIndexTable[1];

    void CoreMeshGroupPC();
    void ~CoreMeshGroupPC();
    CoreModelMesh* GetModelMeshPtr();
    uint32_t GetNumMeshes();
    int32_t* GetModelMeshIndexTable();
};

struct CoreOnScreenKeyboardInputFieldInfo
{
    bool m_prepared;
    char m_title[128];
    char m_inputString[385];
    char m_outputString[385];
    int32_t m_preparedMaximumLength;
    int32_t m_preparedInputLines;
    int32_t m_index;

    void CoreOnScreenKeyboardInputFieldInfo();
    void ~CoreOnScreenKeyboardInputFieldInfo();
    void Reset();
    void Prepare(char* i_title, char* i_string, int32_t i_maximumLength, int32_t i_inputLines);
    bool IsPrepared();
    void Start(int32_t i_index, CoreFont* i_font, uint32_t i_changeMissingCharsTo);
    void CopyInputStringToOutputString();
    int32_t DoAction(int32_t i_action);
    char* GetTitle();
    char* GetEditedText();
    int32_t GetPreparedMaximumLength();
    bool IsEditedTempEmpty();
    CORE_OSK_RESULT_TAG GetResult();
    void DoCallBack(bool i_hasFailed, bool i_canceled, void* i_finishedCallBack, void* i_callBackUserData, bool i_lastCallBack);
};

struct HDC__
{
    int32_t unused;
};

struct IXMLDOMImplementation : IDispatch
{
    HRESULT __stdcall hasFeature();
    void IXMLDOMImplementation();
};

struct _PMD
{
    int32_t mdisp;
    int32_t pdisp;
    int32_t vdisp;
};

struct CAL0_MemoryManagerSoundRAM : CAL0_MemoryManager
{
    void CAL0_MemoryManagerSoundRAM();
    void ~CAL0_MemoryManagerSoundRAM();
    uint32_t AllocateMemory(uint32_t bytes);
};

struct _CMC_PEND_INFO
{
    _CRYPTOAPI_BLOB PendToken;
    _FILETIME PendTime;
};

struct CoreNetworkDialogInterface : CoreCommonDialogStatus
{
    static CoreNetworkDialogInterface* m_dummyInstance;
    static CoreNetworkDialogInterface* m_defaultInstance;

    CoreNetworkDialogInterface* CreateInstance(CoreMemory* i_memoryInterface);
    CoreNetworkDialogInterface* GetDummyInstance();
    CoreNetworkDialogInterface* GetDefaultInstance();
    void SetDefaultInstance();
    void DeleteInstance();
    bool Prepare();
    bool Start();
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    void CoreNetworkDialogInterface();
};

struct tagHARDWAREHOOKSTRUCT
{
    HWND* hwnd;
    uint32_t message;
    uint32_t wParam;
    int32_t lParam;
};

struct _PSFEATURE_OUTPUT
{
    int32_t bPageIndependent;
    int32_t bSetPageDevice;
};

struct IROTData : IUnknown
{
    HRESULT __stdcall GetComparisonData();
    void IROTData();
};

struct CoreDebugClient
{
    char szName[32];
    void* lpDoDebugFunc;
    int32_t iLevel;
    void* lpUserData;
};

struct CAL0_Math
{
    static uint32_t m_Seed;

    ca_fixed ca_sinfp();
    ca_fixed ca_cosfp();
    ca_fixed ca_tanfp();
    ca_fixed ca_asinfp();
    ca_fixed ca_atanfp();
    ca_fixed ca_acosfp();
    ca_fixed ca_sqrtfp();
    ca_fixed ca_log10fp();
    ca_fixedhp ca_log10fphp();
    ca_fixed ca_fpabs();
    uint32_t ca_abs();
    ca_fixed ca_10powxfp();
    uint32_t ca_rand();
    uint32_t ca_rand_max();
    void ca_randomize_timer();
    ca_fixed ca_atofp();
    void CAL0_Math();
    void rng_srand();
    uint32_t rng_rand();
};

struct HINSTANCE__
{
    int32_t unused;
};

struct CoreFXMappedVariable
{
    CoreHash m_hVarName;
    void* m_pVarMap;

    void CoreFXMappedVariable();
    void ~CoreFXMappedVariable();
};

struct CorePanel : CoreMenuBase
{
    struct OnScreenMessage
    {
        uint32_t m_GameTextHash;
        char m_Format[1];
    };

    CorePanelData* m_data;

    void CorePanel();
    void ~CorePanel();
    void Construct(CoreMemory* io_memory);
    void Destruct(CoreMemory* io_memory);
    void Init(CoreObjectUpdateStruct* io_updateStruct);
    void Reset(CoreObjectUpdateStruct* io_updateStruct);
    void Update(CoreObjectUpdateStruct* io_updateStruct, float fTimeElapsed);
    void AddOnScreenMessage(char* i_message);
    void SendOnScreenMessage(char* i_message, uint32_t i_GameTextHash, bool i_RemoteStationsOnly);
    void Render(CoreGameRender* io_graphics);
    void RenderComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
    void RenderGlobals(CoreGameRender* io_graphics, CoreObjectUpdateStruct* io_updateStruct);
    void SetActiveView(uint32_t i_view);
    void DoDebug(CoreDebugInput* i_input);
    void SetBodgeVisibility();
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    float GetGlobalVisibility();
    void SetGlobalVisibility();
    int32_t FindComponent(CoreHash i_name);
    CoreMenuComponent* GetComponent(int32_t i_index);
    CoreTextureSet* GetTextureSet();
    CoreHash GetTextureSetID();
    void SetTextureSet(CoreTextureSet* i_textureSet, CoreHash i_textureSetID);
    void AddComponent(CoreHash i_componentName, CoreHash i_Type);
    int32_t GetNumComponents();
    uint32_t GetActiveView();
    CoreScripted::CommandReturn FnPanelSetVisibility(CoreCommand* io_command);
    CoreScripted::CommandReturn FnPanelUpdate();
};

struct adpcmwaveformat_tag
{
    tWAVEFORMATEX wfx;
    uint32_t wSamplesPerBlock;
    uint32_t wNumCoef;
    adpcmcoef_tag aCoef[0];
};

struct ca_3DVelocity
{
    ca_fixed dx;
    ca_fixed dy;
    ca_fixed dz;

    void ca_3DVelocity();
};

struct CAL1_ProgramSaver : CAL0_FileSaver
{
    CAL1_AudioDriver* m_AD;
    CAL1_AudioItemDatabase* m_AID;
    uint32_t* m_CAL1Data;
    uint32_t m_CAL1NumTypes;
    CA_AI_Type* m_CAL1TypeArray;
    bool m_EnableWriteAIFL;
    bool m_EnableWriteName;
    bool m_EnableOptimise;

    void CAL1_ProgramSaver();
    void ~CAL1_ProgramSaver();
    void EnableWriteAIFL();
    void EnableWriteName();
    void EnableOptimise();
    CAAudioError AssembleSections();
    CAAudioError DestroySections();
    CAAudioError AssembleCAL1();
    CAAudioError DestroyCAL1();
    CAAudioError WriteAudioItem();
    uint32_t WriteAudioItemDetails();
};

struct CoreBuildSystemInterfaceUsingNamedPipe
{
    CoreMemory* m_memoryInterface;
    CoreStringBuffer<256> m_buildPath;
    CoreStringBuffer<256> m_defaultPath;
    uint32_t m_messageID;
    CoreNamedPipeInterface* m_namedPipe;
    CoreRecentFileNameList m_recentFileNameList;
    bool m_applicationWasStarted;

    void CoreBuildSystemInterfaceUsingNamedPipe();
    bool InitForBuildSystem(CoreMemory* i_memoryInterface, char* i_pipeName, char* i_defaultPath, bool i_startApplication);
    void ExitForBuildSystem();
    bool BuildSystemCompleteTheFileName(char* i_fileName, char* i_devicePrefix, CoreStringBuffer<256>& o_fileName);
    bool ProcessBuildSystemMessage(uint32_t i_startMessageID, uint32_t i_endMessageID, char* i_messagePrefix, char* o_returnMessageBuffer, int32_t i_returnMessageBufferSize);
    bool StartApplication(char* i_pipeName);
    bool WaitUntilApplicationIsReady(float i_timeout);
};

struct HMIXEROBJ__
{
    int32_t unused;
};

struct CoreCriticalSectionBuffers
{
    CoreCriticalSectionBuffersHeaders m_buffers;
    CoreCriticalSectionBuffersHeaders m_copyBuffers;

    void CoreCriticalSectionBuffers();
    void Init();
    uint32_t GetWholeBufferSize();
    bool AddBuffer();
    uint32_t CopyAndReset();
    void Reset();
    bool GetLostCountAndReset();
    CoreCriticalSectionBufferHeader* GetBufferFromCopy();
    void FlushCopy();
};

struct IProcessLock : IUnknown
{
    uint32_t __stdcall AddRefOnProcess();
    uint32_t __stdcall ReleaseRefOnProcess();
    void IProcessLock();
};

struct IXMLDOMNamedNodeMap : IDispatch
{
    HRESULT __stdcall getNamedItem();
    HRESULT __stdcall setNamedItem();
    HRESULT __stdcall removeNamedItem();
    HRESULT __stdcall get_item();
    HRESULT __stdcall get_length();
    HRESULT __stdcall getQualifiedItem();
    HRESULT __stdcall removeQualifiedItem();
    HRESULT __stdcall nextNode();
    HRESULT __stdcall reset();
    HRESULT __stdcall get__newEnum();
    void IXMLDOMNamedNodeMap();
};

struct CoreBodyMarkerData
{
    int32_t iNumBodyMarkers;
    CoreBodyMarker* lpoBodyMarkerArray;
    CoreVector vBoundSpherePos;
    float fBoundSphereRadius;
    int32_t iActiveMarkerCount;
    int32_t iLastValid;

    void CoreBodyMarkerData();
};

struct IXMLError : IUnknown
{
    HRESULT __stdcall GetErrorInfo();
    void IXMLError();
};

struct CoreNonRenderableObject : CoreObject
{
    void CoreNonRenderableObject();
    void ~CoreNonRenderableObject();
    void Construct();
    void Destruct();
    void Init();
    void Reset();
};

struct IInternetProtocolRoot : IUnknown
{
    HRESULT __stdcall Start();
    HRESULT __stdcall Continue();
    HRESULT __stdcall Abort();
    HRESULT __stdcall Terminate();
    HRESULT __stdcall Suspend();
    HRESULT __stdcall Resume();
    void IInternetProtocolRoot();
};

struct CoreFXControl
{
    CoreFXControl* m_pPrev;
    CoreFXControl* m_pNext;
    CoreVector m_Pos;
    CoreVector m_Rot;
    int32_t* m_CmdPtr;
    uint32_t m_Command;
    uint32_t m_ComFlags;
    int32_t* m_CallBackPtr;
    float m_CallBackRate;
    float m_CallBackRateTot;
    int32_t* m_LoopPtr;
    uint32_t m_nLoop;
    uint32_t m_ComWait;
    uint32_t m_ComWaitTick;
    uint32_t m_ComWaitEnd;

    void CoreFXControl();
};

struct CoreHashTable : CoreHashElementTable
{
    uint32_t m_tableSize;
    CoreHashElement* m_elements;

    void CoreHashTable();
    void Construct(int32_t i_maxItems, CoreMemory* i_memory);
    void Destruct(CoreMemory* i_memory);
    bool Add(CoreHash i_hash, uint32_t i_newData);
    bool Remove(CoreHash i_hash);
    bool Find(CoreHash i_hash, uint32_t& o_foundData);
    bool Update(CoreHash i_hash, uint32_t i_newData);
    void RemoveAll();
    uint32_t GetMaxNumItems();
    void Resize();
    bool Write();
    CoreHashElement* GetElementPtr(uint32_t i_index);
    bool CompareHashArray();
    bool FindIndex(CoreHash i_hash, uint32_t& o_index);
    void Zero();
};

struct ISoftDistExt : IUnknown
{
    HRESULT __stdcall ProcessSoftDist();
    HRESULT __stdcall GetFirstCodeBase();
    HRESULT __stdcall GetNextCodeBase();
    HRESULT __stdcall AsyncInstallDistributionUnit();
    void ISoftDistExt();
};

struct CoreCriticalSection
{
    void* m_state;
    bool m_started;

    void CoreCriticalSection();
    void ~CoreCriticalSection();
    void Start();
    void End();
};

struct CoreFXSequenceFrame
{
    uint32_t m_AnimFrame;
    uint32_t m_rgb;
    float m_Scale;
};

struct CoreModelBoneControl
{
    void* m_callbackFunction;
    void* m_data;
};

struct CAL0_API_PC : CAL0_API
{
    void CAL0_API_PC();
    void ~CAL0_API_PC();
    CAAudioError Initialise(uint32_t i_heapSize, void* i_Address, bool useSysMemory);
    CAAudioError Reset();
    CAAudioError Destroy();
};

struct CoreNet : CoreScripted
{
    enum CoreNetAsynchronous
    {
        ASYNCHRONOUS_FREE,
        ASYNCHRONOUS_RUNNING,
        ASYNCHRONOUS_TIMED_OUT,
        ASYNCHRONOUS_ABORTED,
        ASYNCHRONOUS_SUCCESS,
    };

    enum CoreNetSyncState
    {
        SYNC_UNKNOWN,
        SYNC_NOT_READY,
        SYNC_WAITING,
        SYNC_READY,
    };

    enum CoreNetSyncEventState
    {
        SYNC_EVENT_ENDED,
        SYNC_EVENT_STARTED,
        SYNC_EVENT_ABORTED,
    };

    enum CoreNetConstants
    {
        MAX_PACKET_LENGTH = 1024,
        GAME_PORT = 3658,
        MAX_MESSAGES = 128,
        MAX_CODED_MESSAGES = 24,
        MAX_SERVERS = 8,
        MAX_NAME_LENGTH = 100,
        NETWORK_THREAD_FREQUENCY = 100,
    };

    enum CoreNetSockets
    {
        INADDR_ANY = 0,
        INADDR_LOOPBACK = 2130706433,
        INADDR_BROADCAST = 255,
        INADDR_NONE = 255,
    };

    struct CoreNetServer
    {
        uint32_t m_IPAddress;
        float m_PingTime;
        uint32_t m_AttachedClients;
        uint32_t m_MaxClients;
        float m_Timestamp;
        uint32_t m_GameSpecific;
        bool m_CanJoin;
        char m_Name[100];
    };

    struct DeviceInitialisationData
    {
        uint32_t m_GameHash;
        bool m_UseTimeouts;
        uint32_t m_NetworkAdapter;
        uint32_t m_HostIPAddress;
        uint32_t m_SubnetMask;
        uint32_t m_DefaultGateway;
        bool m_ActivateNetwork;
        bool m_UseDECINetwork;
        bool m_UseAdhocNetwork;
    };

    static CoreHash NETWORK_LOGGER;
    static CoreHash NETWORK_SERVER_LOGGER;
    static CoreHash NETWORK_CLIENT_LOGGER;
    CoreNetInternalData* m_Data;
    CoreNetDevice* m_Device;

    void Construct(CoreMemory* io_Memory, CoreHash& i_Type);
    void Destruct(CoreMemory* io_Memory);
    void Init(CoreWorldUpdateStruct* i_WorldUpdateStruct, CoreNet::DeviceInitialisationData* i_Init);
    void Shutdown();
    void Reset();
    void ExitCallBack(void* i_callBackUserData);
    char* GetIPAddress(uint32_t i_IPAddress);
    uint32_t GetHostIPAddress(char* i_HostName);
    void SetAcceptBroadcastPackets();
    void SendPacket(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
    void SendCodedPacket(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
    void BroadcastPacket(CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
    void BroadcastCodedPacket(CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
    bool IsPacketWaiting();
    uint32_t GetPacketFromAddress();
    uint32_t GetPacketType();
    void* GetPacketData();
    void NextPacket();
    void IgnoreRestOfPackets();
    void Update(CoreWorldUpdateStruct* io_WorldUpdateStruct);
    bool IsValid();
    void SetSyncState();
    void SendSyncState();
    void SetSendSyncState();
    void SetSyncStateCache();
    CoreNet::CoreNetSyncState GetSyncState();
    uint32_t GetNumberOfNetworkPlayers();
    uint32_t GetNetworkPlayerIPAddress(int32_t i_PlayerIndex);
    CoreNet::CoreNetSyncState GetNetworkPlayerSyncState();
    char* GetNetworkPlayerName(int32_t i_PlayerIndex);
    uint32_t GetNetworkPlayerColour();
    CoreNet::CoreNetAsynchronous SetAsynchronousTimeout();
    void ClearAsynchronousTimeout();
    CoreNet::CoreNetAsynchronous GetAsynchronousStatus();
    CoreNet::CoreNetAsynchronous IsServerReady();
    CoreNet::CoreNetAsynchronous AreClientsReady();
    void FindServers();
    void JoinServer();
    void LeaveGame();
    bool GameJoined();
    void ClearDiscoveredServersList();
    void ClearNetworkPlayerList();
    uint32_t GetDiscoveredServerCount();
    CoreNet::CoreNetServer* GetDiscoveredServerList();
    bool GetConnectedState();
    void SetConnectionLost();
    int32_t GetPlayerID();
    bool IsServer();
    bool IsClient();
    bool IsNetworkGame();
    uint32_t GetMaxNetworkPlayers();
    bool IsInLobby();
    void SetIsInLobby(bool i_State);
    uint32_t GetGameSpecificServerData();
    bool GetWLANSwitchOnState();
    bool GetStartGameState();
    void SetStartGameState(bool i_StartGameState);
    void SetShowWLANSwitchDialogue();
    bool GetShowWLANSwitchDialogue();
    void DoDebug(CoreDebugInput* i_Input, float i_Timestamp);
    void DrawRXTXActivity(CoreGraphicsDevice* i_GraphicsDevice);
    void* GetVariablePointer(CoreHash i_variableName);
    CoreScripted::CommandReturn RunFunction(CoreCommand* io_command);
    CoreScripted::CommandReturn FnFindServers();
    CoreScripted::CommandReturn FnJoinGame(CoreCommand* io_Command);
    CoreScripted::CommandReturn FnLeaveGame();
    CoreScripted::CommandReturn FnStartGame(CoreCommand* io_Command);
    CoreScripted::CommandReturn FnHostGame(CoreCommand* io_Command);
    CoreScripted::CommandReturn FnAcceptBroadcastPackets();
    CoreScripted::CommandReturn FnSetAsynchronousTimeout(CoreCommand* io_Command);
    CoreScripted::CommandReturn FnSynchronise(CoreCommand* io_Command);
    CoreScripted::CommandReturn FnResetNetworkDevice();
    CoreScripted::CommandReturn FnNetworkUpdate(CoreCommand* io_Command);
    void CoreNet();
    void ~CoreNet();
};

struct CoreFontTextureInfo
{
    CoreFont* m_instance;
    CoreTextureSet* m_textureSet;
    CoreHash m_textureHashes[4];

    void CoreFontTextureInfo();
    void ~CoreFontTextureInfo();
};

struct CorePSPStdCFileDevice : CoreFileDevice
{
    void CorePSPStdCFileDevice();
    void ~CorePSPStdCFileDevice();
    void Construct();
    void Destruct();
    void Init();
    CoreFileHandle Open();
    bool Close();
    int32_t Read();
    bool Seek();
    bool AsyncFinished();
    int32_t Write();
    int32_t FileSize();
    bool GetFileTimes();
    bool SetFileTimes();
    bool DoesFileExist();
    bool IsReadOnly();
    bool ChangeReadOnly();
    bool CompleteTheFileName();
};

struct _wireVARIANT
{
    uint32_t clSize;
    uint32_t rpcReserved;
    uint32_t vt;
    uint32_t wReserved1;
    uint32_t wReserved2;
    uint32_t wReserved3;
    int32_t llVal;
    int32_t lVal;
    uint32_t bVal;
    int32_t iVal;
    float fltVal;
    float dblVal;
    int32_t boolVal;
    int32_t scode;
    tagCY cyVal;
    float date;
    _FLAGGED_WORD_BLOB* bstrVal;
    IUnknown* punkVal;
    IDispatch* pdispVal;
    _wireSAFEARRAY** parray;
    _wireBRECORD* brecVal;
    uint32_t* pbVal;
    int32_t* piVal;
    int32_t* plVal;
    int32_t* pllVal;
    float* pfltVal;
    float* pdblVal;
    int32_t* pboolVal;
    int32_t* pscode;
    tagCY* pcyVal;
    float* pdate;
    _FLAGGED_WORD_BLOB** pbstrVal;
    IUnknown** ppunkVal;
    IDispatch** ppdispVal;
    _wireSAFEARRAY*** pparray;
    _wireVARIANT** pvarVal;
    char cVal;
    uint32_t uiVal;
    uint32_t ulVal;
    uint32_t ullVal;
    int32_t intVal;
    uint32_t uintVal;
    tagDEC decVal;
    tagDEC* pdecVal;
    char* pcVal;
    uint32_t* puiVal;
    uint32_t* pulVal;
    uint32_t* pullVal;
    int32_t* pintVal;
    uint32_t* puintVal;
};

struct CoreFXEmitterItem
{
    uint32_t m_Flags;
    int32_t m_rgb0;
    uint32_t m_cullingType;
    int32_t m_rgb1;
    uint32_t m_ItemType;
    float m_Velocity;
    float m_Scale;
    uint32_t m_iterCount;
    uint32_t m_iterSpeed;
    void* m_pCtrl;
    float m_Rate;
    float m_RateTot;
    uint32_t m_PrimType;
    uint32_t m_iterRange;
    CoreVector m_Direction;
    CoreVector m_Offset;
    CoreVector m_GenPos;
    uint32_t m_Frame;
    uint32_t m_Count;
    float m_Diverge;
    float m_Rot;

    void CoreFXEmitterItem();
};

struct CAL1_AudioItemFileLink : CAL1_AudioItem
{
    char* m_LinkFileName;

    void CAL1_AudioItemFileLink();
    void ~CAL1_AudioItemFileLink();
    void SetLinkFileName(char* filename);
    char* GetLinkFileName();
    CAAudioError LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
    CAAudioError SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
};

struct CoreFilename
{
    CoreString m_full;
    CoreString m_fullBackslash;
    CoreString m_drive;
    CoreString m_path;
    CoreString m_pathName;
    CoreString m_name;
    CoreString m_ext;
    CoreString m_parentPaths[4];
    CoreString m_parentNames[4];
    CoreString m_parts[8];

    void CoreFilename();
    void ~CoreFilename();
    void Init();
    char* GetFull();
    char* GetFullBackslash();
    char* GetPathName();
    char* GetName();
    char* GetExt();
    char* GetPath();
    char* GetParent();
    char* GetParentName();
    char* GetPart();
    char* GetDrive();
};

struct HHOOK__
{
    int32_t unused;
};

struct tagMONITORINFO
{
    uint32_t cbSize;
    tagRECT rcMonitor;
    tagRECT rcWork;
    uint32_t dwFlags;
};

struct IContext : IUnknown
{
    HRESULT __stdcall SetProperty();
    HRESULT __stdcall RemoveProperty();
    HRESULT __stdcall GetProperty();
    HRESULT __stdcall EnumContextProps();
    void IContext();
};

struct tagCOMPOSITIONFORM
{
    uint32_t dwStyle;
    tagPOINT ptCurrentPos;
    tagRECT rcArea;
};

struct IXMLAttribute : IDispatch
{
    HRESULT __stdcall get_name();
    HRESULT __stdcall get_value();
    void IXMLAttribute();
};

struct ICreateErrorInfo : IUnknown
{
    HRESULT __stdcall SetGUID();
    HRESULT __stdcall SetSource();
    HRESULT __stdcall SetDescription();
    HRESULT __stdcall SetHelpFile();
    HRESULT __stdcall SetHelpContext();
    void ICreateErrorInfo();
};

struct CoreXMLStringTableHandler
{
    CoreXMLDocString* m_pStringArrays[129];
    CoreXMLDocString* m_pStringArrayEndPointers[129];
    uint32_t m_UniqueLength;
    CoreMemory* m_pMemory;

    void CoreXMLStringTableHandler();
    void ~CoreXMLStringTableHandler();
    void Clear();
    CoreXMLDocString* Find();
    CoreXMLDocString* Add();
    CoreXMLDocString* FindOrAddString();
    void SetUniqueLength();
};

struct HCONV__
{
    int32_t unused;
};

struct IPersistStream : IPersist
{
    HRESULT __stdcall IsDirty();
    HRESULT __stdcall Load();
    HRESULT __stdcall Save();
    HRESULT __stdcall GetSizeMax();
    void IPersistStream();
};

struct IPersist : IUnknown
{
    HRESULT __stdcall GetClassID();
    void IPersist();
};

struct IPipeLong : IUnknown
{
    HRESULT __stdcall Pull();
    HRESULT __stdcall Push();
    void IPipeLong();
};

struct IPropertySetStorage : IUnknown
{
    HRESULT __stdcall Create();
    HRESULT __stdcall Open();
    HRESULT __stdcall Delete();
    HRESULT __stdcall Enum();
    void IPropertySetStorage();
};

struct CoreInputConnectedControllers
{
    static bool* m_callBack;
    static void* m_callBackUserData;
    static int32_t m_startupDelay;
    static int32_t m_settlingTime;
    static float m_lastUpdateTime;
    static bool m_valid1;
    static int32_t m_validCount1;
    static int32_t m_invalidCount1;
    static bool m_valid2;
    static int32_t m_validCount2;
    static int32_t m_invalidCount2;
    static int32_t m_controllerCount;
    static bool m_controllerRemovedMessageActive;

    // TODO vtable

    void SetCallBack();
    void SetStartupDelay();
    void SetSettlingTime();
    bool IsReady();
    bool IsController1Valid();
    bool IsController2Valid();
    int32_t GetControllerCount();
    bool IsControllerRemovedMessageActive();
    void CoreInputConnectedControllers();
    void YouCannotInstanceThisClass();
    void Update(bool i_isValid1, bool i_isValid2);
};

struct IAuthenticate : IUnknown
{
    HRESULT __stdcall Authenticate();
    void IAuthenticate();
};

struct CoreStringBuffer<16>
{
    char m_buffer[16];

    void CoreStringBuffer<16>();
    void Clear();
    char* operator const char *();
    char* GetString();
    uint32_t GetLength();
    uint32_t GetMaxLength();
    bool IsSame();
    bool IsSameIgnoreCase();
    void operator=();
    void Copy();
    void NCopy();
    void Cat();
    void ToUpper();
    void ToLower();
    float ToFloat();
    int32_t ToInt();
    int32_t FindChar();
    int32_t ReverseFindChar();
    int32_t VSPrint();
    int32_t SPrint();
    int32_t CatPrint();
};

struct tagMCI_ANIM_UPDATE_PARMS
{
    uint32_t dwCallback;
    tagRECT rc;
    HDC__* hDC;
};

struct CAL1_LevelExporter
{
    CAL1_API* m_CAL1API;
    char* m_ProjectPath;
    char* m_LevelPath;
    char* m_OutputPath;
    char* m_ExportName;
    uint32_t m_PlatformMask;
    uint32_t m_LanguageMask;
    uint32_t m_AudioFormat;
    uint32_t m_PlatformIndex;
    char m_LevelName[256];
    CAL1_AudioItemDatabase* m_aid;

    // TODO vtable

    void CAL1_LevelExporter();
    void ~CAL1_LevelExporter();
    CAAudioError SetProjectPath();
    CAAudioError SetLevelPath();
    CAAudioError SetOutputPath();
    CAAudioError SetExportName();
    CAAudioError SetPlatformMask();
    CAAudioError SetLanguageMask();
    CAAudioError SetAudioFormat();
    char* GetProjectPath();
    char* GetScenePath();
    char* GetOutputPath();
    char* GetExportName();
    uint32_t GetPlatformMask();
    uint32_t GetLanguageMask();
    uint32_t GetAudioFormat();
    CAAudioError Export();
    CAAudioError BuildLevel();
    CAAudioError SaveLevel();
    CAAudioError ExtractObjects();
    CAAudioError ExtractEvents();
    CAAudioError ExtractSamples();
};

struct HWAVEOUT__
{
    int32_t unused;
};

struct CoreOnScreenKeyboardInterface : CoreCommonDialogStatus
{
    static CoreOnScreenKeyboardInterface* m_dummyInstance;
    static CoreOnScreenKeyboardInterface* m_defaultInstance;
    static CoreOnScreenKeyboardInterface* m_gameInstance;

    CoreOnScreenKeyboardInterface* CreateInstance(CoreMemory* i_memoryInterface);
    CoreOnScreenKeyboardInterface* GetDummyInstance();
    CoreOnScreenKeyboardInterface* GetDefaultInstance();
    void SetDefaultInstance();
    void DeleteInstance();
    bool Prepare();
    bool Start();
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    void CoreOnScreenKeyboardInterface();
};

struct CAL1_AudioItemDatabase : CAL0_List
{
    void CAL1_AudioItemDatabase();
    void ~CAL1_AudioItemDatabase();
    uint32_t GetUniqueID();
    uint32_t GetUniqueRuntimeID();
    CAAudioError AddDBItem(CAL1_AudioItem* item, uint32_t& position);
    CAAudioError DeleteAllDBObjects();
    CAAudioError DeleteDBItem(CAL1_AudioItem* item);
    CAAudioError GetItemByName();
    CAAudioError MakeIDs();
};

struct CoreHashElementTable
{
    uint32_t m_numItems;

    uint32_t GetNumItems();
    bool Find(CoreHash i_hash, uint32_t& o_foundData, CoreHashElement* i_elementBase);
    bool Update(CoreHash i_hash, uint32_t i_newData, CoreHashElement* i_elementBase);
    void RemoveAll(CoreHashElement* i_elementBase);
    bool FindIndex(CoreHash i_hash, uint32_t& o_index, CoreHashElement* i_elementBase);
};

struct _MIDL_SERVER_INFO_
{
    _MIDL_STUB_DESC* pStubDesc;
    int32_t** DispatchTable;
    uint32_t* ProcString;
    uint32_t* FmtStringOffset;
    void** ThunkTable;
    _RPC_SYNTAX_IDENTIFIER* pTransferSyntax;
    uint32_t nCount;
    _MIDL_SYNTAX_INFO* pSyntaxInfo;
};

struct CorePS2DmaModel
{
    CoreQWORD* lpqwDmaPtr;
    uint32_t usDataFormat;
    uint32_t usCodeFlags;
    uint32_t usCycleCount;
    uint32_t usNumQWORDS;
};

struct HPALETTE__
{
    int32_t unused;
};

struct CoreAudioSequencerEntry
{
    float m_Time;
    CoreHash m_AudioEvent;
    bool m_Start;
    bool m_Stop;
    bool m_Looping;
    float m_StartFreqFactor;
    float m_TargetFreqFactor;
    float m_TargetFreqDuration;
    uint32_t m_StartVol;
    uint32_t m_TargetVol;
    float m_TargetVolDuration;
    int32_t m_StartPan;
    int32_t m_TargetPan;
    float m_TargetPanDuration;

    void Reset();
    void CoreAudioSequencerEntry();
    void ~CoreAudioSequencerEntry();
};

struct CoreNodeChain
{
    CoreNodeRoot m_chainHead;
    CoreNodeRoot m_chainTail;

    void CoreNodeChain();
    void ~CoreNodeChain();
    CoreNodeRoot* GetFirst();
    void Construct();
    void Connect();
    void Disconnect();
    void DisconnectChain();
    uint32_t GetCount();
};

struct CoreArray<int>
{
};

struct CAL0_MemoryManager : CAL0_List
{
    uint32_t m_StartAddr;
    uint32_t m_EndAddr;
    uint32_t m_Alignment;

    void CAL0_MemoryManager();
    void ~CAL0_MemoryManager();
    uint32_t AllocateMemory(uint32_t bytes);
    CAAudioError DeallocateMemory(uint32_t pointer);
    CAAudioError ClearAllAllocatedMemory();
    CAAudioError GetUsedMemory(uint32_t* bytes);
    CAAudioError GetUnusedMemory(uint32_t* bytes);
    CAAudioError GetLargestFreeBlockSize(uint32_t* bytes);
    CAAudioError CopyDataToBlock(uint32_t blockAddr, void* dataPtr);
    CAAudioError CopyDataDirectly(uint32_t destAddr, uint32_t srcAddr, uint32_t length);
    void SetAlignment();
    uint32_t GetStartAddress();
    uint32_t GetEndAddress();
    uint32_t GetMemorySize();
    uint32_t Align(uint32_t value);
    CAAudioError MemCopy(void* dest, void* source, uint32_t length);
};

struct IPipeDouble : IUnknown
{
    HRESULT __stdcall Pull();
    HRESULT __stdcall Push();
    void IPipeDouble();
};

struct CoreFX
{
    enum EmitFlags
    {
        EF_HASOBJECT = (1 << 0),
        EF_HASBONE = (1 << 2),
        EF_HASEVENT = (1 << 4),
        EF_USEOBJECTORIENT = (1 << 5),
        EF_ACTIVE = (1 << 6),
    };

    enum EmitShapes
    {
        ES_BOX,
        ES_POINT,
        ES_LINE,
        ES_SPHERE,
    };

    enum PrimFlags
    {
        PF_ROTATION = (1 << 0),
        PF_SCALING = (1 << 1),
        PF_RELSCALE = (1 << 2),
        PF_VELSCALE = (1 << 3),
        PF_BILLBOARD = (1 << 4),
        PF_RELPOS = (1 << 5),
        PF_SCREENPOS = (1 << 6),
        PF_SCALETOSCREEN = (1 << 7),
        PF_ZBIAS = (1 << 8),
        PF_YSCALE = (1 << 9),
        PF_ASPECT_RATIO = (1 << 10),
        PF_NO_ZTEST = (1 << 11),
        PF_VELBLEND = (1 << 12),
        PF_PICKUP = (1 << 13),
        PF_NOSCALE = (1 << 14),
    };

    enum CommandFlags
    {
        FXCF_CMDHOLD = (1 << 0),
        FXCF_REMOVE = (1 << 1),
        FXCF_GOTITEMS = (1 << 2),
        FXCF_CALLBACK = (1 << 3),
        FXCF_INCALLBACK = (1 << 4),
        FXCF_RANDSEED = (1 << 5),
    };

    enum PrimTypes
    {
        PT_PARTICLE,
        PT_PARTICLE2D,
        PT_MODEL,
        PT_LINE,
        PT_BEZIER,
        PT_MAX,
    };

    enum Textures
    {
        FXT_NULL = 255,
        FXT_BEAM0 = 0,
        FXT_BEAM1 = 1,
        FXT_BEAM2 = 2,
        FXT_BEAM3 = 3,
        FXT_FXPAGE = 4,
        FXT_ALPHA = 5,
        FXT_SUNFLARE = 6,
        FXT_FLUFFCLOUD = 7,
        FXT_FXPAGE2 = 8,
        FXT_GODRAY = 9,
        FXT_VINES = 10,
        FXT_TARGET = 11,
        FXT_MAX_REGULAR = 12,
        FXT_FRMBUF = 12,
        FXT_MAX = 13,
    };

    enum Blend
    {
        FXB_ADD,
        FXB_SUB,
        FXB_XLU,
        FXB_MAX,
    };

    enum Contexts
    {
        FXCONTEXT_CAMERA,
        FXCONTEXT_PLAYER0_0,
        FXCONTEXT_PLAYER0_1,
        FXCONTEXT_PLAYER0_2,
        FXCONTEXT_PLAYER0_3,
        FXCONTEXT_MAX_CONTEXTS,
    };

    enum
    {
        CO_RGB0 = 0,
        CO_RGB1 = 1,
        CO_SCALE = 2,
        CO_MAX = 3,
        FCO_RGB0 = 1,
        FCO_RGB1 = 2,
    };

    enum AnimCmd
    {
        CMD_END,
        CMD_ENDLIST,
        CMD_ADDPOSX,
        CMD_ADDPOSY,
        CMD_ADDPOSZ,
        CMD_ADDPOSXYZ,
        CMD_SNAPFLOOR,
        CMD_SETROTX,
        CMD_SETROTY,
        CMD_SETROTZ,
        CMD_SETROTADDX,
        CMD_SETROTADDY,
        CMD_SETROTADDZ,
        CMD_SETROTADDADDX,
        CMD_SETROTADDADDY,
        CMD_SETROTADDADDZ,
        CMD_SETSCALE,
        CMD_SETSCALEADD,
        CMD_SETSCALEADDADD,
        CMD_SETRGB,
        CMD_BLENDRGB,
        CMD_BLENDALPHA,
        CMD_REPEATFRAME,
        CMD_RANGEFRAME,
        CMD_SETGRAVITY,
        CMD_SETANIMRATE,
        CMD_SETFLAGS,
        CMD_WRITEFLAGS,
        CMD_SCALE,
        CMD_SETVELSCALE,
        CMD_SPAWN,
        CMD_CLONE,
        CMD_SETVELX,
        CMD_SETVELY,
        CMD_SETVELZ,
        CMD_SETVELXYZ,
        CMD_SETDESTVELX,
        CMD_SETDESTVELY,
        CMD_SETDESTVELZ,
        CMD_SCALERGB,
        CMD_SETZBIAS,
        CMD_SETBLENDMODE,
        CMD_HINT,
        CMD_SETCALLBACK,
        CMD_ENDCALLBACK,
        CMD_LOOP,
        CMD_LOOPNEXT,
        CMD_SETSTARTWIDTH,
        CMD_SETENDWIDTH,
        CMD_SETMIDWIDTH,
        CMD_SETJITTER,
        CMD_SETRANDSEED,
        CMD_SETBEZIERVELS,
        CMD_WAIT,
        CMD_SETASPECT,
        CMD_FUNCTION,
        CMD_SETCONTEXT,
    };

    enum AnimCmdScope
    {
        SCP_PARTICLE = 2147483648,
        SCP_MODEL = 1073741824,
        SCP_LINE = 536870912,
        SCP_BEZIER = 268435456,
        SCP_COMMON = 4026531840,
    };

    enum AnimCmdFlags
    {
        ACF_BREAK = (1 << 16),
        ACF_OVERRIDE = (1 << 17),
        ACF_EXTRA1 = (1 << 18),
        ACF_EXTRA2 = (1 << 19),
        ACF_EXTRA3 = (1 << 20),
        ACF_CHILD = (1 << 21),
        ACF_HINT1 = (1 << 22),
        ACF_HINT2 = (1 << 23),
        ACF_HINT3 = (1 << 24),
        ACF_RANDOM = (1 << 18),
        ACF_RANDOMPOS = (1 << 19),
        ACF_RANDOMNEG = (1 << 20),
        ACF_RANDOMFROMANGLE = (1 << 19),
    };

    enum AnimCmdUse
    {
        FXCMD_END = 4026597376,
        FXCMD_ENDLIST = 4026597377,
        FXCMD_WAIT = 4026597429,
        FXCMD_ADDPOSX = 4026531842,
        FXCMD_ADDPOSY = 4026531843,
        FXCMD_ADDPOSZ = 4026531844,
        FXCMD_ADDPOSRANDFROMANGLE = 4027056133,
        FXCMD_ADDPOSXRAND = 4026793986,
        FXCMD_ADDPOSYRAND = 4026793987,
        FXCMD_ADDPOSZRAND = 4026793988,
        FXCMD_SNAPFLOOR = 4026531846,
        FXCMD_SETROTX = 4026531847,
        FXCMD_SETROTY = 4026531848,
        FXCMD_SETROTZ = 4026531849,
        FXCMD_SETROTADDX = 4026531850,
        FXCMD_SETROTADDY = 4026531851,
        FXCMD_SETROTADDZ = 4026531852,
        FXCMD_SETROTADDADDX = 4026531853,
        FXCMD_SETROTADDADDY = 4026531854,
        FXCMD_SETROTADDADDZ = 4026531855,
        FXCMD_SETSCALE = 4026531856,
        FXCMD_SETSCALEADD = 4026531857,
        FXCMD_SETSCALEADDADD = 4026531858,
        FXCMD_SETRGB = 4026531859,
        FXCMD_BLENDRGB = 4026531860,
        FXCMD_BLENDALPHA = 4026531861,
        FXCMD_REPEATFRAME = 2147549206,
        FXCMD_RANGEFRAME = 2147549207,
        FXCMD_RANGEFRAMETIME = 2147811351,
        FXCMD_SETGRAVITY = 4026531864,
        FXCMD_SETGRAVITYRAND = 4026794008,
        FXCMD_SETANIMRATE = 4026531865,
        FXCMD_SETFLAGS = 4026531866,
        FXCMD_WRITEFLAGS = 4026531867,
        FXCMD_SETSCALERAND = 4026794000,
        FXCMD_SCALE = 4026531868,
        FXCMD_SETVELSCALE = 4026531869,
        FXCMD_SETROTRANDX = 4026793991,
        FXCMD_SETROTRANDY = 4026793992,
        FXCMD_SETROTRANDZ = 4026793993,
        FXCMD_SETROTADDRANDX = 4026793994,
        FXCMD_SETROTADDRANDY = 4026793995,
        FXCMD_SETROTADDRANDZ = 4026793996,
        FXCMD_SETVELX = 4026531872,
        FXCMD_SETVELY = 4026531873,
        FXCMD_SETVELZ = 4026531874,
        FXCMD_SETVELXRAND = 4026794016,
        FXCMD_SETVELYRAND = 4026794017,
        FXCMD_SETVELZRAND = 4026794018,
        FXCMD_SETDESTVELX = 4026531876,
        FXCMD_SETDESTVELY = 4026531877,
        FXCMD_SETDESTVELZ = 4026531878,
        FXCMD_SETDESTVELXRAND = 4026794020,
        FXCMD_SETDESTVELYRAND = 4026794021,
        FXCMD_SETDESTVELZRAND = 4026794022,
        FXCMD_SETVELRANDFROMANGLE = 4027056163,
        FXCMD_SPAWN = 4026531870,
        FXCMD_CLONE = 4026531871,
        FXCMD_SCALERAND = 4026794012,
        FXCMD_SCALERGB = 4026531879,
        FXCMD_SETZBIAS = 2147483688,
        FXCMD_SETBLENDMODE = 2147483689,
        FXCMD_SETCALLBACK = 4026531883,
        FXCMD_ENDCALLBACK = 4026531884,
        FXCMD_LOOP = 4026531885,
        FXCMD_LOOPNEXT = 4026531886,
        FXCMD_SETASPECT = 4026531894,
        FXCMD_FUNCTION = 4026531895,
        FXCMD_SETCONTEXT = 4026531896,
        FXCMD_SETSTARTWIDTH = 268435503,
        FXCMD_SETENDWIDTH = 268435504,
        FXCMD_SETMIDWIDTH = 268435505,
        FXCMD_SETJITTER = 268435506,
        FXCMD_SETRANDSEED = 268435507,
        FXCMD_SETBEZIERVELS = 268435508,
        FXCMD_HINT_PRIMTYPE = 4030726186,
    };

    enum AnimCmdUseOverride
    {
        FXCMD_SETRGB_OVERRIDE = 131091,
        FXCMD_BLENDRGB_OVERRIDE,
    };

    enum FXCreator
    {
        FXC_GAME,
        FXC_TOOL,
    };

    struct CoreFXInfoNode
    {
        CoreHash m_Name;
        float m_PosX;
        float m_PosY;
        float m_PosZ;
        float m_Width;
        float m_Height;
        float m_Depth;

        void CoreFXInfoNode();
        void ~CoreFXInfoNode();
    };

    struct RawMaterial
    {
        uint32_t m_nTextures;
        CoreFX::Textures m_TextureID[2];
        float m_uv[4];
        float m_tw;
        float m_th;
        float m_w;
        float m_h;
        float m_ox;
        float m_oy;
        uint32_t m_Orient;
    };

    struct TextureRef
    {
        CoreHash m_TextureSetHash;
        CoreHash m_TextureHash;
        CoreTextureSet* m_pTextureSet;
        CoreTextureInfo* m_pTextureInfo;
        bool m_bIsValid;

        void TextureRef();
        void ~TextureRef();
    };

    struct CoreFXChainAnchor
    {
        CoreFXControl* m_pPrimitivePool;
        uint32_t m_nPrimitives;
        CoreFXControl m_UsedHead;
        CoreFXControl m_UsedTail;
        CoreFXControl m_FreeHead;
        CoreFXControl m_FreeTail;

        void CoreFXChainAnchor();
    };

    struct CoreFXPrimitiveChain
    {
        CoreFX::CoreFXChainAnchor m_Anchor;
        uint32_t* m_pUpdate;
        void* m_pRender;
        bool m_bPostRender;

        void CoreFXPrimitiveChain();
    };

    struct EMem
    {
        void* m_pEmitterMem;
        void* m_pEmitterItemMem;
        void* m_pVariableList;
        CoreFXEmitterItem* m_pFreeEmitterItem;
        CoreFXMappedVariable* m_pFreeMappedVar;
        uint32_t m_nFreeEmitterItems;
        uint32_t m_nFreeMappedVars;
        uint32_t m_EmitterIndex;
        CoreFXEmitter** m_EmitterArray;
        CoreFX::CoreFXChainAnchor m_FXEmitters;
        uint32_t m_EmitterMarkers[8];

        void EMem();
    };

    struct ERender
    {
        CoreFX::ERender::__unnamed m_pItems[128];
        uint32_t m_nItems;
    };

    CoreFX::__unnamed m_EmitterOverrides;
    static float FXScaleTerm;
    CoreRGBA m_fogColour;
    bool m_fogParticles;
    bool m_fogOn;
    CoreFX::CoreFXPrimitiveChain m_Primitives[5];
    CoreFX::EMem m_UsedMem;
    CoreFX::ERender m_EmitterRenderList;
    CoreFXMaterial* m_pMaterials;
    uint32_t m_nMaterials;
    uint32_t m_FontIndex;
    uint32_t m_nFonts;
    CoreFX::__unnamed m_FontInfo[4];
    CoreMatrix m_ViewMatrix;
    static CoreFX::RawMaterial TEST_RAW_MATERIALS[0];
    static CoreFX::TextureRef m_TextureRefs[0];
    CoreVector m_vecContext[5];
    CoreVector m_VecGlobal[2];
    static bool m_HideFX;
    static CoreFX* m_pInstance;
    int32_t m_currentPlayer;
    void* m_pRenderCallback;
    CoreHashTable m_GlobalEvents;
    CoreHashTable m_LoadFonts;
    bool m_bAssetsRegistered;
    bool m_bDisable;
    static int32_t m_RandSeed;
    CoreFX::__unnamed m_Assets;
    uint32_t m_OverRideIdxRead;
    uint32_t m_OverRideIdxWrite;
    uint32_t m_OverRideData[32];
    static uint32_t s_PrimSize[0];
    static char* s_PrimNames[0];
    static char s_DbgWrk[0];
    static uint32_t s_NumActive[0];
    CoreMemory* m_pMemPool;
    CoreFXLibrary* m_pFXLibrary;
    CoreFX::FXCreator m_Creator;
    float m_UVScale;

    // TODO vtable

    void CoreFX();
    void ~CoreFX();
    void Construct(CoreMemory* pMemPool, CoreFX::FXCreator iCreator);
    void Destruct();
    void Reset();
    void Update(CoreLevelUpdateStruct* pUpdate);
    void LoadMaterials();
    void AddFont(CoreHash assetName);
    void UpdateAnimCmd(CoreFXControl* pCtrl);
    void UpdateAnimCmdHold();
    bool UpdateAnimCmdRepeat();
    void RegisterAssets(CoreTextureSet* pTexSet);
    void CreateEmitters(CoreMemory* pMemPool);
    CoreFXEmitter* GetFreeEmitter();
    CoreFXEmitter* CreateAnimEmitter(char* pName, CoreVector Pos, uint32_t Shape, int32_t* pAnim);
    void SetEmitterMinMax(CoreFXEmitter* pEmit, CoreVector Min, CoreVector Max);
    void AddEmitterItem();
    void AddEmitterItems(CoreFXEmitter* pEmit, CoreFXEmitterItem* pSrcItem);
    void EmitterMapScriptVariable(CoreFXEmitter* pEmit, char* pMapName, CoreHash hVarName);
    void EmitterAttachToObject(CoreFXEmitter* pEmit, CoreHash objectName, CoreHash boneName);
    void EmitterAddGlobalEvent();
    void eFnFXEmitter(CoreCommand* pCmd, CoreScripted* pOwner);
    void UpdateEmitterItemIterated();
    void UpdateEmitterItemControlled(CoreFXEmitter* pEmit, CoreVector Pos, CoreVector Min, CoreVector Max, CoreFXEmitterItem* pItem);
    void PostControlOverride();
    void GetControlOverride();
    void RenderEmitterItemList();
    void ResetEmitterRenderList();
    void AddEmitterItemToRenderList();
    CoreFXEmitter* FindEmitter(CoreHash hID);
    CoreFX::CoreFXInfoNode* FindInfoNode(CoreHash hName);
    void SetEmitterFlags();
    CoreVector GetEmitterItemPos();
    void RegisterGlobalEvents();
    void SignalGlobalEvent(CoreHash hEventName, CoreHash hEventSource);
    bool TestGlobalEvent();
    bool IsClassCollide();
    void AddGlobalEvent();
    void ResetEmittersToMarker(uint32_t nMarker);
    void SetEmitterMarker();
    void SetFXLibrary();
    CoreFXLibrary* GetFXLibrary();
    void ResetEmitters();
    void LoadFonts();
    void LoadFont(CoreHash assetName);
    int32_t fxRandA();
    int32_t fxRandB();
    int32_t fxRandC();
    float fxRandfA();
    float fxRandfB(float max);
    float fxRandfC(float max);
    int32_t SetRandSeed(int32_t newVal);
    CoreTextureInfo* GetTextureInfo();
    CoreTextureSet* GetTextureSet();
    CoreHash GetTextureHash(CoreFX::Textures texID);
    void Render(CoreGraphicsDevice* pGraphics, bool bPostRender);
    CoreFXPrimitive* CreateAnimPrimitive();
    CoreFXPrimitive* CreateAnimChildPrimitive(CoreParticleFXPrimitive* pParent, int32_t* pAnim, CoreVector vel, bool bClone);
    CoreFXPrimitive* CreateBezierPrimitive(CoreVector* pPosArray, CoreVector* pVelArray, uint32_t Life, uint32_t nSegs, int32_t* pAnim);
    CoreFXPrimitive* CreateBezierChildPrimitive(CoreBezierFXPrimitive* pParent, int32_t* pAnim);
    CoreFXPrimitive* CreateLinePrimitive(CoreVector Pos, int32_t* pAnim, CoreVector Vel);
    CoreFXPrimitive* InitialiseAnimPrimitive(CoreParticleFXPrimitive* pPrim, CoreVector Pos, int32_t* pAnim, CoreVector vel, bool bPostRender);
    void HideFX();
    void SetGlobal();
    void GetGlobal();
    char** GetDebugInfo();
    void DoDebug();
    void ShowEmitterList();
    CoreFX* CreateInstance(CoreMemory* pMemPool, CoreFX::FXCreator iCreator);
    CoreFX* CreateEditorInstance();
    void SetContext(CoreFX::Contexts iContext, CoreVector iPos);
    void RenderSingleParticle(CoreParticleFXPrimitive* pPrim, CoreGraphicsDevice* pDevice);
    void ConnectChain();
    void UpdateEmitterChain();
    void UpdateEmitter(CoreFXEmitter* pEmit);
    CoreFXPrimitive* GetPrimitive(uint32_t idxPrim);
    void RemovePrimitive();
    void ResetOverRideRead();
    bool GetOverRide();
    uint32_t GetPrimitiveSize();
    uint32_t GetMaxPrimitives(uint32_t idxPrim);
    uint32_t UpdateParticles(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain);
    uint32_t UpdateBeziers(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain);
    uint32_t UpdateLines(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain);
    void RenderParticles(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain, CoreGraphicsDevice* pDevice);
    void Render2DParticles(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain, CoreGraphicsDevice* pDevice);
    void RenderBeziers(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain, CoreGraphicsDevice* pDevice);
    void RenderLines(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain, CoreGraphicsDevice* pDevice);
    void renderParticlesBatch();
    void AllocateMaterials(uint32_t nMaterials);
    CoreFX* GetInstance();
    int32_t* GetRegisteredFX();
    CoreFXMaterial* GetMaterial(uint32_t nMat);
    uint32_t GetFontBase();
    CoreHash GetFontID();
    void AddRenderCallback();
    void DrawParticleLine();
    void Test();
};

struct CoreRecentFileNameList
{
    int32_t m_timeOutMilliseconds64;
    int32_t m_entryCount;
    CoreRecentFileName* m_fileNames;
    CoreMemory* m_memoryInterface;

    void CoreRecentFileNameList();
    bool Init(CoreMemory* i_memoryInterface, uint32_t i_entryCount, float i_timeOutSeconds);
    void Free();
    void Reset();
    CoreRecentFileName* Add(char* i_fileName, char* i_userString, bool& o_alreadyAdded);
    CoreRecentFileName* Find(char* i_fileName);
    CoreRecentFileName* GetEntry();
    CoreRecentFileName* FindUnusedOrLeastRecent();
};

struct CAL0_MemoryManagerSoundRAMPC : CAL0_MemoryManagerSoundRAM
{
    void CAL0_MemoryManagerSoundRAMPC();
    void ~CAL0_MemoryManagerSoundRAMPC();
};

struct CoreBGLightPattern
{
    uint32_t m_numFrames;

    CoreBGLightPatternFrame* GetFrame();
};

struct CoreCreatureJumpDef
{
    float m_maxGap;
    float m_maxClimb;
};

struct CoreHashGroup64
{
    int32_t m_iNumItems;
    int32_t m_iTableSize;
    CoreArray<CoreHashElement64> m_oElements;

    void CoreHashGroup64();
    void ~CoreHashGroup64();
    void Construct();
    void Destruct();
    int32_t GetNumItems();
    bool bAdd();
    bool bRemove();
    bool Find();
    bool bUpdate();
    void RemoveAll();
    int32_t GetMaxNumItems();
    CoreHashElement64* GetElementPtr();
    bool FindIndex();
    void Zero();
};

struct _DIDATAFORMAT
{
    uint32_t dwSize;
    uint32_t dwObjSize;
    uint32_t dwFlags;
    uint32_t dwDataSize;
    uint32_t dwNumObjs;
    _DIOBJECTDATAFORMAT* rgodf;
};

struct DIEFFECT
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwDuration;
    uint32_t dwSamplePeriod;
    uint32_t dwGain;
    uint32_t dwTriggerButton;
    uint32_t dwTriggerRepeatInterval;
    uint32_t cAxes;
    uint32_t* rgdwAxes;
    int32_t* rglDirection;
    DIENVELOPE* lpEnvelope;
    uint32_t cbTypeSpecificParams;
    void* lpvTypeSpecificParams;
    uint32_t dwStartDelay;
};

struct DIFILEEFFECT
{
    uint32_t dwSize;
    _GUID GuidEffect;
    DIEFFECT* lpDiEffect;
    char szFriendlyName[260];
};

struct _DICOLORSET
{
    uint32_t dwSize;
    uint32_t cTextFore;
    uint32_t cTextHighlight;
    uint32_t cCalloutLine;
    uint32_t cCalloutHighlight;
    uint32_t cBorder;
    uint32_t cControlFill;
    uint32_t cHighlightFill;
    uint32_t cAreaFill;
};

struct DIDEVICEOBJECTINSTANCEA
{
    uint32_t dwSize;
    _GUID guidType;
    uint32_t dwOfs;
    uint32_t dwType;
    uint32_t dwFlags;
    char tszName[260];
    uint32_t dwFFMaxForce;
    uint32_t dwFFForceResolution;
    uint32_t wCollectionNumber;
    uint32_t wDesignatorIndex;
    uint32_t wUsagePage;
    uint32_t wUsage;
    uint32_t dwDimension;
    uint32_t wExponent;
    uint32_t wReportId;
};

struct DIPROPHEADER
{
    uint32_t dwSize;
    uint32_t dwHeaderSize;
    uint32_t dwObj;
    uint32_t dwHow;
};

struct DIDEVICEOBJECTDATA
{
    uint32_t dwOfs;
    uint32_t dwData;
    uint32_t dwTimeStamp;
    uint32_t dwSequence;
    uint32_t uAppData;
};

struct DIDEVICEINSTANCEA
{
    uint32_t dwSize;
    _GUID guidInstance;
    _GUID guidProduct;
    uint32_t dwDevType;
    char tszInstanceName[260];
    char tszProductName[260];
    _GUID guidFFDriver;
    uint32_t wUsagePage;
    uint32_t wUsage;
};

struct DIEFFECTINFOA
{
    uint32_t dwSize;
    _GUID guid;
    uint32_t dwEffType;
    uint32_t dwStaticParams;
    uint32_t dwDynamicParams;
    char tszName[260];
};

struct _DIMOUSESTATE2
{
    int32_t lX;
    int32_t lY;
    int32_t lZ;
    uint32_t rgbButtons[8];
};

struct CoreInputDeviceDirectInput : CoreInputDevice
{
    IDirectInput8A* m_directInput;
    IDirectInputDevice8A* m_mouseDevice;
    IDirectInputDevice8A* m_keyboardDevice;
    IDirectInputDevice8A* m_padDevice[4];
    DIDEVCAPS m_padCaps;
    uint32_t m_numPads;
    uint32_t m_currentPad;
    HWND* m_hwnd;
    HINSTANCE__* m_hinstance;
    IDirectInputEffect* m_effects[4];
    _GUID m_effectGUID[4];
    DICONSTANTFORCE m_constantForce[4];
    DIEFFECT m_effectParam[4];
    uint32_t m_effectAxes[4][2];
    int32_t m_effectDirection[4][2];
    int32_t m_effectsFound;
    bool m_rumbleEnable;
    uint32_t m_keyBuffer[256];
    CoreStringBuffer<256> m_appName;

    void CoreInputDeviceDirectInput();
    void ~CoreInputDeviceDirectInput();
    void Construct(CoreMemory* i_memory, char* i_appName);
    void Destruct(CoreMemory* i_memory);
    void Init(bool i_enableMouse);
    void Reset();
    void Update(CoreKeyboardData* io_keyboardData, CorePadData* io_padData, CoreMouseData* io_mouseData, float i_frameTime);
    void DisableRumble();
    void EnableRumble();
    void Rumble(int32_t, CoreRumbleEnvelope*);
    void StopRumble(int32_t);
    void InitKeyboard();
    void UpdateKeyboard(CoreKeyboardData* io_keyboardData);
    void ReMapKeyboard(CoreInputState* i_states);
    void InitPads();
    void UpdatePads(CorePadData* io_padData);
    void InitMouse();
    void UpdateMouse(CoreMouseData* io_mouseData);
    float ScaleAxis();
    int32_t __stdcall EnumJoysticksCallback(DIDEVICEINSTANCEA* i_instance, void* io_context);
    int32_t __stdcall EnumAxesCallback(DIDEVICEOBJECTINSTANCEA* i_objectInstance, void* io_context);
    int32_t __stdcall EnumEffects(DIEFFECTINFOA* i_effectInfo, void* io_context);
};

struct _DICONFIGUREDEVICESPARAMSA
{
    uint32_t dwSize;
    uint32_t dwcUsers;
    char* lptszUserNames;
    uint32_t dwcFormats;
    _DIACTIONFORMATA* lprgFormats;
    HWND* hwnd;
    _DICOLORSET dics;
    IUnknown* lpUnkDDSTarget;
};

struct IDirectInput8A : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall CreateDevice();
    HRESULT __stdcall EnumDevices();
    HRESULT __stdcall GetDeviceStatus();
    HRESULT __stdcall RunControlPanel();
    HRESULT __stdcall Initialize();
    HRESULT __stdcall FindDevice();
    HRESULT __stdcall EnumDevicesBySemantics();
    HRESULT __stdcall ConfigureDevices();
    void IDirectInput8A();
};

struct IDirectInputDevice8A : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall GetCapabilities();
    HRESULT __stdcall EnumObjects();
    HRESULT __stdcall GetProperty();
    HRESULT __stdcall SetProperty();
    HRESULT __stdcall Acquire();
    HRESULT __stdcall Unacquire();
    HRESULT __stdcall GetDeviceState();
    HRESULT __stdcall GetDeviceData();
    HRESULT __stdcall SetDataFormat();
    HRESULT __stdcall SetEventNotification();
    HRESULT __stdcall SetCooperativeLevel();
    HRESULT __stdcall GetObjectInfo();
    HRESULT __stdcall GetDeviceInfo();
    HRESULT __stdcall RunControlPanel();
    HRESULT __stdcall Initialize();
    HRESULT __stdcall CreateEffect();
    HRESULT __stdcall EnumEffects();
    HRESULT __stdcall GetEffectInfo();
    HRESULT __stdcall GetForceFeedbackState();
    HRESULT __stdcall SendForceFeedbackCommand();
    HRESULT __stdcall EnumCreatedEffectObjects();
    HRESULT __stdcall Escape();
    HRESULT __stdcall Poll();
    HRESULT __stdcall SendDeviceData();
    HRESULT __stdcall EnumEffectsInFile();
    HRESULT __stdcall WriteEffectToFile();
    HRESULT __stdcall BuildActionMap();
    HRESULT __stdcall SetActionMap();
    HRESULT __stdcall GetImageInfo();
    void IDirectInputDevice8A();
};

struct DIDEVCAPS
{
    uint32_t dwSize;
    uint32_t dwFlags;
    uint32_t dwDevType;
    uint32_t dwAxes;
    uint32_t dwButtons;
    uint32_t dwPOVs;
    uint32_t dwFFSamplePeriod;
    uint32_t dwFFMinTimeResolution;
    uint32_t dwFirmwareRevision;
    uint32_t dwHardwareRevision;
    uint32_t dwFFDriverVersion;
};

struct IDirectInputEffect : IUnknown
{
    HRESULT __stdcall QueryInterface();
    uint32_t __stdcall AddRef();
    uint32_t __stdcall Release();
    HRESULT __stdcall Initialize();
    HRESULT __stdcall GetEffectGuid();
    HRESULT __stdcall GetParameters();
    HRESULT __stdcall SetParameters();
    HRESULT __stdcall Start();
    HRESULT __stdcall Stop();
    HRESULT __stdcall GetEffectStatus();
    HRESULT __stdcall Download();
    HRESULT __stdcall Unload();
    HRESULT __stdcall Escape();
    void IDirectInputEffect();
};

struct DICONSTANTFORCE
{
    int32_t lMagnitude;
};

struct DIENVELOPE
{
    uint32_t dwSize;
    uint32_t dwAttackLevel;
    uint32_t dwAttackTime;
    uint32_t dwFadeLevel;
    uint32_t dwFadeTime;
};

struct DIPROPRANGE
{
    DIPROPHEADER diph;
    int32_t lMin;
    int32_t lMax;
};

struct DIEFFESCAPE
{
    uint32_t dwSize;
    uint32_t dwCommand;
    void* lpvInBuffer;
    uint32_t cbInBuffer;
    void* lpvOutBuffer;
    uint32_t cbOutBuffer;
};

struct _DIACTIONA
{
    uint32_t uAppData;
    uint32_t dwSemantic;
    uint32_t dwFlags;
    char* lptszActionName;
    uint32_t uResIdString;
    _GUID guidInstance;
    uint32_t dwObjID;
    uint32_t dwHow;
};

struct _DIACTIONFORMATA
{
    uint32_t dwSize;
    uint32_t dwActionSize;
    uint32_t dwDataSize;
    uint32_t dwNumActions;
    _DIACTIONA* rgoAction;
    _GUID guidActionMap;
    uint32_t dwGenre;
    uint32_t dwBufferSize;
    int32_t lAxisMin;
    int32_t lAxisMax;
    HINSTANCE__* hInstString;
    _FILETIME ftTimeStamp;
    uint32_t dwCRC;
    char tszActionMap[260];
};

struct _DIDEVICEIMAGEINFOA
{
    char tszImagePath[260];
    uint32_t dwFlags;
    uint32_t dwViewID;
    tagRECT rcOverlay;
    uint32_t dwObjID;
    uint32_t dwcValidPts;
    tagPOINT rgptCalloutLine[5];
    tagRECT rcCalloutRect;
    uint32_t dwTextAlign;
};

struct _DIDEVICEIMAGEINFOHEADERA
{
    uint32_t dwSize;
    uint32_t dwSizeImageInfo;
    uint32_t dwcViews;
    uint32_t dwcButtons;
    uint32_t dwcAxes;
    uint32_t dwcPOVs;
    uint32_t dwBufferSize;
    uint32_t dwBufferUsed;
    _DIDEVICEIMAGEINFOA* lprgImageInfoArray;
};

struct DIJOYSTATE2
{
    int32_t lX;
    int32_t lY;
    int32_t lZ;
    int32_t lRx;
    int32_t lRy;
    int32_t lRz;
    int32_t rglSlider[2];
    uint32_t rgdwPOV[4];
    uint32_t rgbButtons[128];
    int32_t lVX;
    int32_t lVY;
    int32_t lVZ;
    int32_t lVRx;
    int32_t lVRy;
    int32_t lVRz;
    int32_t rglVSlider[2];
    int32_t lAX;
    int32_t lAY;
    int32_t lAZ;
    int32_t lARx;
    int32_t lARy;
    int32_t lARz;
    int32_t rglASlider[2];
    int32_t lFX;
    int32_t lFY;
    int32_t lFZ;
    int32_t lFRx;
    int32_t lFRy;
    int32_t lFRz;
    int32_t rglFSlider[2];
};

struct _DIOBJECTDATAFORMAT
{
    _GUID* pguid;
    uint32_t dwOfs;
    uint32_t dwType;
    uint32_t dwFlags;
};

struct CoreInputDeviceNull : CoreInputDevice
{
    void CoreInputDeviceNull();
    void ~CoreInputDeviceNull();
    void Construct(CoreMemory*, char*);
    void Destruct(CoreMemory*);
    void Init(bool);
    void Reset();
    void Update(CoreKeyboardData* io_keyboardData, CorePadData* io_padsData, CoreMouseData* io_mouseData, float);
};

struct InputName
{
    char* name;
    char normal;
    char shifted;
};

enum CoreParamType
{
    PAR_NONE,
    PAR_LOCAL_VAR,
    PAR_GLOBAL_VAR,
    PAR_INT_CONSTANT,
    PAR_FLOAT_CONSTANT,
    PAR_STRING_CONSTANT,
};

enum CoreOpType
{
    OP_EQ = 0,
    OP_LT = 1,
    OP_GT = 2,
    OP_ALWAYS = 3,
    OP_BASIC_TYPE = 3,
    OP_NOT = 4,
};

struct CoreFXDefault : CoreFX
{
    static uint32_t m_MaxPrims[5];

    void CoreFXDefault();
    void ~CoreFXDefault();
    void Render(CoreGraphicsDevice* pGraphics, bool bPostRender);
    void RenderSingleParticle(CoreParticleFXPrimitive* pPrim, CoreGraphicsDevice* pDevice);
    uint32_t GetMaxPrimitives(uint32_t idxPrim);
};

struct CoreStringBuffer<2048>
{
    char m_buffer[2048];

    void CoreStringBuffer<2048>();
    void Clear();
    char* operator const char *();
    char* GetString();
    uint32_t GetLength();
    uint32_t GetMaxLength();
    bool IsSame();
    bool IsSameIgnoreCase();
    void operator=();
    void Copy();
    void NCopy();
    void Cat();
    void ToUpper();
    void ToLower();
    float ToFloat();
    int32_t ToInt();
    int32_t FindChar();
    int32_t ReverseFindChar();
    int32_t VSPrint();
    int32_t SPrint();
    int32_t CatPrint();
};

struct FormatFlags
{
    int32_t width;
    int32_t precision;
    bool longSize;
    bool leftAlign;
    bool signPrefix;
    bool zeroPrefix;

    void FormatFlags();
    void Reset();
};

enum CoreStr::VSPrint::__l5::FCMode
{
    FCM_NORMAL,
    FCM_FLAG,
    FCM_WIDTH,
    FCM_PRECISION,
    FCM_SIZE,
    FCM_FORMAT,
};

struct CoreStringBuffer<100>
{
    char m_buffer[100];

    void CoreStringBuffer<100>();
    void Clear();
    char* operator const char *();
    char* GetString();
    uint32_t GetLength();
    uint32_t GetMaxLength();
    bool IsSame();
    bool IsSameIgnoreCase();
    void operator=();
    void Copy();
    void NCopy();
    void Cat();
    void ToUpper();
    void ToLower();
    float ToFloat();
    int32_t ToInt();
    int32_t FindChar();
    int32_t ReverseFindChar();
    int32_t VSPrint();
    int32_t SPrint();
    int32_t CatPrint();
};

struct LoggerOutput
{
    struct Logger
    {
        char* name;
        uint32_t colour;
        uint32_t background;
        int32_t enabled;
        int32_t registered;
    };

    int32_t m_logStartup;
    HWND* m_logWnd;
    CoreMap<LoggerOutput::Logger> m_logList;
    uint32_t m_logCount;
    LoggerOutput::Logger m_loggers[64];
    CoreMemoryStack m_stack;
    uint32_t m_stackMemory[1636];

    LoggerOutput& GetOutput();
    bool CreateLogger(char* i_name, uint32_t i_colour, uint32_t i_background);
    void EnableLogger();
    void DisableLogger();
    void VLogMessage(CoreHash i_id, char* i_format, char* i_list);
    void LogMessage(CoreHash i_id, char* i_format);
    void LoggerOutput();
    void ~LoggerOutput();
    bool ActivateLogWindow();
    void Register(char* i_name, uint32_t i_colour, uint32_t i_background);
    void __stdcall OutputDebugStringDetour();
};

struct CoreMap<LoggerOutput::Logger> : CoreMapBase
{
    void CoreMap<LoggerOutput::Logger>();
    bool AddKey(CoreHash i_key, LoggerOutput::Logger* i_data);
    LoggerOutput::Logger* FindKey(CoreHash i_key);
    bool UpdateKey();
    void ~CoreMap<LoggerOutput::Logger>();
    void __dflt_ctor_closure();
};

struct CoreLangNameEnum
{
    char* name;
    CoreInit::CoreLanguageEnum language;
};

struct CoreOnScreenKeyboardDummyInterface : CoreOnScreenKeyboardInterface
{
    void CoreOnScreenKeyboardDummyInterface();
    void DeleteInstance();
    bool Prepare(char* i_title, char* i_string, int32_t i_maximumLength, int32_t i_inputLines, int32_t i_inputIndex);
    bool Start(void* i_finishedCallBack, void* i_callBackUserData);
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    char* GetCommonDialogTitle();
};

struct CoreMessageBoxDummyInterface : CoreMessageBoxInterface
{
    void CoreMessageBoxDummyInterface();
    void DeleteInstance();
    bool Start(void* i_finishedCallBack, void* i_callBackUserData, char* i_fmtString);
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    bool IsReady();
    char* GetCommonDialogTitle();
};

struct CoreSaveGameDummyInterface : CoreSaveGameInterface
{
    void CoreSaveGameDummyInterface();
    void DeleteInstance();
    bool Start(void* i_finishedCallBack, void* i_callBackUserData);
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    bool IsReady();
    char* GetCommonDialogTitle();
};

struct CoreNetworkDialogDummyInterface : CoreNetworkDialogInterface
{
    void CoreNetworkDialogDummyInterface();
    void DeleteInstance();
    bool Prepare(int32_t i_userValue);
    bool Start(void* i_finishedCallBack, void* i_callBackUserData);
    bool Update();
    bool ExtraUpdate();
    bool Stop();
    char* GetCommonDialogTitle();
};

struct CoreNamedPipeDummyInterface : CoreNamedPipeInterface
{
    void DeleteInstance();
    bool Create(char* i_pipeName);
    bool Open(char* i_pipeName);
    bool IsReady();
    bool IsDataReady(int32_t i_size);
    void Close();
    bool Read(void* o_buffer, int32_t i_bufferSize, int32_t& o_sizeRead);
    bool Send(void* i_data, int32_t i_dataSize);
    void CoreNamedPipeDummyInterface();
    void ~CoreNamedPipeDummyInterface();
};

struct CoreNamedPipePC : CoreNamedPipeInterface
{
    struct Async
    {
        enum ASYNC_STAGE_TAG
        {
            ASYNC_IDLE,
            ASYNC_STARTED,
            ASYNC_FINISHED_OK,
            ASYNC_FAILED,
        };

        enum ASYNC_STAGE
        {
            ASYNC_IDLE,
            ASYNC_STARTED,
            ASYNC_FINISHED_OK,
            ASYNC_FAILED,
        };

        CoreNamedPipePC::Async::ASYNC_STAGE_TAG m_stage;
        uint32_t m_size;
        uint32_t m_timeStarted;
        char* m_title;
        char* m_name;
        void* m_handle;
        _OVERLAPPED* m_overlapped;

        void Async();
        void Idle();
        void Start(char* i_title, char* i_name, void* i_handle, _OVERLAPPED* io_overlapped);
        void FinishedOK();
        void Failed();
        void Update();
        void WaitUntilFinished();
        bool IsIdle();
        bool HasStarted();
        bool HasFinishedOK();
        bool HasFailed();
        bool HasStartedOrFinishedOK();
        uint32_t GetSize();
        void Cancel();
    };

    CoreStringBuffer<256> m_pipeName;
    void* m_pipeHandle;
    _OVERLAPPED m_overlapped;
    bool m_createPipe;
    bool m_openPipe;
    CoreNamedPipePC::Async m_asyncConnect;
    CoreNamedPipePC::Async m_asyncRead;
    CoreNamedPipePC::Async m_asyncSend;

    void CoreNamedPipePC();
    void ~CoreNamedPipePC();
    void DeleteInstance();
    bool Create(char* i_pipeName);
    bool Open(char* i_pipeName);
    bool IsReady();
    bool IsDataReady(int32_t i_size);
    void Close();
    bool Read(void* o_buffer, int32_t i_bufferSize, int32_t& o_sizeRead);
    bool Send(void* i_data, int32_t i_dataSize);
    char* GetPipeName();
    bool StartConnect();
    void Disconnect();
    bool IsConnected();
    int32_t GetSizeAvailable();
    bool StartRead(void* o_buffer, int32_t i_bufferSize);
    bool WaitUntilReadFinished(int32_t& o_sizeRead);
    bool HasReadingFinished();
    bool StartSend(void* i_data, int32_t i_dataSize);
    bool WaitUntilSendFinished();
    bool HasSendFinished();
    void Cancel();
};

struct CoreHashDebugStringEntry
{
    uint32_t m_hash;
    uint32_t m_stringOffset;

    void Set();
};

struct CoreHashDebugString
{
    static char m_defaultBuffer[0];
    static char* m_buffer;
    static uint32_t m_bufferSize;
    static uint32_t m_sizeFree;
    static CoreHashDebugStringEntry* m_hashes;
    static uint32_t m_hashCount;
    static uint32_t m_hashHalfWay;
    static uint32_t m_hashNextPowerOf2;
    static uint32_t m_hashStringOffset;

    bool SetNewBuffer(char* io_buffer, uint32_t i_bufferSize);
    bool AddString(uint32_t i_hash, char* i_hashString);
    char* GetHashString();
    CoreHashDebugStringEntry* FindHash(uint32_t i_hash, uint32_t& o_hashIndex, bool& o_matchFound);
    void SetBuffer();
};

union _Dconst
{
    uint32_t _Word[8];
    float _Float;
    float _Double;
    float _Long_double;
};

enum std::float_denorm_style
{
    denorm_indeterminate = 255,
    denorm_absent = 0,
    denorm_present = 1,
};

enum std::float_round_style
{
    round_indeterminate = 255,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3,
};

struct std::_Num_base
{
    static std::float_denorm_style has_denorm;
    static bool has_denorm_loss;
    static bool has_infinity;
    static bool has_quiet_NaN;
    static bool has_signaling_NaN;
    static bool is_bounded;
    static bool is_exact;
    static bool is_iec559;
    static bool is_integer;
    static bool is_modulo;
    static bool is_signed;
    static bool is_specialized;
    static bool tinyness_before;
    static bool traps;
    static std::float_round_style round_style;
    static int32_t digits;
    static int32_t digits10;
    static int32_t max_exponent;
    static int32_t max_exponent10;
    static int32_t min_exponent;
    static int32_t min_exponent10;
    static int32_t radix;
};

struct std::numeric_limits<unsigned int> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    uint32_t min();
    uint32_t max();
    uint32_t epsilon();
    uint32_t round_error();
    uint32_t denorm_min();
    uint32_t infinity();
    uint32_t quiet_NaN();
    uint32_t signaling_NaN();
};

struct std::numeric_limits<float> : std::_Num_float_base
{
    static int32_t digits;
    static int32_t digits10;
    static int32_t max_exponent;
    static int32_t max_exponent10;
    static int32_t min_exponent;
    static int32_t min_exponent10;

    float min();
    float max();
    float epsilon();
    float round_error();
    float denorm_min();
    float infinity();
    float quiet_NaN();
    float signaling_NaN();
};

struct std::numeric_limits<__int64> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    int32_t min();
    int32_t max();
    int32_t epsilon();
    int32_t round_error();
    int32_t denorm_min();
    int32_t infinity();
    int32_t quiet_NaN();
    int32_t signaling_NaN();
};

struct std::numeric_limits<bool> : std::_Num_int_base
{
    static bool is_modulo;
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    bool min();
    bool max();
    bool epsilon();
    bool round_error();
    bool denorm_min();
    bool infinity();
    bool quiet_NaN();
    bool signaling_NaN();
};

struct std::numeric_limits<unsigned short> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    uint32_t min();
    uint32_t max();
    uint32_t epsilon();
    uint32_t round_error();
    uint32_t denorm_min();
    uint32_t infinity();
    uint32_t quiet_NaN();
    uint32_t signaling_NaN();
};

struct std::numeric_limits<unsigned long> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    uint32_t min();
    uint32_t max();
    uint32_t epsilon();
    uint32_t round_error();
    uint32_t denorm_min();
    uint32_t infinity();
    uint32_t quiet_NaN();
    uint32_t signaling_NaN();
};

struct std::_Num_int_base : std::_Num_base
{
    static bool is_bounded;
    static bool is_exact;
    static bool is_integer;
    static bool is_modulo;
    static bool is_specialized;
    static int32_t radix;
};

struct std::numeric_limits<int> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    int32_t min();
    int32_t max();
    int32_t epsilon();
    int32_t round_error();
    int32_t denorm_min();
    int32_t infinity();
    int32_t quiet_NaN();
    int32_t signaling_NaN();
};

struct std::numeric_limits<char> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    char min();
    char max();
    char epsilon();
    char round_error();
    char denorm_min();
    char infinity();
    char quiet_NaN();
    char signaling_NaN();
};

struct std::numeric_limits<double> : std::_Num_float_base
{
    static int32_t digits;
    static int32_t digits10;
    static int32_t max_exponent;
    static int32_t max_exponent10;
    static int32_t min_exponent;
    static int32_t min_exponent10;

    float min();
    float max();
    float epsilon();
    float round_error();
    float denorm_min();
    float infinity();
    float quiet_NaN();
    float signaling_NaN();
};

struct std::numeric_limits<long double> : std::_Num_float_base
{
    static int32_t digits;
    static int32_t digits10;
    static int32_t max_exponent;
    static int32_t max_exponent10;
    static int32_t min_exponent;
    static int32_t min_exponent10;

    float min();
    float max();
    float epsilon();
    float round_error();
    float denorm_min();
    float infinity();
    float quiet_NaN();
    float signaling_NaN();
};

struct std::_Num_float_base : std::_Num_base
{
    static std::float_denorm_style has_denorm;
    static bool has_denorm_loss;
    static bool has_infinity;
    static bool has_quiet_NaN;
    static bool has_signaling_NaN;
    static bool is_bounded;
    static bool is_exact;
    static bool is_iec559;
    static bool is_integer;
    static bool is_modulo;
    static bool is_signed;
    static bool is_specialized;
    static bool tinyness_before;
    static bool traps;
    static std::float_round_style round_style;
    static int32_t radix;
};

struct std::numeric_limits<long> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    int32_t min();
    int32_t max();
    int32_t epsilon();
    int32_t round_error();
    int32_t denorm_min();
    int32_t infinity();
    int32_t quiet_NaN();
    int32_t signaling_NaN();
};

struct std::numeric_limits<unsigned char> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    uint32_t min();
    uint32_t max();
    uint32_t epsilon();
    uint32_t round_error();
    uint32_t denorm_min();
    uint32_t infinity();
    uint32_t quiet_NaN();
    uint32_t signaling_NaN();
};

struct std::numeric_limits<unsigned __int64> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    uint32_t min();
    uint32_t max();
    uint32_t epsilon();
    uint32_t round_error();
    uint32_t denorm_min();
    uint32_t infinity();
    uint32_t quiet_NaN();
    uint32_t signaling_NaN();
};

struct std::numeric_limits<short> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    int32_t min();
    int32_t max();
    int32_t epsilon();
    int32_t round_error();
    int32_t denorm_min();
    int32_t infinity();
    int32_t quiet_NaN();
    int32_t signaling_NaN();
};

struct std::numeric_limits<signed char> : std::_Num_int_base
{
    static bool is_signed;
    static int32_t digits;
    static int32_t digits10;

    int32_t min();
    int32_t max();
    int32_t epsilon();
    int32_t round_error();
    int32_t denorm_min();
    int32_t infinity();
    int32_t quiet_NaN();
    int32_t signaling_NaN();
};

struct CoreMemoryStackMarker
{
    CoreHash m_name;
    uint32_t* m_freeMem;

    void CoreMemoryStackMarker();
    void ~CoreMemoryStackMarker();
    CoreHash GetName();
    uint32_t* GetFreeMem();
    void SetName(CoreHash i_name);
    void SetFreeMem();
    void Zero();
};

struct JustConstruct
{
    void JustConstruct();
};

struct CoreRegistryEmulateUsingFile : CoreRegistryInterface
{
    void DeleteInstance();
    bool ReadNumber(char* i_valueName, uint32_t* o_number);
    int32_t ReadString(char* i_valueName, char* o_stringBuffer, int32_t i_stringBufferSize);
    int32_t ReadBinary(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
    bool WriteNumber(char* i_valueName, uint32_t i_number);
    bool WriteString(char* i_valueName, char* i_string);
    bool WriteBinary(char* i_valueName, void* i_buffer, int32_t i_bufferSize);
    bool DeleteValue(char* i_valueName);
    void CoreRegistryEmulateUsingFile();
    void ~CoreRegistryEmulateUsingFile();
};

struct CoreRegistryDummyInterface : CoreRegistryInterface
{
    void DeleteInstance();
    bool ReadNumber(char* i_valueName, uint32_t* o_number);
    int32_t ReadString(char* i_valueName, char* o_stringBuffer, int32_t i_stringBufferSize);
    int32_t ReadBinary(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
    bool WriteNumber(char* i_valueName, uint32_t i_number);
    bool WriteString(char* i_valueName, char* i_string);
    bool WriteBinary(char* i_valueName, void* i_buffer, int32_t i_bufferSize);
    bool DeleteValue(char* i_valueName);
    void CoreRegistryDummyInterface();
    void ~CoreRegistryDummyInterface();
};

struct CoreAssetManagerMemoryBlock
{
    enum CoreAssetManagerMemoryBlockBitFlagsEnum
    {
        CORE_MEMORY_LOCKED_BIT,
        CORE_ASSET_ACTIVE_BIT,
        CORE_ASSET_LOADING_BIT,
    };

    CoreU128* m_lpqwMemory;
    CoreAssetManagerMemoryBlock* m_lpoPrevBlock;
    CoreAssetManagerMemoryBlock* m_lpoNextBlock;
    int32_t m_iSizeInBytes;
    CoreHash m_assetID;
    CoreHash m_assetType;
    int32_t m_numAllocations;
    uint32_t m_ucFlags;
    bool m_upToDate;
    bool m_dirty;
    uint32_t m_numPadBytes;
    CoreDateTime m_fileTime;
    CoreDateTime m_newerFileTime;
    CoreStringBuffer<64> m_name;

    void CoreAssetManagerMemoryBlock();
    void ~CoreAssetManagerMemoryBlock();
    void Reset();
    CoreU128* lpqwGetMemoryPtr();
    CoreAssetManagerMemoryBlock* GetPrevBlockPtr();
    CoreAssetManagerMemoryBlock* GetNextBlockPtr();
    int32_t GetSizeInBytes();
    int32_t GetAssetSizeInBytes();
    CoreHash GetID();
    CoreHash GetType();
    int32_t GetNumAllocations();
    void ReSetNumAllocations();
    void SetNumAllocations();
    bool IsFreeSpace();
    bool IsInUse();
    bool IsMemoryLocked();
    bool IsAssetActive();
    bool IsAssetLoading();
    void SetMemoryLocked();
    void SetAssetActive();
    void SetAssetLoading();
    bool AllocAsset();
    bool DeAllocAsset();
    void SetFree();
    void SetUnUsed();
    void* Allocate(CoreHash assetID, CoreHash assetType, uint32_t uiSizeInBytes, CoreDateTime& i_fileTime, char* i_name);
    void AddFreeSpaceBefore();
    void AddFreeSpaceAfter();
    bool IsValid();
    void Create(void* lpMemoryPtr, int32_t iSizeInBytes, CoreAssetManagerMemoryBlock* lpoPrevBlock, CoreAssetManagerMemoryBlock* lpoNextBlock);
    void SetMemoryPtr();
    void SetPrevBlockPtr();
    void SetNextBlockPtr();
    void SetSizeInBytes();
    void SetID(CoreHash assetID);
    void SetType();
    CoreDateTime& GetFileTime();
    CoreDateTime& GetNewerFileTime();
    void SetFileTime();
    void SetUpToDate();
    void SetOutOfDate();
    bool IsUpToDate();
    bool IsOutOfDate();
    void SetDirty();
    bool IsDirty();
    char* GetName();
    void SetName();
};

struct CoreAssetManagerData
{
    CoreU128Aligned* m_lpqwArenaBase;
    int32_t m_iArenaSizeInBytes;
    CoreAssetManagerMemoryBlock* m_lpoMemBlocks;
    CoreAssetManagerMemoryBlock* m_lpoMemBlock0;
    uint32_t m_iNumMemBlocks;
    CoreHashTable m_assetTypes;
    CoreAssetManagerAssetTypeInfo* m_assetTypeInfo;
    uint32_t m_maxNumAssetTypes;
    CoreHashTable m_oClients;
    CoreAssetManagerClientInfo* m_lpoClientInfo;
    int32_t m_iMaxNumClients;
    int32_t m_iUpdateClientIndex;
    CoreHash m_defragAssetID;
    CoreHash m_defragAssetType;
    uint32_t m_defragNumMoved;
    bool m_defragUpdateAllClients;
    bool m_purgedSomething;
    void* m_lpLoadFileMemoryPtr;
    void* m_lpPostLoadFileMemoryPtr;
    bool* m_bGlobalCanICreateAssetFunction;
    bool* m_bGlobalCreateAssetFunction;
    bool* m_bGlobalDeleteAssetFunction;
    bool* m_bGlobalMoveAssetFunction;
    void* m_lpGlobalCreateDeleteUserData;
    CoreAssetManager::CoreAssetManagerState m_eState;
    char m_cLoadingFileName[256];
    CoreHash m_loadingAssetID;
    CoreHash m_loadingAssetType;
    bool m_bAsyncLoadFile;
    bool m_bPostLoadFileDone;
    bool* m_lpAsyncLoadFileCallback;
    void* m_lpAsyncLoadFileUserData1;
    void* m_lpAsyncLoadFileUserData2;
    void* m_lpAsyncLoadFileUserData3;
    CoreHash m_createAssetID;
    CoreHash m_createAssetType;
    bool m_startPanicMode;
    bool m_inPanicMode;
    bool m_exitPanicMode;
    int32_t m_panicModeFreeSizeNeeded;
    int32_t m_iDbgFreeMem;
    int32_t m_iDbgActiveMem;
    int32_t m_iDbgInActiveMem;
    int32_t m_iDbgTotalMem;
    int32_t m_iDbgLockedMem;
    int32_t m_iDbgMaxSingleFreeInactiveMem;
    int32_t m_iDbgNumFreeBlocks;
    int32_t m_iDbgNumActiveBlocks;
    int32_t m_iDbgNumInActiveBlocks;
    int32_t m_iDbgNumMemoryLockedBlocks;
    int32_t m_iDbgNumUnUsedBlocks;
    int32_t m_iDbgTotalBlocks;
    int32_t m_iDbgMaxSingleFreeInactive;
    int32_t m_iDbgLargestFreeMem[128];
    int32_t m_iDbgLargestUsedMem[128];
    int32_t m_iDbgLargestUsedMemBlock[128];
    int32_t m_iDbgSelectedUsedListDisplay;
    int32_t m_iDbgSelectedMemBlockListDisplay;
    int32_t m_iDbgSelectedFreeListDisplay;
    bool m_iDbgMemBlockDisplay;
    int32_t* m_iDbgNumPerType;
    int32_t* m_iDbgMemoryPerType;

    void CoreAssetManagerData();
    void ~CoreAssetManagerData();
};

struct CoreAssetManagerClientInfo
{
    void* lpClientCallbackFunc;
    void* lpUsrData1;
    void* lpUsrData2;
    uint32_t uiID;
};

struct CoreAudio_SpeechQueue
{
    CoreAudio_SpeechQueueEntry m_Entries[8];
    uint32_t m_TimeOutCounter;
    uint32_t m_TimeOutLimit;

    void CoreAudio_SpeechQueue();
    bool AddEntry();
    void Process();
    void Clear();
    void ~CoreAudio_SpeechQueue();
};

enum SpeechQueueStatus
{
    SpeechQueueStatus_EmptySlot,
    SpeechQueueStatus_Pending,
    SpeechQueueStatus_Starting,
    SpeechQueueStatus_Started,
    SpeechQueueStatus_Ending,
};

struct CoreAudioEventInitData
{
    char* lpcName;
    uint32_t uiCoreAudioID;
};

struct CoreAudio_SpeechQueueEntry
{
    CoreHash m_SpeechHash;
    int32_t m_Percentage;
    uint32_t m_Group;
    uint32_t m_Param;
    SpeechQueueStatus m_Status;

    void Clear();
    void CoreAudio_SpeechQueueEntry();
    void ~CoreAudio_SpeechQueueEntry();
};

struct ca_floatfp
{
    float value;

    void ca_floatfp();
    ca_floatfp& operator=();
    ca_floatfp operator+();
    ca_floatfp operator-();
    ca_floatfp operator*();
    ca_floatfp operator/();
    ca_floatfp& operator+=();
    ca_floatfp& operator-=();
    ca_floatfp& operator*=();
    ca_floatfp& operator/=();
    bool operator==();
    bool operator>=();
    bool operator>();
    bool operator<=();
    bool operator<(ca_floatfp& aValue);
    bool operator!=();
    ca_floatfp GetFixed();
    float GetFloat();
    ca_floatfp& SetFixed();
    uint32_t GetUInt16();
    uint32_t GetUInt32();
    float GetValue();
};

struct CoreConsoleData
{
    CoreConsoleCommand lpoConsoleCommands[64];
    int32_t iNumCommands;
    char lplpcLines[18][80];
    int32_t iTopLine;
    int32_t iWriteLine;
    int32_t iLinePosition;
    char lpcCommand[80];
    bool bActive;
    float fBlink;
    float fConsoleSlider;
    CoreRGBA oColour;

    void CoreConsoleData();
};

struct CoreGameControllerInternalData
{
    CoreVariableStore* lpoVariableStore;
    CoreScriptStore* lpoScriptStore;
    CoreGameRender* lpoGraphics;
    CoreGraphicsDevice* lpoGraphicsDevice;
    CoreInput* lpoInput;
    CoreWorld* lpoWorld;
    CoreConsole* lpoConsole;
    CoreNet* lpoNet;
    CoreWorldUpdateStruct* lpoWorldUpdateStruct;
    CoreGameTextUnit* lpoGameText;
    CoreDebugInput debugInput;
    int32_t iTime;
    int32_t startPanicModeTime;
    float fGameTime;
    float fTimeOut;
    bool bNoRender;
    float fFrameRate;
    int32_t iGameCycle;
    float fFrameRateStartTime;
    uint32_t uiDebugFlags;
    uint32_t screenShotFrameNumber;
    uint32_t movieFrameNumber;
    bool takeScreenShot;
    bool takeVideoMemoryShot;
    bool makeScreenMovie;
    bool makeVideoMemoryMovie;
    CoreHash globalLinkedScriptsAssetID;
    CoreHash globalTextAssetID;
    CoreScripted* lpoCurrentDebugObject;
    int32_t iCurrentDebugMenuOffset;
    int32_t iDebugObjectVarIndex;
    bool bDebugHex;
    bool updateScript;
    bool renderWorld;

    void CoreGameControllerInternalData();
    void ~CoreGameControllerInternalData();
};

struct CoreGlowStore
{
};

struct CoreMarkupStore
{
};

struct CoreDecalStore
{
};

struct CoreLevelInternalData
{
    CoreMemory* lpoLevelMemory;
    CoreMemory* lpoGlobalMemory;
    CoreObjectController* lpoObjectController;
    CoreObjectUpdateStruct* lpoObjectUpdateStruct;
    int32_t debugSelectedCurve;
    uint32_t uiDrawFlags;
    int32_t debugObject;
    bool debugObjectDisplay;
    CoreScriptStore* lpoScriptStore;
    CoreGlowStore* lpoGlowStore;
    CoreMarkupStore* lpoMarkupStore;
    CoreDecalStore* lpoDecalStore;
    CoreFX* m_pCoreFX;
    bool bLevelNetworkComunicating;
    CoreNet::CoreNetAsynchronous m_CoreNetAsynchronousStatus;
    CoreCutScenePlayer* lpoCutScenePlayer;
    uint32_t uiPlayCutScene;
    uint32_t uiCutScenePlaying;
    uint32_t uiCutSceneParent;
    uint32_t uiCutScenePlayingFlag;
    int32_t iStartDelayTimer;
    CoreMenuSystem* menuSystem;
    uint32_t loadMenu;
    uint32_t currentMenu;
    CoreLevelAreaData areaDatas[32];
    uint32_t numAreasLoaded;
    int32_t mainAreaIndex;
    CoreLevelCompiled* mainLevelCompiled;
    char lpcLevelName[32];
    char lpcAreaName[32];
    char lpcLevelCluster[16];
    CoreHash oLevelHash;
    uint32_t uiScriptStoreAssetID;
    uint32_t levelClusterAssetID;
    uint32_t fxTexSetAssetID;
    int32_t rTreeIndexBuffer[256];
    CoreVector detectionBBoxMin;
    CoreVector detectionBBoxMax;
    uint32_t numEngineDynamicLights;
    CoreLevelDynamicLight* engineDynamicLights;
    CoreLevelLight* engineDynamicLevelLights;
    bool scriptRunning;
    bool ready;
    bool levelIsLoaded;
    float m_pauseTimer;

    void CoreLevelInternalData();
    void ~CoreLevelInternalData();
};

struct CoreLevelAreaData
{
    CoreLevelCompiled* levelCompiled;
    uint32_t levelCompiledAssetID;
    uint32_t levelName;
    uint32_t areaName;
};

struct CoreLevel::RenderDebug::__l129::CoreAttractor
{
    enum
    {
        VERSION = 1,
    };

    float x1;
    float y1;
    float z1;
    float x2;
    float y2;
    float z2;
    float planeX;
    float planeY;
    float planeZ;
    float planeDistance;
    uint32_t typeHash;
    float width;
};

enum CoreCutSceneAnimCommand
{
    ONCE = 0,
    UNTIL_TIME = 1,
    REPEAT_N = 2,
    FOREVER = 3,
    BASIC_COMMAND = 3,
    BLEND_FROM_PREVIOUS = 4,
    Y_ROTATE = 8,
};

struct CoreCutSceneObjectData
{
    CoreCutSceneAnimCommand eCommand;
    float fTimer;
    float fAnimLength;
    int32_t iCounter;
    float fEndTime;
    bool bReady;
    bool bFollowKeys;
    float fYRotate;
};

struct CoreCutScenePlayerData
{
    bool playing;
    CoreHash currentCutScene;
    float timer;
    float endTime;
    bool timerOn;
    CoreHash currentCamera;
    CoreHash savedCameraName;
    bool fadeDownEnd;
    bool fadeUpAfter;
    bool doneFadeDown;
    float fadeInTime;
    float fadeOutTime;
    float audioFadeInFactor;
    float audioFadeOutFactor;
    CoreHash cutSceneParent;
    CoreHash audio;
    float FPSScaler;
    bool skip;
    bool canSkip;
    bool forceNoSkip;
    CoreStringBuffer<256> overrideModelName;
    CoreStringBuffer<256> overrideTextureName;
    int32_t titleCutsceneState;
    bool bRequestedPlay;
    float speedFactor;

    void CoreCutScenePlayerData();
    void ~CoreCutScenePlayerData();
};

struct CoreAnimatingObjectData
{
    CoreMemory* m_lpoMemory;
    CoreU128* m_lpqwMemoryBuffer;
    int32_t m_iMemoryBufferSize;
    CoreBlender* m_blender;
    bool m_animating;
    CoreEulerAngle m_animDir;
    float* m_lpfOverrideBlendShapeTargetValue;
    bool* m_lpbOverrideBlendShapeTarget;
    int32_t m_iNumBlendShapeTargets;
    CoreHash m_LastAnimHash;
    float m_LastAnimTime;
    CoreBoneOverrideInfo m_oBoneOverrideInfos[50];

    void CoreAnimatingObjectData();
    void ~CoreAnimatingObjectData();
};

struct CoreBlender
{
    enum BlenderType
    {
        BLENDER_BASIC,
        BLENDER_SIMPLE,
        BLENDER_COMPLEX,
    };

    enum BlenderFlags
    {
        BF_NO_COMMAND_EVENTS,
        BF_NO_TIMEDBLEND_EVENTS,
        BF_NO_ANIM_EVENTS,
        BF_NO_BLENDTREE_EVENTS,
    };

    static CoreMemoryStack m_blendCache;
    static CoreMemoryStack m_boneCache;
    static bool m_boneSet0[64];
    static int32_t m_instanceCounter;
    static uint32_t m_blenderFlags;
    static bool m_focusBlendsActive;
    static float m_focusBlendStartTime;
    static float m_focusBlendEndTime;

    // TODO vtable

    void ~CoreBlender();
    int32_t GetBlenderType();
    bool IsBlenderSequenced();
    void Construct(CoreMemory* i_memory);
    void Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
    void ResetAnimations();
    void ClearAnimList();
    CoreFileSystem::CoreFileLoadReturn AttachAnimationSetFile();
    bool AttachAnimationSet();
    bool AttachAnimationSequencer();
    void HandleAssetManagerClientCallback();
    CoreAnimationSet* GetAnimationSet();
    CoreVector GetPositionChange();
    CoreEulerAngle GetOrientationChange();
    void GetAnimateVelocity();
    void Animate();
    bool AddAnim();
    bool SetGoalState();
    bool AddImmediateBlend();
    void UpdateJointsState();
    void RenderAnimList();
    CoreHash GetPrimaryAnimID();
    CoreHash GetPrimaryAnimNameHash();
    float GetPrimaryAnimTime();
    float GetPrimaryAnimEndTime();
    float GetPrimaryAnimPlaybackSpeed();
    CoreHash GetSlotAnimID();
    CoreHash GetSlotAnimNameHash();
    float GetSlotAnimTime();
    float GetSlotAnimEndTime();
    float GetSlotPlaybackSpeed();
    CoreHash GetAnimStateContext();
    float GetAnimStateEndTime();
    bool GetAnimStateLooping();
    bool IsSlotAnimBlending();
    bool IsSlotAnimMirrored();
    bool IsSlotPlaying();
    float GetSlotWeight();
    void SetSlotWeight();
    void SetSlotPlaybackSpeed();
    CoreAnimSpec* GetPrimaryAnimSpec();
    CoreAnimSpec* GetAnimSpecByHash();
    bool CanAddAnim();
    bool GetTimer();
    int32_t GetNumAnimDataSets();
    CoreHash GetAnimDataSetHash();
    void ClearOffsetBlends();
    bool SetAnimFlag();
    void ClearAnimFlag();
    bool IsAnimFlagSet();
    void ClearAllAnimFlags();
    bool GetUpdateAnimDir();
    void SetUpdateAnimDir();
    void MakeNetworkPacket();
    void UpdateFromNetworkPacket();
    void GetBlenderStats();
    void BlendJointStates(CoreJointState* io_outputState, CoreJointState** io_inputState, float* i_weight, int32_t i_boneCount, CoreModelSkeleton* i_skeleton);
    uint32_t GetBlenderFlags();
    bool IsFocusActive();
    float GetFocusStartTime();
    float GetFocusEndTime();
    void SetBlenderFlags();
    void SetFocusActive();
    void SetFocusStartTime();
    void SetFocusEndTime();
    void CoreBlender();
};

struct CoreAnimSlot
{
    CoreHash m_oName;
    float m_fStartTime;
    float m_fEndTime;
    float m_fDefaultEndTime;
    float m_fBlendTime;
    void* m_lpBlendCallBackFunc;
    void* m_lpBlendCallBackUsrData;
    bool m_bCallBackActive[4];
    float m_fCallBackTime[4];
    void* m_lpCallBackFunc[4];
    void* m_lpCallBackUsrData[4];
    bool m_bLooping;
    bool m_bActive;
    bool m_blendLooping;
    bool m_mirror;

    void CoreAnimSlot();
    void ~CoreAnimSlot();
    void Reset();
    CoreHash GetName();
    float GetStartTime();
    float GetEndTime();
    float GetDefaultEndTime();
    float GetBlendTime();
    void* GetBlendCallBackFunc();
    void* GetBlendCallBackUsrData();
    void GetBlendCallBackData();
    int32_t GetFirstCallBackData(float& fTime, void*& oCallBackFunc, void*& lpUsrData);
    void GetCallBackData();
    float GetCallBackTime();
    void* GetCallBackFunc();
    void* GetCallBackUsrData();
    bool GetLooping();
    bool GetBlendLooping();
    bool IsActive();
    bool IsMirror();
    void SetName(CoreHash oName);
    void SetStartTime();
    void SetEndTime();
    void SetDefaultEndTime();
    void SetBlendTime();
    void SetBlendCallBackFunc();
    void SetBlendCallBackUsrData();
    void SetCallBackData();
    void AddCallBackData();
    void SetCallBackFunc();
    void SetCallBackUsrData();
    void SetCallBackTime();
    void DisableCallBack();
    void SetLooping();
    void SetBlendLooping();
    void SetActive();
    void SetInActive();
    void SetMirror();
    void SetDefaults();
    void RestoreDefaultEndTime();
};

struct CoreAnimList
{
    enum eAnimListPlace
    {
        TOP_OF_LIST = 0,
        BOTTOM_OF_LIST = 254,
        END_OF_LIST = 253,
        NEXT = 1,
        CURRENT = 0,
        UNDEFINED = -999,
    };

    CoreAnimSlot m_oSlots[4];

    void CoreAnimList();
    void ~CoreAnimList();
    void Reset();
    void PopList();
    void SetAnim(int32_t iListIndex, CoreAnimSlot* lpAnimSlot, bool bLastInList);
    void SetStartTime();
    void SetLooping();
    void SetCallBackData();
    void AddCallBackData();
    void SetCallBackTime();
    void SetCallBackFunc();
    void SetCallBackUsrData();
    void SetBlendTime(int32_t iListIndex, float fDeltaTimeInSeconds);
    void SetBlendCallBackFunc();
    void SetBlendCallBackUsrData();
    void SetEndTime();
    void RestoreDefaultEndTime();
    CoreHash GetAnim(int32_t iListIndex);
    float GetStartTime();
    bool GetLooping();
    bool GetBlendLooping(int32_t iListIndex);
    bool IsMirror(int32_t iListIndex);
    void GetCallBackData();
    float GetCallBackTime();
    void* GetCallBackFunc();
    void* GetCallBackUsrData();
    float GetBlendTime();
    void* GetBlendCallBackFunc();
    void* GetBlendCallBackUsrData();
    float GetEndTime();
    float GetDefaultEndTime();
    CoreAnimSlot* GetSlotPtr(int32_t iListIndex);
    bool IsActive(int32_t iListIndex);
    int32_t FindEndOfList();
};

struct CoreBlenderBasic : CoreBlender
{
    uint32_t m_animationSetFile;
    uint32_t m_animationSetAssetHash;
    CoreAnimationSet* m_animationSet;
    float m_currentTime;
    float m_currentTimeScale;
    float m_lastTime;
    float m_blendTime;
    float m_endTime;
    bool m_blending;
    bool m_playAnim;
    CoreAnimList m_animList;
    CoreHash m_previousAnim;
    bool m_previousAnimLooping;
    bool m_previousAnimMirror;
    float m_secondAnimCurrentTime;
    float m_secondAnimEndTime;
    float m_secondAnimAlpha;
    float m_secondAnimTimeScale;
    CoreHash m_secondAnim;
    bool m_playSecondAnim;
    bool m_secondAnimMirror;
    CoreHash m_blendingAnim;
    bool m_blendingAnimLooping;
    bool m_blendingAnimMirror;
    float m_blendingScale;
    float m_blendingAlpha;
    float m_blendingAnimCurrentTime;
    float m_blendingAnimEndTime;
    float m_blendingDeltaTime;

    int32_t GetBlenderType();
    bool IsBlenderSequenced();
    void Construct(CoreMemory* i_memory);
    void Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
    void ResetAnimations();
    void ClearAnimList();
    CoreFileSystem::CoreFileLoadReturn AttachAnimationSetFile(uint32_t i_clientID, CoreObjectUpdateStruct* i_updateStruct, char* i_animationSetName);
    bool AttachAnimationSet(CoreAnimationSet* i_animSet, uint32_t i_animationSetFile, uint32_t i_animationSetAssetHash);
    bool AttachAnimationSequencer(CoreAnimSequencer* i_animSeq, uint32_t i_animationSetFile, uint32_t i_animSequencerAssetHash);
    void HandleAssetManagerClientCallback(CoreAssetManager* i_assetManager, CoreWorld* i_world, CoreHash& i_assetID, CoreHash& i_assetType);
    CoreAnimationSet* GetAnimationSet(CoreHash& i_animName);
    CoreVector GetPositionChange(CoreAnimatingObject* i_ao, float i_startTime, float i_endTime);
    CoreEulerAngle GetOrientationChange(CoreAnimatingObject* i_ao, float i_startTime, float i_endTime);
    void GetAnimateVelocity(CoreVector* o_velocityPos, CoreEulerAngle* o_velocityRot, CoreVector* o_offsetPos, CoreEulerAngle* o_offsetRot);
    void Animate(CoreAnimatingObject* i_ao, CoreObjectUpdateStruct* i_updateStruct, float i_deltaTimeInSeconds);
    bool AddAnim(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
    bool SetGoalState(CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
    bool AddImmediateBlend(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
    void UpdateJointsState(CoreAnimatingObject* i_ao, CoreHashArray* i_jointIndexTable, CoreJointState* io_jointStates);
    void RenderAnimList(CoreGraphicsDevice* i_graphicsDevice, CoreVector& io_screenPos1, CoreVector& io_screenPos2);
    CoreHash GetPrimaryAnimID();
    CoreHash GetPrimaryAnimNameHash();
    float GetPrimaryAnimTime();
    float GetPrimaryAnimEndTime();
    float GetPrimaryAnimPlaybackSpeed();
    CoreHash GetSlotAnimID(CoreHash& i_slotID);
    CoreHash GetSlotAnimNameHash(CoreHash& i_slotID);
    float GetSlotAnimTime(CoreHash& i_slotID);
    float GetSlotAnimEndTime(CoreHash& i_slotID);
    float GetSlotPlaybackSpeed(CoreHash& i_slotID);
    CoreHash GetAnimStateContext(CoreHash i_animState);
    float GetAnimStateEndTime(CoreHash i_animState);
    bool GetAnimStateLooping(CoreHash i_animState);
    bool IsSlotAnimBlending(CoreHash& i_slotID);
    bool IsSlotAnimMirrored(CoreHash& i_slotID);
    bool IsSlotPlaying(CoreHash& i_slotID);
    float GetSlotWeight(CoreHash& i_slotID);
    void SetSlotWeight(CoreHash& i_slotID, float i_weight, float i_time, bool i_killOnZeroWeight);
    void SetSlotPlaybackSpeed(CoreHash& i_slotID, float i_playbackSpeed);
    CoreAnimSpec* GetPrimaryAnimSpec();
    CoreAnimSpec* GetAnimSpecByHash(CoreHash& i_animID);
    bool CanAddAnim(CoreHash& i_slotID, CoreHash& i_animID);
    bool GetTimer(CoreHash i_timerName, float& o_time);
    int32_t GetNumAnimDataSets();
    CoreHash GetAnimDataSetHash(int32_t i_index);
    void ClearOffsetBlends();
    bool SetAnimFlag(CoreHash& i_flagHash);
    void ClearAnimFlag(CoreHash& i_flagHash);
    bool IsAnimFlagSet(CoreHash& i_flagHash);
    void ClearAllAnimFlags();
    bool GetUpdateAnimDir();
    void SetUpdateAnimDir(bool i_value);
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    void GetBlenderStats(char* o_blenderStats);
    void HandleCallBack(CoreObjectUpdateStruct* i_updateStruct, float i_lastTime, float i_presentTime);
    void SetBlendTime();
    float GetBlendTime();
    CoreHash GetAnim(int32_t i_listIndex);
    bool GetBlendLooping();
    bool IsMirror();
    CoreAnimList::eAnimListPlace GetListIndexFromSlotHash(CoreHash& i_slotID);
    void SetBlendingData(float i_time);
    void UpdateTimesForNewAnim();
    void UpdateBlendTime();
    void UpdateBlendingFlag(float i_scaledDeltaTimeInSeconds, float i_deltaTimeInSeconds);
    void CoreBlenderBasic();
    void ~CoreBlenderBasic();
};

struct CoreSpecInfo
{
    int32_t m_setNumber;
    int32_t m_specNumber;
    CoreAnimSequencer* m_animSeq;
    CoreAnimationSet* m_animSet;
    CoreAnimSpec* m_animSpec;
    CoreHash m_state;
    float m_time;
    float m_blendTime;
    float m_playbackSpeed;
    uint32_t m_flags;
    uint32_t m_ease;

    void CoreSpecInfo();
    void ~CoreSpecInfo();
};

struct CoreAnimDataInfo
{
    CoreAnimationSet* m_animSet;
    CoreHash m_nameHash;
    float m_endTime;
    float m_playbackSpeed;
    bool m_isLooping;
    bool m_isMirror;

    void CoreAnimDataInfo();
    void ~CoreAnimDataInfo();
};

struct CoreAnimDataSetElement
{
    uint32_t m_animationSetFile;
    uint32_t m_animSetAssetHash;
    uint32_t m_animSeqAssetHash;
    CoreAnimationSet* m_animationSet;
    CoreAnimSequencer* m_animationSequencer;
};

struct CoreBlenderTimer
{
    bool m_active;
    uint32_t m_name;
    float m_time;
    uint32_t m_flags;
};

struct CoreBlenderGoalData
{
    float m_subPlaybackSpeed;
    float m_offsetPos[3];
    float m_offsetRot[3];
};

struct CoreBlenderTimers
{
    CoreBlenderTimer m_data[2];

    // TODO vtable

    void Construct();
    void Destruct();
    void Reset();
    bool AddNewTimer(CoreHash& i_name, uint32_t i_flags, float i_initialDelta);
    void UpdateTimers(float i_deltaTime, bool i_onBlend);
    bool GetTimer(CoreHash& i_name, float& o_time);
    bool StopTimer(CoreHash& i_name, float i_finalDelta);
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    void CoreBlenderTimers();
};

struct CoreBlenderGoalInfo
{
    CoreBlenderGoalData m_data[2];

    // TODO vtable

    void Construct();
    void Destruct();
    void Reset();
    void ClearOffsetBlend();
    void ClearSubPlaybackSpeed();
    char Add(float i_subPlaybackSpeed, CoreVector& i_offsetPos, CoreEulerAngle& i_offsetRot);
    float GetSubPlaybackSpeed();
    void GetOffsetPos(int32_t i_index, CoreVector& o_value);
    void GetOffsetRot(int32_t i_index, CoreEulerAngle& o_value);
    bool HasSubPlaybackSpeed();
    bool HasOffsetBlend(int32_t i_index);
    void SetOffsetPos();
    void SetOffsetRot();
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    void CoreBlenderGoalInfo();
};

struct CoreBlenderFlags
{
    uint32_t m_data[4];

    // TODO vtable

    void Construct();
    void Destruct();
    void Reset();
    bool SetFlag(uint32_t i_flagHash);
    void ClearFlag(uint32_t i_flagHash);
    bool IsFlagSet();
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    void CoreBlenderFlags();
};

struct CoreBlenderSequenced : CoreBlender
{
    static CoreBlenderEvents m_events;
    bool m_updateAnimDir;

    void Construct(CoreMemory* i_memory);
    void Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
    void ClearAnimList();
    void ResetAnimations();
    CoreFileSystem::CoreFileLoadReturn AttachAnimationSetFile(uint32_t i_clientID, CoreObjectUpdateStruct* i_updateStruct, char* i_animationSetName);
    bool AttachAnimationSet(CoreAnimationSet* i_animSet, uint32_t i_animationSetFile, uint32_t i_animationSetAssetHash);
    bool AttachAnimationSequencer(CoreAnimSequencer* i_animSeq, uint32_t i_animationSetFile, uint32_t i_animSequencerAssetHash);
    void HandleAssetManagerClientCallback(CoreAssetManager* i_assetManager, CoreWorld* i_world, CoreHash& i_assetID, CoreHash& i_assetType);
    CoreAnimationSet* GetAnimationSet(CoreHash& i_animName);
    int32_t GetBlenderType();
    bool IsBlenderSequenced();
    CoreVector GetPositionChange(CoreAnimatingObject* i_ao, float i_startTime, float i_endTime);
    CoreEulerAngle GetOrientationChange(CoreAnimatingObject* i_ao, float i_startTime, float i_endTime);
    void GetAnimateVelocity();
    void Animate();
    bool AddAnim();
    bool SetGoalState();
    bool AddImmediateBlend();
    void UpdateJointsState();
    void RenderAnimList();
    CoreHash GetPrimaryAnimID();
    CoreHash GetPrimaryAnimNameHash();
    float GetPrimaryAnimTime();
    float GetPrimaryAnimEndTime();
    float GetPrimaryAnimPlaybackSpeed();
    CoreHash GetSlotAnimID();
    CoreHash GetSlotAnimNameHash();
    float GetSlotAnimTime();
    float GetSlotAnimEndTime();
    float GetSlotPlaybackSpeed();
    CoreHash GetAnimStateContext(CoreHash i_animState);
    float GetAnimStateEndTime(CoreHash i_animState);
    bool GetAnimStateLooping(CoreHash i_animState);
    bool IsSlotAnimBlending();
    bool IsSlotAnimMirrored();
    bool IsSlotPlaying();
    float GetSlotWeight();
    void SetSlotWeight();
    void SetSlotPlaybackSpeed();
    CoreAnimSpec* GetPrimaryAnimSpec();
    CoreAnimSpec* GetAnimSpecByHash(CoreHash& i_animID);
    bool CanAddAnim();
    bool GetTimer();
    int32_t GetNumAnimDataSets();
    CoreHash GetAnimDataSetHash(int32_t i_index);
    void ClearOffsetBlends();
    bool SetAnimFlag(CoreHash& i_flagHash);
    void ClearAnimFlag(CoreHash& i_flagHash);
    bool IsAnimFlagSet(CoreHash& i_flagHash);
    void ClearAllAnimFlags();
    bool GetUpdateAnimDir();
    void SetUpdateAnimDir(bool i_value);
    void MakeNetworkPacket();
    void UpdateFromNetworkPacket();
    void StepSequencer(CoreAnimatingObject* i_ao, float i_deltaTimeInSeconds);
    bool GetAnimSpecPrimaryAnimInfo(CoreSpecInfo& i_specInfo, CoreAnimDataInfo& o_animInfo);
    int32_t FindTimedBlend(CoreSpecInfo& i_specInfoSrc, CoreSpecInfo& o_specInfoTgt, float i_deltaTime);
    float CalcTimeBetweenAnims(CoreHash& i_startState, float i_startTime, CoreHash& i_targetState);
    bool EvaluateCondition(CoreAnimSequencer* i_animSeq, int32_t i_conditionIndex);
    CoreAltAnim* ChooseAltAnim(CoreSpecInfo& specInfo);
    bool ValidateAltAnim(CoreAltAnim* i_altAnim, CoreSpecInfo& i_specInfo, bool i_displayError);
    bool CalculateOffsetBlend(CoreAnimatingObject* i_ao, CoreSpecInfo& i_specInfoSrc, CoreSpecInfo& i_specInfoTgt, CoreVector& o_offsetPos, CoreEulerAngle& o_offsetRot);
    char SetupOffsetBlending(CoreAnimatingObject* i_ao, CoreHash& i_slotID, int32_t i_slotIndex, int32_t i_goalInfoIndex, CoreSpecInfo& i_specInfoTgt);
    float FrameSnap(float i_time);
    void StepBlender();
    void CheckForEvent_Anim();
    void CheckForEvent_BlendTree();
    void CheckForEvent_Command();
    void CheckForEvent_TimedBlend();
    void ProcessEvent_Anim();
    void ProcessEvent_BlendTree();
    void ProcessEvent_Command(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
    void ProcessEvent_TimedBlend();
    bool InitialiseSpecInfoFromIndex();
    bool InitialiseSpecInfoFromState();
    bool InitialiseSpecInfoFromSlot();
    CoreBlenderFlags* GetBlenderFlags();
    CoreBlenderGoalInfo* GetBlenderGoalInfo();
    CoreBlenderTimers* GetBlenderTimers();
    int32_t AnimDataSet_GetCount();
    int32_t AnimDataSet_AddItem();
    uint32_t AnimDataSet_GetAnimSetFile();
    uint32_t AnimDataSet_GetAnimSetAssetHash();
    uint32_t AnimDataSet_GetAnimSequencerAssetHash();
    CoreAnimationSet* AnimDataSet_GetAnimSet();
    CoreAnimSequencer* AnimDataSet_GetAnimSequencer();
    int32_t AnimDataSet_GetAnimSetIndexByHash();
    CoreAnimationSet* AnimDataSet_GetAnimSetByHash();
    int32_t AnimDataSet_GetIndexByAnimSpecID();
    void AnimDataSet_SetAnimSetFile();
    void AnimDataSet_SetAnimSet();
    void AnimDataSet_SetAnimSequencer();
    void AnimDataSet_SetAnimSetAssetHash();
    void AnimDataSet_SetAnimSequencerAssetHash();
    float Ease(float i_time, float i_easeFrom, float i_easeTo);
    void AutoBlendCallback(CoreAnimatingObject* i_ao, CoreHash i_slotID, CoreHash i_oldState, CoreHash i_newState);
    uint32_t GetAudioParams(CoreAnimatingObject* i_ao, CoreAnimCommandAudio* i_command, CoreVector& o_detectPosition);
    void CoreBlenderSequenced();
    void ~CoreBlenderSequenced();
};

struct CoreBlenderEvent
{
    enum BlendEventType
    {
        BE_COMMAND = 1,
        BE_TIMED_BLEND,
        BE_ANIM,
        BE_BLEND_TREE,
    };

    uint32_t m_eventID;
    float m_time;
    bool m_terminate;
    bool m_primaryStateChanged;
    int32_t m_dataS32_1;
    int32_t m_dataS32_2;
    uint32_t m_dataU32_1;
    uint32_t m_dataU32_2;
    uint32_t m_dataU32_3;
    float m_dataF32_1;
    float m_dataF32_2;
    CoreBlenderEvent* m_next;
};

struct CoreBlenderEvents
{
    CoreBlenderEvent* m_head;
    CoreBlenderEvent m_cache[20];
    int32_t m_nextAvailable;
    bool m_terminate;
    uint32_t m_lastID;

    void Reset();
    CoreBlenderEvent* GetHead();
    bool GetTerminate();
    void SetTerminate();
    void SetLastID();
    CoreBlenderEvent* GetNewEvent();
    void AddEvent(CoreBlenderEvent* i_newEvent);
    bool IsValidEvent();
    void AddCommand(uint32_t i_eventID, float i_deltaTime, uint32_t i_animSetIndex, uint32_t i_animSpecIndex, CoreHash i_slotID, int32_t i_commandIndex, uint32_t i_commandType);
    void AddBlendTree(uint32_t i_eventID, float i_deltaTime, uint32_t i_blendIndex, uint32_t i_blendSubIndex);
    void AddAnim(uint32_t i_eventID, float i_deltaTime, int32_t i_animIndex, float i_newTime, uint32_t i_hasLooped);
    void AddTimedBlend(uint32_t i_eventID, float i_deltaTime, int32_t i_slotIndex, float i_targetTime, float i_blendTime, uint32_t i_blendFlags, uint32_t i_targetState, uint32_t i_flags, uint32_t i_ease);
};

struct CoreBlenderAnimElementSimple
{
    uint32_t m_animSetNumber;
    uint32_t m_animSpecNumber;
    uint32_t m_animID;
    float m_time;
    float m_playbackSpeed;
    uint32_t m_flags;
};

struct CoreAnimDataSetSimple
{
    CoreAnimDataSetElement m_data;

    void Construct();
    void Destruct();
    int32_t GetCount();
    int32_t AddItem();
    uint32_t GetAnimSetFile();
    uint32_t GetAnimSetAssetHash();
    uint32_t GetAnimSequencerAssetHash();
    CoreAnimationSet* GetAnimSet();
    CoreAnimSequencer* GetAnimSequencer();
    int32_t GetAnimSetIndexByHash();
    CoreAnimationSet* GetAnimSetByHash();
    int32_t GetIndexByAnimSpecID();
    void SetAnimSetFile();
    void SetAnimSet();
    void SetAnimSequencer();
    void SetAnimSetAssetHash();
    void SetAnimSequencerAssetHash();
};

struct CoreBlenderAnimsSimple
{
    enum AnimFlags
    {
        AF_PLAYING,
        AF_PRIMARY,
        AF_COMMAND,
        AF_LOOPING,
        AF_MIRROR,
        AF_ADVANCED,
        AF_USED,
    };

    CoreBlenderAnimElementSimple m_data[2];

    // TODO vtable

    void Construct();
    void Destruct();
    uint32_t GetAnimID();
    float GetTime();
    void GetAnimSpecNumber();
    float GetPlaybackSpeed();
    bool IsPlaying();
    bool IsPrimary();
    bool IsCommand();
    bool IsLooping();
    bool IsMirror();
    bool IsAdvanced();
    bool IsUsed();
    void SetTime();
    void SetAnimSpecNumber();
    void SetPlaybackSpeed();
    void SetPlaying();
    void SetPrimary();
    void SetCommand();
    void SetLooping();
    void SetMirror();
    void SetAdvanced();
    void SetUsed();
    void ClearAllAdvanced();
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    int32_t AddAltAnim(CoreAltAnim* i_altAnim, CoreSpecInfo& i_specInfo, CoreAnimDataSetSimple* i_animDataSet, CorePlayAnimInfo* i_animInfo, uint32_t i_blendFlags);
    void FreeUnused();
    void CoreBlenderAnimsSimple();
};

struct CoreBlenderBlendsSimple
{
    enum BlendFlags
    {
        BF_BLENDING,
        BF_KILL_ON_ZERO_WEIGHT,
        BF_INDEX1_IS_ANIM,
        BF_INDEX2_IS_ANIM,
        BF_INDEX1_HAS_VELOCITY,
        BF_INDEX2_HAS_VELOCITY,
        BF_INDEX1_HAS_BONESET,
        BF_INDEX2_HAS_BONESET,
        BF_INDEX1_HAS_EASE,
        BF_INDEX2_HAS_EASE,
    };

    enum BlendAddMode
    {
        BAM_EMPTY_TREE = 1,
        BAM_LONE_SLOT,
        BAM_MIXED_SLOT,
        BAM_STANDARD_SLOT,
    };

    uint32_t m_flags;
    uint32_t m_ease;
    float m_weight;
    float m_blendTime;
    float m_blendWeightDelta;

    // TODO vtable

    void Construct();
    void Destruct();
    int32_t GetIndex();
    float GetWeight();
    float GetBlendTime();
    float GetBlendWeightDelta();
    bool IsIndexAnAnim();
    bool IsBlending();
    bool IsKillOnZeroWeight();
    bool IndexHasVelocity();
    bool IndexHasEase();
    char GetGoalInfoIndex();
    uint32_t GetEaseParams();
    void SetIndex();
    void SetWeight();
    void SetIndexIsAnAnim();
    void SetBlendTime();
    void SetBlendTarget();
    void SetBlending();
    void SetKillOnZeroWeight();
    void SetIndexHasVelocity();
    void SetIndexHasEase();
    void SetGoalInfoIndex();
    void SetEaseParams();
    void ClearVelocityFlags();
    bool AddAltAnimBlends(CoreBlenderAnimsSimple* i_anims, CorePlayAnimInfo* i_animInfo, uint32_t i_blendFlags, uint32_t i_ease);
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    void CoreBlenderBlendsSimple();
};

struct CoreBlenderSimple : CoreBlenderSequenced
{
    CoreAnimDataSetSimple m_animDataSet;
    CoreBlenderAnimsSimple m_anims;
    CoreBlenderBlendsSimple m_blends;
    uint32_t m_currentState;
    uint32_t m_goalState;
    CoreVector m_velocityPos;
    CoreEulerAngle m_velocityRot;

    int32_t GetBlenderType();
    void Construct(CoreMemory* i_memory);
    void Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
    void ResetAnimations();
    void GetAnimateVelocity(CoreVector* o_velocityPos, CoreEulerAngle* o_velocityRot, CoreVector* o_offsetPos, CoreEulerAngle* o_offsetRot);
    void Animate(CoreAnimatingObject* i_ao, CoreObjectUpdateStruct* i_updateStruct, float i_deltaTimeInSeconds);
    bool AddAnim(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
    bool SetGoalState(CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
    bool AddImmediateBlend(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
    void UpdateJointsState(CoreAnimatingObject* i_ao, CoreHashArray* i_jointIndexTable, CoreJointState* io_jointStates);
    void RenderAnimList(CoreGraphicsDevice* i_graphicsDevice, CoreVector& io_screenPos1, CoreVector& io_screenPos2);
    CoreHash GetPrimaryAnimID();
    CoreHash GetPrimaryAnimNameHash();
    float GetPrimaryAnimTime();
    float GetPrimaryAnimEndTime();
    float GetPrimaryAnimPlaybackSpeed();
    CoreHash GetSlotAnimID(CoreHash& i_slotID);
    CoreHash GetSlotAnimNameHash(CoreHash& i_slotID);
    float GetSlotAnimTime(CoreHash& i_slotID);
    float GetSlotAnimEndTime(CoreHash& i_slotID);
    float GetSlotPlaybackSpeed(CoreHash& i_slotID);
    bool IsSlotAnimBlending(CoreHash& i_slotID);
    bool IsSlotAnimMirrored(CoreHash& i_slotID);
    bool IsSlotPlaying(CoreHash& i_slotID);
    float GetSlotWeight(CoreHash& i_slotID);
    void SetSlotWeight(CoreHash& i_slotID, float i_weight, float i_time, bool i_killOnZeroWeight);
    void SetSlotPlaybackSpeed(CoreHash& i_slotID, float i_playbackSpeed);
    CoreAnimSpec* GetPrimaryAnimSpec();
    bool CanAddAnim(CoreHash& i_slotID, CoreHash& i_animID);
    bool GetTimer(CoreHash i_timerName, float& o_time);
    void ClearOffsetBlends();
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    void GetBlenderStats(char* o_blenderStats);
    void StepBlender(float i_deltaTime);
    void CheckForEvent_Anim(float i_deltaTime);
    void CheckForEvent_BlendTree(float i_deltaTime);
    void CheckForEvent_Command(float i_deltaTime);
    void CheckForEvent_TimedBlend(float i_deltaTime);
    void ProcessEvent_Anim(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
    void ProcessEvent_BlendTree(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao, bool i_killSlot);
    void ProcessEvent_TimedBlend(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
    bool InitialiseSpecInfoFromIndex(int32_t& i_animSetIndex, int32_t& i_animSpecIndex, CoreSpecInfo& i_tbi);
    bool InitialiseSpecInfoFromState(CoreHash& i_state, CoreSpecInfo& i_tbi);
    bool InitialiseSpecInfoFromSlot(int32_t i_slotIndex, CoreSpecInfo& i_tbi);
    CoreBlenderFlags* GetBlenderFlags();
    CoreBlenderGoalInfo* GetBlenderGoalInfo();
    CoreBlenderTimers* GetBlenderTimers();
    int32_t AnimDataSet_GetCount();
    int32_t AnimDataSet_AddItem();
    uint32_t AnimDataSet_GetAnimSetFile(int32_t i_index);
    uint32_t AnimDataSet_GetAnimSetAssetHash(int32_t i_index);
    uint32_t AnimDataSet_GetAnimSequencerAssetHash(int32_t i_index);
    CoreAnimationSet* AnimDataSet_GetAnimSet(int32_t i_index);
    CoreAnimSequencer* AnimDataSet_GetAnimSequencer(int32_t i_index);
    int32_t AnimDataSet_GetAnimSetIndexByHash(CoreHash& i_animSetHash);
    CoreAnimationSet* AnimDataSet_GetAnimSetByHash(CoreHash& i_animSetHash);
    int32_t AnimDataSet_GetIndexByAnimSpecID(CoreHash& i_animSpecID, int32_t& o_specIndex);
    void AnimDataSet_SetAnimSetFile(int32_t i_index, uint32_t i_animSetFile);
    void AnimDataSet_SetAnimSet(int32_t i_index, CoreAnimationSet* i_animSet);
    void AnimDataSet_SetAnimSequencer(int32_t i_index, CoreAnimSequencer* i_animSeq);
    void AnimDataSet_SetAnimSetAssetHash(int32_t i_index, uint32_t i_animationSetAssetHash);
    void AnimDataSet_SetAnimSequencerAssetHash(int32_t i_index, uint32_t i_animSequencerAssetHash);
    bool GetVelocityByBlendTree(float i_deltaTime, CoreVector& o_velPos, CoreQuat& o_velRot);
    bool PerformTimedBlend(CoreAnimatingObject* i_ao, CoreSpecInfo& i_specInfoTgt);
    bool PerformImmediateBlend(CoreAnimatingObject* i_ao, CoreHash& i_state, float i_startTime, uint32_t i_flags);
    void CoreBlenderSimple();
    void ~CoreBlenderSimple();
};

struct CoreBlenderSlotElement
{
    uint32_t m_slotID;
    uint32_t m_animSetNumber;
    uint32_t m_animSpecNumber;
    uint32_t m_currentState;
    uint32_t m_goalState;
    float m_playbackSpeed;
    uint32_t m_priority;
    uint32_t m_flags;
    char m_goalInfoIndex;
    uint32_t m_boneSetIndex;
};

struct CoreBlenderAnimElementComplex
{
    uint32_t m_slotID;
    uint32_t m_animSetNumber;
    uint32_t m_animSpecNumber;
    uint32_t m_animID;
    float m_time;
    float m_playbackSpeed;
    uint32_t m_flags;
};

struct CoreBlenderBlendElement
{
    char m_index[2];
    uint32_t m_flags[2];
    float m_weight[2];
    float m_blendTime[2];
    float m_blendWeightDelta[2];
    char m_goalInfoIndex;
    uint32_t m_ease[2];
};

struct CoreBlenderBlendIndexData
{
    int32_t m_index;
    bool m_isBlending;
    bool m_isKillOnZeroWeight;
    bool m_isAnim;
    bool m_isVelocity;
    bool m_isBoneSet;
    bool m_isEase;
};

struct CoreAnimDataSetComplex
{
    CoreAnimDataSetElement m_data[2];
    int32_t m_count;

    void Construct();
    void Destruct();
    int32_t GetCount();
    int32_t AddItem();
    uint32_t GetAnimSetFile();
    uint32_t GetAnimSetAssetHash();
    uint32_t GetAnimSequencerAssetHash();
    CoreAnimationSet* GetAnimSet();
    CoreAnimSequencer* GetAnimSequencer();
    int32_t GetAnimSetIndexByHash();
    CoreAnimationSet* GetAnimSetByHash();
    int32_t GetIndexByAnimSpecID(CoreHash& i_animSpecID, int32_t& o_specIndex);
    void SetAnimSetFile();
    void SetAnimSet();
    void SetAnimSequencer();
    void SetAnimSetAssetHash();
    void SetAnimSequencerAssetHash();
};

struct CoreBlenderSlots
{
    enum SlotFlags
    {
        SF_PRIMARY_SLOT,
    };

    CoreBlenderSlotElement m_data[4];
    int32_t m_count;

    // TODO vtable

    void Construct();
    void Destruct();
    int32_t GetCount();
    int32_t GetSlotIndex();
    int32_t GetPrimarySlotIndex();
    CoreHash GetSlotID(int32_t i_index);
    float GetPlaybackSpeed();
    CoreHash GetCurrentState(int32_t i_index);
    CoreHash GetGoalState(int32_t i_index);
    char GetGoalInfoIndex();
    void GetAnimSpecNumber();
    bool IsPrimarySlot();
    int32_t GetBoneSetIndex();
    void SetPlaybackSpeed();
    void SetCurrentState();
    void SetGoalState();
    void SetGoalInfoIndex();
    void SetAnimSpecNumber();
    int32_t AddSlot(CoreHash& i_slotID, CoreSpecInfo& i_specInfo, CorePlayAnimInfo* i_animInfo);
    bool UpdateSlot(CoreHash& i_slotID, CoreSpecInfo& i_specInfo);
    void FreeUnused(CoreBlenderAnimsComplex* i_anims);
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    bool HasAnyBoneSets();
    void CoreBlenderSlots();
};

struct CoreBlenderAnimsComplex
{
    enum AnimFlags
    {
        AF_PLAYING,
        AF_PRIMARY,
        AF_COMMAND,
        AF_LOOPING,
        AF_MIRROR,
        AF_ADVANCED,
        AF_USED,
    };

    CoreBlenderAnimElementComplex m_data[8];
    int32_t m_count;

    // TODO vtable

    void Construct();
    void Destruct();
    uint32_t GetAnimID();
    float GetTime();
    void GetAnimSpecNumber();
    float GetPlaybackSpeed();
    bool IsPlaying();
    bool IsPrimary();
    bool IsCommand();
    bool IsLooping();
    bool IsMirror();
    bool IsAdvanced();
    bool IsUsed();
    void SetTime();
    void SetAnimSpecNumber();
    void SetPlaybackSpeed();
    void SetPlaying();
    void SetPrimary();
    void SetCommand();
    void SetLooping();
    void SetMirror();
    void SetAdvanced();
    void SetUsed();
    void ClearAllAdvanced();
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    int32_t GetCount();
    CoreHash GetSlotID(int32_t i_index);
    bool IsSlotUsed(CoreHash& i_slotID);
    bool IsSlotMirrored(CoreHash& i_slotID);
    int32_t AddAnim(CoreHash& i_slotID, int32_t i_animSetNumber, int32_t i_animSpecNumber, CoreHash& i_animID, float i_time, float i_playbackSpeed, bool i_primaryAnim, bool i_loopingAnim, bool i_mirrorAnim, bool i_playAnim);
    int32_t AddAltAnim(CoreHash& i_slotID, CoreAltAnim* i_altAnim, CoreSpecInfo& i_specInfo, CoreAnimDataSetComplex* i_animDataSet, CorePlayAnimInfo* i_animInfo, uint32_t i_blendFlags);
    void FreeUnused(CoreBlenderBlendsComplex* i_blends);
    int32_t GetPrimaryAnimBySlotID(CoreHash& i_slotID);
    void ClearPrimaryFlagBySlotID(CoreHash& i_slotID);
    void CoreBlenderAnimsComplex();
};

struct CoreBlenderBlendsComplex
{
    enum BlendFlags
    {
        BF_BLENDING,
        BF_KILL_ON_ZERO_WEIGHT,
        BF_INDEX_IS_ANIM,
        BF_INDEX_HAS_VELOCITY,
        BF_INDEX_HAS_BONESET,
        BF_INDEX_HAS_EASE,
    };

    enum BlendAddMode
    {
        BAM_EMPTY_TREE = 1,
        BAM_LONE_SLOT,
        BAM_MIXED_SLOT,
        BAM_STANDARD_SLOT,
    };

    CoreBlenderBlendElement m_data[8];
    int32_t m_count;

    // TODO vtable

    void Construct();
    void Destruct();
    int32_t GetIndex();
    float GetWeight();
    float GetBlendTime();
    float GetBlendWeightDelta();
    bool IsIndexAnAnim();
    bool IsBlending();
    bool IsKillOnZeroWeight();
    bool IndexHasVelocity();
    bool IndexHasBoneSet();
    char GetGoalInfoIndex();
    bool IndexHasEase();
    uint32_t GetEaseParams();
    void SetIndex();
    void SetWeight();
    void SetIndexIsAnAnim();
    void SetBlendTime();
    void SetBlendWeightDelta();
    void SetBlendTarget(int32_t i_index, int32_t i_subIndex, float i_targetWeight, float i_blendTime);
    void SetBlendTargetEx(int32_t i_index, int32_t i_subIndex, float i_targetWeight, float i_blendTime, bool i_killOnZeroWeight, bool i_blendingDifferentSlots);
    void SetBlending();
    void SetKillOnZeroWeight();
    void SetIndexHasVelocity();
    void SetIndexHasBoneSet();
    void SetIndexHasEase();
    void SetGoalInfoIndex();
    void SetEaseParams();
    void GetIndexData(int32_t i_index, int32_t i_subIndex, CoreBlenderBlendIndexData& o_indexData);
    void SetIndexData(int32_t i_index, int32_t i_subIndex, CoreBlenderBlendIndexData& i_indexData);
    void CopyIndexData(int32_t i_tgtIndex, int32_t i_tgtSubIndex, int32_t i_srcIndex, int32_t i_srcSubIndex);
    void CopyWeightData(int32_t i_tgtIndex, int32_t i_tgtSubIndex, int32_t i_srcIndex, int32_t i_srcSubIndex);
    void ClearVelocityFlags();
    int32_t GetCount();
    void InsertBlends(int32_t i_insertPoint, int32_t i_count);
    int32_t GetBlendSlotIDUsageCount(int32_t i_index, CoreBlenderAnimsComplex* i_anims, CoreHash& i_slotID);
    bool AddAltAnimBlends(CoreHash& i_slotID, CoreAltAnim* i_altAnim, CoreBlenderAnimsComplex* i_anims, CoreBlenderSlots* i_slots, int32_t i_animIndex, CorePlayAnimInfo* i_animInfo, uint32_t i_blendFlags, char i_goalInfoIndex, uint32_t i_ease);
    bool IsAnimUsed(int32_t i_animIndex);
    void RemapOnAnim(int32_t i_animIndex, int32_t i_offset);
    void RemapOnBlend(int32_t i_blendIndex, int32_t i_offset);
    void RemapOnBlendEquals(int32_t i_oldBlendIndex, int32_t i_newBlendIndex);
    void KillBlend(int32_t i_index, int32_t i_subIndex);
    void FreeUnused(CoreBlenderAnimsComplex* i_anims);
    int32_t GetBlendParent(int32_t i_index, int32_t& o_subIndex);
    int32_t GetEarliestSlotRef(CoreHash& i_slotID, CoreBlenderAnimsComplex* i_anims, int32_t& o_indexRef, bool& o_loneRef);
    void UpdateLoneStatus(int32_t i_blendIndex, int32_t& o_blendSubIndex, bool& o_isLone);
    int32_t FindLastBlendIndex(int32_t i_blendIndex, int32_t i_blendSubIndex);
    bool GetSlotGlobalWeight(int32_t i_blendIndex, CoreHash& i_slotID, CoreBlenderAnimsComplex* i_anims, float i_parentGlobalWeight, float& o_weight);
    bool SetSlotGlobalWeight(int32_t i_blendIndex, CoreHash& i_slotID, CoreBlenderAnimsComplex* i_anims, float i_parentGlobalWeight, float i_targetWeight, float i_targetTime, bool& io_killOnZeroWeight, bool& o_globalWeightSet, float& o_weight);
    void SetBlendAnimPlayingFlag(CoreBlenderAnimsComplex* i_anims, int32_t i_blendIndex, int32_t i_blendSubIndex, bool i_playing);
    int32_t GetBlendByGoalInfoIndex();
    void OnBlendFinishClearGoalInfoIndices(int32_t i_blendIndex, CoreBlenderGoalInfo* i_goalInfo);
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    void CalculateGlobalAnimWeights(float* io_animWeights, int32_t* io_blendIndex, int32_t* io_blendSubIndex, int32_t i_blendIndex, float i_parentWeight);
    bool HasAnyBoneSets();
    bool IsBlendingDifferentSlots(int32_t i_blendIndex, CoreBlenderAnimsComplex* i_anims, CoreHash& o_slotID);
    void CoreBlenderBlendsComplex();
};

struct CoreBlenderComplex : CoreBlenderSequenced
{
    CoreAnimDataSetComplex m_animDataSet;
    CoreBlenderSlots m_slots;
    CoreBlenderAnimsComplex m_anims;
    CoreBlenderBlendsComplex m_blends;
    CoreBlenderTimers m_timers;
    CoreBlenderGoalInfo m_goalInfo;
    CoreBlenderFlags m_flags;
    CoreVector m_velocityPos;
    CoreEulerAngle m_velocityRot;
    CoreVector m_offsetPos;
    CoreEulerAngle m_offsetRot;

    int32_t GetBlenderType();
    void Construct(CoreMemory* i_memory);
    void Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
    void ResetAnimations();
    void GetAnimateVelocity(CoreVector* o_velocityPos, CoreEulerAngle* o_velocityRot, CoreVector* o_offsetPos, CoreEulerAngle* o_offsetRot);
    void Animate(CoreAnimatingObject* i_ao, CoreObjectUpdateStruct* i_updateStruct, float i_deltaTimeInSeconds);
    bool AddAnim(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
    bool SetGoalState(CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
    bool AddImmediateBlend(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
    void UpdateJointsState(CoreAnimatingObject* i_ao, CoreHashArray* i_jointIndexTable, CoreJointState* io_jointStates);
    void RenderAnimList(CoreGraphicsDevice* i_graphicsDevice, CoreVector& io_screenPos1, CoreVector& io_screenPos2);
    CoreHash GetPrimaryAnimID();
    CoreHash GetPrimaryAnimNameHash();
    float GetPrimaryAnimTime();
    float GetPrimaryAnimEndTime();
    float GetPrimaryAnimPlaybackSpeed();
    CoreHash GetSlotAnimID(CoreHash& i_slotID);
    CoreHash GetSlotAnimNameHash(CoreHash& i_slotID);
    float GetSlotAnimTime(CoreHash& i_slotID);
    float GetSlotAnimEndTime(CoreHash& i_slotID);
    float GetSlotPlaybackSpeed(CoreHash& i_slotID);
    bool IsSlotAnimBlending(CoreHash& i_slotID);
    bool IsSlotAnimMirrored(CoreHash& i_slotID);
    bool IsSlotPlaying(CoreHash& i_slotID);
    float GetSlotWeight(CoreHash& i_slotID);
    void SetSlotWeight(CoreHash& i_slotID, float i_weight, float i_time, bool i_killOnZeroWeight);
    void SetSlotPlaybackSpeed(CoreHash& i_slotID, float i_playbackSpeed);
    CoreAnimSpec* GetPrimaryAnimSpec();
    bool CanAddAnim(CoreHash& i_slotID, CoreHash& i_animID);
    bool GetTimer(CoreHash i_timerName, float& o_time);
    void ClearOffsetBlends();
    void MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
    void UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
    void StepBlender(float i_deltaTime);
    void CheckForEvent_Anim(float i_deltaTime);
    void CheckForEvent_BlendTree(float i_deltaTime);
    void CheckForEvent_Command(float i_deltaTime);
    void CheckForEvent_TimedBlend(float i_deltaTime);
    void ProcessEvent_Anim(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
    void ProcessEvent_BlendTree(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao, bool i_killSlot);
    void ProcessEvent_TimedBlend(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
    bool InitialiseSpecInfoFromIndex(int32_t& i_animSetIndex, int32_t& i_animSpecIndex, CoreSpecInfo& i_tbi);
    bool InitialiseSpecInfoFromState(CoreHash& i_state, CoreSpecInfo& i_tbi);
    bool InitialiseSpecInfoFromSlot(int32_t i_slotIndex, CoreSpecInfo& i_tbi);
    CoreBlenderFlags* GetBlenderFlags();
    CoreBlenderGoalInfo* GetBlenderGoalInfo();
    CoreBlenderTimers* GetBlenderTimers();
    int32_t AnimDataSet_GetCount();
    int32_t AnimDataSet_AddItem();
    uint32_t AnimDataSet_GetAnimSetFile(int32_t i_index);
    uint32_t AnimDataSet_GetAnimSetAssetHash(int32_t i_index);
    uint32_t AnimDataSet_GetAnimSequencerAssetHash(int32_t i_index);
    CoreAnimationSet* AnimDataSet_GetAnimSet(int32_t i_index);
    CoreAnimSequencer* AnimDataSet_GetAnimSequencer(int32_t i_index);
    int32_t AnimDataSet_GetAnimSetIndexByHash(CoreHash& i_animSetHash);
    CoreAnimationSet* AnimDataSet_GetAnimSetByHash(CoreHash& i_animSetHash);
    int32_t AnimDataSet_GetIndexByAnimSpecID(CoreHash& i_animSpecID, int32_t& o_specIndex);
    void AnimDataSet_SetAnimSetFile(int32_t i_index, uint32_t i_animSetFile);
    void AnimDataSet_SetAnimSet(int32_t i_index, CoreAnimationSet* i_animSet);
    void AnimDataSet_SetAnimSequencer(int32_t i_index, CoreAnimSequencer* i_animSeq);
    void AnimDataSet_SetAnimSetAssetHash(int32_t i_index, uint32_t i_animationSetAssetHash);
    void AnimDataSet_SetAnimSequencerAssetHash(int32_t i_index, uint32_t i_animSequencerAssetHash);
    void GetBlenderStats(char* o_blenderStats);
    void EvaluateBlendTreeRecursive(CoreAnimatingObject* i_ao, int32_t i_blendNum, CoreHashArray* i_jointIndexTable, CoreJointState* o_jointStates, float i_parentWeight);
    void EvaluateBlendTreeRecursive_BuildBoneSets(int32_t i_blendNum, bool* i_parentBoneSet, int32_t i_boneCount);
    void EvaluateBlendTreeRecursive_BoneSet(CoreAnimatingObject* i_ao, int32_t i_blendNum, CoreHashArray* i_jointIndexTable, CoreJointState* o_jointStates, int32_t i_boneCount);
    CoreHash GetSlotAnimIDByIndex(int32_t i_slotIndex);
    int32_t GetBlendControllingSlot(CoreHash& i_slotID, int32_t& o_index, int32_t& o_subIndex);
    float GetSlotWeightLocal();
    void SetSlotWeightLocal();
    bool PerformTimedBlend(CoreAnimatingObject* i_ao, int32_t i_slotIndex, CoreSpecInfo& i_specInfoTgt);
    bool PerformImmediateBlend(CoreAnimatingObject* i_ao, int32_t i_slotIndex, CoreHash& i_state, float i_startTime, uint32_t i_flags);
    bool GetBlendTreeOriginOffset(int32_t i_blendIndex, float i_deltaTime, CoreVector& o_offsetPos, CoreEulerAngle& o_offsetRot);
    bool GetVelocityByBlendTree(int32_t i_blendIndex, float i_deltaTime, CoreVector& o_velPos, CoreQuat& o_velRot, CoreVector& o_offsetPos, CoreEulerAngle& o_offsetRot);
    char ProcessAnimInfoOnUserBlend(int32_t i_slotIndex, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo, CoreHash& i_currAnimID, float i_currAnimTime);
    void CheckSpaceAvailableForNewAnims(int32_t i_requiredAnims);
    void CoreBlenderComplex();
    void ~CoreBlenderComplex();
};

struct CoreBoneOverrideInfo
{
    int32_t iBoneIndex;
    float m_fRotX;
    float m_fRotY;
    float m_fRotZ;
    float m_fTransX;
    float m_fTransY;
    float m_fTransZ;
    bool m_bRotRelXOverride;
    bool m_bRotRelYOverride;
    bool m_bRotRelZOverride;
    bool m_visibleOverride;
    bool m_bRotAbsXOverride;
    bool m_bRotAbsYOverride;
    bool m_bRotAbsZOverride;
    bool m_visibleValue;
    bool m_bTransRelXOverride;
    bool m_bTransRelYOverride;
    bool m_bTransRelZOverride;
    bool m_bPadding3;
    bool m_bTransAbsXOverride;
    bool m_bTransAbsYOverride;
    bool m_bTransAbsZOverride;
    bool m_transRemoveJointTranslate;

    void Zero();
};

struct CoreGeometryObjectData
{
    uint32_t m_uiModelCompiledFile;
    uint32_t m_modelCompiledShadowFile;
    uint32_t m_modelCompiledEngineFile;
    uint32_t m_uiTextureSetFiles[4];
    CoreTextureSet* m_lpoTextureSets[4];
    CoreTextureOverride textureOverrides[4];
    uint32_t numTextureOverrides;
    CoreModelCompiled* m_lpoModelCompiled;
    CoreModelCompiled* m_modelCompiledShadow;
    CoreModelCompiled* m_modelCompiledEngine;
    CoreModelSkeleton* m_lpoModelSkeleton;
    CoreStringBuffer<16> m_modelFileName;
    CoreStringBuffer<16> m_shadowFileName;
    CoreStringBuffer<16> m_engineFileName;
    CoreEulerAngle m_eaOrient;
    CoreVector m_vOrigin;
    CoreVector m_vScale;
    CoreMatrix m_mtLocal2World;
    CoreRGBA m_oColour;
    bool m_hasAddSubtractMaterials;
    bool m_bValidSkeleton;
    bool m_bStateChanged;
    float m_fLastTimeStateChanged;
    uint32_t* m_textureOffsets;
    bool m_settledTextureOffsets;
    CoreMatrix* m_lpoMatrixList;
    char* m_lpcVisibleList;
    CoreJointState* m_lpoJointState;
    float* m_lpfBlendShapeAlphaValues;
    CoreDetectorSpheres m_oDetectorSpheres;
    CoreCollidables m_oCollidables;
    CoreSingleCollidable* m_lpoCollidables;
    CoreMemory* m_lpoMemory;
    CoreVector m_vLightOffsetPoint;
    CoreGraphicsDeviceModelCompiledInfo m_oGraphicsDeviceModelInfo;
    CoreGraphicsDeviceLightData m_lightData;
    CoreGraphicsDeviceLightData m_renderLightData;
    CoreVector m_incandescentLight;
    float m_fadeValue;
    bool m_bHasGeometry;
    bool m_bHasPhysics;
    bool m_physicsSwitch;
    bool m_physicsSwitchForNetworkedObject;
    float m_physicsBlendScale;
    int32_t m_physicsBlendMode;
    float m_physicsAnimVelScale;
    CorePhysicsArticulate* m_physicsArticulate;
    CoreU128* m_lpqwMemoryBuffer;
    int32_t m_iMemoryBufferSize;
    uint32_t m_drawFlagOptions;
    CoreModelBoneControl* m_boneControl;

    void CoreGeometryObjectData();
};

struct CoreRenderableObjectData
{
    enum RenderDebugFlags
    {
        NO_Z_WRITE_BIT,
        NO_Z_TEST_BIT,
        BEFORE_LEVEL_BIT,
        PANEL_OBJECT_BIT,
        NO_VIEW_CULLING_BIT,
        LAST_OBJECT_BIT,
        SINGLE_VIEW_OBJECT_BIT,
        NO_VIEW_OCCLUSION_BIT,
    };

    CoreVector bboxMin;
    CoreVector bboxMax;
    CoreVector boundingSphereOffset;
    float boundingSphereRadius;
    uint32_t renderFlags;

    void CoreRenderableObjectData();
};

struct CoreObjectControllerInfo
{
    CoreMemoryPool* lpoMemoryPool;
    int32_t iNumObjectTypes;
    CoreObject** lpCreators[18];
    int32_t lpiObjectMaxs[18];
    int32_t lpiObjectCounts[18];
    CoreHash lpoObjectTypes[18];
    CoreObject* objectTypeHeads[18];
    CoreObject* objectTypeTails[18];
    int32_t numObjectPropertyLists;
    CoreObjectListNode objectListsByProperties[64];
    CoreObjectListNode* objectListsByPropertiesFree;
    CoreObjectListNode* objectListsByPropertiesCurrent;
    uint32_t objectListsByPropertiesFreeIndex;
    CoreObjectListNode* objectListsByPropertiesHeads[8];
    CoreObjectListNode* objectListsByPropertiesTails[8];
    int32_t iNumberOfObjects;
    CoreObject** lplpoObjects;
    bool bPauseObjects;
    uint32_t uiNextID;
    uint32_t m_NumberOfEvents;
    CoreEvent m_EventDatabase[42];
    uint32_t* m_EventDataStorage;
    int32_t iCutSceneNumber;
    int32_t viewNumber;
    int32_t viewerNumber;
    int32_t audioLocatorNumber;
    CoreHash currentViewerObject;
    int32_t currentViewerObjectID;
    int32_t m_UpdateAudioLocatorIndex;
    bool PlayingUnderwaterLoop;

    void CoreObjectControllerInfo();
    void ~CoreObjectControllerInfo();
};

struct CorePanelData
{
    bool active;
    uint32_t activeView;
    CoreMenuComponent defaultComponents[64];
    CoreMenuComponent* components[64];
    int32_t numComponents;
    CoreMenuComponentSlider visibility;
    float visibilityCurrentValue;
    CoreHash textureSetID;
    CoreTextureSet* textureSet;
    int32_t debugComponent;
    bool debugDarken;

    void CorePanelData();
    void ~CorePanelData();
};

struct CoreWorldInternalData
{
    CoreLevel* lpoLevel;
    CoreDetect* lpoDetect;
    CoreAIController* lpoAIController;
    CorePanel* lpoPanel;
    CoreAssetManager* lpoAssetManager;
    bool bPaused;
    bool bScriptPause;
    uint32_t activePadIDForMenu;
    float fTimeScale;
    CoreHash loadingAssetHash;
    CoreHash loadingAssetType;
    CoreStringBuffer<256> loadingAssetName;
    uint32_t uiCurrentLevelHash;
    uint32_t uiLoadLevelHash;
    uint32_t uiResetLevelHash;
    bool bViewBackgroundLevel;
    float fFadeValue;
    float fFadeTarget;
    bool whiteFade;
    float fadeTime;
    float audioFadeFactor;
    int32_t iPauseTimer;
    CoreHash loadingScreenName[4];
    CoreTextureSet* lpoLoadingScreenTextureSet[4];
    bool bDisplayLoadingScreen;
    CoreMemory* lpoMemory;
    CoreNet* lpoNet;
    bool bNoNetworking;
    uint32_t networkAdapter;
    int32_t iNetworkWhichPlayer;
    bool bLanClient;
    bool doNetworkMenu;
    bool m_ProcessingEvent;
    bool m_RemoteMachinePaused;
    bool bLevelSelectActive;
    int32_t iLevelSelectSelected;
    uint32_t uiStreamLevel;
    uint32_t loadingLevelCount;
    bool noMainMenu;
    CorePhysicsWorld* physicsWorld;
    int32_t levelRunCycles;
    int32_t levelMaxRunCycles;
    int32_t levelMinRandomLevel;
    int32_t levelMaxRandomLevel;
    bool simulatePSP;

    void CoreWorldInternalData();
    void ~CoreWorldInternalData();
};

struct CoreWorldEvent
{
    uint32_t m_Type;
};

struct CoreWorldEventPause : CoreWorldEvent
{
    bool m_Paused;
    bool m_PauseAudio;
};

struct CoreWorldEventLevelNotification : CoreWorldEvent
{
    uint32_t m_LevelHash;
};

struct CoreCameraObjectData
{
    float nearClip;
    float farClip;
    float verticalFieldOfView;
    float fogNear;
    float fogFar;
    float fogAlpha;
    float fogRed;
    float fogGreen;
    float fogBlue;
    bool fog;
    bool bloom;
    float bloomIntensity;
    float bloomFeedback;
    float bloomThreshold;
    bool focalBlur;
    float focalBlurZ;
    float focalBlurAmount;
    bool motionBlur;
    float motionBlurAmount;
    bool radialBlur;
    float radialBlurAngle;
    float radialBlurScale;
    float radialBlurCenterX;
    float radialBlurCenterY;
    bool FSFX0;
    bool FSFX1;
    bool FSFX2;
    bool FSFX3;
    bool FSFX4;
    bool FSFX5;
    bool FSFX6;
    bool FSFX7;
    bool FSFX8;
    bool FSFX9;
    CoreVector lookAtPos;
    bool firstTimeFlag;
    bool lookAtCatchupFlag;
    bool connectedToViewerFlag;
    CoreViewerObject* currentViewerObject;
    CoreCameraObject::CameraStateType stateType;
    float roll;
    bool cameraActive;
    CoreHash cameraEffectName;
    bool selectableAsNearestFlag;

    void CoreCameraObjectData();
    void ~CoreCameraObjectData();
};

struct CoreDetectInternalData
{
    CoreDetectResult oResults;
    CoreVector vInputPosA;
    CoreVector vInputPosB;
    CoreDetectorSpheres* lpoInputSpheres;
    CoreVector vMoveVector;
    CoreVector vMoveVectorNormal;
    CoreVector vBoundSpherePos;
    float fBoundSphereRadius;
    float fMoveDistance;
    CoreDetectPolyType eCurrentType;
    CoreVector vDetectPos;
    CoreVector vButtVector;
    int32_t iSphereOrder[8];
    float fSphereRadius;
    float fButtDistance;
    float fMinSphereRadius;
    float fMaxSphereRadius;
    char iFloorSphere;
    bool bEnableFloors;
    bool bDebugRenderDetectors;
    uint32_t exclusiveSubtype;
    CoreAnimatingObject* lpoDetectObjects[64];
    int32_t iNumDetectObjects;
    CoreSingleCollidable oDetectCollidables[16];
    int32_t iNumDetectCollidables;
    uint32_t detectorObjectID;
    CoreVector vUp;
    CoreVector vDown;
    uint32_t uiDetectFlags;
    float debugDrawRadius;
    CoreDetectorSpheres internalDetectorSpheres;
    int32_t triangleIDWallsHit[32];
    CoreDetectPoly objectPoly;
    CoreDetectCache* m_detectCache;
    int32_t m_numCaches;
    CoreDetectCache* m_cache;
    float m_floorHeightCacheRadius;
    bool m_fillCache;
    uint32_t m_flags;
    static CoreHash m_cameraIgnoreHash;

    void CoreDetectInternalData();
};

struct CoreDetectCache
{
    bool m_complete;
    bool m_locked;
    bool m_forced;
    bool m_floorCache;
    CoreVector m_minRegion;
    CoreVector m_maxRegion;
    CoreDetectPoly m_detectPolys[256];
    int32_t m_numDetectPolys;
    CoreTransformedCollidable m_transformedCollidables[128];
    int32_t m_numTransformedCollidables;
    CoreDetectPolyType m_typeOrder[2];
    CoreDetectPoly* m_polyListStartPoints[3];

    void CoreDetectCache();
    void Reset();
};

enum CoreDetect::bSphereToPolyDetection::__l5::ClosestRegion
{
    CORNER_A,
    CORNER_B,
    CORNER_C,
    EDGE_AB,
    EDGE_AC,
    EDGE_BC,
    FACE_ABC,
};

struct cRT_LineWH
{
    float m_lineW;
    float m_lineH;
    float m_offsetX;
    float m_offsetY;
    uint32_t m_index;
    uint32_t m_count;

    void Reset();
    void cRT_LineWH();
    int32_t GetIndex();
    int32_t GetCount();
    void AddToLineW(float i_charW, float i_charH, float i_extraX);
    float GetLineW();
    void ResetOffsetX();
    void AddOffsetX();
    float GetOffsetX();
    void CheckH();
    float GetLineH();
    void SetOffsetY();
    float GetOffsetY();
    void __dflt_ctor_closure();
};

struct cRT_StringWH
{
    cRT_LineWH m_lines[256];
    int32_t m_lineCounter;
    bool m_reportedTooManyLines;
    float m_stringW;
    float m_stringH;
    uint32_t m_bufUnicodeString[2048];
    cRT_LineWH m_lineWH;
    cRT_LineWH m_lineWH_ww;
    float m_fixedH;
    float m_extraX;
    float m_extraY;
    float m_wordWrapWidth;
    bool m_usingWordWrap;
    int32_t m_lastCharWasSpace;

    void Reset();
    void cRT_StringWH(char* i_string);
    uint32_t* GetUnicodeString();
    float GetStringW();
    float GetStringH();
    int32_t GetLineCount();
    cRT_LineWH& GetLineWH();
    void StartGetWH(int32_t i_stringIndex, float i_fixedH, float i_extraX, float i_extraY, float i_wordWrapWidth);
    void AddLine(int32_t i_stringIndex);
    void EndGetWH();
    void AddToLineW(int32_t& io_stringIndex, float i_charW, float i_charH, bool i_isSpace);
};

struct CoreAudioLocatorObjectData
{
    CoreHash m_AudioEventHash;
    bool m_AutoStart;
    bool m_DistanceCulled;
    bool m_Started;
    bool m_UpdateDistanceCulling;

    void Reset();
    void CoreAudioLocatorObjectData();
    void ~CoreAudioLocatorObjectData();
};

struct CoreStringBuffer<128>
{
    char m_buffer[128];

    void CoreStringBuffer<128>(char* i_format);
    void Clear();
    char* operator const char *();
    char* GetString();
    uint32_t GetLength();
    uint32_t GetMaxLength();
    bool IsSame();
    bool IsSameIgnoreCase();
    void operator=();
    void Copy();
    void NCopy();
    void Cat();
    void ToUpper();
    void ToLower();
    float ToFloat();
    int32_t ToInt();
    int32_t FindChar();
    int32_t ReverseFindChar();
    int32_t VSPrint();
    int32_t SPrint(char* i_format);
    int32_t CatPrint();
};

struct CoreGameOnScreenKeyboardCharacterTable
{
    enum
    {
        OSKCaps = 91,
        OSKSpace = 93,
        OSKDelete = 123,
        OSKCancel = 125,
        OSKDone = 124,
    };

    static char m_characterTable[0];
    static char* m_characterTableLanguageSpecific;
    static int32_t m_characterTableEntries;
    static int32_t m_characterTableLineLength;
    int32_t m_characterTableLineCount;
    int32_t m_x;
    int32_t m_y;
    bool m_caps;
    float m_flashValue;

    void CoreGameOnScreenKeyboardCharacterTable();
    void Reset(bool i_isEmpty);
    void MoveLeft();
    void MoveRight();
    void MoveUp();
    void MoveDown();
    int32_t GetAction();
    void ChangeCaps();
    void Render(CoreGameRender* io_graphics, CoreFont* i_font, CoreGameOnScreenKeyboardParameters* i_oskParameters, float i_centreX, float i_centreY, float i_scaleX, float i_scaleY, float i_totalWidth, float i_totalHeight, float i_alphaScaler, int32_t i_renderFlags);
    void SetLanguageSpecificCharacters();
    int32_t GetCurrentIndex();
    int32_t GetRawAction();
    bool FindAction(int32_t i_action, int32_t& o_x, int32_t& o_y);
    int32_t GetRawIndex();
    bool IsRawSpacer();
    bool IsLineOfSpacers();
    int32_t CountNonSpacers(int32_t i_y);
    int32_t GetUsedLinesCount();
    void RawLeft();
    void RawRight();
    void RawUp();
    void RawDown();
};

struct CoreGraphicsDeviceOpenGL : CoreGraphicsDevice
{
    CoreGraphicsDeviceOpenGLInternalData* m_lpoData;
    static bool m_allowResize;
    static bool m_fullScreen;
    static bool m_initHasBeenCalled;
    static uint32_t m_screenWidth;
    static uint32_t m_screenHeight;
    static CoreGraphicsDeviceOpenGL* m_pInstance;

    void CoreGraphicsDeviceOpenGL();
    void ~CoreGraphicsDeviceOpenGL();
    void Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams, char* lpcAppName);
    void Destruct(CoreMemory* lpoMemory);
    void Init();
    void Reset();
    void InitCommon();
    uint32_t GetDisplayWidth();
    uint32_t GetDisplayHeight();
    void DoDebug(CoreDebugInput* i_input);
    bool SpecificFunction(uint32_t i_functionName);
    void BeginDrawDynamicLightVolume();
    void EndDrawDynamicLightVolume();
    void DrawDynamicLightVolume(CoreGraphicsDevice::CoreLightVolumeShape shape, CoreMatrix& transform);
    void SetNumScreens(uint32_t i_count);
    void InitScreen(uint32_t i_index);
    void SetSingleViewMode();
    void SetCamera(CoreVector& vPosition, CoreEulerAngle& eaDirection);
    void ClearScreen();
    void FinishBuffer();
    void SwapBuffer();
    void AddStaticMesh(CoreGeometryCompiled* i_staticMesh, uint32_t iFlags, CoreTextureInfo* pTexInfo, CoreTexturePage* pTexPage, uint32_t pass);
    void RegisterRenderTextureSet(CoreMemory* io_memory, uint32_t rType, CoreTextureSet* pTexSet);
    void UpdateRenderTextureSet(uint32_t rType, CoreTextureSet* pTexSet);
    void FlushBatchRender(uint32_t i_pass);
    void ResetBatchRender(uint32_t i_pass);
    uint32_t uiBeginGeometryPass(int32_t);
    CoreVector vWorldToScreen(CoreVector& vWorld, bool& bZclipped);
    CoreVector vViewToScreen(CoreVector& vWorld, bool& o_bZclipped);
    void GouraudLine(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour1, CoreRGBA oColour2);
    void Line(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
    void Triangle(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreRGBA oColour);
    void Quad(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour);
    void TexturedQuad(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour, CoreUV oUV0, CoreUV oUV1, CoreUV oUV2, CoreUV oUV3);
    void TexturedQuadFast(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA, uint32_t*, uint32_t*);
    void LineStrip(CoreVector& vPos, CoreVector& vScale, float* lpfCoordPointer, int32_t iNumCoords, CoreRGBA oColour);
    void TriBatch(float* i_triStoreData, CoreRGBA i_colour, uint32_t i_vertexCount);
    void TexturedTriBatch(float* i_triStoreData, CoreRGBA i_colour, uint32_t i_vertexCount);
    void BeginFastQuadRender(uint32_t);
    void EndFastQuadRender();
    void GouraudLineScreen(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour1, CoreRGBA oColour2);
    void LineScreen(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
    void TriangleScreen(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreRGBA oColour);
    void QuadScreen(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour);
    void TexturedQuadScreen(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour, CoreUV oUV0, CoreUV oUV1, CoreUV oUV2, CoreUV oUV3);
    void LineStripScreen(CoreVector& vPos, CoreVector& vScale, float* lpfCoordPointer, int32_t iNumCoords, CoreRGBA oColour);
    void TriBatchScreen(float* i_triStoreData, CoreRGBA i_colour, uint32_t i_vertexCount);
    void TexturedTriBatchScreen(float* i_triStoreData, CoreRGBA i_colour, uint32_t i_vertexCount);
    void DrawGeometryCompiled(CoreGeometryCompiled* lpoModel, CoreGraphicsDevice::CoreGeometryDrawEnum eGeometryType, int32_t iNumBlendShapeTargets, int32_t iBlendShapeSkeletonIndex);
    void DrawMeshGroup(CoreMeshGroup* lpoMeshGroup);
    void DrawStaticMesh(CoreGeometryCompiled* lpoStaticMesh);
    void SphereObjectMatrix(CoreMatrix& mtLocal2World, CoreRGBA oColour);
    void CylinderObjectMatrix(CoreMatrix& mtLocal2World, CoreRGBA oColour);
    void SausageObject(CoreVector& vCentre, CoreEulerAngle& eaOrient, float fLength, float fRadius, CoreRGBA oColour);
    void ConeObject(CoreVector& vPos, float fLength, float fAngle, CoreEulerAngle& eaOrient, CoreRGBA oColour);
    void ConeObjectMatrix(CoreMatrix& mtObject2World, CoreRGBA oColour);
    void* GetVertexBuffer(int32_t iNumVerts, CoreGraphicsDevice::CoreVertexFormat eVertexFormat, CoreGraphicsDevice::CoreGeometryType eGeometryType);
    void RenderVertexBuffer(void* lpVertexBuffer, CoreGraphicsDevice::CoreVertexFormat eVertexFormat, bool bFullClip);
    void SolidCuboidObjectMatrix(CoreMatrix& mtLocal2World, CoreRGBA oColour);
    void WireFrameCuboidObjectMatrix(CoreMatrix& mtLocal2World, CoreRGBA oColour);
    void SetProjection();
    void SetResizable();
    void SetFullScreen();
    void SetDisplayWidthPreInit(uint32_t i_width);
    void SetDisplayHeightPreInit(uint32_t i_height);
    void SetDisplayWidth();
    void SetDisplayHeight();
    void LockOrthogonal();
    void UnlockOrthogonal();
    void DisableZTest();
    void DisableZWrite();
    void DisableZTestAndWrite();
    void EnableZTest();
    void EnableZWrite();
    void EnableZTestAndWrite();
    void SetBlendState(bool bEnable);
    void SetBlendFunction(CoreGraphicsDevice::CoreBlendModeEnum eBlendMode, float fAlpha);
    void EnableOverbrightMode();
    void DisableOverbrightMode();
    void GouraudShading(bool bEnable);
    bool bCanILoadTextureData(char*);
    bool bLoadTextureData(char* lpcFileName, CoreTextureSet* lpoTextureSet, CoreAssetManager* lpoAssetManager, bool bAsync);
    void UnLoadTextureData(CoreTextureSet* lpoTextureSet);
    bool bCanILoadModelData(char*);
    bool bCanILoadLevelData(char*, char*);
    bool bLoadModelData(char*, CoreModelGeometry*, CoreAssetManager* lpoAssetManager, bool bAsync);
    void UnLoadModelData(CoreModelGeometry*);
    void MoveTextureData(CoreTextureSet* lpoTextureSet);
    void MoveModelData(CoreModelGeometry* lpoModelGeometry);
    void SelectLights(CoreGraphicsDeviceLightData* lpoLightData);
    void SetShadowDirection(CoreVector shadowDir, float maxShadowLength);
    bool SnapshotDrawBuffer(char* i_name);
    void SetMultipleDrawModes(uint32_t bTexture, uint32_t bCulling, uint32_t bLighting);
    CoreVector unProject(float iX, float iY, float iZ);
    CoreVector Project(float iX, float iY, float iZ);
    void getLocalMousePos(float& oX, float& oY);
    void getLocalMouseDelta(float& oX, float& oY);
    uint32_t GetScreenWidth();
    uint32_t GetScreenHeight();
    void RenderGeometryCompiledBounds(CoreModelMesh* iModelMesh);
    void GetGeometryCompiledReport(CoreModelMesh* iModelMesh, CoreStringBuffer<256>& iStr);
    void GetGeometryCompiledInfo(CoreModelMesh* iModelMesh, uint32_t& nVerts);
    void idleFunction();
    void MainLoop(void* i_idleFunction);
    void SelectTexture(CoreTexturePage* i_texturePage, CoreTextureInfo* i_textureInfo, CoreGraphicsDevice::CoreTextureFilterTypes i_filtering, uint32_t i_pass);
    void SelectUnLit(uint32_t i_flags);
    void SetLights();
    void SelectMaterialProperties(CoreVector& vMaterialColour, CoreVector& vIncandescenceColour, float fDiffuseIntensity, CoreVector& vSpecularColour, float fSpecularCosinePower, uint32_t i_flags, uint32_t i_pass);
    void SelectMatrixPalette();
    void DrawCylinder(float fX1, float fX2, float fRadius1, float fRadius2, float fRadiusMult, float fNX1, float fNX2);
    void DrawSphere(float fRadius);
    void DrawSausage(float fLength, float fRadius);
    void DrawCone();
    void Set2DProjection();
    void Unset2DProjection();
    void ReshapeCallback(int32_t iWidth, int32_t iHeight);
};

struct CoreBatchRender
{
    enum
    {
        MAX_RENDER_CHAIN_ELEMENTS = 6144,
        MAX_RENDER_CHAIN_ELEMENTS_WITH_MATRIX = 512,
    };

    struct CoreBatchRenderChainElementFull
    {
        bool m_bUseMatrix;
        uint32_t m_Pass;
        uint32_t m_Flags;
        CoreGeometryCompiled* m_pMesh;
        CoreBatchRender::CoreBatchRenderChainElementFull* m_pNext;
        CoreTextureInfo* m_pTextureInfo;
        float m_useMatrix[16];
    };

    struct CoreBatchRenderChainElement
    {
        bool m_bUseMatrix;
        uint32_t m_Pass;
        uint32_t m_Flags;
        CoreGeometryCompiled* m_pMesh;
        CoreBatchRender::CoreBatchRenderChainElement* m_pNext;
        CoreTextureInfo* m_pTextureInfo;
    };

    struct CoreBatchRenderChainHead
    {
        CoreTexturePage* m_pTexture;
        uint32_t m_nMeshes;
        CoreBatchRender::CoreBatchRenderChainElementFull* m_pFirst;
    };

    CoreBatchRender::CoreBatchRenderChainHead* m_pRenderChainHead;
    uint32_t m_nRenderChains;
    uint32_t m_nTextures;
    CoreBatchRender::__unnamed m_TexturesByMode[2];
    CoreBatchRender::CoreBatchRenderChainElement m_Elements[6144];
    CoreBatchRender::CoreBatchRenderChainElementFull m_ElementsFull[512];
    uint32_t m_ElementIndex;
    uint32_t m_ElementIndexFull;
    CoreTextureSet* m_pTexSet;
    CoreBatchRender::__unnamed m_LocalCaps;
    CoreMemory* m_pMemPool;
    static CoreBatchRender* m_pInstance;

    // TODO vtable

    void CoreBatchRender();
    void ~CoreBatchRender();
    void Init(CoreMemory* pMemory, CoreTextureSet* pTexSet, bool i_alloc);
    void Update(CoreTextureSet* pTexSet);
    void Release();
    void AddMesh(CoreGeometryCompiled* pMesh, uint32_t iFlags, CoreTextureInfo* pTexInfo, CoreTexturePage* pTexPage, uint32_t pass);
    void BeginScene();
    void Render(uint32_t);
    void Reset(uint32_t i_pass);
    void RenderBatchedMesh();
    void GetDeviceCaps();
    void CopyTargetMatrix();
    void LocalInit();
};

struct CoreBatchRenderPC : CoreBatchRender
{
    CoreBatchRenderPC::__unnamed m_DeviceCaps;

    void CoreBatchRenderPC();
    void ~CoreBatchRenderPC();
    void Render(uint32_t i_pass);
    void RenderBatchedMesh(CoreBatchRender::CoreBatchRenderChainElementFull* pElement);
    void GetDeviceCaps();
    void CopyTargetMatrix(float* pTarget, CoreMatrix* pSrc);
};

struct GLUquadric
{
};

struct CoreGraphicsDeviceOpenGLInternalData
{
    char lpcWindowName[80];
    bool m_bFullscreen;
    float m_oMatrixPalette[16][4][4];
    int32_t m_iParentedMeshIndex;
    bool m_bOverBright;
    bool m_bUsingGLUT;
    bool forceAlphaBlend;
    bool alphaBlending;
    bool backFaceCulling;
    CoreVector vLightCol0;
    CoreVector vLightCol1;
    CoreVector vLightCol2;
    CoreVector vLightCol3;
    CoreVector vLightDir0;
    CoreVector vLightDir1;
    CoreVector vLightDir2;
    CoreVector vLightDir3;
    CoreVector vAmbient;
    CoreVector vMaterialColour;
    CoreVector vIncandescenceColour;
    float fDiffuseIntensity;
    CoreVector m_vSpecularCosinePower;
    CoreVector m_vSpecularDirection;
    CoreVector m_vLightComputedWorldPos;
    float m_fSpecularIntensities[4];
    float m_singleSpecularLightIntensity;
    float m_localMouseX;
    float m_localMouseY;
    float m_localMouseXOld;
    float m_localMouseYOld;
    void* glColorTableEXT;
    void* glBlendEquationEXT;
    void* glBlendColorEXT;
    bool bHasNVVertexShaders;
    void* glVertexAttrib4fvNV;
    void* glVertexAttrib3fvNV;
    void* glVertexAttrib2fvNV;
    void* glVertexAttrib4sNV;
    void* glVertexAttrib1sNV;
    void* glVertexAttrib4ubvNV;
    void* glProgramParameters4fvNV;
    void* glProgramParameter4fNV;
    void* glGetProgramParameterfvNV;
    void* glBindProgramNV;
    void* glLoadProgramNV;
    void* glGenProgramsNV;
    void* glTrackMatrixNV;
    CoreBatchRenderPC m_StaticMeshRender;
    HWND* m_gameHWND;
    void* m_idleFunction;

    void CoreGraphicsDeviceOpenGLInternalData();
    void ~CoreGraphicsDeviceOpenGLInternalData();
};

struct CoreProfileEntry
{
    uint32_t m_uiHash;
    CoreRGBA m_oColour;
    int32_t m_iNumCalls;
    uint32_t m_uiCumulativeCount;
    char m_lpcName[16];

    void CoreProfileEntry();
    void ~CoreProfileEntry();
    void SetFree();
    void UpdateTime();
    void UpdateCalls();
    void Activate();
    bool IsFree();
    CoreRGBA GetColour();
    int32_t GetNumCalls();
    uint32_t GetCumulativeCount();
    int32_t GetAverageCount();
    uint32_t GetHash();
    char* GetName();
};

enum CoreDynamicLightEditTypeEnum
{
    EDIT_DYNAMIC_LIGHT_TYPE,
    EDIT_DYNAMIC_LIGHT_POSITION,
    EDIT_DYNAMIC_LIGHT_ORIENTATION,
    EDIT_DYNAMIC_LIGHT_INNER_COLOUR,
    EDIT_DYNAMIC_LIGHT_OUTER_COLOUR,
    EDIT_DYNAMIC_LIGHT_RADII,
    EDIT_DYNAMIC_LIGHT_SIZE,
};

enum CoreDynamicFlapEditTypeEnum
{
    EDIT_DYNAMIC_FLAP_POSITION,
    EDIT_DYNAMIC_FLAP_ORIENTATION,
    EDIT_DYNAMIC_FLAP_SIZE,
    EDIT_DYNAMIC_FLAP_EDGES,
};

enum CoreDynamicLightVolumeEditTypeEnum
{
    EDIT_DYNAMIC_LIGHT_VOLUME_POSITION,
    EDIT_DYNAMIC_LIGHT_VOLUME_ORIENTATION,
    EDIT_DYNAMIC_LIGHT_VOLUME_SCALE,
};

struct CoreLevelLightSetDebugData
{
    bool bDrawAllLights;
    bool bDrawChosenLight;
    bool bDrawSelectedLights;
    bool bDrawAllFlaps;
    bool bDrawSelectedFlaps;
    bool bEditDynamicLights;
    bool bEditDynamicFlaps;
    bool bEditDynamicLightVolumes;
    bool bDrawText;
    bool bDrawGraphics;
    bool bGammaMode;
    int32_t iDrawLevel;
    int32_t iChosenLight;
    int32_t iSelectedLightsToDraw;
    int32_t iCurrentLightsToCompute;
    float fGamma;
    int32_t iRedBase;
    int32_t iGreenBase;
    int32_t iBlueBase;
    CoreVector vSeletectedLightsWorldPos;
    int32_t iSelectedLightsIndex[4];
    float fSelectedLightsIntensities[4];
    CoreVector vSelectedLightsDirections[4];
    CoreVector vSelectedLightsColours[4];
    CoreVector vSelectedLightsPositions[4];
    CoreVector vSelectedLightsAmbient;
    int32_t iSelectedActiveFlaps[16];
    int32_t iSelectedNumActiveFlaps;
    int32_t iSelectedDynamicLight;
    uint32_t uiDynamicLightEditType;
    int32_t iSelectedDynamicFlap;
    uint32_t uiDynamicFlapEditType;
    int32_t iNumDynamicLightVolumes;
    int32_t iSelectedDynamicLightVolume;
    DebugDynamicLightVolume dynamicLightVolumes[8];
    uint32_t uiDynamicLightVolumeEditType;

    void CoreLevelLightSetDebugData();
};

struct DebugDynamicLightVolume
{
    bool active;
    CoreGraphicsDevice::CoreLightVolumeShape shape;
    CoreVector position;
    CoreEulerAngle orientation;
    CoreVector scale;
    int32_t index;

    void DebugDynamicLightVolume();
};

struct CoreLevelLightSet::SelectLightsFromList::__l3::CoreLightChoose
{
};

struct CoreLevelLightSet::SelectLightsFromList::__l2::CoreLightNode
{
    int32_t iArrayIndex;
    float fIntensity;
};

struct CoreAlphaCharacter
{
    int32_t iNumCoords1;
    float* lpfCoords1;
    int32_t iNumCoords2;
    float* lpfCoords2;
};

struct CoreGraphicsDeviceInternalData
{
    float m_fFixedAlpha;
    CoreGraphicsDevice::CoreBlendModeEnum m_eBlendMode;
    uint32_t m_uiNumEntriesInMatrixList;
    CoreGraphicsDeviceMeshInfo* m_meshInfos;
    CoreGraphicsDeviceMeshInfo* m_currentMeshInfo;
    uint32_t m_numMeshInfos;
    CoreGraphicsDeviceMeshInfo** m_meshInfoHeads;
    CoreGraphicsDeviceMeshInfo** m_meshInfoTails;
    CoreHashTable m_meshInfoTypeTable;
    uint32_t m_numMeshInfoTypes;
    CoreGraphicsDeviceSortMeshHandle* m_sortMeshHandles;
    CoreGraphicsDeviceSortMeshHandle* m_currentSortMeshHandle;
    uint32_t m_numSortedMeshes;
    CoreLevelLightSet* m_levelLightSet;
    CoreGraphicsDeviceDynamicLightVolume dynamicLightVolumes[8];
    CoreRGBA globalDynamicLightVolumeColour;
    CoreTextureInfo m_drawBufferTexture;
    uint32_t m_uiCurrentTextureID;
    uint32_t m_uiCurrentTextureFlags;
    CoreGraphicsDevice::CoreTextureFilterTypes m_uiCurrentTextureFiltering;
    bool m_bBlending;
    bool m_bUseTextures;
    bool m_bGouraudShading;
    bool m_bIsWireFrame;
    CoreVector m_viewFrustrumProjDirs[4];
    CoreVector m_viewFrustrumNegMinConstants[6];
    CoreVector m_viewFrustrumNegMaxConstants[6];

    void CoreGraphicsDeviceInternalData();
    void ~CoreGraphicsDeviceInternalData();
};

struct CoreGraphicsDeviceNull : CoreGraphicsDevice
{
    void CoreGraphicsDeviceNull();
    void ~CoreGraphicsDeviceNull();
    void Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams, char* lpcAppName);
    void Destruct(CoreMemory* lpoMemory);
    void Init();
    void Reset();
    void DoDebug(CoreDebugInput* i_input);
    bool SpecificFunction(uint32_t);
    void BeginDrawDynamicLightVolume();
    void EndDrawDynamicLightVolume();
    void DrawDynamicLightVolume(CoreGraphicsDevice::CoreLightVolumeShape, CoreMatrix&);
    void SetCamera(CoreVector& i_pos, CoreEulerAngle& i_angle);
    void ClearScreen();
    void FinishBuffer();
    void SwapBuffer();
    uint32_t GetDisplayWidth();
    uint32_t GetDisplayHeight();
    CoreVector vWorldToScreen(CoreVector&, bool& bZclipped);
    CoreVector vViewToScreen(CoreVector&, bool& bZclipped);
    void GouraudLine(CoreVector&, CoreVector&, CoreRGBA, CoreRGBA);
    void Line(CoreVector&, CoreVector&, CoreRGBA);
    void Circle(CoreVector&, float, CoreRGBA);
    void Triangle(CoreVector&, CoreVector&, CoreVector&, CoreRGBA);
    void Quad(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA);
    void TexturedQuad(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA, CoreUV, CoreUV, CoreUV, CoreUV);
    void TexturedQuadFast(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA, uint32_t*, uint32_t*);
    void LineStrip(CoreVector&, CoreVector&, float*, int32_t, CoreRGBA);
    void TriBatch(float*, CoreRGBA, uint32_t);
    void TexturedTriBatch(float*, CoreRGBA, uint32_t);
    void BeginFastQuadRender(uint32_t);
    void EndFastQuadRender();
    void SphereObjectMatrix(CoreMatrix&, CoreRGBA);
    void CylinderObjectMatrix(CoreMatrix&, CoreRGBA);
    void SausageObject(CoreVector&, CoreEulerAngle&, float, float, CoreRGBA);
    void ConeObject(CoreVector&, float, float, CoreEulerAngle&, CoreRGBA);
    void ConeObjectMatrix(CoreMatrix&, CoreRGBA);
    void GouraudLineScreen(CoreVector&, CoreVector&, CoreRGBA, CoreRGBA);
    void LineScreen(CoreVector&, CoreVector&, CoreRGBA);
    void CircleScreen(CoreVector&, float, CoreRGBA);
    void TriangleScreen(CoreVector&, CoreVector&, CoreVector&, CoreRGBA);
    void QuadScreen(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA);
    void TexturedQuadScreen(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA, CoreUV, CoreUV, CoreUV, CoreUV);
    void LineStripScreen(CoreVector&, CoreVector&, float*, int32_t, CoreRGBA);
    void TriBatchScreen(float*, CoreRGBA, uint32_t);
    void TexturedTriBatchScreen(float*, CoreRGBA, uint32_t);
    void Line2D(CoreVector&, CoreVector&, CoreRGBA);
    void UnfilledBox2D(CoreVector&, CoreVector&, CoreRGBA);
    void FilledBox2D(CoreVector&, CoreVector&, CoreRGBA);
    void LineStrip2D(CoreVector&, CoreVector&, float*, int32_t, CoreRGBA);
    void* GetVertexBuffer(int32_t, CoreGraphicsDevice::CoreVertexFormat, CoreGraphicsDevice::CoreGeometryType);
    void RenderVertexBuffer(void*, CoreGraphicsDevice::CoreVertexFormat, bool);
    void SolidCuboidObjectMatrix(CoreMatrix&, CoreRGBA);
    void WireFrameCuboidObjectMatrix(CoreMatrix&, CoreRGBA);
    float GetFontWidth();
    float GetFontHeight();
    void DrawMeshGroup(CoreMeshGroup*);
    void DrawStaticMesh(CoreGeometryCompiled*);
    void LockOrthogonal();
    void UnlockOrthogonal();
    void DisableZTest();
    void DisableZWrite();
    void DisableZTestAndWrite();
    void EnableZTest();
    void EnableZWrite();
    void EnableZTestAndWrite();
    void SetBlendState(bool);
    void SetBlendFunction(CoreGraphicsDevice::CoreBlendModeEnum, float);
    void EnableOverbrightMode();
    void DisableOverbrightMode();
    void SetMultipleDrawModes(uint32_t, uint32_t, uint32_t);
    void SetLights();
    bool bCanILoadTextureData(char*);
    bool bLoadTextureData(char*, CoreTextureSet*, CoreAssetManager*, bool);
    void UnLoadTextureData(CoreTextureSet*);
    bool bCanILoadModelData(char*);
    bool bCanILoadLevelData(char*, char*);
    bool bLoadModelData(char*, CoreModelGeometry*, CoreAssetManager*, bool);
    void UnLoadModelData(CoreModelGeometry*);
    void MoveTextureData(CoreTextureSet*);
    void MoveModelData(CoreModelGeometry*);
    void SelectLights(CoreGraphicsDeviceLightData*);
    void SetShadowDirection(CoreVector, float);
    void SelectTexture(CoreTexturePage*, CoreTextureInfo*, CoreGraphicsDevice::CoreTextureFilterTypes, uint32_t);
    void SelectUnLit(uint32_t);
    void SelectMaterialProperties(CoreVector&, CoreVector&, float, CoreVector&, float, uint32_t, uint32_t);
    void SelectMatrixPalette();
};

struct CoreGraphicsDeviceSortMeshHandle
{
    uint32_t iIndex;
    float fSortValue;
    CoreGraphicsDeviceMeshInfo* lpoMeshInfo;
    int32_t iPadding;
};

struct TGA_HEADER
{
    uint32_t identsize;
    uint32_t colourmaptype;
    uint32_t imagetype;
    int32_t colourmapstart;
    int32_t colourmaplength;
    uint32_t colourmapbits;
    int32_t xstart;
    int32_t ystart;
    int32_t width;
    int32_t height;
    uint32_t bits;
    uint32_t descriptor;
};

struct MW
{
    struct MWInitMessage
    {
        uint32_t maxAllocs;
        uint32_t memoryStart;
        uint32_t memoryEnd;
    };

    struct MWAddAlloc
    {
        uint32_t memoryStart;
        uint32_t memoryEnd;
        uint32_t lineNo;
        char name[128];
    };

    struct MWDealloc
    {
        uint32_t memoryStart;
    };

    static uint32_t gMWInitialise;
    static uint32_t gMWAddAlloc;
    static uint32_t gMWDealloc;
    static uint32_t gMWClose;
    static HWND* gMWWindow;
    static void* m_Process;

    void MWInit(uint32_t start, uint32_t end, uint32_t numAllocs);
    void MWAlloc();
    void MWDeallocate();
    void MWOpen();
    void MWClose();
    void MWInitMessageIDs();
};

struct CAL1_InstanceRecord
{
    uint32_t m_InstanceValue;
    uint32_t m_RuntimeID;
    CAL1_AudioItem* m_AudioItem;

    void Clear();
    void CAL1_InstanceRecord();
};

enum ThreadStatus
{
    NOT_STARTED,
    STARTED,
    ACTIVE,
    BEING_KILLED,
    KILLED,
};

struct CoreNetDevice
{
    enum
    {
        INVALID_SOCKET = 255,
        SOCKET_ERROR = 255,
    };

    struct CorePacketHeader
    {
        uint32_t m_ID;
        uint32_t m_PacketChecksum;
        uint32_t m_To;
        uint32_t m_From;
        uint32_t m_Size;
        uint32_t m_Type;
        uint32_t m_Code;
        uint32_t m_TimeStamp;
    };

    struct CorePacket : CoreNetDevice::CorePacketHeader
    {
        uint32_t m_Data[1];
    };

    struct Core_in_addr
    {
        CoreNetDevice::Core_in_addr::__unnamed S_un;
    };

    struct Core_sockaddr_in
    {
        int32_t sin_family;
        uint32_t sin_port;
        CoreNetDevice::Core_in_addr sin_addr;
        char sin_zero[8];
    };

    struct Core_sockaddr
    {
        uint32_t sa_family;
        char sa_data[14];
    };

    static uint32_t HANDSHAKE_PROTOCOL;
    static uint32_t SYNC_QUERY;
    static uint32_t SYNC_STATE;
    static uint32_t LOBBY_PROTOCOL;
    static uint32_t ARE_YOU_A_SERVER;
    static uint32_t I_AM_A_SERVER;
    static uint32_t JOIN_GAME;
    static uint32_t YOU_HAVE_BEEN_JOINED;
    static uint32_t YOU_HAVE_BEEN_REJECTED;
    static uint32_t LEAVING_GAME;
    static uint32_t START_GAME;
    static uint32_t NETWORK_PLAYER_INFO;
    static uint32_t NETWORK_PLAYER_INFO_REQUEST;
    static uint32_t KEEP_ALIVE;
    static uint32_t KEEP_ALIVE_QUERY;
    static uint32_t KEEP_ALIVE_REPLY;
    static uint32_t HEARTBEAT;
    CoreNetDeviceInternalData* m_Data;

    // TODO vtable

    void CoreNetDevice();
    void ~CoreNetDevice();
    CoreNetDevice* InstantiateDevice(CoreMemory* io_Memory, CoreHash& i_Type);
    void Construct(CoreMemory* i_Memory);
    void Destruct(CoreMemory* i_Memory);
    void Init(CoreNet::DeviceInitialisationData* i_Init);
    void Shutdown();
    void Reset();
    char* GetIPAddress(uint32_t i_IPAddress);
    uint32_t GetHostIPAddress();
    bool IsValid();
    void SetNetworkDeviceIsValid();
    void SetAcceptBroadcastPackets(bool i_Accept);
    bool GetAcceptBroadcastPackets();
    void SendPacket(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
    void SendCodedPacket(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
    void BroadcastPacket(CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
    void BroadcastCodedPacket(CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
    void SendPacketInternal(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength, bool i_IsCoded);
    uint32_t GetCode();
    float GetHandshakePingInterval();
    void SetHandshakePingInterval(float i_DesiredSeconds);
    float GetKeepAlivePingInterval();
    void SetKeepAlivePingInterval(float i_DesiredSeconds);
    float GetKeepAliveMaxTimeout();
    void SetKeepAliveMaxTimeout(float i_DesiredMaxTimeout);
    float GetKeepAliveForLobbyMaxTimeout();
    void SetKeepAliveForLobbyMaxTimeout(float i_DesiredMaxTimeout);
    float GetConnectionReliability();
    void SetConnectionReliability(float i_DesiredPercentage);
    uint32_t GetGameHash();
    void SetGameHash(uint32_t i_Hash);
    uint32_t GetSendMessagesQueued();
    uint32_t GetSendMessagesSent();
    CoreNetDevice::CorePacket* GetNextUnsentPacket();
    void SetHostIPAddress(uint32_t i_IPAddress);
    bool IsPacketWaiting();
    uint32_t GetPacketFromAddress();
    uint32_t GetPacketType();
    void* GetPacketData();
    void NextPacket();
    void IgnoreRestOfPackets();
    uint32_t htons();
    uint32_t htonl();
    int32_t recvfrom();
    int32_t sendto();
    uint32_t inet_addr();
    void IncrementCodedMessageSendStats(CoreNetDevice::CorePacket* i_Packet);
    void IncrementNormalMessageSendStats(CoreNetDevice::CorePacket* i_Packet);
    void SetCoreNetLatency(uint32_t i_Latency);
    void SetServerIPAddress(uint32_t i_IPAddress);
    uint32_t GetNumberOfNetworkPlayers();
    uint32_t GetNetworkPlayerIPAddress(int32_t i_PlayerIndex);
    char* GetNetworkPlayerName(int32_t i_PlayerIndex);
    uint32_t GetNetworkPlayerColour(int32_t i_PlayerIndex);
    void ProcessHandshake(CoreNetDevice::CorePacket* i_Packet);
    CoreNet::CoreNetAsynchronous SetAsynchronousTimeout(float i_Seconds);
    void ClearAsynchronousTimeout();
    CoreNet::CoreNetAsynchronous GetAsynchronousStatus();
    CoreNet::CoreNetAsynchronous IsServerReady();
    CoreNet::CoreNetAsynchronous AreClientsReady();
    void SetSyncState(CoreNet::CoreNetSyncState i_SyncState);
    void SendSyncState();
    void SetSendSyncState();
    void SetSyncStateCache(CoreNet::CoreNetSyncState i_SyncState);
    CoreNet::CoreNetSyncState GetSyncState();
    CoreNet::CoreNetSyncState GetNetworkPlayerSyncState();
    void ProcessLobby(CoreNetDevice::CorePacket* i_Packet);
    void FindServers();
    void JoinServer(uint32_t i_ServerIPAddress);
    void ClearDiscoveredServersList();
    uint32_t GetDiscoveredServerCount();
    CoreNet::CoreNetServer* GetDiscoveredServerList();
    void LeaveGame();
    void RemovePlayer(uint32_t i_IPAddress);
    void SendNetworkPlayerList();
    void SendStartGame();
    bool GameJoined();
    bool GameRejected();
    void ClearNetworkPlayerList();
    bool GetConnectedState();
    int32_t GetPlayerID(uint32_t i_IPAddress);
    int32_t GetServerID();
    bool IsServer();
    bool IsClient();
    void SetCoreNetInstance(CoreNet* i_CoreNet);
    bool GetWLANSwitchOnState();
    void ErrorDialogue();
    void DoDebug(CoreDebugInput* i_Input, float i_Timestamp);
    void DoDebug_General(CoreDebugInput* i_Input, float i_Timestamp);
    void DoDebug_GameState(CoreDebugInput* i_Input, float i_Timestamp);
    void DoDebug_CodedMessages(CoreDebugInput* i_Input, float i_Timestamp);
    void DrawRXTXActivity(CoreGraphicsDevice* i_GraphicsDevice);
    char* DecodeSyncState(CoreNet::CoreNetSyncState i_SyncState);
    char* DecodeCoreHash(uint32_t i_CoreHash);
    void ProcessInbound(CoreNetDevice::CorePacket* i_Packet, uint32_t i_Length);
    void Update();
    void UpdateWhenBlocked(void* i_callBackUserData);
    CoreNetDevice* InstantiatePlatformSpecificDevice(CoreMemory* io_Memory, CoreHash& i_Type);
};

struct CoreNetNetworkPlayer
{
    enum NETWORK_PLAYER_FLAGS
    {
        SERVER,
        TEMPORARY_NAME,
    };

    uint32_t m_IPAddress;
    CoreNet::CoreNetSyncState m_SyncState;
    float m_TimeLastMessageReceived;
    float m_TimeLastMessageSent;
    uint32_t m_Flags;
    uint32_t m_Colour;
    char m_Name[100];
};

struct CoreNetDeviceInternalData
{
    CoreNet* m_CoreNet;
    uint32_t m_HostIPAddress;
    uint32_t m_SendBuffers[128][1024];
    uint32_t m_SendMessagesSent;
    uint32_t m_SendMessagesQueued;
    uint32_t m_ReceiveBuffers[128][1024];
    uint32_t m_ReceiveMessagesRead;
    uint32_t m_ReceiveMessagesQueued;
    uint32_t m_CodedBuffers[24][1024];
    uint32_t m_CodedMessagesQueued;
    float m_CodedMessageLastSendTime;
    bool m_AcceptBroadcastPackets;
    bool m_NetworkDeviceIsValid;
    uint32_t m_GameHash;
    float m_ConnectionReliability;
    float m_HandshakePingInterval;
    float m_KeepAlivePingInterval;
    float m_KeepAliveMaxTimeout;
    float m_KeepAliveMaxTimeoutReset;
    float m_KeepAliveMaxTimeoutForLobby;
    float m_ResetTime;
    float m_SendTime;
    uint32_t m_PacketNumber;
    CoreNetNetworkPlayer* m_NetworkPlayer;
    uint32_t m_NetworkPlayerCount;
    CoreNet::CoreNetServer m_Server[8];
    uint32_t m_ServerCount;
    bool m_GameJoined;
    bool m_GameRejected;
    float m_LobbyLastAction;
    uint32_t m_SynchronisationID;
    float m_AsynchronousStartTime;
    float m_AsynchronousTimeoutPeriod;
    float m_AsynchronousLastAction;
    CoreNet::CoreNetAsynchronous m_AsynchronousStatus;
    float m_StatTimestamp;
    uint32_t m_StatCodedMessageSendCount;
    uint32_t m_StatCodedBytesSent;
    uint32_t m_StatCodedMessageReceiveCount;
    uint32_t m_StatCodedBytesReceived;
    uint32_t m_StatNormalMessageSendCount;
    uint32_t m_StatNormalBytesSent;
    uint32_t m_StatNormalMessageReceiveCount;
    uint32_t m_StatNormalBytesReceived;
    uint32_t m_StatCodedMessageSendCountTotal;
    uint32_t m_StatCodedBytesSentTotal;
    uint32_t m_StatCodedMessageReceiveCountTotal;
    uint32_t m_StatCodedBytesReceivedTotal;
    uint32_t m_StatNormalMessageSendCountTotal;
    uint32_t m_StatNormalBytesSentTotal;
    uint32_t m_StatNormalMessageReceiveCountTotal;
    uint32_t m_StatNormalBytesReceivedTotal;
    uint32_t m_StatLastSentCodedPacketTo;
    uint32_t m_StatLastSentCodedPacketSize;
    uint32_t m_StatLastSentCodedPacketType;
    uint32_t m_StatLastRecvCodedPacketFrom;
    uint32_t m_StatLastRecvCodedPacketSize;
    uint32_t m_StatLastRecvCodedPacketType;
    uint32_t m_StatLastSentNormalPacketTo;
    uint32_t m_StatLastSentNormalPacketSize;
    uint32_t m_StatLastSentNormalPacketType;
    uint32_t m_StatLastRecvNormalPacketFrom;
    uint32_t m_StatLastRecvNormalPacketSize;
    uint32_t m_StatLastRecvNormalPacketType;
    uint32_t m_StatRemoteReceivedMessageCount;
    uint32_t m_StatRemoteSentMessageCount;
    uint32_t m_StatCoreNetLatency;
    uint32_t m_StatCoreNetLatencyHighWatermark;
    uint32_t m_StatCoreNetLatencyLowWatermark;
};

struct CoreNetDevicePC : CoreNetDevice
{
    CoreNetDevicePCInternalData* m_DeviceSpecificData;

    void CoreNetDevicePC();
    void ~CoreNetDevicePC();
    void Construct(CoreMemory* i_Memory);
    void Destruct(CoreMemory* i_Memory);
    void Init(CoreNet::DeviceInitialisationData* i_Init);
    void Shutdown();
    uint32_t GetHostIPAddress(char* i_HostName);
    uint32_t htons(uint32_t i_hostshort);
    uint32_t htonl(uint32_t i_hostlong);
    int32_t recvfrom(uint32_t i_Socket, char* o_Buffer, int32_t i_BufferLength, int32_t i_Flags, CoreNetDevice::Core_sockaddr* o_From, int32_t* io_FromLength);
    int32_t sendto(uint32_t i_Socket, char* i_Buffer, int32_t i_BufferLength, int32_t i_Flags, CoreNetDevice::Core_sockaddr* i_To, int32_t i_ToLength);
    uint32_t inet_addr(char* i_IPAddress);
    int32_t WSAGetLastError(char** o_Message);
    void ReceiveThread();
    void SendThread();
    void KillThreads();
    bool InitTCPIPStack();
    bool InitSocket();
};

struct CoreNetDevicePCInternalData
{
    WSAData m_WinSockData;
    uint32_t m_Socket;
    uint32_t m_NetworkAdapter;
    ThreadStatus m_ReceiveThreadStatus;
    ThreadStatus m_SendThreadStatus;
};

struct CoreNetInternalData
{
    bool m_FindServersState;
    bool m_GameJoinedState;
    bool m_HostGameState;
    bool m_AcceptBroadcastPacketsState;
    bool m_ClearNetworkList;
    bool m_ConnectionLostState;
    uint32_t m_NumberOfPlayers;
    bool m_Connected;
    bool m_IsNetworkGame;
    bool m_IsServer;
    bool m_IsClient;
    bool m_IsValid;
    bool m_IsInLobby;
    bool m_WLANSwitchOnState;
    bool m_ShowWLANSwitchDialogue;
    bool m_StartGameState;
    int32_t m_ServerID;
    float m_AsynchronousTimeout;
    int32_t m_AsynchronousStatus;
    uint32_t m_GameSpecificServerData;
    CoreNet::CoreNetSyncEventState m_SyncEventStatus;
};

struct CoreNetDeviceNULL : CoreNetDevice
{
    void CoreNetDeviceNULL();
    void ~CoreNetDeviceNULL();
    void Init(CoreNet::DeviceInitialisationData* i_Init);
    void Shutdown();
    uint32_t GetHostIPAddress(char* i_HostName);
    uint32_t htons(uint32_t hostshort);
    uint32_t htonl(uint32_t hostlong);
    int32_t recvfrom(uint32_t i_Socket, char* o_Buffer, int32_t i_BufferLength, int32_t i_Flags, CoreNetDevice::Core_sockaddr* o_From, int32_t* io_FromLength);
    int32_t sendto(uint32_t i_Socket, char* i_Buffer, int32_t i_BufferLength, int32_t i_Flags, CoreNetDevice::Core_sockaddr* i_To, int32_t i_ToLength);
    uint32_t inet_addr(char* i_IPAddress);
};

enum CoreNetDevice::DoDebug_General::__l2::__unnamed
{
    SIMULATED_RELIABILITY,
    HANDSHAKE_PING_INTERVAL,
    KEEP_ALIVE_PING_INTERVAL,
    KEEP_ALIVE_MAX_TIMEOUT,
    KEEP_ALIVE_FOR_LOBBY_MAX_TIMEOUT,
    PARAM_MAX,
};

enum CoreNetDevice::DoDebug::__l2::__unnamed
{
    GENERAL_INFO,
    PLAYER_INFORMATION,
    CODED_MESSAGES_INFO,
};

struct CoreNetLobbyMessage
{
    uint32_t m_Type;
    float m_TimeStamp;
    CoreNet::CoreNetServer m_Server;
    CoreNetLobbyPlayer m_PlayerInfo[1];
};

struct CoreNetLobbyPlayer
{
    uint32_t m_IPAddress;
    uint32_t m_Flags;
    uint32_t m_Colour;
    char m_Name[100];
};

struct CoreNetSyncMessage
{
    uint32_t m_MessageType;
    CoreNet::CoreNetSyncState m_SyncState;
    uint32_t m_SyncID;
};

struct _startupinfo
{
    int32_t newmode;
};

struct TypeDescriptor
{
    uint32_t hash;
    void* spare;
    char name[0];
};

struct _s_CatchableType
{
    uint32_t properties;
    TypeDescriptor* pType;
    PMD thisDisplacement;
    int32_t sizeOrOffset;
    void* copyFunction;
};

struct PMD
{
    int32_t mdisp;
    int32_t pdisp;
    int32_t vdisp;
};

struct _s_CatchableTypeArray
{
    int32_t nCatchableTypes;
    _s_CatchableType* arrayOfCatchableTypes[0];
};

struct _s_ThrowInfo
{
    uint32_t attributes;
    void* pmfnUnwind;
    int32_t* pForwardCompat;
    _s_CatchableTypeArray* pCatchableTypeArray;
};

struct EHExceptionRecord
{
    struct EHParameters
    {
        uint32_t magicNumber;
        void* pExceptionObject;
        _s_ThrowInfo* pThrowInfo;
    };

    uint32_t ExceptionCode;
    uint32_t ExceptionFlags;
    _EXCEPTION_RECORD* ExceptionRecord;
    void* ExceptionAddress;
    uint32_t NumberParameters;
    EHExceptionRecord::EHParameters params;
};

union FT
{
    uint32_t ft_scalar;
    _FILETIME ft_struct;
};

enum _RTC_ErrorNumber
{
    _RTC_CHKSTK,
    _RTC_CVRT_LOSS_INFO,
    _RTC_CORRUPT_STACK,
    _RTC_UNINIT_LOCAL_USE,
    _RTC_ILLEGAL,
};

uint32_t g_maxMeshes;
char* animSequencerAssetTypeName;
uint32_t m_indexArray[208];
CoreProfileEntry* CoreDebug::m_lpoPreviousProfileEntry;
void* $S84;
void* $S84;
void* $S84;
uint32_t CORE_BIT_TABLE[32];
GLUquadric* g_lpoQuadric;
void* m_pExitCallBack;
void* $S159;
CoreRGBA CA_Colour_BlueViolet;
void* $S156;
void* $S150;
void* $S153;
uint32_t $S152;
CoreHash ANIMSTATE_WOLF_RUNATTACK_HASH;
uint32_t $S94;
CoreHash TRHashes::FXE_FLAMETORCH0_HASH;
void* $S15;
void* $S15;
void* $S15;
void* $S15;
void* $S15;
void* $S15;
void* $S15;
void* $S15;
uint32_t $S15;
void* $S15;
void* $S15;
void* $S15;
uint32_t $S15;
void* $S15;
uint32_t $S15;
void* $S15;
uint32_t $S15;
void* $S15;
uint32_t $S15;
void* $S15;
void* $S15;
void* $S15;
void* $S15;
void* $S15;
void* $S258;
char* CAL1_AudioItem::m_TypeNames[19];
void* $S255;
int32_t fxBlowyParticle1[20];
void* $S252;
int32_t fxDumbBubble0[30];
int32_t fxDumbBubble1[36];
TRBiteInfo npierre_gun1;
CoreHash ANIMSTATE_ROLL_OUT_HASH;
int32_t fxExplosionTendril[26];
CoreStringBuffer<256> BuildSystemHelper::m_optionsFileName;
uint32_t $S25;
void* $S25;
void* $S25;
int32_t fxMuzzleFlare[8];
CoreHash LEFTGAME;
bool CoreInit::m_forceItalian;
void* $S357;
void* $S354;
char* CA_PLAT_TEXT[14];
bool CoreInit::m_forceEUR;
void* $S351;
int32_t CAL0_Util::m_Tick[8];
bool CoreGameMessageBox::m_overrideActive;
float lpfCoordsOpenBracket[8];
CoreHash TRHashes::ANIMSTATE_START_HASH;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
float CORE_DISTANCE_TO_TRIANGLE_THRESHOLD;
int32_t fxDartEmit[39];
int32_t fxDartEmit[0];
CoreHash TRHashes::PANEL_COMPONENT_AMMOCLIP;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
float FIXED_ALPHA_SCALE;
void* $S35;
void* $S35;
void* $S35;
void* $S459;
tagRECT m_windowPosition;
tagRECT m_windowPosition;
CoreRGBA CA_Colour_Chocolate;
float CoreKernel::m_elapsedTimeInSeconds;
CoreVector flareVel;
void* $S450;
CoreHash ANIMSTATE_WOLF_STANDTURN_MIRROR_HASH;
void* $S453;
void* $S456;
CoreVector vineBoxes[6][2];
CoreModelMaterial** CoreSceneContainer::m_meshListTable;
int32_t fxFlareGlow0[20];
int32_t CoreGameMessageBox::m_overrideControllerInputIndex;
void* $S45;
void* $S45;
void* $S45;
void* $S45;
void* $S45;
void* $S45;
void* $S45;
void* $S45;
void* $S45;
void* $S45;
int32_t CoreError::s_fatalErrorException;
TRFogBulbStruct g_fogBulbs_10a[5];
float climbWallEdgeUp;
uint32_t CoreInit::m_maxNetworkPlayers;
CoreHash REMOVEDFROMGAME;
void* $S558;
int32_t fxFireSmokeBlackHand[55];
int32_t fxSunGlow2[30];
CoreHash trapDoorAnims[4];
int32_t CAL0_Util::m_Tock[8];
CoreHash ANIMSTATE_ROAR_MIRROR_HASH;
float ARROW_HEAD_LENGTH_IN_SCREEN_UNITS;
void* $S552;
char* pszLoadingScreenName;
void* $S555;
uint32_t* TRTriggerNode::m_pTriggerEventBufferStart;
CoreHash CoreWorld::m_modelCompiledAssetTypeHash;
float distToCorner_ShimmyExternal90;
float distToCorner_ShimmyExternal90;
uint32_t CoreSceneContainer::m_meshGlobalPartitionIndex;
HWND* m_nameDebugHwnd;
uint32_t $S55;
void* $S55;
CoreHash MESSAGE_BOX_HASH;
CoreFXLibrary* CoreFXLibrary::m_pInstance;
CoreHash TRHashes::ANIMSTATE_UNDERWATER_SWITCHHASH;
uint32_t m_currentGroup;
float lpfCoordsN[8];
CoreHash fallingCeilingAnims[3];
CoreRGBA Colour_Green;
CoreFXEmitterItem fxeBeam0NoFlies[2];
CoreKernelTimer CoreKernel::m_timers[4];
int32_t CoreKernel::m_mainFrameRate;
uint32_t CAL0_Util::m_MemoryAllocated;
int32_t fxFireTorchSmall[48];
CoreStringBuffer<256> g_loadingStrings[2];
int32_t fxExplosionStart[27];
CoreHash TRHashes::ANIMSTATE_CONTEXT_WALK_RUN_STANCE;
int32_t fxFlameThrowerFiller[27];
CoreHash CoreInput::CORE_MENU_RIGHT_0;
uint32_t CoreNetDevice::KEEP_ALIVE_QUERY;
char CAL1_AudioDriverPC::exception_string[1024];
bool s_OSKSettingsSaved;
CoreHash TRHashes::WEAPON_DRAW;
void* $S75;
void* $S75;
void* $S75;
CoreHash s_overrideTextureHash;
CoreHash ANIMSTATE_WALK_ATTACK_FRONT_HASH;
int32_t fxGunSmoke[47];
CoreHash TRHashes::CAMERA_LEFTHASH;
TRInvInit inv_magammo_option;
CoreHash TRHashes::ATTRACTOR_INWALLHASH;
_new_audio_info NewAudioInfo[174];
_new_audio_info NewAudioInfo[0];
CoreNetworkDialogInterface* CoreNetworkDialogInterface::m_dummyInstance;
bool TRNode::m_nodeVisibility[11];
char* CA_LANG_TEXT[9];
int32_t* phdMxptr;
CoreHashTable CoreAudio::m_oSoundDatabase;
_DIDATAFORMAT c_dfDIJoystick2;
float CoreTypes::MinFloat64;
CoreOnScreenKeyboardInterface* CoreOnScreenKeyboardInterface::m_gameInstance;
void* $S144;
char CoreTypes::MaxInt8;
CoreGameButtonText CoreGameMessageBox::YesButtonText;
void* $S147;
float NewMidasBounds[12];
void* $S141;
char* lpcHardShader;
CoreHash TRHashes::ANIMSTATE_SWITCH_OFF_HASH;
int32_t fxDartEmitAfterSmoke[34];
int32_t fxDartEmitAfterSmoke[0];
uint32_t $S14;
void* $S14;
uint32_t $S14;
void* $S14;
uint32_t $S14;
void* $S14;
uint32_t $S14;
void* $S14;
uint32_t $S14;
void* $S14;
void* $S14;
char* BSI_REPLY_APP_IS_RUNNING;
char CoreGameOnScreenKeyboardCharacterTable::m_characterTable[60];
HWND* m_hWnd;
HWND* m_hWnd;
float CoreBlender::m_focusBlendStartTime;
uint32_t m_selectedGroupIndex;
void* $S249;
void* $S246;
uint32_t flareLife;
CoreWorld* CoreWorld::m_instance;
void* $S243;
JustConstruct g_jc;
void* $S240;
float NewPickUpBoundsUW[12];
int32_t fxLavaMistParticle[38];
int32_t fxFireTorchHand[50];
CoreHash AE_DAMAGE_WARNING;
CoreFader CoreGameMessageBox::m_overrideFader;
bool g_doAudioLocators;
int32_t fxMuzzleFlare1[10];
CoreFileSystem* CoreFile::s_fileSystem;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
void* $S24;
CoreHash TRHashes::ATTRACTOR_OVERHANGEDGEHASH;
CoreHash animstateStackList[32];
float FR_GRAVITY;
float FR_GRAVITY;
float FR_GRAVITY;
float FR_GRAVITY;
char* MESSAGE_BOX_LOGGER;
bool CoreKernel::m_debugAudioHeap;
void* $S348;
void* $S345;
void* $S342;
bool CoreInit::m_forceGerman;
int32_t fxLavaMist2[46];
int32_t _commode;
int32_t fxLavaMist1[46];
float s_screenTimeOut;
CoreFXEmitterItem fxeSmartSnowSmall[2];
CoreHash TRHashes::ANIMSTATE_MIDDLE_HASH;
CoreHash CoreWorld::m_animationSetAssetTypeHash;
TRFogBulbStruct g_fogBulbs_1[4];
TRTriggerNode::trigEventGroup* m_selectedEventGroup;
void* $S441;
CoreGameOnScreenKeyboardCharacterTable s_oskCharTable;
int32_t gEncodeProgress;
void* $S444;
CoreHash AE_SPEED_BOOST_2_END;
void* $S447;
float lpfCoordsError[10];
CoreHash TRHashes::NPC_MISC_PRIMARY;
int32_t fxFlareGlow1[22];
CoreRGBA Colour_Chocolate;
VineDefinitions vineDefinitions[3];
void* $S44;
void* __rtc_taa[1];
char* scriptStoreAssetTypeName;
CoreHash AE_GROUNDZEROFAIL;
CoreFXEmitterItem fxeSnowGlint[2];
bool CoreScripted::m_ScriptLoggerCreated;
TRBiteInfo nkid_gun1;
TRBiteInfo nkid_gun2;
CoreRGBA CoreDebug::m_oDefaultConsoleColour;
void* $S549;
float NewPuzzleHoleBounds[12];
CoreFXEmitterItem fxeFlameTorchFireFlies[5];
CoreFXEmitterItem fxeBigBeam[3];
CoreRGBA CA_Colour_CornflowerBlue;
CoreNode* CoreNode::m_nodeArray[11];
uint32_t iParentedShader;
void* $S540;
CoreHash TRHashes::ANIMSTATE_CEILING_SMASH_HASH;
void* $S543;
void* $S546;
float* CoreFileDevice::s_GetElapsedTimeFunc;
CoreFXEmitterItem fxeBigBeam1[2];
uint32_t CoreSceneContainer::m_visibleIndexList[256];
float climbWallOffsetDropOffMax;
CoreHash CURRENT_HASH;
void* $S54;
void* $S54;
void* $S54;
void* $S54;
void* $S54;
void* $S54;
void* $S54;
uint32_t $S54;
CoreOnScreenKeyboardInterface* CoreOnScreenKeyboardInterface::m_dummyInstance;
CoreHash AE_SLIDE_GLASS;
char* TRSceneryNode::m_pVineTypeNames[0];
char* TRSceneryNode::m_pVineTypeNames[24];
int32_t fxFlickerGlowSmall[17];
TRInvInit inv_gun_option;
float lpfCoordsO[18];
float CoreInputConnectedControllers::m_lastUpdateTime;
CoreVector BIG_VECTOR;
int32_t fxDart[7];
void* $S64;
bool CoreSceneContainer::m_viewRoomCentric;
float MAX_PITCH;
float MAX_PITCH;
int32_t gDecodeProgress;
float climbWallToShimmyAttractorDistTolerance;
CoreHash TRHashes::ANIMSTATE_WALKHASH;
TRInvInit inv_flare_option;
float lpfCoordsDash[4];
int32_t fxLightningTest[17];
char s_messageBoxBuffer[513];
CoreHash TRHashes::DAMAGEHASH;
CoreHash CoreInput::CORE_MENU_RIGHT_1;
uint32_t FRWorld::PLAYER_DATA_EVENT;
_GUID GUID_SysMouse;
void* $S74;
int32_t fxGroundMistParticleDisturbed[38];
int32_t _fmode;
CoreFXEmitterItem fxeNaziYellowBeam[2];
int32_t fxFlareSmoke[0];
int32_t fxFlareSmoke[38];
CoreHash FATAL_ERROR_HASH;
uint32_t CoreAnimSequencer::s_animSeqID;
CoreHash TRHashes::MIDWAYHASH;
float NO_FLOOR;
float NO_FLOOR;
float NO_FLOOR;
float NO_FLOOR;
float NO_FLOOR;
float NO_FLOOR;
float CoreTypes::MaxFloat32;
uint32_t $S86;
int32_t fxFireDrip[30];
TRHitItem TRHitItem::m_itemArray[1024];
CoreHash CoreInput::CORE_MENU_SELECT_0;
CoreHash CoreInput::CORE_MENU_SELECT_1;
int32_t fxFireDripSlave[27];
void* __rtc_iaa[1];
CoreHash g_elementHashes[4];
CoreRGBA Colour_Red;
TRInvInit inv_grcrys_option;
CoreFileDevice* CoreKernel::m_fileDevice;
void* $S174;
void* $S177;
void* $S171;
uint32_t activeModel;
float g_ellipseRotation;
CoreHash TRHashes::ENDHASH;
CoreHash TRHashes::ATTRACTOR_EDGEHASH;
CoreGameButtonText CoreGameOnScreenKeyboard::DoneButtonText;
void* $S96;
void* $S96;
void* $S96;
uint32_t iStaticShader;
bool TRNode::m_bUsingEditor;
uint32_t CoreAudio::m_LastSurfaceType;
CoreMessageBoxDummyInterface s_dummyInstance;
CoreSaveGameDummyInterface s_dummyInstance;
CoreNetworkDialogDummyInterface s_dummyInstance;
_GUID DS3DALG_HRTF_LIGHT;
int32_t CoreLevel::s_occluderValidIndexes[256];
void* $S17;
uint32_t $S17;
void* $S17;
uint32_t $S17;
void* $S17;
void* $S17;
void* $S17;
void* $S279;
float lpfCoordsQuestion[12];
CoreHash CoreWorld::m_fontAssetTypeHash;
void* $S276;
float headHeight;
CoreHash g_hyperride;
void* $S273;
void* $S270;
_GUID IID_IDirectSound3DBuffer;
void* __xc_a[0];
void* __xc_a[1];
CoreHash TRHashes::RESET_ORIENTHASH;
float lpfCoordsPlus[4];
bool CoreInit::m_movieTestLoop;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S27;
void* $S378;
int32_t fxReticule[14];
int32_t CoreInit::m_argc;
void* $S375;
void* $S372;
int32_t g_count;
CoreHash TRHashes::NPC_ANIMTYPE_IDLE;
CoreHash ANIMSTATE_WOLF_RUNTURN_MIRROR_HASH;
CoreHash fallingBlockAnims[4];
int32_t NodeDialog_SpecificDlgItems[68];
CoreHash TRHashes::ACTION_WALKHASH;
void* $S37;
int32_t fxLaserGlare2[14];
TRFogBulbStruct g_fogBulbs_2[2];
CoreGameButtonText CoreGameMessageBox::NoButtonText;
void* $S471;
uint32_t CoreNetDevice::KEEP_ALIVE;
void* $S474;
void* $S477;
bool CoreFileSystem::m_absoluteFileAccess;
CoreHash TRHashes::WEAPON_FIRE;
CoreHash AE_CHECKPOINTHIT;
CoreHash ANIMSTATE_FLY_HASH;
int32_t fxFlareGlow2[16];
int32_t fxLaserGlare[13];
char* CoreFX::s_PrimNames[5];
uint32_t $S47;
uint32_t CoreNetDevice::JOIN_GAME;
CoreHash ANIMSTATE_FIRE_LOOP_OFF_HASH;
void* $S579;
int32_t fxSunGlow[30];
float frun2;
bool g_performanceFrequencyInit;
CoreGameButtonText CoreGameOnScreenKeyboard::SpaceButtonText;
void* $S570;
void* $S573;
CoreHash TRHashes::ANIMSTATE_CONTEXT_JUMPS;
uint32_t irun1;
void* $S576;
int32_t fxLaserGlareFlat[12];
uint32_t TREdItemNode::m_createCount;
CoreHash TRHashes::PANEL_COMPONENT_HEALTHBAROVERLAY;
void* $S57;
void* $S57;
void* $S57;
void* $S57;
void* $S57;
void* $S57;
uint32_t $S57;
void* $S57;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
float CURVEDATA_GRIDSIZE;
bool CoreGraphicsDeviceOpenGL::m_fullScreen;
CoreHash TRHashes::ANIMSTATE_CONTEXT_STEPS;
CoreFX* CoreFX::m_pInstance;
int32_t CoreGameOnScreenKeyboardCharacterTable::m_characterTableEntries;
CoreHash g_clavicle_L_hash;
float fMillion;
float lpfCoordsL[6];
CoreGameButtonText CoreGameMessageBox::RetryButtonText;
void* $S67;
CoreLevel* CoreLevel::m_instance;
TRInvInit inv_compass_option;
uint32_t CoreNetDevice::LEAVING_GAME;
char* NETWORK_LOGGER_NAME;
CoreHash TRHashes::ATTRACTOR_LASTCHANCEGRABHANGEDGEHASH;
CoreHash TRHashes::ANIMSTATE_PULL_HASH;
CoreSceneClip CoreSceneContainer::m_sceneClip[256];
uint32_t CAL0_Util::m_NumDeAllocs;
CoreHash ANIMSTATE_WOLF_STALK_HASH;
CoreHash CoreFont::m_circleButtonHash;
float g_ellipseXPos;
TRInvInit inv_scion_option;
CoreFXEmitterItem fxeDumbBubbles1[2];
CoreFXEmitterItem fxeDumbBubbles0[5];
bool CoreInit::m_useAudio;
CoreHash TRHashes::BACKWARDABSHASH;
bool g_stopControl;
bool ItemsDialogUpdate;
CoreHash TRHashes::ANIMSTATE_CLOSED_HASH;
void* $S87;
void* $S87;
void* $S87;
int32_t fxFireTest[26];
uint32_t FRWorld::PLAYER_DATA_EVENT_ID;
uint32_t PAUSE_EVENT;
bool g_performanceFrequencyValid;
void* CoreRegistryPC::m_defaultMasterKeyHandle;
void* $S168;
CoreHash TRHashes::LEFTHANDHASH;
void* $S165;
CoreHash TRHashes::LEFTUPLEGHASH;
void* $S162;
uint32_t $S97;
uint32_t CoreLevelCompiled::s_levelCompiledID;
HWND* MW::gMWWindow;
bool CoreInitPC::m_build;
CoreHash CoreInput::CORE_MENU_UP_1;
CoreHash CoreAudio::m_MusicHash;
CoreHash CoreInput::CORE_MENU_UP_0;
uint32_t $S16;
uint32_t $S16;
uint32_t $S16;
uint32_t $S16;
uint32_t $S16;
int32_t fxSmartSnowRad1[38];
int32_t fxSmartSnowRad2[38];
CoreRGBA oTextColour;
CoreHash TRHashes::LEFTRELHASH;
bool bIgnore2;
void* $S267;
void* $S264;
float lpfCoordsDoubleQuote[4];
void* $S261;
void* __xi_z[0];
void* __xi_z[1];
CoreHash DEFAULT_LOGGER_HASH;
TRBiteInfo npierre_gun2;
CoreHash movingBlockAnims[3];
CoreHash ANIMSTATE_180_TURN_MIRROR_HASH;
char* NETWORK_CLIENT_LOGGER_NAME;
CoreHash AE_SCORELOOPLARGE;
char* CoreNode::m_nodeTypeNames[15];
char* CoreNode::m_nodeTypeNames[0];
CoreHash AE_FIREWORK;
void* $S26;
void* $S369;
CoreHash TRHashes::ANIMSTATE_DROP_LOOPHASH;
CoreGameMessageBoxButtons CoreGameMessageBox::m_overrideButtons;
void* $S366;
void* $S363;
CoreHash TRHashes::FX_RETICULE_HASH;
void* $S360;
CoreHash ANIMSTATE_DART_DEACTIVATE_HASH;
CoreHash TRHashes::FXE_FLAMETORCH0_FIREFLIES_HASH;
bool CoreInit::m_isPoweringOff;
uint32_t CoreClusterData::s_clusterID;
CoreHash BOTTOMOFLIST_HASH;
CoreRGBA s_overrideButtonColourWhite;
CoreHash TRHashes::LOWER_EXTERNAL_VELOCITYHASH;
void* $S36;
void* $S36;
void* $S36;
void* $S36;
void* $S36;
void* $S36;
void* $S36;
void* $S36;
void* $S36;
void* $S36;
void* $S468;
CoreHash ANIMSTATE_START_HASH;
char* modelCompiledAssetTypeName;
void* $S462;
void* $S465;
uint32_t CoreLED::m_nestStack[32];
CoreHash TRHashes::PANEL_COMPONENT_BULLET;
_DIDATAFORMAT c_dfDIMouse2;
void* $S46;
void* $S46;
uint32_t CoreAudio::m_LastMenuMusicVolume;
TRFogBulbStruct g_fogBulbs_10b[2];
int32_t g_asyncStartOffset;
TRNode::stringInfo TRNode::m_stringInfo;
CoreCreatureJumpDef sCreatureJumpDefs[0];
CoreCreatureJumpDef sCreatureJumpDefs[5];
CoreHash TRHashes::ANIMSTATE_SAVE_START_HASH;
void* $S561;
TRInvInit inv_magnum_option;
CoreHash TRHashes::ANIMSTATE_JUMP_RIGHT_MIDDLE;
void* $S564;
bool CoreInit::m_forceUSA;
CoreHash TRHashes::LEFTARMSLOTHASH;
void* $S567;
int32_t CoreInputConnectedControllers::m_startupDelay;
uint32_t CoreAudio::m_LastMenuSpeechVolume;
CoreHash CoreWorld::m_textureSetAssetTypeHash;
CoreHash TRHashes::ANIMSTATE_JUMP_BACK_MIDDLE;
CoreHash g_hairBonesTable[7];
CoreHash TRHashes::ANIMSTATE_OFF_HASH;
uint32_t CoreAudio::m_MusicDuckPercentage;
uint32_t $S56;
CoreHash TRHashes::RIGHTHANDHASH;
TRFogBulbStruct g_fogBulbs_3a[7];
TRFogBulbStruct g_fogBulbs_3b[2];
int32_t fxLightningTestFade2[35];
uint32_t MW::gMWAddAlloc;
float lpfCoordsM[10];
CoreHash TRHashes::ACTION_ACTION_CLICKHASH;
_GUID IID_IDirectSound3DListener;
void* $S66;
void* $S66;
void* $S66;
void* $S66;
void* $S66;
void* $S66;
void* $S66;
char* FATAL_ERROR_LOGGER;
CoreHash g_animstateJumpRunBadLandHash;
int32_t CoreSceneContainer::m_containerListStart;
TRBiteInfo nCentaur_rear;
char* DEFAULT_LOGGER;
char* EventTypeNames[13];
CoreFXEmitterItem fxeSmallSplash[2];
CoreHash TRHashes::ANIMSTATE_LARA_CRYSTAL_RELEASE;
CoreHash TRHashes::ACTION_BACKWARDRELHASH;
int32_t fxDistortRainMove[16];
TRInvInit inv_explosiv_option;
char* a_rootString;
CoreHash TRHashes::RESET_DETECTIONHASH;
char* CoreAudio::m_SampleItemData;
CoreHash CoreFont::m_crossButtonHash;
CoreHash TRHashes::RIGHTUPLEGHASH;
CoreVector CoreDebug::m_vConsoleCurrentPos;
char* lpcStaticShader;
void* $S76;
float g_ellipseYPos;
CoreHash g_animstateBackwardWipeoutHash;
int32_t fxSmartBubbleNoRipple[25];
bool CoreInitPC::m_useDebugAudioMemory;
void* $S80;
uint32_t CAL0_File::m_NumOpenRequests;
int32_t fxFireLeap[29];
float CoreTypes::MinFloat32;
CoreNode* m_pListNodeArray[2048];
CoreFXEmitterItem fxeSmartSnowLarge[2];
CoreHash raptorStance;
uint32_t SLIDE_TYPE_CONCRETE;
int32_t fxFireLeapSlave[21];
uint32_t $S119;
char* CoreKernel::m_globalClusterName;
float climbWallMaxNormalDistDiff;
TRInvInit inv_gunammo_option;
void* $S114;
void* $S117;
void* $S111;
int32_t CoreObjectController::s_memoryPoolSize;
CoreHash TRHashes::FORWARDABSHASH;
TRInvInit inv_title_sound;
TRInvInit inv_shotgun_option;
bool CoreAudio::m_MusicVolumeChanged;
void* $S90;
void* $S90;
void* $S90;
float m_storedGreen;
CoreHash ANIMSTATE_ATTACK_HASH;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
void* $S11;
uint32_t $S11;
void* $S11;
uint32_t $S11;
uint32_t $S11;
void* $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
void* $S11;
uint32_t $S11;
void* $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
uint32_t $S11;
void* $S11;
void* $S11;
CoreHash TRHashes::ANIMSTATE_SURFACE_TREADHASH;
int32_t fxSmartSnowRad05[38];
uint32_t startActiveModel;
uint32_t $S218;
TRGlobals G;
void* $S219;
void* $S216;
CoreHash CoreInput::CORE_MENU_START_0;
CoreHash TRHashes::ANIMSTATE_SAVE_NO_HASH;
uint32_t bNoFXRender;
void* $S213;
void* $S210;
char* BSI_ASK_BUILD_PREFIX;
void* CoreInputConnectedControllers::m_callBackUserData;
float pup_y;
float pup_x;
CoreHash CoreGameText::m_hashFileName[5];
float pup_z;
int32_t s_OSKResult;
int32_t lFirstCount;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
void* $S21;
CoreModelMaterial* m_pUpdateMaterials[1024];
CoreHash TRHashes::FLOWHASH;
CoreHash ANIMSTATE_SHOOT_LOOP_HASH;
CoreHash ANIMSTATE_DOOR_SMASH_HASH;
CoreFileDevice* CoreCluster::s_device;
_GUID GUID_SysKeyboard;
void* $S318;
CoreHash TRHashes::RIGHTABSHASH;
CoreHash ANIMSTATE_WOLF_JUMPDNSTART_HASH;
void* $S315;
void* $S312;
CoreVector CoreSceneContainer::m_dynamicLightPos[2];
CoreHash TRHashes::FXE_WATERMIST_HASH;
uint32_t CoreGraphicsDeviceOpenGL::m_screenHeight;
CoreHash TRHashes::FX_BULLETCASING_HASH;
char CoreHashDebugString::m_defaultBuffer[28672];
uint32_t CAL0_File::m_NumCloseRequests;
int32_t fxSplashBigFloorSlave[34];
void* $S31;
float CoreAudio::m_MenuSpeechVolume;
uint32_t TRETriggerNode::m_createCount;
TRFogBulbStruct g_fogBulbs_4[2];
uint32_t CoreNetDevice::HEARTBEAT;
CoreRGBA Colour_CornflowerBlue;
void* $S411;
void* $S414;
void* $S417;
bool CoreInit::m_useNetwork;
TRObjectDB gObjectDB;
void* $S41;
void* $S41;
CoreHash TRHashes::FXE_DUMBBUBBLES0_HASH;
CoreGameButtonText CoreGameOnScreenKeyboard::CancelButtonText;
void* g_asyncHandle;
TRBiteInfo nWarrior_shard;
int32_t fxFireBallSmokeSlave[14];
void* $S519;
TRBiteInfo nWarrior_bite;
CoreHash CoreWorld::m_levelAssetTypeHash;
TRTriggerNode::trigEventGroupUpdate TRTriggerNode::m_trigEventGroupUpdateList[32];
_GUID DS3DALG_HRTF_FULL;
CoreHash TRHashes::ANIMSTATE_LARA_USE_GREEN_CRYSTAL;
void* $S510;
void* $S513;
playerBurnBonePairs playerBurnBonePairTable[17][2];
float CoreAudio::m_MenuMusicVolume;
void* $S516;
CoreHash ANIMSTATE_WOLF_SPINE_HASH;
void* $S51;
void* $S51;
void* $S51;
void* $S51;
void* $S51;
void* $S51;
void* $S51;
void* $S51;
void* $S51;
void* $S51;
void* $S618;
void* $S612;
TRRoomEffects g_roomEffects;
CoreHash TRHashes::CAMERA_UPHASH;
_GUID GUID_NULL;
float lpfCoordsZ[8];
uint32_t CoreNetDevice::START_GAME;
float lpfCoordsJ[12];
void* $S615;
CoreRegistryInterface* CoreInit::m_registryInterface;
int32_t fxLaserGlareFlatFlare[11];
CoreHash TRHashes::RAGDOLL_DAMAGEFULLHASH;
int32_t fxBulletCasing[20];
char* BSI_ASK_IS_APP_READY;
CoreVector CoreDebug::m_vConsoleLineSize;
CoreHash TRHashes::ANIMSTATE_OPEN_HASH;
CoreMessageBoxInterface* CoreMessageBoxInterface::m_gameInstance;
CoreHash AE_MAXFLOW_LOOP;
char CoreKernel::m_secondLevelClusterName[256];
CoreHash TRHashes::ANIMSTATE_HINT_READ_CROUCHING_HASH;
CoreHash TRHashes::BACKGROUNDHASH;
CoreHash ENDOFLIST_HASH;
int32_t fxUnderwaterBlood[63];
int32_t fxDustflyParticleSubII[67];
TRTriggerController gTriggerController;
int32_t fxDustCloud[77];
TRAttractors gAttractors;
CoreHash TRHashes::FUNCTIONHASH;
CoreHash ANIMSTATE_REAR_UP_ATTACK_MIRROR_HASH;
CoreHash TRHashes::SET_JUMP_VELOCITYHASH;
CoreStringBuffer<256> CoreFile::m_downLoadContentGamePath;
CoreHash TRHashes::FX_MUZZLEFLARE_HASH;
CoreFXEmitterItem fxeFireDrip[2];
int32_t fxSplash[15];
CoreInputID s_selectInputID;
CoreHash AE_DAMAGE_LOOP;
CoreFXEmitterItem fxeFireLeap[2];
CoreHash TRHashes::ANIMSTATE_PUSH_HASH;
void* $S81;
void* $S81;
void* $S81;
void* CoreInit::m_powerCallBacksUserData[4];
TRInvInit inv_pickup1_option;
int32_t fxSwirlSnowNegZ[34];
void* $S108;
void* $S105;
void* $S105;
CoreHash CoreWorld::m_genericFileAssetTypeHash;
void* $S102;
void* $S102;
CoreHash g_animstateJumpBadLandHash;
CoreHash ANIMSTATE_WALK_SWEEP_ATTACK_HASH;
int32_t CoreFont::m_fontTextureInfoCount;
TRBiteInfo nlion_bite;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
uint32_t $S10;
bool CoreAudio::m_demo;
char RegVal::m_registryBuffer[256];
int32_t CoreKernel::m_lastElapsedTimeInTimerCycles;
int32_t fxQuickSnow[27];
bool g_criticalSectionInitialised;
void* $S207;
CoreHash CoreInput::CORE_MENU_START_1;
void* $S204;
CoreHash CoreInput::CORE_MENU_BACK_1;
CoreHash CoreInput::CORE_MENU_BACK_0;
void* $S201;
_OVERLAPPED g_asyncOverlapped;
int32_t fxExplosion[19];
TREffects gEffects;
TRInvInitList InvInitList[23];
bool CAL0_Util::m_BanNormalAlloc;
int32_t CoreInputConnectedControllers::m_invalidCount1;
TRInvInit inv_medi_option;
bool CAL0_Util::m_Initialised;
uint32_t $S20;
void* $S20;
void* $S20;
void* $S20;
void* $S20;
uint32_t $S20;
TRBiteInfo nrat_bite;
CoreGraphicsDeviceOpenGL* g_lpoGraphicsDevice;
CoreHash TRHashes::ANIMSTATE_PENDULUM_SWING_HASH;
uint32_t CoreSceneContainer::m_viewRoomCentricDepth;
bool CoreGraphicsDeviceOpenGL::m_initHasBeenCalled;
void* $S309;
void* $S306;
void* $S303;
void* $S300;
TRBiteInfo nape_bite;
CoreHash ANIMSTATE_WOLF_JUMPDNFALL_HASH;
int32_t CoreDebug::m_firstTiming;
CoreSaveGameInterface* CoreSaveGameInterface::m_dummyInstance;
uint32_t LEVEL_NOTIFICATION_EVENT;
float lpfCoordsLessThan[6];
TRInvInit inv_pickup2_option;
bool m_bTransformNotifyUpdate;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S30;
void* $S408;
CoreHash TRHashes::ATTRACTOR_CLIMBABLEWALLHASH;
PICKTYPE m_pickTypes[4];
CoreHash TRHashes::ANIMSTATE_JUMP_STANCEHASH;
CoreFX::TextureRef CoreFX::m_TextureRefs[13];
CoreHash ANIMSTATE_DART_ACTIVATE_HASH;
CoreHash TRHashes::ANIMSTATE_SURFACE_SWIM_BACKHASH;
int32_t fxSnowGlint[22];
uint32_t codeCheckBoxes[10];
uint32_t codeCheckBoxes[10];
void* $S402;
uint32_t CoreGraphicsDeviceOpenGL::m_screenWidth;
void* $S405;
void* $S40;
float climbWallGetOnWidthTolerance;
uint32_t FRWorld::PLAYER_INVENTORY_EVENT_ID;
char* memoryAssetTypeName;
CoreHash ANIMSTATE_REAR_UP_WALK_HASH;
CoreVector CoreSceneContainer::m_globalBoundsMax;
void* $S501;
CoreMemoryStack CoreBlender::m_boneCache;
void* $S504;
void* $S507;
float climbWallOffsetGetOn;
CoreHash ANIMSTATE_BEAR_NECK_HASH;
void* CoreInit::m_idleCallBacks[4];
CoreAudioEventInitData oInitData[257];
void* $S609;
CoreRGBA s_overrideButtonColour;
int32_t fxDust2[27];
void* $S603;
int32_t CoreDebug::m_iCommandListLength;
void* $S600;
int32_t fxDust0[27];
int32_t fxDust1[27];
void* $S606;
CoreHash ANIMSTATE_FIRE_SKULL_CLOSE_HASH;
float lpfCoordsK[14];
CoreRenderTextSettings CoreRenderText::DefaultSettings;
int32_t fxBreath[0];
int32_t fxBreath[39];
void* $S60;
void* $S60;
void* $S60;
void* $S60;
void* $S60;
void* $S60;
uint32_t $S60;
uint32_t $S60;
CAL0_Heap CAL0_Util::m_MiniHeap[3];
CoreGameController* CoreGameController::m_instance;
CoreRGBA Colour_Sienna;
CoreMemory* CoreFile::s_globalMemory;
char* CoreGameOnScreenKeyboardCharacterTable::m_characterTableLanguageSpecific;
uint32_t CoreDebug::m_uiUserCounts[2][16];
CoreHash ANIMSTATE_DEATH_HASH;
CoreHash ANIMSTATE_DEATH_HASH;
CoreHash ANIMSTATE_DEATH_HASH;
TRBiteInfo nCentaur_rocket;
CoreHash TRHashes::ANIMSTATE_DROP1_HASH;
int32_t fxDustSlave[24];
CoreHash TRHashes::ANIMSTATE_DROP2_HASH;
CoreHash TRHashes::ANIMSTATE_DROP3_HASH;
CoreHash ANIMSTATE_REAR_UP_HASH;
bool CoreBlender::m_focusBlendsActive;
uint32_t SLIDE_TYPE_STEEL;
void* MW::m_Process;
CoreHash ANIMCONTEXT_ATTACKS;
CoreHash ANIMCONTEXT_ATTACKS;
CoreHash ANIMCONTEXT_ATTACKS;
float V2W;
CoreGameMessageBoxParameters s_messageBoxSettings;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
CoreHash CO_AUDIO_PROCESSING_TYPE_3D;
uint32_t ScratchMem[16384];
float A2R;
float R2A;
CoreHash ANIMSTATE_180_MIRROR_HASH;
CoreHash raptorRun;
TRInvInit inv_title_passport;
void* $S82;
uint32_t CoreBlender::m_blenderFlags;
bool* CoreInputConnectedControllers::m_callBack;
CoreHash TRHashes::ANIMSTATE_SPRINTHASH;
int32_t fxWaterFoam0[44];
uint32_t CoreInit::m_fillMemoryWith;
CoreHash CoreNet::NETWORK_SERVER_LOGGER;
void* $S138;
CoreVector CoreLevel::s_occluderClipPlane[6];
CoreHash TRHashes::SLIDEHASH;
void* $S135;
uint32_t bUseNewFXRender;
CoreHash WAITINGFORCLIENTS;
CoreHash TRHashes::LEFTABSHASH;
void* $S132;
float lpfCoordsColon[4];
uint32_t CoreTiming::m_lockedCount;
CoreHash AE_SCORELOOPSMALL;
TRBiteInfo nWarrior_rocket;
void* CoreInit::m_powerCallBacks[4];
CoreHash TRHashes::LEFTARMHASH;
CoreFXEmitterItem fxeCrystalBeam0_NegZ[2];
void* $S13;
uint32_t $S13;
void* $S13;
uint32_t $S13;
uint32_t $S13;
uint32_t $S13;
uint32_t $S13;
uint32_t $S13;
void* $S13;
float twatarray[256];
float lpfCoordsGreaterThan[6];
CoreHash AE_SPEECH_SPRINT_BOOST;
TRWadFileManager::wadElementCreate TRWadFileManager::m_fileList[256];
void* $S237;
void* $S234;
void* $S231;
CoreHash CoreGameMessageBox::m_overrideTextHash;
int32_t CoreInputConnectedControllers::m_invalidCount2;
CoreRGBA oWhite;
uint32_t dlgNodeType;
void* $S23;
void* $S23;
CoreVector CoreDebug::m_vConsoleStartPos;
CoreHash CoreFont::m_rightShoulderButtonHash;
float CoreBlender::m_focusBlendEndTime;
void* $S339;
CoreHash TRHashes::ANIMSTATE_STANCEHASH;
int32_t fxFlickerGlow[0];
int32_t fxFlickerGlow[17];
int32_t fxLightningTestThin[9];
void* $S336;
CoreHash TRHashes::BACKWARDRELHASH;
void* $S333;
void* $S330;
void* $S33;
void* $S33;
void* $S33;
void* $S33;
void* $S33;
void* $S33;
void* $S33;
void* $S33;
void* $S33;
void* $S33;
void* $S33;
void* $S33;
void* $S438;
CoreHash CoreInput::CORE_MENU_DOWN_0;
CoreHash CoreInput::CORE_MENU_DOWN_1;
bool CoreDebug::m_bProfileTextDisplay;
char CoreFX::s_DbgWrk[4096];
CoreGameButtonText CoreGameMessageBox::OkButtonText;
void* $S432;
CoreHash TRHashes::ANIMSTATE_BLOCK_STANCEHASH;
void* $S435;
bool CoreInit::m_enableMoviePlayback;
uint32_t FRWorld::FRLEVEL_OBJECT_EVENT_ID;
float CoreFX::FXScaleTerm;
void* $S43;
char CAL0_Util::m_WorkingPath[260];
CoreHash TRHashes::ANIMSTATE_CEILING_STILL_HASH;
float IDEAL_PITCH;
float IDEAL_PITCH;
void* $S531;
char* MEMORY_DEBUG_FILENAME;
CoreGameMessageBoxParameters s_defaultMessageBoxParameters;
bool CoreInitPC::m_useDebugAudioHeap;
CoreHash TRHashes::POWERHASH;
void* $S534;
void* $S537;
CoreHash TRHashes::ACTION_SPRINTHASH;
bool CoreKernel::m_debugAudioMemory;
CoreHash TRHashes::RIGHTHANDMESH;
CoreHash TRHashes::PANEL_COMPONENT_HEALTHBARBASE;
uint32_t $S53;
void* $S53;
CoreAlphaCharacter lpoChars[128];
int32_t missionPointBodge;
float lpfCoords8[20];
uint32_t TRECameraNode::m_createCount;
CoreHash TRHashes::LARA_GRAB_GREEN_CRYSTAL;
void* $S630;
int32_t fxFireBitsHand[42];
float lpfCoordsX[10];
float lpfCoordsH[12];
TRCollision gCollision;
float distToCorner_HangInternal90;
float distToCorner_HangInternal90;
CoreHashTable CoreAudio::m_SurfaceTypeIndex;
void* $S63;
void* $S63;
void* $S63;
void* $S63;
void* $S63;
void* $S63;
CoreHash TRHashes::ANIMSTATE_RUNHASH;
uint32_t iSoftShader;
CoreHash TRHashes::RESET_ACTIONHASH;
int32_t fxPlayerBurning[0];
int32_t fxPlayerBurning[40];
CoreHash TRHashes::LEFTHANDPISTOLMESH;
CoreHash ANIMSTATE_HANG_HASH;
CoreMemoryStack CoreBlender::m_blendCache;
CoreHash TRHashes::ANIMSTATE_IDLE_LOOK_AROUND_MIRRORHASH;
int32_t fxSmartBubble1[31];
CheatDescription Cheats[4];
float climbWallToShimmyCornerMaxDistOnMoving;
CoreHash TRHashes::ACTION_FORWARDRELHASH;
int32_t fxLightningTestThinFade2[16];
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D;
uint32_t TRSceneryNode::m_createCount;
char* FXAssetTypeName;
uint32_t CoreHashDebugString::m_bufferSize;
uint32_t $S83;
CoreHash SECONDARY_HASH;
float CoreTypes::MaxFloat64;
uint32_t $S8;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S9;
void* $S6;
void* $S6;
uint32_t $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S6;
void* $S7;
float lpfCoordsCloseSquareBracket[8];
float ARROW_HEAD_WIDTH_IN_WORLD_UNITS;
void* $S4;
void* $S4;
uint32_t $S4;
void* $S5;
uint32_t $S5;
void* $S5;
CoreFontTextureInfo CoreFont::m_fontTextureInfo[4];
void* $S2;
void* $S2;
uint32_t $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
void* $S2;
int32_t fxWaterFoam1[44];
void* $S3;
void* $S3;
void* $S3;
uint32_t $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
void* $S3;
int32_t CoreGameOnScreenKeyboardCharacterTable::m_characterTableLineLength;
uint32_t $S1;
uint32_t $S1;
CoreFXEmitterItem fxeWaterFoam[2];
char CoreTypes::MinInt8;
void* $S129;
CoreCameraObject* g_storedCamera;
void* $S126;
void* $S120;
bool CAL0_Util::m_ShowMemoryLogging;
void* $S123;
bool CoreInit::m_useGraphics;
CoreFXEmitterItem fxeWaterFoam1[2];
uint32_t FRWorld::FRLEVEL_FLIP_EVENT_ID;
CoreHash ANIMSTATE_WOLF_JUMPUPONEHALF_HASH;
int32_t _newmode;
void* $S93;
void* $S93;
void* $S93;
uint32_t $S93;
CoreHash TRHashes::BONESET_LEFTARM;
uint32_t CoreAudio::m_AudioSRAMSize;
char* CoreHashDebugString::m_buffer;
uint32_t $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
uint32_t $S12;
uint32_t $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
uint32_t $S12;
uint32_t $S12;
void* $S12;
uint32_t $S12;
void* $S12;
uint32_t $S12;
uint32_t $S12;
uint32_t $S12;
uint32_t $S12;
uint32_t $S12;
void* $S12;
uint32_t $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
void* $S12;
CoreHash TRHashes::ANIMSTATE_DEFAULT_HASH;
CoreHash TRHashes::ANIMSTATE_FALL_TO_SWIMHASH;
int32_t fxFireLarge[43];
int32_t CoreTiming::m_lockedLevel;
void* $S228;
CoreHash TRHashes::ANIMSTATE_CONTEXT_SURFACE_SWIMMING;
CoreHash TRHashes::DEBUG_JUMPHASH;
float climbWallOffsetStep;
CoreHash raptorAttack1;
CoreHash raptorAttack2;
CoreFXEmitterItem fxeFlameThrower[2];
void* $S225;
CoreHash raptorAttack3;
void* $S222;
CoreHash TRHashes::CONTEXTHASH;
CoreHash AE_SLIDE_ROOFSLATE;
int32_t g_performanceFrequency64;
int32_t fxFireTorch0[48];
char* CoreKernel::m_regionClusterName;
CoreFXEmitterItem fxeBigBeamNoFlies[2];
char gSecretTotals[16];
char gSecretTotals[0];
CoreLevelLight m_simpleDynamics[2];
uint32_t CAL0_Math::m_Seed;
CoreHash ANIMSTATE_WOLF_LEAPATTACK_HASH;
uint32_t CoreNetDevice::HANDSHAKE_PROTOCOL;
CoreHash TRHashes::ACTION_ACTION_HOLDHASH;
int32_t initf;
CoreHash AE_SLIDE_CONCRETE;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
CoreHash CO_AUDIO_PROCESSING_TYPE_2D_DISTATTN;
void* $S327;
CoreHash TRHashes::NULLHASH;
int32_t CoreAudio::m_iUseCD;
float lpfCoordsDot[4];
float NewSpikesBounds[12];
char* CoreInit::m_argv[257];
void* $S324;
CoreHash CoreAudio::m_SurfaceTypeStringHashIndex[256];
CoreHash TOPOFLIST_HASH;
void* $S321;
bool ScratchMemLocked;
int32_t* _imp___adjust_fdiv;
uint32_t CoreHashDebugString::m_hashCount;
float climbWallEdgeLeft;
CoreHash PRIMARY_HASH;
CoreHash PRIMARY_HASH;
FRGameController g_gameController;
CoreHash ANIMSTATE_STANCE_HASH;
CoreHash ANIMSTATE_STANCE_HASH;
CoreHash TRHashes::ANIMSTATE_HINT_READ_STANDING_HASH;
void* $S32;
void* $S32;
bool CoreInit::m_forceFrench;
void* $S429;
CoreHash TRHashes::LEFTHANDMESH;
bool CoreInit::m_useInput;
void* $S420;
void* $S423;
void* $S426;
CoreFXEmitterItem fxeMediumSplash[2];
int32_t CAL0_AudioCodecADPCM::stepsizeTable[89];
void* $S42;
void* $S42;
void* $S42;
void* $S42;
void* $S42;
void* $S42;
void* $S42;
void* $S42;
void* $S42;
void* $S42;
void* $S528;
int32_t lFrequency;
bool CoreInit::m_isPowerOffPending;
char* CoreKernel::m_platformExtension;
bool CoreGameMessageBox::m_overrideStopping;
void* $S522;
void* $S525;
bool CoreInit::m_memoryStickReady;
bool CAL0_Util::m_SendDbgLogToOutput;
bool CoreMem::s_banMallocFree;
float ZOOM_SPEED;
float ZOOM_SPEED;
CoreHash TRHashes::PELVISHASH;
CoreRGBA CA_Colour_Sienna;
uint32_t $S52;
CoreRGBA Colour_Yellow;
CoreProfileEntry* CoreDebug::m_profileStack[64];
uint32_t m_nUpdateMaterials;
CoreHash CoreEvent::EVENT_LOGGER;
CoreHash TRHashes::ANIMSTATE_CONTEXT_DROP_FALL;
float lpfCoords9[16];
TRFogBulbStruct g_fogBulbs_7a[2];
bool CoreKernel::m_useClusters;
void* $S621;
float lpfCoordsY[10];
void* $S627;
int32_t fxFlameThrower[29];
void* $S624;
float lpfCoordsI[12];
float CoreAudio::m_MenuMusicVolumeScaled;
void** __onexitend;
CoreHash CoreNet::NETWORK_CLIENT_LOGGER;
CorePhysicsWorld* CoreCollisionBall::CorePhysicsWorldInstance;
int32_t fxSmartBubble0[25];
CoreHash TRHashes::ACTION_RUNHASH;
float climbWallGetOnDistTolerance;
bool CoreAudio::m_FadeIn;
void* CoreInit::m_idleCallBacksUserData[4];
CoreHash CoreAssetManager::m_fileAssetTypeHash;
CoreHash TRHashes::ANIMSTATE_LARA_CRYSTAL_START;
void* $S72;
void* $S72;
void* $S72;
void* $S72;
bool CoreDebug::m_bActive;
CoreHash ANIMSTATE_WOLF_LEAPEND_HASH;
float distToCorner_HangExternal90;
float distToCorner_HangExternal90;
CoreHash TRHashes::RIGHTARMSLOTHASH;
CoreHash ANIMSTATE_BEAR_SPINE_HASH;
int32_t fxBloodFountain[0];
int32_t fxBloodFountain[39];
int32_t fxBloodFountain[0];
CoreAudio::CoreAudioType CoreAudio::m_eAudioType;
float FLA;
int32_t** _imp___onexit;
CoreHash CoreFont::m_squareButtonHash;
CoreHash CoreWorld::m_clusterAssetTypeHash;
CoreNet::DeviceInitialisationData CoreKernel::m_networkParams;
uint32_t MW::gMWInitialise;
void* CoreInit::m_exitCallBacks[4];
CoreMemory* CoreMem::m_debugMemoryAllocator;
char CoreInit::m_exeName[256];
char* CoreAudio::m_AudioHeap;
int32_t fxWaterSprinkle2[35];
CoreHash TRHashes::ANIMSTATE_JUMP_LEFT_MIDDLE;
float NewKeyHoleBounds[12];
float lpfCoordsComma[4];
CoreMem::CoreMD5State CoreMem::s_md5State;
uint32_t SLIDE_TYPE_GLASS;
CoreHash TRHashes::ANIMSTATE_TRIGGERED_HASH;
uint32_t iHardShader;
int32_t CoreTypes::MaxInt16;
bool CoreInit::m_meshWrapOnly;
float climbWallLRStopDist;
CoreHash TRHashes::BONESET_RIGHTARM;
CoreInputID s_R1InputID;
int32_t fxFlickerGlowHand[19];
int32_t fxSuperSplash[48];
CoreHash ANIMSTATE_STEP_BACK_MIRROR_HASH;
CoreHash TRHashes::ANIMSTATE_PULL_STOP_HASH;
void* __xi_a[0];
void* __xi_a[1];
int32_t CoreDebug::m_iMaxNumProfileEntries;
CoreHash TRHashes::ACTION_FIRE_HELD;
float m_storedBlue;
CorePhysicsWorld* CorePhysicsJoint::CorePhysicsWorldInstance;
bool s_messageBox;
CoreGameMessageBox s_messageBox;
CoreHash TRHashes::RIGHTRELHASH;
bool CoreInit::m_quickStart;
CoreGraphicsDeviceOpenGL* CoreGraphicsDeviceOpenGL::m_pInstance;
float gracePeriod;
CoreHash ANIMSTATE_REAR_UP_ATTACK_HASH;
CoreHash ANIMSTATE_STEP_BACK_HASH;
uint32_t CoreNetDevice::I_AM_A_SERVER;
CoreHash raptorDeath1;
CoreBatchRender* CoreBatchRender::m_pInstance;
bool s_messageBoxSettingsSaved;
CoreHash TRHashes::ANIMSTATE_SAVE_FINISH_HASH;
char* lpcBlendShapeShader;
CoreFXEmitterItem fxeLavaMist[2];
float FR_TURNSPEED;
int32_t fxFire[22];
int32_t g_rtreeViewBuffer[2048];
CoreHash TRHashes::ANIMSTATE_SWITCH_ON_HASH;
uint32_t CoreAudio::m_AudioMemSize;
float NewSwitch2Bounds[12];
CoreHash TRHashes::CAMERA_RIGHTHASH;
CoreLangNameEnum s_validLangs[6];
int32_t fxSunFlare[14];
char* textureSetAssetTypeName;
float lpfCoordsEquals[4];
CoreHash TRHashes::SETUP_ACTION_SPRINTHASH;
TRWadFileManager::wadFileHeader* TRWadFileManager::m_fileBuffer;
CoreInit::CoreLanguageEnum CoreInit::m_language;
int32_t fxSunFlare2[14];
int32_t fxPickupFlare[22];
CoreHash TRHashes::RIGHTHANDPISTOLMESH;
int32_t fxPickupFlare0[35];
CoreInit::CoreVersionEnum CoreInit::m_version;
float lpfCoords6[16];
TRFogBulbStruct g_fogBulbs_8b[2];
TRFogBulbStruct g_fogBulbs_8c[4];
CoreFXEmitterItem fxeSmartBubbles0[2];
CoreFXEmitterItem fxeBeam0_PlusZ[2];
uint32_t CoreNetDevice::LOBBY_PROTOCOL;
CoreVector CoreLevel::s_occluderGuardPlane[6];
float lpfCoordsV[6];
CoreVector flarePos;
float lpfCoordsF[12];
CORE_OSK_RESULT_TAG g_lastOSKResult;
CoreHash TRHashes::FORWARDRELHASH;
bool CoreInit::m_argvUsed[256];
char CoreAudio::m_lpcAppName[256];
CoreHash AE_DUMMY_BODY_PHYSICS;
int32_t matrixStack[0];
int32_t matrixStack[480];
int32_t TRHitItem::m_lastManipItem;
uint32_t g_maskHash;
uint32_t g_maskHash;
_GUID DS3DALG_NO_VIRTUALIZATION;
uint32_t CoreNetDevice::YOU_HAVE_BEEN_JOINED;
int32_t CoreDebug::m_iCurrentDebugLevel;
CoreProfileEntry* CoreDebug::m_lpoProfileEntriesBuffer1;
CoreProfileEntry* CoreDebug::m_lpoProfileEntriesBuffer0;
uint32_t CoreNetDevice::SYNC_STATE;
bool CoreGraphicsDeviceOpenGL::m_allowResize;
CoreHash TRHashes::PANEL_COMPONENT_AIRBARBASE2;
char CoreKernel::m_gameDirName[256];
CoreFXEmitterItem fxeFlameTorch0[6];
CoreHash CoreMenuComponent::SERVER_LISTBOX_COMPONENT;
CoreHash ANIMSTATE_WOLF_NECK_HASH;
char* g_padInputNames[24];
CoreHash ANIMSTATE_RUN_HASH;
COREAUDIO_MUSIC_STATE CoreAudio::m_MusicState;
char* BSI_ASK_SHUTDOWN;
CoreHash ANIMSTATE_WALK_HASH;
CoreHash ANIMSTATE_WALK_HASH;
CoreHash TRHashes::PANEL_COMPONENT_AIRBARBASE;
CoreHash TRHashes::ANIMSTATE_LARA_CRYSTAL_FINISH;
CoreFileSystem* CoreKernel::m_fileSystem;
TRInvInit inv_title_control;
uint32_t CoreModelCompiled::s_modelCompiledID;
uint32_t CoreFont::s_fontCompiledID;
uint32_t CoreFXDefault::m_MaxPrims[5];
int32_t fxSplashBigSlave[40];
int32_t CoreTypes::MinInt64;
void* __rtc_izz[1];
CoreHash ANIMSTATE_WOLF_LEAPSTART_HASH;
TRInvInit inv_title_photo;
TRBiteInfo ncroc_bite;
CoreProfileEntry* CoreDebug::m_lpoProfileEntries;
void* __xc_z[0];
void* __xc_z[1];
CoreHash TRHashes::CAMERA_DOWNHASH;
int32_t CoreInit::m_memoryStickDetachedCounterPowerOff;
CoreFXEmitterItem fxeLavaMistLow[2];
CoreHash AE_SPEED_BOOST_2;
CoreQWORD* CoreDebug::m_lpqwCommandListNext;
float g_tempPierrePath[4][2];
int32_t fxLightningTestFade[35];
CoreHash TRHashes::FOOT_DOWN_LHASH;
CoreAudio_SpeechQueue CoreAudio::m_SpeechQueue;
uint32_t CoreFX::s_PrimSize[5];
int32_t fxLightningTest2[17];
CoreHash raptorTurnAroundMirror;
int32_t fxSmerk[23];
uint32_t CoreDebug::m_uiCurrentTimerCount;
CoreHash TRHashes::FOOT_DOWN_RHASH;
bool CoreBreakPoint::m_shouldAssertBreakPoint;
bool CoreHash::m_storeHashStrings;
uint32_t CoreEvent::OBJECT_BY_NAME_EVENT;
CoreGraphicsDevice* CoreGraphicsDevice::m_instance;
CoreHash g_animstateBackwardWipeoutMirrorHash;
CoreHash ANIMSTATE_WOLF_DEATH1_HASH;
TRBiteInfo nbaldy_gun;
char* pszLoadingScreenTexSetName;
uint32_t CoreAudio::m_FadeValue;
CoreHash TRHashes::NEXTACTIONHASH;
int32_t CAL0_Util::m_CurrentMiniHeap;
CoreHash CoreWorld::m_scriptStoreAssetTypeHash;
CoreHash CoreMenuComponent::DEFAULT_COMPONENT;
int32_t fxGroundMistParticle[38];
int32_t CoreDebug::m_iProfilerNewActiveLevel;
float climbWallOffsetDropOffMin;
char CoreNode::m_textBuffer[32];
CoreHash ANIMSTATE_OFF_HASH;
bool CoreLevel::s_occludersValid;
int32_t CoreGameController::m_disableSoftResetLevel;
uint32_t CoreSceneContainer::m_sceneFlipped;
int32_t fxDebris[39];
TRTriggerNode::trigEvent* m_selectedEvent;
int32_t fxWaterMist1Fall[42];
char* levelAssetTypeName;
CoreMemory* CoreMem::s_globalNewDeleteMemoryStack[16];
CoreHash ANIMSTATE_WOLF_JUMPUPONE_HASH;
char* RegVal::m_subKeyBuffer;
char* fileAssetTypeName;
void* CoreGameMessageBox::m_overrideRenderCallBackUserData;
int32_t CoreDebug::m_profileStackPointer;
uint32_t CoreTypes::MaxUInt8;
uint32_t TRWadFileManager::m_numFiles;
CoreHash AE_SPARK;
CoreHash raptorWalk;
int32_t fxPickupFlare1[35];
int32_t CoreDebug::m_iNumClients;
float lpfCoords7[6];
CoreHash ANIMSTATE_WOLF_WAKE_HASH;
bool GeneralDialogUpdate;
CoreHash CoreAudio::m_SpeechHash;
float lpfCoordsW[10];
CoreGameTextUnit* CoreGameText::m_pGameText[5];
float lpfCoordsG[12];
float climbWallInsideAttractorTolerance;
CoreHash TRHashes::STOPHASH;
TRInvInit inv_sgunammo_option;
CoreFXEmitterItem fxeWaterSprinkle2[2];
CoreFXEmitterItem fxeWaterSprinkle1[2];
CoreFXEmitterItem fxeWaterSprinkle0[2];
uint32_t CoreTypes::MaxUInt32;
CoreGameOnScreenKeyboardParameters s_OSKSettings;
int32_t fxMiniDumbBubble[30];
CoreHashDebugStringEntry* CoreHashDebugString::m_hashes;
bool bIgnore;
CoreHash AE_WADE;
int32_t fxSmallDust[20];
int32_t FRGlobals::currentViewer;
char* lpcGlobalLinkedScriptsFileName;
CoreHash ANIMSTATE_WOLF_LEAPFALL_HASH;
uint32_t CoreTypes::EmptyString16[1];
CoreHash SKULL_BASE_HASH;
int32_t CoreInit::m_memoryStickDetachedCounter;
CoreHash ANIMSTATE_DART_LOOP_HASH;
bool s_OSKBusy;
bool CoreInit::m_forceJapanese;
CoreFXEmitterItem fxeFlameTorchLarge[6];
CoreHash ANIMSTATE_WOLF_SLEEPLOOP_HASH;
CoreLevelLight** CoreSceneContainer::m_lightListTable;
int32_t fxFlareFlare2[16];
int32_t fxFlareFlare3[16];
int32_t fxFlareFlare0[18];
int32_t fxFlareFlare1[18];
CoreHash ANIMSTATE_FIRE_DEACTIVATE_HASH;
float NewPickUpScionBounds[12];
int32_t _adjust_fdiv;
CoreRGBA CA_Colour_Turquoise;
int32_t CoreTypes::MaxInt32;
float CoreSceneContainer::m_dynamicLightRad[2];
CoreGameButtonText CoreGameMessageBox::CancelButtonText;
char g_OSKBuffer[128];
int32_t fxSuperSplash2[42];
CoreNetworkDialogInterface* CoreNetworkDialogInterface::m_defaultInstance;
int32_t fxGreenSmoke[41];
int32_t fxGreenSmoke[0];
bool CoreInit::m_useClusters;
void* CoreInit::m_exitCallBacksUserData[4];
CoreOnScreenKeyboardInterface* CoreOnScreenKeyboardInterface::m_defaultInstance;
bool TriggersDialogUpdate;
CoreHash raptorTurnAround;
CoreHash TRHashes::ANIMSTATE_RAGDOLL_GETUP_FORWARDHASH;
CoreHash TRHashes::ANIMSTATE_SAVE_SPINLOOP_HASH;
int32_t fxWaterSprinkle0Z[35];
bool CoreGameMessageBoxParameters::m_defaultsSet;
CoreHash ANIMSTATE_WOLF_JUMPUPHALF_HASH;
CoreHash TRHashes::RIGHTARMHASH;
CoreFXEmitterItem fxeWaterMist[2];
float CoreAudio::m_MenuSFXVolume;
bool CoreBreakPoint::m_enableCoreBreakPoint;
void* __rtc_tzz[1];
int32_t fxSmallSplash[17];
char* lpcParentedShader;
CoreHash TRHashes::LARA_CRYSTAL_SAVE_SEQ_END;
float g_loadDiskRotation;
uint32_t g_showMesh;
CoreHash BACKGROUNDS_HASH;
bool s_OSKActive;
CoreHash CoreNet::NETWORK_LOGGER;
_GUID IID_IDirectInput8A;
void* CoreGameMessageBox::m_overrideRenderCallBack;
char* CAL1_IDManagerPC::m_IDFileName[260];
CoreHash TRHashes::STAIRSHASH;
TRNode* m_setAssociateSourceNode;
CoreHash ANIMSTATE_WOLF_STANDATTACK_HASH;
char gStringNotFound[128];
int32_t CoreTiming::m_lastTimer64;
int32_t fxBlowSnowNegZ[30];
TRLevelDescription gLevels[0];
TRLevelDescription gLevels[26];
TRLevelDescription gLevels[0];
CoreHash CoreInput::CORE_MENU_SQUARE_0;
CoreHash CoreInput::CORE_MENU_SQUARE_1;
float lpfCoords4[8];
bool CoreMaths::s_initFlag;
uint32_t CoreError::s_disableFlags;
int32_t fxFireBits[44];
float lpfCoordsT[8];
float lpfCoordsD[14];
int32_t fxWaterfallRockHitFall[41];
bool CoreError::m_fatalErrorEnabled;
CoreHash TRHashes::PANEL_COMPONENT_AIRBAROVERLAY;
CoreHash TRHashes::RAGDOLL_DAMAGEHALFHASH;
CoreHash ANIMSTATE_FIRE_SKULL_OPEN_HASH;
uint32_t CA_PLAT_TO_EXP_TABLE[14][4];
CoreClusterFileSystem CoreKernel::m_clusterFileSystem;
int32_t fxWaterChurn[21];
CoreHash TRHashes::GAMEOBJECTHASH;
CoreNode* m_dialogNode;
char* CA_ExpFmt_Text[8];
bool g_asyncReadFinished;
int32_t fxFireBallCallBack[9];
CoreConsole* CoreConsole::m_instance;
TRManipNode TRManipNode::m_manipNode;
CoreHash ANIMSTATE_FIRE_LOOP_MOVING_HASH;
CoreHash ANIMSTATE_STANCE_MIRROR_HASH;
char* genericFileAssetTypeName;
bool CoreInputConnectedControllers::m_controllerRemovedMessageActive;
float MIN_PITCH;
CoreHash TRHashes::ANIMSTATE_CONTEXT_WALL_CLIMB;
CoreHash INVALID_ID;
uint32_t CoreNode::m_numAllocatedNodes[11];
uint32_t TRTriggerNode::m_triggerEventBufferMaxSize;
int32_t fxFireflyParticle[64];
uint32_t m_bDisable;
TRInvInitList InvTitleList[23];
int32_t fxWaterSprinkle1[36];
int32_t CoreGameMessageBox::m_controllerInputIndex;
CoreHash TRHashes::ANIMSTATE_CONTEXT_HORIZONTAL_POLE;
CoreHash TRHashes::ANIMSTATE_PICKUPHASH;
bool CoreInit::m_isPoweringOn;
CoreVector viewOffset;
CoreHash TRHashes::NPC_ANIMTYPE_RUN;
bool CoreInit::m_forcePolish;
float climbWallToShimmyCornerMaxDist;
CoreHashTable CoreAudio::m_AdditionalEventTable;
CoreRGBA Colour_Turquoise;
CoreHash g_pelvis_hash;
bool CoreInit::m_isExiting;
TRSaveGame gSaveGame;
CoreFX::RawMaterial CoreFX::TEST_RAW_MATERIALS[154];
CoreHash ANIMSTATE_INACTIVE_HASH;
int32_t CoreDebug::m_iUserBuffer;
CoreHash ANIMSTATE_WOLF_JUMPDNMID_HASH;
bool CoreSceneContainer::m_dynamicLightState[2];
CoreFXEmitterItem fxeMedBeamNoFlies[2];
CoreHash ANIMSTATE_WOLF_STANDLOOP_HASH;
float MovingBlockBounds[12];
CoreHash ANIMSTATE_WOLF_JUMPDNHALF_HASH;
float lpfCoordsCloseBracket[8];
float g_tempLarsonPath[8][2];
uint32_t CoreNetDevice::YOU_HAVE_BEEN_REJECTED;
int32_t _dowildcard;
CoreHash CoreMenuComponent::CLIENT_LISTBOX_COMPONENT;
int32_t fxFireGlow[17];
CoreHash TRHashes::ANIMSTATE_IDLE_GLOVES_MIRRORHASH;
CoreLevelLightSetDebugData s_debugData;
uint32_t iBlendShapeShader;
CoreHash raptorDeath2;
float climbWallToHangCornerMaxDist;
CoreHash ANIMSTATE_WOLF_JUMPUPTWO_HASH;
char* animationSetAssetTypeName;
CoreInputID s_L1InputID;
int32_t fxExplosionSmokeBlack[52];
CoreHash TRHashes::ANIMSTATE_LARA_CRYSTAL_TOUCH;
uint32_t levelRenderStartModel;
float NewSwitch1Bounds[12];
int32_t CAL0_AudioCodecADPCM::indexTable[16];
CoreHash TRHashes::ANIMSTATE_BLOCK_PULLHASH;
CoreHash TRHashes::PRIMARYHASH;
CoreHash TRWadFileManager::m_assetHash;
CoreHash ANIMSTATE_REAR_UP_STANCE_HASH;
float lpfCoords5[12];
float lpfCoordsU[8];
float lpfCoordsE[14];
char* g_buildTime;
uint32_t* TRTriggerNode::m_pTriggerEventBufferCur;
void* init_cookie;
CoreHash TRHashes::CASEHASH;
int32_t fxLaserBurn[14];
uint32_t CoreHashDebugString::m_hashNextPowerOf2;
char* CA_PLAT_TEXT_LONG[14];
TRInvInit inv_uziammo_option;
CoreHash ANIMSTATE_WOLF_HOWL_HASH;
char* clusterAssetTypeName;
char* EVENT_LOGGER_NAME;
CoreHash CoreAssetManager::m_memoryAssetTypeHash;
TRInvInit inv_key4_option;
char CoreKernel::m_currentLevelClusterName[256];
CoreDebugClient CoreDebug::m_oClients[23];
uint32_t playerColour[4];
CoreHash ANIMSTATE_FIRE_LOOP_STATIC_HASH;
uint32_t CoreTiming::m_timerCount;
uint32_t CoreEvent::WORLD_EVENT;
CoreHash GreenCrystalHashes[4];
int32_t s_messageBoxScriptResult;
CoreHash TRHashes::ANIMSTATE_END_HASH;
float flareRad;
CoreFXEmitterItem fxeBeam2[2];
int32_t fxSplashBig[29];
CoreHash TRHashes::L_ANALOGHASH;
uint32_t CoreSceneContainer::m_visibleIndexCount;
CoreUV s_overrideUV0;
CoreUV s_overrideUV1;
uint32_t CoreHashDebugString::m_sizeFree;
CoreHash TRHashes::CLEAR_DETECTIONHASH;
CoreHash TRHashes::PANEL_COMPONENT_HEALTHBARBASE2;
TRBiteInfo ncowboy_gun2;
void* $S198;
CoreRGBA CoreDebug::m_oUserColours[2][16];
char* lpcSoftShader;
void* $S195;
CoreHash ANIMSTATE_FALL_HASH;
CoreVector g_pistolEndPos[2];
void* $S192;
int32_t CoreTypes::MinInt32;
float lpfCoordsOpenSquareBracket[8];
CoreHash CoreFont::m_leftShoulderButtonHash;
bool CoreInit::m_forceKorean;
CoreTextureSet* s_overrideTextureSet;
CoreHash g_neck_hash;
char* NETWORK_SERVER_LOGGER_NAME;
uint32_t $S19;
uint32_t $S19;
uint32_t $S19;
uint32_t $S19;
void* $S19;
CoreVector CoreSceneContainer::m_dynamicLightRGB[2];
CoreHash TRHashes::ANIMSTATE_UNDERWATER_PICKUPHASH;
float FR_SHIMMYJUMPVEL;
uint32_t CoreLED::m_nestLevel;
void* $S297;
char* RegVal::RegistryKey;
int32_t CoreInit::m_memoryStickAttachedCounterPowerOff;
int32_t fxPickupGlow[38];
void* $S294;
bool CoreKernel::m_debugAudio;
void* $S291;
char* g_mouseInputNames[11];
int32_t fxWaterRing0[19];
int32_t fxPickupGlow1[33];
CoreHash CoreScripted::m_ScriptLoggerHash;
void* $S29;
void* $S29;
CoreStdFileSystem CoreKernel::m_stdFileSystem;
void* $S399;
int32_t fxFireSmokeBlack[49];
CoreHash ANIMSTATE_180_HASH;
CoreHash TRHashes::NPC_ANIMTYPE_WALK;
void* $S396;
int32_t CoreError::s_exitReturnCode;
CoreHash TRHashes::ANIMSTATE_CONTEXT_SPAZ;
void* $S393;
char* PRINT_ERROR_LOGGER;
void* $S390;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
float ILLEGAL_HEIGHT;
CoreHash TRHashes::ANIMSTATE_IDLE_GLOVESHASH;
uint32_t state[624];
CoreHash ANIMSTATE_WOLF_RUNTURN_HASH;
CoreGameOnScreenKeyboard s_onScreenKeyboard;
void* $S39;
void* $S39;
void* $S39;
void* $S39;
void* $S39;
void* $S39;
void* $S39;
void* $S39;
void* $S39;
void* $S39;
void* $S39;
void* $S39;
void* $S498;
uint32_t m_modelIndex;
void* $S492;
CoreHash g_animstateJumpBadLandTrickHash;
void* $S495;
bool m_bDisableEditValueChangeNotify;
int32_t CoreInputConnectedControllers::m_validCount1;
CoreHash TRHashes::CURRENTANIMHASH;
int32_t fxRainLine[7];
uint32_t TRHitItem::m_itemsInScope[1024];
CoreStringBuffer<256> TRWadFileManager::m_fileName;
char* CoreUseful::m_defaultFilePrefix;
int32_t CoreInputConnectedControllers::m_settlingTime;
CoreFXEmitterItem fxeFireFlies[2];
bool CoreInit::m_enableCutScenes;
float distToCorner_ShimmyInternal90;
float distToCorner_ShimmyInternal90;
CoreHash TRHashes::WEAPON_HOLSTER;
void* $S591;
int32_t CoreGameDialogs::m_defaultRenderFlags;
CoreHash TRHashes::ATTRACTORHASH;
void* $S594;
void* $S597;
float g_ellipseXRad;
uint32_t $S59;
void* $S59;
TRBiteInfo teeth1a;
CoreBlenderEvents CoreBlenderSequenced::m_events;
TRBiteInfo teeth1b;
CoreHash CoreWorld::m_animSequencerAssetTypeHash;
CoreHash AE_SLIDE_WOOD;
CoreHash ANIMSTATE_FIRE_ACTIVATE_HASH;
float lpfCoords2[12];
CoreHash ANIMSTATE_WOLF_SLEEP_HASH;
int32_t CoreDebug::m_iNumUserMarkers[2];
CoreHash g_clavicle_R_hash;
TRInvInit inv_bigmedi_option;
CAL1_API* CoreAudio::m_CoreAudio;
int32_t fxWaterSplash[39];
float lpfCoordsR[12];
float lpfCoordsB[20];
int32_t fxPlaneSmoke[26];
int32_t fxFogParticle[28];
void* $S69;
void* $S69;
void* $S69;
void* $S69;
void* $S69;
CoreHash SYSTEM_ID;
CoreVector FRGlobals::ZeroVector;
TRInvInit inv_key3_option;
CoreHash TRHashes::LEFTFOOTHASH;
TRTriggerNode::trigEventGroupList TRTriggerNode::m_trigEventGroups;
CoreHash ANIMSTATE_WOLF_STANDTURN_HASH;
uint32_t __security_cookie;
int32_t fxDumbBubbleGroup2[30];
uint32_t g_ParticleSize;
CoreFXEmitterItem fxeSmartSnowMed[2];
CoreHash savegameAnims[1];
CoreHash savegameAnims[1];
char* SCRIPT_LOGGER;
CoreRGBA CA_Colour_Red;
int32_t fxWaterMist1[46];
float PickUpScion4Bounds[12];
TRSoundSystem gSoundSystem;
void* $S189;
int32_t gLoadState;
CoreHash TRHashes::ANIMSTATE_BALL_ROLL_HASH;
uint32_t $S185;
CoreHash TRHashes::CAMERA_RESETHASH;
void* $S186;
void* $S180;
void* $S183;
uint32_t CoreTextureSet::s_textureSetID;
void* $S99;
void* $S99;
void* $S99;
CoreQWORD* CoreDebug::m_lpqwCommandListBase;
CoreHash TRHashes::RIGHTHASH;
CoreHash TRHashes::ACTION_DRAW;
void* $S18;
void* $S18;
void* $S18;
void* $S18;
void* $S18;
void* $S18;
void* $S18;
void* $S18;
void* $S18;
void* $S18;
uint32_t $S18;
void* $S18;
void* $S18;
void* $S18;
void* $S18;
void* $S18;
uint32_t $S18;
void* $S18;
void* $S18;
void* $S18;
CoreStringBuffer<256> BuildSystemHelper::m_projectName;
uint32_t numTotalModels;
char* gHintLevelTags[16];
CoreQWORD* CoreDebug::m_lpqwCommandListEnd;
CoreHash ANIMSTATE_STANCE_ATTACK_MIRROR_HASH;
int32_t __defaultmatherr;
void* $S288;
CoreNodeRoot::nodeRGB CoreNodeRoot::m_nodeRGB[14];
void* $S285;
uint32_t CoreAudio::m_LastMenuSFXVolume;
CoreGameOnScreenKeyboardParameters s_defaultOnScreenKeyboardParameters;
void* $S282;
CoreHash ANIMSTATE_180_TURN_HASH;
CoreGameButtonText CoreGameOnScreenKeyboard::DeleteButtonText;
float lpfCoordsSlash[4];
bool s_editingEngineDynamicLight;
int32_t fxDustflyParticleSubStandalone[67];
uint32_t $S28;
CoreHash NEXT_HASH;
int32_t fxExplosionTendrilSpawn[32];
CoreHash ANIMSTATE_WOLF_JUMPDNLAND_HASH;
void* $S387;
void* $S384;
bool CoreInit::m_forceEnglish;
uint32_t CoreNode::m_nodeExtraCapacity[11];
void* $S381;
TRInvInitList KeysInitList[23];
CoreHash TRHashes::BAD_LANDHASH;
void** __onexitbegin;
void* $S38;
CoreHash TRHashes::ANIMSTATE_CLOSING_HASH;
void* $S489;
CoreHash thorAnims[4];
CoreHash CoreAudio::m_NextMusicHash;
void* $S480;
CoreFXEmitterItem fxeDustFlies[2];
void* $S483;
float VIEW_SCALE;
bool CoreGameOnScreenKeyboardParameters::m_defaultsSet;
void* $S486;
CoreHash CoreFont::m_textureSetHash;
CoreHash ANIMSTATE_REAR_UP_STANCE_TO_STANCE_HASH;
CoreHash TRHashes::ANYDIRHASH;
CoreHash ANIMSTATE_STANCE_ATTACK_HASH;
CoreHash ANIMSTATE_STANCE_ATTACK_HASH;
uint32_t CoreTypes::MaxUInt16;
CoreHash TRHashes::SWITCHHASH;
uint32_t CoreEvent::OBJECT_BY_TYPE_EVENT;
void* $S48;
void* $S48;
void* $S48;
void* $S48;
void* $S48;
void* $S48;
void* $S48;
void* $S48;
void* $S48;
void* $S48;
void* $S48;
int32_t fxExplosionCore[49];
_OVERLAPPED* g_asyncOverlappedPtr;
CoreHash CoreDetectInternalData::m_cameraIgnoreHash;
uint32_t RESTART_LEVEL_EVENT;
CoreHash TRHashes::RAGDOLL_NORESETHASH;
void* $S588;
int32_t fxDustflyParticleSub[67];
void* $S582;
int32_t fxLightningTestThin2[9];
char* EventGroupTypeNames[12];
int32_t fxLightningTestThinFade[16];
void* $S585;
uint32_t CoreNetDevice::NETWORK_PLAYER_INFO;
uint32_t m_listIndex;
bool CoreInit::m_local;
float g_ellipseYRad;
CoreHash AE_SLIDE_STEEL;
CoreHash animWalk;
CoreHash PRINT_ERROR_HASH;
CoreVector CoreSceneContainer::m_globalBoundsMin;
int32_t fxFireBallII[34];
uint32_t $S58;
uint32_t recursionDepth;
CoreFXEmitterItem fxeWaterSplash[2];
bool CoreInit::m_useOldFormat;
float lpfCoords3[22];
char* BSI_ASK_IS_APP_RUNNING;
int32_t left;
bool CoreInit::m_forcePortuguese;
int32_t fxSmallSplat[21];
int32_t CoreDebug::m_iCurrentDebugClient;
float lpfCoordsS[16];
float lpfCoordsC[8];
TRNode* m_pPickedNode;
bool g_WADRoomDataLoaded;
CoreFXEmitterItem fxeSuperSplash[2];
int32_t fxFireBall[49];
int32_t fxElecFlareGlow[15];
uint32_t CoreEvent::LEVEL_EVENT;
uint32_t LEVEL_TEXTURE_SET_HASH;
bool CoreInit::m_isHoldSwitchOn;
float ARROW_HEAD_WIDTH_IN_SCREEN_UNITS;
CoreHash TRHashes::ANIMSTATE_IDLE_LOOK_AROUNDHASH;
CoreHash TRHashes::ATTRACTOR_LASTCHANCEGRABEDGEHASH;
int32_t fxFireBallSlave[12];
CoreHash ANIMSTATE_ROLL_IN_HASH;
TRInvInit inv_key2_option;
char* BSI_REPLY_APP_IS_READY_PREFIX;
CoreRGBA CA_Colour_Green;
CoreHash TRHashes::NPC_ANIMTYPE_NEARBYIDLE;
CoreHash TRHashes::ANIMSTATE_IDLE_LACESHASH;
float climbWallEdgeRight;
CoreNodeChainGroup CoreNode::m_nodeFreePool;
uint32_t CoreFX::s_NumActive[5];
uint32_t CoreFX::s_NumActive[0];
CoreHash ANIMSTATE_WOLF_RUN_HASH;
CoreHash TRHashes::ATTRACTOR_HANGEDGEHASH;
CoreSceneContainer::meshPartition* CoreSceneContainer::m_meshPartitionTable;
bool CoreInit::m_useNetworkTimeouts;
void* $S78;
void* $S78;
void* $S78;
void* $S78;
CoreOnScreenKeyboardDummyInterface s_dummyKeyboardInstance;
uint32_t TRSceneryNode::m_numVinePresets;
CoreHash TRHashes::ANIMSTATE_PENDULUM_STILL_HASH;
CoreFXEmitterItem fxeBeam0[3];
uint32_t TRNode::m_nodeTotals[11];
uint32_t m_nodeType;
CoreHash AE_WIPEOUT;
CoreInputID s_startInputID;
CoreHash TRHashes::ANIMSTATE_SAVE_YES_HASH;
CoreOccluder* CoreLevel::s_occluderList;
CoreHash CoreFont::m_triangleButtonHash;
uint32_t* next;
bool s_messageBoxBusy;
CoreHash raptorRoar;
CoreHash TRHashes::ANIMSTATE_UNDERWATER_TREADHASH;
CoreHash TRHashes::ANIMSTATE_SURFACE_SWIM_FORWARDHASH;
CoreRGBA Colour_BlueViolet;
uint32_t MW::gMWDealloc;
bool CoreInputConnectedControllers::m_valid2;
CoreHash TRHashes::ATTRACTOR_HPOLEHASH;
bool CoreInputConnectedControllers::m_valid1;
uint32_t twatVal;
CoreHash TRHashes::RAGDOLLHASH;
int32_t CoreFX::m_RandSeed;
bool CoreMem::s_banNewDelete;
int32_t CoreTypes::MinInt16;
TRInvInit inv_puzzle1_option;
CoreHash TRHashes::UPHASH;
uint32_t CoreHashDebugString::m_hashHalfWay;
CoreHash TRHashes::DOWNHASH;
TRInvInit inv_uzi_option;
CoreMessageBoxInterface* CoreMessageBoxInterface::m_dummyInstance;
CoreHash TRHashes::SET_RAGDOLLHASH;
uint32_t CoreHashDebugString::m_hashStringOffset;
_DIDATAFORMAT c_dfDIKeyboard;
CoreHash TRHashes::OTHERHASH;
CoreHash ANIMSTATE_WALK_SWIPE_ATTACK_MIRROR_HASH;
_RTL_CRITICAL_SECTION g_criticalSection;
TRInvInit inv_puzzle2_option;
CoreHash TRHashes::RESET_AVERAGE_VELOCITYHASH;
CoreHash HEAD_HASH;
CoreHash HEAD_HASH;
bool CoreInit::m_isPowerSwitchOn;
char* AUDIO_DIR;
int32_t fxDistortRainScale[18];
FRPlayerObject* g_playerDebugPtr;
CoreHash TRHashes::ANIMSTATE_GREEN_CRYSTAL_NOWT_HASH;
float m_storedTime;
int32_t CoreInit::m_latchMemoryStickAttachedCounter;
float NewPickUpBounds[12];
InputName g_keyInputNames[109];
TRInvInit inv_puzzle3_option;
uint32_t CoreSceneContainer::m_currentContainer;
uint32_t numActiveModels;
uint32_t CAL0_Util::m_NumAllocs;
bool CAL0_Util::m_UseSysAllocOnly;
int32_t fxUnderwaterParticle[23];
CoreHash AE_SPLASH;
CoreHash ANIMSTATE_WALK_SWIPE_ATTACK_HASH;
uint32_t m_selectedEventIndex;
uint32_t MW::gMWClose;
CoreHash TRHashes::ANIMSTATE_180_ROLL;
bool m_multiType;
TRInvInit inv_puzzle4_option;
int32_t CoreInit::m_latchMemoryStickDetachedCounterPowerOff;
uint32_t CoreNetDevice::KEEP_ALIVE_REPLY;
CoreHash TRHashes::ALIGN_HANGHASH;
CoreHash TRHashes::RIGHTFOOTHASH;
CoreHash TRHashes::FXE_SMARTBUBBLES0_HASH;
CoreSaveGameInterface* CoreSaveGameInterface::m_defaultInstance;
CoreHash TRHashes::ANIMSTATE_CONTEXT_CLIMB_VAULT;
bool CAL0_Util::m_BanSysAlloc;
CoreHash ANIMSTATE_ROAR_HASH;
CoreHash TRHashes::DEFAULTHASH;
int32_t CoreBlender::m_instanceCounter;
bool CoreInit::m_forceSpanish;
TRBiteInfo teeth3a;
bool TRETriggerNode::m_bShowEventConnections;
TRBiteInfo teeth3b;
CoreNamedPipeInterface* CoreNamedPipeInterface::m_defaultInstance;
int32_t fxPlaneHaze[15];
CoreRGBA Colour_MediumSlateBlue;
TRSceneryNode::vinePresets TRSceneryNode::m_vinePresets[24];
RegVal m_windowRegPosition;
RegVal m_windowRegPosition;
float lpfCoords0[22];
int32_t fxFireBallSmokeCallBack[9];
float m_storedRed;
uint32_t CoreSceneContainer::m_lightGlobalListIndex;
CoreHash TRHashes::ATTRACTOR_HANGINWALLHASH;
float lpfCoordsP[10];
int32_t fxTargetGlow[18];
CoreHash CoreInput::CORE_MENU_LEFT_1;
CoreHash CoreInput::CORE_MENU_LEFT_0;
CoreHash* g_boneTable[6];
CoreHash TRHashes::BREAKHASH;
CoreRGBA CA_Colour_Yellow;
int32_t fxMediumSplash[42];
TRInvInit inv_key1_option;
CoreModelMaterial** CoreSceneContainer::m_meshDynamicListTable;
CoreRGBA CA_Colour_MediumSlateBlue;
char s_OSKTextBuffer[385];
TRBiteInfo nlarson_gun;
CoreFXEmitterItem fxeWaterMistFall[2];
uint32_t CoreNetDevice::NETWORK_PLAYER_INFO_REQUEST;
char* fontAssetTypeName;
bool CoreBlender::m_boneSet0[64];
int32_t fxDumbBubbleGroup0[30];
CoreHash TRHashes::ANIMSTATE_GREEN_CRYSTAL_FLASH_HASH;
CoreFXEmitterItem fxeBeam1[2];
CoreRGBA CoreGameDialogs::ScreenOverlayRGBA;
uint32_t numTotalZones;
char* BSI_REPLY_BUILD_PREFIX;
CoreHash ANIMSTATE_WOLF_WALK_HASH;
int32_t fxWaterfallRockHitStatic[37];
uint32_t levelRenderNumModels;
uint32_t SLIDE_TYPE_ROOFSLATE;
int32_t CoreInit::m_memoryStickAttachedCounter;
TRBiteInfo ncowboy_gun1;
bool g_finishedOSK;
uint32_t CoreAudio::m_MusicVolume;
CoreHash TRHashes::LEFTHASH;
bool g_inOSK;
bool CoreRegistryInterface::m_emulateUsingFile;
float climbWallEdgeDown;
float s_screenCanProceed;
CoreHash TRHashes::ANIMSTATE_CONTEXT_SLIDE;
int32_t TRHitItem::m_pickedItem;
uint32_t CoreAnimationSet::s_animationSetID;
int32_t CoreTypes::MaxInt64;
float lpfCoordsUnderscore[4];
CoreHash TRHashes::ANIMSTATE_CEILING_FALL_HASH;
bool CoreAudio::m_FadeOut;
uint32_t SLIDE_TYPE_WOOD;
uint32_t TRHitItem::m_numItemsInScope;
CoreHash TRHashes::ACTION_FIRE;
bool CoreInit::m_firstArgIsExeName;
uint32_t CoreSceneContainer::m_maxContainers;
bool CoreInit::m_meshClampOnly;
CoreHash TRHashes::ANIMSTATE_CONTEXT_PUZZLE;
uint32_t CoreNetDevice::ARE_YOU_A_SERVER;
int32_t CoreDebug::m_iProfilerActiveLevel;
WeaponInfoStruct weaponInfo[2];
int32_t CoreInitPC::m_debugMemoryPoolSize;
CoreHash TRHashes::ANIMSTATE_IDLE_LACES_MIRRORHASH;
uint32_t CoreNetDevice::SYNC_QUERY;
bool TRHitItem::m_processNodes[11];
int32_t CoreCommonDialogStatus::m_activeCommonDialogCount;
float lpfCoordsQuote[4];
char* CAL1_AudioItem::m_TypeHeaders[19];
uint32_t CoreTypes::MaxUInt64;
int32_t CoreInit::m_latchMemoryStickDetachedCounter;
CoreHash AE_TRICK_TEXT_1;
uint32_t CoreDebug::m_DebugValue;
CoreHash AE_TRICK_TEXT_3;
CoreHash AE_TRICK_TEXT_2;
CoreFXEmitterItem fxeGroundMist[1];
TRInvInit inv_leadbar_option;
uint32_t TRFXNode::m_createCount;
bool CoreFX::m_HideFX;
TREditor gEditor;
CoreHash TRHashes::ANIMSTATE_STOP_HASH;
CoreQWORD CoreClusterFileSystem::m_memoryBuffer[4608];
int32_t CoreInit::m_latchMemoryStickAttachedCounterPowerOff;
int32_t CoreInputConnectedControllers::m_validCount2;
CoreHash effectsBoneTable[20];
CoreHash TRHashes::ANIMSTATE_CONTEXT_HANG_SHIMMY;
CoreHash TRHashes::ANIMSTATE_RUN_STARTHASH;
CoreHash TRHashes::ANIMSTATE_RAGDOLL_GETUPHASH;
CoreMessageBoxInterface* CoreMessageBoxInterface::m_defaultInstance;
CoreHash TRHashes::ANIMSTATE_UNDERWATER_SWIM_HASH;
CoreHash TRHashes::HEADHASH;
CoreStringBuffer<256> CoreError::s_exeName;
uint32_t* TRNode::m_pNodeHeader;
CoreHash TRHashes::ANIMSTATE_PUSH_STOP_HASH;
CoreHash TRHashes::ANIMSTATE_BLOCK_PUSHHASH;
uint32_t CoreNode::m_nodeSizes[11];
TRBiteInfo teeth2a;
uint32_t CoreLED::m_lastPopped;
TRBiteInfo teeth2b;
CoreHash TRHashes::ANIMSTATE_CONTEXT_UNDERWATER_SWIMMING;
int32_t fxWaterFoam[21];
CoreFader CoreGameDialogs::ScreenOverlayFader;
float lpfCoords1[10];
CoreLevelLight* s_engineDynamicLevelLight;
uint32_t CoreAudio::m_FadeFrameCount;
float lpfCoordsQ[20];
CoreHash CoreWorld::m_FXAssetTypeHash;
float lpfCoordsA[12];
CoreHash TRHashes::ATTRACTOR_WATEREDGEHASH;
int32_t CoreInputConnectedControllers::m_controllerCount;
CoreFXEmitterItem fxeBeam0_NegZ[2];
CoreRGBA CoreDebug::m_oModeTextColour;
int32_t fxFlickerGlowHandSmall[19];
float ARROW_HEAD_LENGTH_IN_WORLD_UNITS;
CoreFXEmitterItem fxeSwirlSnowNegZ[3];
CoreHash TRHashes::ANIMSTATE_ON_HASH;
CoreRTreeParams CoreDetectionData::m_rtreeParams;
CoreHash ANIMSTATE_WOLF_LEAPMID_HASH;
CAL0_Heap CAL0_Util::m_Heap;
int32_t fxDumbBubbleGroup1[30];
bool CoreInit::m_forceJAP;
void $E416();
void $E413();
void CoreObjectControllerInfo::~CoreObjectControllerInfo();
void $E41();
void CoreObjectControllerInfo::CoreObjectControllerInfo();
void $E518();
void $E419();
void* CAL1_AudioStreamerPC::`scalar deleting destructor'();
void CoreMenuComponentListBox::ListBoxItem::ListBoxItem();
void* CAL0_MemoryManagerSoundRAM::`scalar deleting destructor'();
void* CoreGraphicsDevice::`scalar deleting destructor'();
void $E512();
void TriBatch::~TriBatch();
void $E515();
void* TRGameObject::`scalar deleting destructor'();
void* CAL1_AudioPlayback::`scalar deleting destructor'();
void CoreMenuSystemData::~CoreMenuSystemData();
void $E51();
void TriBatchStore::TriBatchStore();
void QuadStore::QuadStore();
void* CoreFileDevice::`scalar deleting destructor'();
void CoreChaseCamera::~CoreChaseCamera();
void $E611();
void $E614();
void* CoreGraphicsDeviceNull::`scalar deleting destructor'();
void $E617();
void $E311();
void $E71();
void $E317();
void CoreAnimatingObjectData::CoreAnimatingObjectData();
void $E314();
void TRInvObject::~TRInvObject();
void $E81();
void TRObjectInfo::~TRObjectInfo();
void $E108();
void $E107();
void $E105();
void $E104();
void $E102();
void $E101();
void TRPanel::TRPanel();
void FRObjectController::~FRObjectController();
void CoreBlenderBasic::CoreBlenderBasic();
void CoreSpecInfo::CoreSpecInfo();
void* TREdItemNode::`scalar deleting destructor'();
void $E209();
void $E204();
void $E206();
void $E207();
void CoreGameMessageBoxParameters::~CoreGameMessageBoxParameters();
void* CoreNodeRoot::`scalar deleting destructor'();
void $E200();
void $E138();
void CoreRegistryEmulateUsingFile::CoreRegistryEmulateUsingFile();
void* CoreInputDeviceNull::`scalar deleting destructor'();
void $E137();
void* CAL1_InstanceTable::`scalar deleting destructor'();
void CoreAnimDataInfo::CoreAnimDataInfo();
void $E21();
void $E201();
void* CAL0_Heap::`scalar deleting destructor'();
void* CAL1_AudioStreamer_Standard::`scalar deleting destructor'();
[! NO TYPE] CoreGameFrame::operator=();
void* CoreFXMaterial::`scalar deleting destructor'();
void $E135();
void* CAL1_ProgramLoader::`scalar deleting destructor'();
void $E203();
void $E134();
void QuadStore::~QuadStore();
void CorePanelData::~CorePanelData();
void TRBGLightNode::~TRBGLightNode();
void TRChaseCamera::~TRChaseCamera();
void TRECameraNode::~TRECameraNode();
void $E132();
void TRFixedCamera::~TRFixedCamera();
void $E131();
void $E213();
void* FRObjectController::`scalar deleting destructor'();
void TRSceneryNode::~TRSceneryNode();
void* CoreMemory::`scalar deleting destructor'();
void $E212();
void TRTriggerNode::~TRTriggerNode();
void $E210();
void CoreAudioLocatorObject::~CoreAudioLocatorObject();
void TRMultiMeshObject::~TRMultiMeshObject();
void CoreAudio_SpeechQueue::~CoreAudio_SpeechQueue();
void CoreMap<unsigned int>::~CoreMap<unsigned int>();
void CoreGroupRailCamera::~CoreGroupRailCamera();
void* TRFXNode::`scalar deleting destructor'();
void CoreWorldInternalData::~CoreWorldInternalData();
void $E216();
void $E215();
void* CAL0_MemoryManager::`scalar deleting destructor'();
void CoreMap<LoggerOutput::Logger>::~CoreMap<LoggerOutput::Logger>();
void CoreMap<bool __cdecl(FRPlayerObject * const,int)>::~CoreMap<bool __cdecl(FRPlayerObject * const,int)>();
void $E92();
void $E20();
void CoreInputMapping::CoreInputMapping();
void* FRFXLibrary::`scalar deleting destructor'();
void* CoreGameRender::`scalar deleting destructor'();
void __stdcall __ArrayUnwind(void* ptr, uint32_t size, int32_t count, void* pDtor);
void __stdcall `eh vector constructor iterator'(void* ptr, uint32_t size, int32_t count, void* pCtor, void* pDtor);
void $E219();
void TRCameraNode::~TRCameraNode();
void* TRPanel::`scalar deleting destructor'();
void* CAL1_SampleGroupPlayback::PlaybackData_Sequencial::`scalar deleting destructor'();
void* CoreObject::`scalar deleting destructor'();
void $E13();
void $E218();
void* CoreBinaryScriptStore::`scalar deleting destructor'();
void $E308();
void* TRMultiMeshObject::`scalar deleting destructor'();
void* CoreNamedPipeDummyInterface::`scalar deleting destructor'();
void $E305();
void $E302();
void* CoreBlender::`scalar deleting destructor'();
void* CoreWorld::`scalar deleting destructor'();
void* CoreCutScenePlayer::`scalar deleting destructor'();
void $E239();
void $E30();
void* CAL1_SampleGroupPlayback::PlaybackData_Random::`scalar deleting destructor'();
void* CAL1_AudioItemFileLink::`scalar deleting destructor'();
void TREdItemNode::~TREdItemNode();
void $E11();
void CoreBlenderSimple::CoreBlenderSimple();
void CAL1_SampleGroupPlayback::PlaybackData_Chain::~PlaybackData_Chain();
void $E236();
void CoreWorldInternalData::CoreWorldInternalData();
void* RegVal::`scalar deleting destructor'();
void $E401();
void $E407();
void $E404();
void $E230();
void $E509();
void $E503();
void $E500();
void TriBatch::TriBatch();
void* TRETriggerNode::`scalar deleting destructor'();
void $E90();
void $E233();
void $E506();
void* CoreClusterFileSystem::`scalar deleting destructor'();
void TRManipNode::TRManipNode();
void* CoreMenuComponent::`scalar deleting destructor'();
void CoreNodeRoot::~CoreNodeRoot();
void $E110();
void CoreGraphicsDeviceOpenGLInternalData::CoreGraphicsDeviceOpenGLInternalData();
void* CorePCStdCFileDevice::`scalar deleting destructor'();
void FRPlayerObject::~FRPlayerObject();
void $E50();
void $E111();
void* CoreCutSceneCamera::`scalar deleting destructor'();
void $E608();
void $E23();
void $E602();
void $E113();
void* CoreBlenderBasic::`scalar deleting destructor'();
void* CAL1_StreamLoader::`scalar deleting destructor'();
void TRObjectInfo::TRObjectInfo();
void FRTrickTable::~FRTrickTable();
void $E605();
void $E114();
void* CoreGameController::`scalar deleting destructor'();
void $E60();
void CoreGameOnScreenKeyboardParameters::~CoreGameOnScreenKeyboardParameters();
void $E116();
void $E338();
void* CoreAudioLocatorObject::`scalar deleting destructor'();
void FRBackgroundObject::~FRBackgroundObject();
void $E117();
void $E335();
void* CoreNetDevice::`scalar deleting destructor'();
void $E119();
void $E86();
void CoreCameraObjectData::CoreCameraObjectData();
void CoreLevelUpdateStruct::CoreLevelUpdateStruct();
void* CAL1_AudioItem::`scalar deleting destructor'();
void* CoreNet::`scalar deleting destructor'();
void TRMenuSystem::~TRMenuSystem();
void $E179();
void* CoreRegistryEmulateUsingFile::`scalar deleting destructor'();
void $E177();
void $E332();
void $E176();
void $E174();
void $E173();
void CoreGameControllerInternalData::CoreGameControllerInternalData();
void $E171();
void FRBackgroundObjectData::FRBackgroundObjectData();
void CoreObjectUpdateStruct::CoreObjectUpdateStruct();
void CoreCutScenePlayerData::CoreCutScenePlayerData();
void $E170();
void $E96();
void $E80();
void $E17();
void CoreNodeChainGroup::CoreNodeChainGroup();
void CoreMenuSystemData::CoreMenuSystemData();
void CoreLevelAsyncData::CoreLevelAsyncData();
void CoreCutSceneCamera::~CoreCutSceneCamera();
void $E33();
void $E278();
void CoreBlenderComplex::CoreBlenderComplex();
void $E275();
void $E272();
void* CoreObjectController::`scalar deleting destructor'();
void $E27();
void* CAL0_API::`scalar deleting destructor'();
void* CoreAssetManager::`scalar deleting destructor'();
void $E374();
void FRActionStatus::FRActionStatus();
void CoreInputState::CoreInputState();
void $E377();
void* CoreNetDevicePC::`scalar deleting destructor'();
void TRCreature::TRCreature();
void TRObjectNode::~TRObjectNode();
void $E371();
void* CoreInputDeviceDirectInput::`scalar deleting destructor'();
void $E479();
void* CoreGameOnScreenKeyboard::`scalar deleting destructor'();
void $E473();
void $E470();
void* TRFixedCamera::`scalar deleting destructor'();
void* TRBGLightNode::`scalar deleting destructor'();
void* TRAIController::`scalar deleting destructor'();
void* TREdObject::`scalar deleting destructor'();
void* CAL1_SampleGroupPlayback::PlaybackData::`scalar deleting destructor'();
void* CoreRegistryPC::`scalar deleting destructor'();
void $E476();
void $E431();
void TRPanelPolyGroup::TRPanelPolyGroup();
void* CoreChaseCamera::`scalar deleting destructor'();
void $E437();
void $E434();
void CoreCutSceneObject::~CoreCutSceneObject();
void TREdObject::~TREdObject();
void $E47();
void $E578();
void* TRObjectNode::`scalar deleting destructor'();
void $E572();
void* CorePCBuildSystemFileDevice::`scalar deleting destructor'();
void CoreGameControllerInternalData::~CoreGameControllerInternalData();
void* TRFoliageObject::`scalar deleting destructor'();
void $E72();
void CoreFontTextureInfo::CoreFontTextureInfo();
void $E575();
void $E57();
void* CAL0_List::`scalar deleting destructor'();
void CoreFontTextureInfo::~CoreFontTextureInfo();
void $E77();
[! NO TYPE] CoreFRGBA::operator=();
[! NO TYPE] CoreGameMessageBoxParameters::operator=();
void* CoreRailCamera::`scalar deleting destructor'();
void aiCharacterAnim::aiCharacterAnim();
void TRMultiMeshObjectData::TRMultiMeshObjectData();
void* CoreMemoryStack::`scalar deleting destructor'();
void $E87();
[! NO TYPE] CoreGameOnScreenKeyboardParameters::operator=();
void* CAL1_AudioDriver::`scalar deleting destructor'();
void* CAL1_ReverbManager::`scalar deleting destructor'();
void $E168();
void $E167();
void* CoreMenuComponentListBox::`scalar deleting destructor'();
void $E165();
void $E164();
void $E62();
void CoreMenuComponentListBox::~CoreMenuComponentListBox();
void $E162();
void* CoreRegistryInterface::`scalar deleting destructor'();
void $E161();
void* CoreNetDeviceNULL::`scalar deleting destructor'();
void* FRBackgroundObject::`scalar deleting destructor'();
void* CAL0_File::`scalar deleting destructor'();
void $E16();
void* CAL1_ChannelManager::`scalar deleting destructor'();
void $E269();
void $E266();
void $E260();
void* CoreFX::`scalar deleting destructor'();
void $E539();
void $E263();
void $E626();
void* CoreRegistryDummyInterface::`scalar deleting destructor'();
void CoreNodeChainGroup::~CoreNodeChainGroup();
void CoreMenuComponentListBox::CoreMenuComponentListBox();
void $E623();
void $E620();
void* CoreBlenderComplex::`scalar deleting destructor'();
void $E26();
void* CAL0_MemoryManagerSoundRAMPC::`scalar deleting destructor'();
void* CAL1_API::`scalar deleting destructor'();
void $E368();
void $E78();
void $E533();
void* CAL1_SampleGroupPlayback::PlaybackData_Delay::`scalar deleting destructor'();
void $E365();
void $E629();
void $E362();
void $E530();
void* CAL0_FileLoader::`scalar deleting destructor'();
void* CAL1_AudioObject::`scalar deleting destructor'();
void $E68();
void CoreNet::CoreNet();
void $E36();
void $E536();
void $E461();
void* FRGameController::`scalar deleting destructor'();
void* CoreFileSystem::`scalar deleting destructor'();
void* CoreInputDevice::`scalar deleting destructor'();
void $E467();
void $E464();
void $E569();
void $E563();
void $E560();
void $E584();
void $E587();
void $E581();
void $E566();
void $E48();
void _RTC_Terminate();
void $E56();
void _ftol2();
void $E485();
void* CoreStdFileSystem::`scalar deleting destructor'();
void* CAL1_AudioData::`scalar deleting destructor'();
void TRManipNode::~TRManipNode();
void $E53();
void $E482();
void* CAL0_AudioWadManager::`scalar deleting destructor'();
void $E524();
void $E488();
void CoreWorldUpdateStruct::CoreWorldUpdateStruct();
void __stdcall `eh vector destructor iterator'(void* ptr, uint32_t size, int32_t count, void* pDtor);
void $E38();
void $E66();
void TRObjectDB::~TRObjectDB();
void $E383();
void $E527();
void $E380();
void $E386();
void $E389();
void $E521();
void $E84();
void $E281();
void $E287();
void TRPanel::~TRPanel();
void* CoreGraphicsDeviceOpenGL::`scalar deleting destructor'();
void $E284();
void CoreObject::~CoreObject();
void $E159();
void $E158();
void $E18();
void $E63();
void $E156();
void $E99();
void $E155();
void $E153();
void* CoreCutSceneObject::`scalar deleting destructor'();
void $E180();
void $E183();
void $E182();
void $E185();
void $E186();
void $E189();
void $E188();
void $E152();
[! NO TYPE] CoreFX::__unnamed::__unnamed();
void $E150();
void $E254();
void $E89();
void $E257();
void $E251();
void CoreMap<CoreHash const >::~CoreMap<CoreHash const >();
void $E42();
void TRGameObject::~TRGameObject();
void __SEH_prolog();
void* CAL1_SRAMLoader::`scalar deleting destructor'();
void* TRSceneryNode::`scalar deleting destructor'();
void $E359();
void* TRManipNode::`scalar deleting destructor'();
void $E356();
void* CoreLevel::`scalar deleting destructor'();
void $E350();
void* CoreConsole::`scalar deleting destructor'();
void $E69();
void $E353();
void TRWadFileManager::wadElementCreate::wadElementCreate();
void* CoreScripted::`scalar deleting destructor'();
void* CAL1_Sample::`scalar deleting destructor'();
void CoreGroupCamera::~CoreGroupCamera();
void* CoreDetect::`scalar deleting destructor'();
void $E59();
void $E35();
void* CoreFlexibleCamera::`scalar deleting destructor'();
void $E596();
void* CoreNamedPipeInterface::`scalar deleting destructor'();
void $E590();
void $E593();
void $E599();
void $E458();
void $E494();
void $E497();
void $E491();
void* CoreFXLibrary::`scalar deleting destructor'();
void $E452();
void $E425();
void $E455();
void $E39();
void __stdcall `vector constructor iterator'(void* __t, uint32_t __s, int32_t __n, void** __f);
void $E392();
void* CoreGroupRailCamera::`scalar deleting destructor'();
void $E395();
void $E398();
void $E29();
void $E45();
void $E293();
void $E290();
void $E296();
void $E299();
void $E551();
void $E557();
void $E422();
void $E98();
void CoreBlenderBasic::~CoreBlenderBasic();
void CoreRailCamera::~CoreRailCamera();
void $E191();
void $E192();
void $E195();
void $E194();
void $E197();
void* CoreMemoryArray::`scalar deleting destructor'();
void $E554();
void CAL1_SampleGroupPlayback::PlaybackData_Sequencial::~PlaybackData_Sequencial();
void TRETriggerNode::~TRETriggerNode();
void $E428();
void $E198();
void CoreGameRenderInternalData::~CoreGameRenderInternalData();
void $E65();
void TRFXNode::~TRFXNode();
void* TRInvObject::`scalar deleting destructor'();
void $E32();
void $E75();
[! NO TYPE] CAL1_AudioData::operator=();
void* FRLevel::`scalar deleting destructor'();
void* TRTriggerNode::`scalar deleting destructor'();
void* CoreAIController::`scalar deleting destructor'();
void* TRChaseCamera::`scalar deleting destructor'();
void $E149();
void $E147();
void CorePCBuildSystemFileDevice::~CorePCBuildSystemFileDevice();
void $E146();
void CoreNet::~CoreNet();
void $E144();
void $E143();
void $E141();
void CoreMap<CoreHash const >::`default constructor closure'();
void $E140();
void* CAL1_AudioItemDatabase::`scalar deleting destructor'();
void $E323();
void $E320();
void $E95();
void $E8();
void $E14();
void $E9();
void $E326();
void $E83();
void $E248();
void _RTC_Initialize();
void $E5();
void $E245();
void $E6();
void* FRPlayerObject::`scalar deleting destructor'();
void $E242();
void* CoreNamedPipePC::`scalar deleting destructor'();
void $E24();
void $E344();
void* CAL1_AudioStreamer::`scalar deleting destructor'();
void $E2();
void* TRCameraNode::`scalar deleting destructor'();
void $E347();
void* CAL1_SampleGroupPlayback::PlaybackData_Chain::`scalar deleting destructor'();
void $E329();
void* CoreBatchRenderPC::`scalar deleting destructor'();
void $E341();
void* CAL1_SampleGroup::`scalar deleting destructor'();
void* CoreMemoryPool::`scalar deleting destructor'();
void __SEH_epilog();
void $E449();
void* CoreGroupCamera::`scalar deleting destructor'();
void $E443();
void $E129();
void $E440();
void* CoreMenuSystem::`scalar deleting destructor'();
void $E446();
void $E44();
void CoreMap<FRActionStatus>::~CoreMap<FRActionStatus>();
void $E128();
void* TRECameraNode::`scalar deleting destructor'();
void $E548();
void $E126();
void* CAL0_API_PC::`scalar deleting destructor'();
void* TRMenuSystem::`scalar deleting destructor'();
void $E542();
void $E545();
void $E54();
void $E125();
void* CoreBlenderSimple::`scalar deleting destructor'();
void $E221();
void* CAL1_AudioEvent::`scalar deleting destructor'();
void $E123();
void* CorePanel::`scalar deleting destructor'();
void $E122();
void CoreViewerObject::~CoreViewerObject();
void $E227();
void $E120();
void CorePanelData::CorePanelData();
void $E74();
void* CoreBatchRender::`scalar deleting destructor'();
void* CoreFXDefault::`scalar deleting destructor'();
void CoreFlexibleCamera::~CoreFlexibleCamera();
void $E224();
void* CAL1_API_PC::`scalar deleting destructor'();
void* CAL1_SampleGroupPlayback::`scalar deleting destructor'();
void TRFoliageObject::~TRFoliageObject();
void CorePCBuildSystemFileDevice::CorePCBuildSystemFileDevice();
void* CAL1_AudioDriverPC::`scalar deleting destructor'();
void* CoreViewerObject::`scalar deleting destructor'();
void CoreCameraObject::~CoreCameraObject();
void TRCreature::~TRCreature();
void $E12();
void* FRWorld::`scalar deleting destructor'();
void $E93();
void CoreCollisionBall::CoreCollisionBall();
void TRInventory::TRInventory();
void CoreGraphicsDeviceOpenGLInternalData::~CoreGraphicsDeviceOpenGLInternalData();
void* CAL0_AudioCodecADPCM::`scalar deleting destructor'();
void $E410();
#endif

#if 1 // F:\VS70Builds\3077\vc\crtbld\crt\src\intel\chkstk.asm
void _chkstk();
#endif

#if 1 // F:\VS70Builds\3077\vc\crtbld\crt\src\intel\lldiv.asm
void _alldiv();
#endif

#if 1 // F:\VS70Builds\3077\vc\crtbld\crt\src\intel\lldvrm.asm
void _alldvrm();
#endif

#if 1 // F:\VS70Builds\3077\vc\crtbld\crt\src\intel\llmul.asm
void _allmul();
#endif

#if 1 // F:\VS70Builds\3077\vc\crtbld\crt\src\intel\llshl.asm
void _allshl();
#endif

#if 1 // F:\VS70Builds\3077\vc\crtbld\crt\src\intel\ulldiv.asm
void _aulldiv();
#endif

#if 1 // F:\VS70Builds\3077\vc\crtbld\crt\src\intel\ullshr.asm
void _aullshr();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_api.cpp
void CAL0_API::CAL0_API();
void CAL0_API::~CAL0_API();
CAAudioError CAL0_API::Initialise(uint32_t i_heapSize, void* i_address, bool useSysMemory);
CAAudioError CAL0_API::Reset();
CAAudioError CAL0_API::Destroy();
void CAL0_API::SetHeapLogging(bool log);
void CAL0_API::SetMemoryLogging(bool log);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_audiocodecadpcm.cpp
void CAL0_AudioCodecADPCM::CAL0_AudioCodecADPCM();
void CAL0_AudioCodecADPCM::~CAL0_AudioCodecADPCM();
bool CAL0_AudioCodecADPCM::DecodeData(void* input, uint32_t encodedDataLength, uint32_t numChannels, void* output);
void CAL0_AudioCodecADPCM::ResetCodec();
void CoreBlenderFlags::Reset();
void CAL0_AudioCodecADPCM::Sound_Convert_ADPCM_To_16BitMono(char* indata, int32_t* outdata, int32_t sample_count, CAL0_AudioCodecADPCM::SOUND_CONVERT_PERSISTENT_ADPCM_DATA& persistent_data);
void CAL0_AudioCodecADPCM::Sound_Convert_ADPCM_To_16BitStereo(char* indata, int32_t* outdata, int32_t sample_count, CAL0_AudioCodecADPCM::SOUND_CONVERT_PERSISTENT_ADPCM_DATA& persistent_data);
bool CAL0_AudioCodecADPCM::decode4BitADPCM_DLH(uint32_t* ADPCMData, uint32_t encodedDataLength, uint32_t numChannels, int32_t* decodedPCMDataPointer, CAL0_AudioCodecADPCM::SOUND_CONVERT_PERSISTENT_ADPCM_DATA* persistant);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_audiowadmanager.cpp
void CAL0_AudioWadManager::CAL0_AudioWadManager();
void CAL0_AudioWadManager::~CAL0_AudioWadManager();
bool CAL0_AudioWadManager::OpenAudioWad(char* filename, uint32_t offset);
void CAL0_AudioWadManager::CloseAudioWad();
CAL0_AudioWadEntry* CAL0_AudioWadManager::GetWadEntry(char* filename, uint32_t m_Language);
void CAL0_AudioWadManager::ClearAllEntries();
CAL0_File* CAL0_AudioWadManager::GetOpenWadFile();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_file.cpp
void CAL0_File::CAL0_File();
void CAL0_File::~CAL0_File();
char* CAL0_File::GetFilePath();
uint32_t CAL0_File::Read_uint32();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_fileloader.cpp
void CAL0_FileLoader::CAL0_FileLoader();
void CAL0_FileLoader::~CAL0_FileLoader();
CAAudioError CAL0_FileLoader::LoadFile(CAL0_File* file, uint32_t offset);
CAAudioError CAL0_FileLoader::ReadHeader();
CAAudioError CAL0_FileLoader::ParseChunks();
CAAudioError CAL0_FileLoader::LoadSection(uint32_t sectionIndex);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_heap.cpp
void CAL0_Heap::CAL0_Heap();
void CAL0_Heap::~CAL0_Heap();
void CAL0_Heap::ResetParams();
void CAL0_Heap::SetHeapName(char* name);
void CAL0_Heap::SetHeapColour(char* colour);
CAAudioError CAL0_Heap::SetHeapMarker();
CAAudioError CAL0_Heap::ResetHeapMarker();
CAAudioError CAL0_Heap::ResetHeapToMarker();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_list.cpp
void CAL0_List::CAL0_List(uint32_t i_maxItems);
void CAL0_List::~CAL0_List();
CAAudioError CAL0_List::AddItem(void* i_item, uint32_t i_ID, uint32_t* o_entryPoint);
CAAudioError CAL0_List::SetItem(void* i_item, uint32_t i_ID, uint32_t i_position);
CAAudioError CAL0_List::GetItem(uint32_t i_position, void** i_item, uint32_t* o_ID);
CAAudioError CAL0_List::Shuffle();
CAAudioError CAL0_List::DeleteItemByPosition(uint32_t i_position);
CAAudioError CAL0_List::DeleteItemByID(uint32_t i_ID);
CAAudioError CAL0_List::GetItemFromID(uint32_t i_ID, void** o_item, uint32_t* o_position);
CAAudioError CAL0_List::GetIDFromIndex(uint32_t i_index, uint32_t* o_ID);
CAAudioError CAL0_List::GetIndexFromID(uint32_t i_ID, uint32_t* o_index);
CAAudioError CAL0_List::InsertItemBeforeItem(void* i_item, uint32_t i_ID, void* i_searchItem);
CAAudioError CAL0_List::ClearAll();
CAAudioError CAL0_List::CopyItems(CAL0_List* fromList);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_memorymanager.cpp
void CAL0_MemoryManager::CAL0_MemoryManager(uint32_t numMemAllocs, uint32_t startAddr, uint32_t endAddr);
void CAL0_MemoryManager::~CAL0_MemoryManager();
uint32_t CAL0_MemoryManager::AllocateMemory(uint32_t bytes);
CAAudioError CAL0_MemoryManager::DeallocateMemory(uint32_t pointer);
CAAudioError CAL0_MemoryManager::ClearAllAllocatedMemory();
CAAudioError CAL0_MemoryManager::GetUsedMemory(uint32_t* bytes);
CAAudioError CAL0_MemoryManager::GetUnusedMemory(uint32_t* bytes);
CAAudioError CAL0_MemoryManager::GetLargestFreeBlockSize(uint32_t* bytes);
CAAudioError CAL0_MemoryManager::CopyDataToBlock(uint32_t blockAddr, void* dataPtr);
CAAudioError CAL0_MemoryManager::CopyDataDirectly(uint32_t destAddr, uint32_t srcAddr, uint32_t length);
uint32_t CAL0_MemoryManager::Align(uint32_t value);
CAAudioError CAL0_MemoryManager::MemCopy(void* dest, void* source, uint32_t length);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_memorymanagersoundram.cpp
void CAL0_MemoryManagerSoundRAM::CAL0_MemoryManagerSoundRAM(uint32_t numMemAllocs, uint32_t startAddr, uint32_t endAddr);
void CAL0_MemoryManagerSoundRAM::~CAL0_MemoryManagerSoundRAM();
uint32_t CAL0_MemoryManagerSoundRAM::AllocateMemory(uint32_t bytes);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\cal0_util.cpp
CAAudioError CAL0_Util::InitialiseHeap(uint32_t heapSize, void* address, bool useSysMemory);
CAAudioError CAL0_Util::ResetHeap();
void* CAL0_Util::AllocateMemoryFromHeap(uint32_t size);
void CAL0_Util::DeallocateMemoryFromHeap(void* address);
CAAudioError CAL0_Util::ca_LockSystemHeap();
CAAudioError CAL0_Util::ca_ResetLevelHeap();
CAAudioError CAL0_Util::ca_LockLevelHeap();
CAAudioError CAL0_Util::ca_MarkAreaHeap();
CAAudioError CAL0_Util::ca_UnMarkAreaHeap();
uint32_t CAL0_Util::ca_mem_write_uint8(void* dest, uint32_t value);
uint32_t CAL0_Util::ca_mem_write_uint16(void* dest, uint32_t value);
uint32_t CAL0_Util::ca_mem_write_int16(void* dest, int32_t value);
uint32_t CAL0_Util::ca_mem_write_uint32(void* dest, uint32_t value);
uint32_t CAL0_Util::ca_mem_write_fixed(void* dest, ca_floatfp value);
uint32_t CAL0_Util::ca_mem_write_data(void* dest, void* data, uint32_t length);
uint32_t CAL0_Util::ca_mem_read_uint8(void* dest, uint32_t* value);
uint32_t CAL0_Util::ca_mem_read_uint16(void* dest, uint32_t* value);
uint32_t CAL0_Util::ca_mem_read_int16(void* dest, int32_t* value);
uint32_t CAL0_Util::ca_mem_read_uint32(void* dest, uint32_t* value);
uint32_t CAL0_Util::ca_mem_read_fixed(void* dest, ca_floatfp* value);
void CAL0_Util::SetHeapLogging(bool set);
void CAL0_Util::ca_showMemoryLogging(bool show);
uint32_t CAL0_Util::ca_Align(uint32_t value, uint32_t alignment);
CAAudioError CAL0_Util::strDeallocAllocAndCopy(char** destStr, char* sourceStr);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\pc\cal0_api_pc.cpp
void CAL0_API_PC::CAL0_API_PC();
void CAL0_API_PC::~CAL0_API_PC();
CAAudioError CAL0_API_PC::Initialise(uint32_t i_heapSize, void* i_Address, bool useSysMemory);
CAAudioError CAL0_API_PC::Reset();
CAAudioError CAL0_API_PC::Destroy();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\pc\cal0_file_pc.cpp
CAAudioError CAL0_File::Open(char* i_filePath, CAL0_FILE_ACCESS i_accessType, bool lockToUser);
CAAudioError CAL0_File::Reopen(CAL0_FILE_ACCESS i_accessType);
CAAudioError CAL0_File::Read(uint32_t* o_destination, uint32_t i_numBytes, uint32_t& o_BytesRead);
CAAudioError CAL0_File::Seek(int32_t i_offset, CAL0_FILE_SEEK i_seekType);
CAAudioError CAL0_File::Write(uint32_t* i_source, uint32_t i_numBytes);
CAAudioError CAL0_File::Close();
uint32_t CAL0_File::GetCursorPosition();
uint32_t CAL0_File::GetFileLength();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\pc\cal0_globalfile_pc.cpp
uint32_t a_open(void* filename, uint32_t accessType);
uint32_t a_close(uint32_t fileID);
uint32_t a_seek(uint32_t fileID, int32_t offset, uint32_t seekType);
uint32_t a_read(uint32_t fileID, void* buffer, uint32_t readLength);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\pc\cal0_heap_pc.cpp
CAAudioError CAL0_Heap::Initialise(uint32_t heapSize, void* memoryPointer, bool useSysMemory);
CAAudioError CAL0_Heap::Release();
void* CAL0_Heap::Alloc(uint32_t size);
void CAL0_Heap::Dealloc(void* blockPointer);
bool CAL0_Heap::CheckHeapInit();
void CAL0_Heap::SetHeapLogging(bool log);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\pc\cal0_math_pc.cpp
ca_floatfp CAL0_Math::ca_sinfp(ca_floatfp radians);
ca_floatfp CAL0_Math::ca_cosfp(ca_floatfp radians);
ca_floatfp CAL0_Math::ca_asinfp(ca_floatfp value);
ca_floatfp CAL0_Math::ca_atanfp(ca_floatfp value);
ca_floatfp CAL0_Math::ca_sqrtfp(ca_floatfp a);
ca_floatfp CAL0_Math::ca_log10fp(ca_floatfp x);
uint32_t CAL0_Math::ca_rand();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\pc\cal0_memorymanagersoundrampc.cpp
void CAL0_MemoryManagerSoundRAMPC::CAL0_MemoryManagerSoundRAMPC(uint32_t numMemAllocs, uint32_t startAddr, uint32_t endAddr);
void CAL0_MemoryManagerSoundRAMPC::~CAL0_MemoryManagerSoundRAMPC();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l0_lowlevel\pc\cal0_util_pc.cpp
void CAL0_Util::ca_dbgLog(bool is_valid, char* format);
void* CAL0_Util::ca_AllocSysMem(uint32_t size);
void CAL0_Util::ca_DeallocSysMem(void* address);
void CAL0_Util::ca_InitMemory();
void CAL0_Util::ca_ReleaseMemory();
void* CAL0_Util::ca_AllocMemory(uint32_t size);
void CAL0_Util::ca_DeallocMemory(void* address);
void* CAL0_Util::ca_memset(void* ptr, char value, uint32_t length);
void* CAL0_Util::ca_memcpy(void* ptr_dest, void* ptr_src, uint32_t length);
int32_t CAL0_Util::ca_memcmp(void* ptr_one, void* ptr_two, uint32_t length);
int32_t CAL0_Util::ca_strlen(char* str1);
char* CAL0_Util::ca_strcpy(char* str_dest, char* str_src);
int32_t CAL0_Util::ca_strcmp(char* str1, char* str2);
char* CAL0_Util::ca_strncpy(char* dest, char* src, uint32_t length);
char* CAL0_Util::ca_strcat(char* dest, char* src);
uint32_t CAL0_Util::ca_sprintf(char* stringBuffer, char* format);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_api.cpp
void CAL1_API::CAL1_API();
void CAL1_API::~CAL1_API();
CAAudioError CAL1_API::Initialise(uint32_t i_heapSize, void* i_address, bool i_useSysMemory, uint32_t i_numChannels, uint32_t i_numStreams, uint32_t i_numEffects, uint32_t i_numDBItems, uint32_t i_creationFlags, uint32_t i_maxInstances);
CAAudioError CAL1_API::Reset();
CAAudioError CAL1_API::Destroy();
CAAudioError CAL1_API::CreateNonPlatformObjects();
CAAudioError CAL1_API::LoadProgram(char* filename, uint32_t offset);
CAAudioError CAL1_API::LoadSRAM(char* filename, uint32_t offset);
CAAudioError CAL1_API::LoadStream(char* filename, uint32_t offset, uint32_t languageMask);
CAAudioError CAL1_API::LoadAudioWad(char* filename, uint32_t offset, char* levelName, uint32_t languageMask);
CAL1_AudioDriver* CAL1_API::GetAD();
CAL1_AudioItemDatabase* CAL1_API::GetAID();
CAAudioError CAL1_API::FrameEnd();
CAAudioError CAL1_API::StartAudioItem(uint32_t audioID, uint32_t instance);
CAAudioError CAL1_API::StartAudioItemParam(uint32_t audioID, uint32_t instance, uint32_t param);
CAAudioError CAL1_API::UpdateAudioItem(uint32_t audioID, uint32_t instance);
CAAudioError CAL1_API::TriggerAudioItem(uint32_t audioID, uint32_t instance);
CAAudioError CAL1_API::StopAudioItem(uint32_t audioID, uint32_t instance);
bool CAL1_API::IsAudioItemPlaying(uint32_t audioID, uint32_t instance);
CAAudioError CAL1_API::StartObjectEvent(uint32_t objectID, uint32_t instance, uint32_t eventID);
CAAudioError CAL1_API::StartObjectEventParam(uint32_t objectID, uint32_t instance, uint32_t eventID, uint32_t param);
CAAudioError CAL1_API::UpdateObjectEvent(uint32_t objectID, uint32_t instance, uint32_t eventID);
CAAudioError CAL1_API::TriggerObjectEvent(uint32_t objectID, uint32_t instance, uint32_t eventID);
CAAudioError CAL1_API::StopObjectEvent(uint32_t objectID, uint32_t instance, uint32_t eventID);
CAAudioError CAL1_API::UpdateObject(uint32_t objectID, uint32_t instance);
bool CAL1_API::IsObjectEventPlaying(uint32_t objectID, uint32_t instance, uint32_t eventID);
CAAudioError CAL1_API::SetAudioData(CAL1_AudioData* audioData);
void CAL1_API::ResetAudioData();
void CAL1_API::SetAudioData_3D(bool is3D);
void CAL1_API::SetAudioData_GroupMask(uint32_t groupMask);
void CAL1_API::SetAudioData_Point(ca_3DPoint point);
void CAL1_API::SetAudioData_Velocity(ca_3DVelocity velocity);
void CAL1_API::SetAudioData_VolumeOffset(uint32_t volumeOffset);
void CAL1_API::SetListenerPosition(ca_floatfp x, ca_floatfp y, ca_floatfp z);
void CAL1_API::SetListenerOrientation(ca_floatfp fx, ca_floatfp fy, ca_floatfp fz, ca_floatfp tx, ca_floatfp ty, ca_floatfp tz);
void CAL1_API::SetListenerVelocity(ca_floatfp dx, ca_floatfp dy, ca_floatfp dz);
void CAL1_API::StopAll();
void CAL1_API::Pause();
void CAL1_API::UnPause();
void CAL1_API::DisconnectHardware();
void CAL1_API::ReconnectHardware();
bool CAL1_API::IsHardwareConnected();
void CAL1_API::SetGlobalReverb(uint32_t reverbID);
uint32_t CAL1_API::GetVersionNumber();
CAAudioError CAL1_API::LoadLevel(char* globalFileName, uint32_t globalOffset, char* globalLevelName, uint32_t globalLanguageMask, char* filename, uint32_t offset, char* levelName, uint32_t languageMask);
CAAudioError CAL1_API::LoadLevelScene(char* sceneName, uint32_t languageMask);
CAAudioError CAL1_API::MarkCurrentArea();
CAAudioError CAL1_API::ResetCurrentArea();
CAAudioError CAL1_API::UnloadLevelScene(char* sceneName);
CAAudioError CAL1_API::UnloadLevel();
CAAudioError CAL1_API::CreateInstance(uint32_t itemID, uint32_t& instance);
uint32_t CAL1_API::GetNumInstances();
void CAL1_API::SetGroupVolume(uint32_t iGroupIndex, uint32_t iVolume);
uint32_t CAL1_API::GetGroupVolume(uint32_t iGroupIndex);
void CAL1_API::DebugShowStats();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audiodata.cpp
void CAL1_AudioData::CAL1_AudioData();
void CAL1_AudioData::~CAL1_AudioData();
void CAL1_AudioData::Reset();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audiodriver.cpp
void CAL1_AudioDriver::CAL1_AudioDriver(uint32_t numChannels, uint32_t numStreams, uint32_t numReverbPresets);
void CAL1_AudioDriver::Reset();
void CAL1_AudioDriver::~CAL1_AudioDriver();
void CAL1_AudioDriver::Close();
CAAudioError CAL1_AudioDriver::Update3DListener();
CAAudioError CAL1_AudioDriver::Recalculate3DBasic();
CAAudioError CAL1_AudioDriver::Recalculate3DDolbySurround();
CAAudioError CAL1_AudioDriver::Recalculate3DFull();
CAAudioError CAL1_AudioDriver::Calculate3DAndDoppler(CAL1_Sample* sample);
bool CAL1_AudioDriver::CalculateViewTransform(CAL1_AudioListener* listener, ca_floatfp* pViewMatrix);
bool CAL1_AudioDriver::CalculateLRFRAndDistance(ca_floatfp SoundX, ca_floatfp SoundY, ca_floatfp SoundZ, ca_floatfp* pViewMatrix, ca_floatfp* pPan, ca_floatfp* pFrontRear, ca_floatfp* pDistance);
ca_floatfp CAL1_AudioDriver::CalculateDoppler(ca_floatfp listener_x, ca_floatfp listener_z, ca_floatfp listener_v, ca_floatfp listener_theta, ca_floatfp source_x, ca_floatfp source_z, ca_floatfp source_v, ca_floatfp source_theta, ca_floatfp source_min_dist, ca_floatfp source_max_dist, ca_floatfp doppler_factor);
CAAudioError CAL1_AudioDriver::Set3DAndDopplerMode(uint32_t threeDMode, uint32_t dopplerMode);
CAAudioError CAL1_AudioDriver::SetNextListener(CAL1_AudioListener* listener);
CAAudioError CAL1_AudioDriver::FrameEnd();
CAAudioError CAL1_AudioDriver::Stream();
void CAL1_AudioDriver::Tick();
CAAudioError CAL1_AudioDriver::StartAudioItem(CAL1_AudioPlayback* item);
CAAudioError CAL1_AudioDriver::AddToPlaybackList(CAL1_AudioPlayback* item);
CAAudioError CAL1_AudioDriver::EndAudioItem(CAL1_AudioPlayback* item);
CAAudioError CAL1_AudioDriver::UpdateAudioItem(CAL1_AudioPlayback* item);
CAAudioError CAL1_AudioDriver::TriggerAudioItem(CAL1_AudioPlayback* item);
CAAudioError CAL1_AudioDriver::TickAudioPlaybackList();
CAAudioError CAL1_AudioDriver::StopSample(CAL1_Sample* sample);
uint32_t CAL1_AudioDriver::GetTimerUpdateFrequency();
CAAudioError CAL1_AudioDriver::SetDefaultStreamFileName(char* fileName, uint32_t fileOffset);
CAAudioError CAL1_AudioDriver::SetDefaultStreamFileName_Common(char* fileName, uint32_t fileOffset);
CAAudioError CAL1_AudioDriver::SetGlobalStreamFileName(char* fileName, uint32_t fileOffset);
CAAudioError CAL1_AudioDriver::SetGlobalStreamFileName_Common(char* fileName, uint32_t fileOffset);
CAAudioError CAL1_AudioDriver::UpdateChannelVolume(uint32_t channel);
CAAudioError CAL1_AudioDriver::UpdateChannelPan(uint32_t channel);
CAAudioError CAL1_AudioDriver::UpdateChannelFrequency(uint32_t channel);
CAAudioError CAL1_AudioDriver::UpdateChannel3D(uint32_t channel);
CAAudioError CAL1_AudioDriver::UpdateChannelOcclusion(uint32_t channel);
CAL1_AudioStreamer* CAL1_AudioDriver::AllocateStreamer();
CAAudioError CAL1_AudioDriver::AllocateChannelForStreamingSample(CAL1_Sample* iStreamingSample);
CAAudioError CAL1_AudioDriver::DeallocateChannelForStreamingSample(CAL1_Sample* iStreamingSample);
CAAudioError CAL1_AudioDriver::DeallocateStreamer(CAL1_AudioStreamer* streamer);
CAAudioError CAL1_AudioDriver::StopChannel(uint32_t channel);
void CAL1_AudioDriver::SetSoloMuteMask(uint32_t soloMuteMask);
uint32_t CAL1_AudioDriver::GetScaledOcclusion(ca_floatfp minDist, uint32_t occlusion);
uint32_t CAL1_AudioDriver::GetOcclusionVolumeOffset(uint32_t channel, uint32_t occlusionValue, ca_floatfp minDist);
CAAudioError CAL1_AudioDriver::SetMasterAttenuation(uint32_t masterAtten);
CAAudioError CAL1_AudioDriver::UpdateMasterAttenuation();
CAAudioError CAL1_AudioDriver::SetHRTFMode(uint32_t hrtfMode);
void CAL1_AudioDriver::PauseAll();
void CAL1_AudioDriver::UnpauseAll();
CAAudioError CAL1_AudioDriver::DeallocateAllStreams();
CAAudioError CAL1_AudioDriver::SetChannel3D(uint32_t channel, ca_3DPoint* position, ca_3DVelocity* velocity, ca_floatfp minDist, ca_floatfp maxDist);
void CAL1_AudioDriver::StopAllChannels();
uint32_t CAL1_AudioDriver::GetNumberOfChannels();
CAL1_Sample* CAL1_AudioDriver::GetSampleOnChannel(uint32_t channel);
CAL1_ChannelManager* CAL1_AudioDriver::GetChannelManager();
bool CAL1_AudioDriver::IsChannelDeferred(uint32_t channel);
uint32_t CAL1_AudioDriver::GetChannelFrequency(uint32_t channel);
bool CAL1_AudioDriver::IsEAXReverbMorphingEnabled();
bool CAL1_AudioDriver::IsChannelPaused(uint32_t channel);
CAAudioError CAL1_AudioDriver::SetChannelPan(uint32_t channel, int32_t pan, int32_t panFR);
CAAudioError CAL1_AudioDriver::SetChannelVolume(uint32_t channel, uint32_t volume);
CAAudioError CAL1_AudioDriver::SetChannelFrequency(uint32_t channel, uint32_t frequency);
CAAudioError CAL1_AudioDriver::SetChannelOcclusion(uint32_t channel, uint32_t occlusion);
CAAudioError CAL1_AudioDriver::WriteChannelBufferData(uint32_t channel, uint32_t offset, uint32_t length, void* data);
CAAudioError CAL1_AudioDriver::SetDefaultStreamFileID(uint32_t fileID);
CAAudioError CAL1_AudioDriver::SetDefaultStreamFileID_Common(uint32_t fileID);
uint32_t CoreEvent::GetDataLength();
char* CAL1_AudioDriver::GetDefaultStreamFileName();
uint32_t CAL1_AudioDriver::GetDefaultStreamFileID_Common();
int32_t CoreLevelDynamicLight::GetType();
char* CAL1_AudioDriver::GetDefaultStreamFileName_Common();
uint32_t CAL1_SRAMLoader::GetSRAMAddress();
uint32_t CAL1_AudioDriver::GetDefaultStreamFileOffset_Common();
CAAudioError CAL1_AudioDriver::SetGlobalStreamFileID(uint32_t fileID);
CAAudioError CAL1_AudioDriver::SetGlobalStreamFileID_Common(uint32_t fileID);
uint32_t CAL1_AudioDriver::GetGlobalStreamFileID();
CAL1_AudioItemDatabase* CAL1_ProgramLoader::GetAID();
int32_t CoreFileSystem::GetMaxNumberOfOpenFiles();
char* CAL1_AudioDriver::GetGlobalStreamFileName();
uint32_t CAL1_AudioDriver::GetGlobalStreamFileOffset();
uint32_t CAL1_AudioDriver::GetGlobalStreamFileID_Common();
char* CAL1_AudioDriver::GetGlobalStreamFileName_Common();
int32_t CoreBlenderComplex::AnimDataSet_GetCount();
uint32_t CAL1_AudioDriver::GetGlobalStreamFileOffset_Common();
CAL0_MemoryManagerSoundRAM* CAL1_AudioDriver::GetMemoryManager();
bool CAL1_AudioDriver::IsDriverPaused();
CAL1_ReverbManager* CAL1_AudioDriver::GetReverbManager();
CoreFont* CoreMenuComponent::GetFont();
CAAudioError CAL1_AudioDriver::StartAudioItemDelay(CAL1_AudioPlayback* item, uint32_t delay);
void CAL1_AudioDriver::TickDelayTable();
void CAL1_AudioDriver::ClearDelayTable();
void CAL1_AudioDriver::SetDeferred(bool deferred);
uint32_t CAL1_AudioDriver::SetGroupVolume(uint32_t iGroupIndex, uint32_t iVolume);
uint32_t CAL1_AudioDriver::GetGroupVolume(uint32_t iGroupIndex);
void CAL1_AudioDriver::DisconnectHardware();
void CAL1_AudioDriver::ReconnectHardware();
bool CAL1_AudioDriver::IsHardwareConnected();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audioevent.cpp
void CAL1_AudioEvent::CAL1_AudioEvent(uint32_t id, char* name, uint32_t numPlaybackItems, uint32_t numGridEntries, CAL1_AudioDriver* ad);
void CAL1_AudioEvent::~CAL1_AudioEvent();
[! NO TYPE] CAL1_AudioEvent::operator=();
CAAudioError CAL1_AudioEvent::Start();
CAAudioError CAL1_AudioEvent::End();
CAAudioError CAL1_AudioEvent::Update();
CAAudioError CAL1_AudioEvent::SetGridPosition(uint32_t gridPosition);
CAAudioError CAL1_AudioEvent::SetNumGridEntries(uint32_t numGridEntries);
CAAudioError CAL1_AudioEvent::Trigger();
uint32_t CAL1_AudioEvent::GetSaveDataCount();
uint32_t CAL1_AudioEvent::SaveData(uint32_t* memPtr);
uint32_t CAL1_AudioEvent::RestoreData(uint32_t* memPtr);
CAAudioError CAL1_AudioEvent::LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
CAAudioError CAL1_AudioEvent::SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
CAAudioError CAL1_AudioEvent::DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* aid);
CAAudioError CAL1_AudioEvent::DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
bool CAL1_AudioEvent::IsPlaying();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audioitem.cpp
void CAL1_AudioItem::CAL1_AudioItem(uint32_t id, char* name, CA_AI_Type type);
void CAL1_AudioItem::~CAL1_AudioItem();
void CAL1_AudioItem::SetName(char* name);
uint32_t CAL1_AudioItem::GetSaveDataCount();
uint32_t CAL1_AudioItem::SaveData(uint32_t* memPtr);
uint32_t CAL1_AudioItem::RestoreData(uint32_t* memPtr);
CAAudioError CAL1_ReverbManager::SetReverbLevel(CAL1_ReverbPreset* from, int32_t balance, CAL1_ReverbPreset* to);
CAAudioError CAL1_AudioItem::LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
CAAudioError CAL1_AudioItem::SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
CAAudioError CAL1_AudioItem::DuplicateItem(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* i_AID);
CAAudioError CAL1_AudioItem::DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* i_AID);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audioitemdatabase.cpp
void CAL1_AudioItemDatabase::CAL1_AudioItemDatabase(uint32_t maxItems);
void CAL1_AudioItemDatabase::~CAL1_AudioItemDatabase();
uint32_t CAL1_AudioItemDatabase::GetUniqueRuntimeID();
CAAudioError CAL1_AudioItemDatabase::AddDBItem(CAL1_AudioItem* item, uint32_t& position);
CAAudioError CAL1_AudioItemDatabase::DeleteDBItem(CAL1_AudioItem* item);
CAAudioError CAL1_AudioItemDatabase::DeleteAllDBObjects();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audioitemfilelink.cpp
void CAL1_AudioItemFileLink::CAL1_AudioItemFileLink(uint32_t id, char* name, char* linkFileName);
void CAL1_AudioItemFileLink::~CAL1_AudioItemFileLink();
void CAL1_AudioItemFileLink::SetLinkFileName(char* filename);
CAAudioError CAL1_AudioItemFileLink::LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
CAAudioError CAL1_AudioItemFileLink::SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audiolistener.cpp
void CAL1_AudioListener::CAL1_AudioListener();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audioobject.cpp
void CAL1_AudioObject::CAL1_AudioObject(uint32_t id, char* name, uint32_t numSubObjects, uint32_t numEvents);
void CAL1_AudioObject::~CAL1_AudioObject();
[! NO TYPE] CAL1_AudioObject::operator=();
CAAudioError CAL1_AudioObject::EventStart(uint32_t eventID);
CAAudioError CAL1_AudioObject::EventStartWithParams(uint32_t eventID, uint32_t gridPosition);
CAAudioError CAL1_AudioObject::EventEnd(uint32_t eventID);
CAAudioError CAL1_AudioObject::EventUpdate(uint32_t eventID);
CAAudioError CAL1_AudioObject::EventTrigger(uint32_t eventID);
bool CAL1_AudioObject::IsEventPlaying(uint32_t eventID);
CAAudioError CAL1_AudioObject::LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
CAAudioError CAL1_AudioObject::SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
CAAudioError CAL1_AudioObject::AllocateSubObjectList(uint32_t numSubObjects);
CAAudioError CAL1_AudioObject::AllocateEventList(uint32_t numEvents);
CAAudioError CAL1_AudioObject::SetAudioData(CAL1_AudioData* data);
CAAudioError CAL1_AudioObject::DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* aid);
CAAudioError CAL1_AudioObject::DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
CAAudioError CAL1_AudioObject::Update();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audioparameter.cpp
CAAudioError CAL1_AudioParameter::SetVariable(CAL1_AudioParameter::CA_AP_Type type, void* valuePtr);
CAAudioError CAL1_AudioParameter::CreateVariable(CAL1_AudioParameter::CA_AP_Type type);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audioplayback.cpp
void CAL1_AudioPlayback::CAL1_AudioPlayback(uint32_t id, char* name, uint32_t numParameters, CAL1_AudioDriver* ad);
void CAL1_AudioPlayback::~CAL1_AudioPlayback();
[! NO TYPE] CAL1_AudioPlayback::operator=();
CAAudioError CAL1_AudioPlayback::Start();
CAAudioError CAL1_AudioPlayback::End();
CAAudioError CAL1_AudioPlayback::Update();
CAAudioError CAL1_AudioDriver::Create();
int32_t CoreGraphicsDevice::GetNumGeometryPasses();
int32_t CoreBlenderSimple::GetBlenderType();
uint32_t CoreAudio::GetVersion();
uint32_t CoreGameController::GetVersion();
void CAL1_AudioPlayback::SetAudioData(CAL1_AudioData* data, uint32_t mixVolume);
CAAudioError CAL1_AudioPlayback::Tick();
CAAudioError CAL1_AudioPlayback::SetInterval(uint32_t interval);
CAAudioError CAL1_AudioPlayback::SetTimer(bool useTimer);
uint32_t CAL1_AudioPlayback::GetInterval();
bool CAL1_AudioPlayback::GetTimer();
bool CAL1_AudioPlayback::IsPlaying();
void CAL1_AudioPlayback::DoCompletionTrigger(CAL1_AudioPlayback* from);
void CAL1_AudioPlayback::DoAlmostCompleteTrigger(CAL1_AudioPlayback* from);
void CAL1_AudioPlayback::SetCompletionTrigger(CAL1_AudioPlayback* playback);
CAAudioError CAL1_AudioPlayback::DoTimer();
CAAudioError CAL1_AudioPlayback::DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* i_AID);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_audiostreamer.cpp
void CAL1_AudioStreamer_Standard::CAL1_AudioStreamer_Standard(CAL1_AudioDriver* audioDriver, uint32_t primaryBufferSize, uint32_t secondaryBufferSize);
void CAL1_AudioStreamer_Standard::~CAL1_AudioStreamer_Standard();
CAAudioError CAL1_AudioStreamer_Standard::Play(CAL1_Sample* sample);
CAAudioError CAL1_AudioStreamer_Standard::StartStream();
CAAudioError CAL1_AudioStreamer_Standard::Stop();
CAAudioError CAL1_AudioStreamer_Standard::Stream();
CAAudioError CAL1_AudioStreamer_Standard::AllocatePrimaryBuffer();
uint32_t CAL1_AudioStreamer_Standard::GetPercentComplete();
void CAL1_AudioStreamer_Standard::ResetStreamer();
uint32_t CAL1_AudioStreamer_Standard::ReadData(uint32_t fileID, void* dataBuffer, uint32_t length, uint32_t* bufferDataRead);
void CAL1_AudioStreamer_Standard::SeekData(uint32_t fileID, uint32_t fileStartOffset, uint32_t seekType);
CAAudioError CAL1_AudioStreamer_Standard::TransferStartBlockToMemory(uint32_t channel, uint32_t startOffset, uint32_t source, uint32_t length);
CAAudioError CAL1_AudioStreamer_Standard::TransferSectorToMemory(uint32_t sector, uint32_t channel, uint32_t startOffset, uint32_t source, uint32_t length);
void CAL1_AudioStreamer::~CAL1_AudioStreamer();
CAAudioError CAL1_AudioStreamer::Play(CAL1_Sample* sample);
CAAudioError CAL1_AudioStreamer::Stop();
uint32_t CAL1_AudioStreamer::GetPercentComplete();
CAAudioError CAL1_AudioStreamer::AllocateStreamer();
CAAudioError CAL1_AudioStreamer::DeallocateStreamer();
bool CAL1_AudioStreamer::IsAllocated();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_channelmanager.cpp
void CAL1_ChannelManager::CAL1_ChannelManager(uint32_t numChannels, CAL1_AudioDriver* audioDriver);
CAAudioError CAL1_ChannelManager::AllocateChannel(uint32_t* channel, uint32_t priority);
CAAudioError CAL1_ChannelManager::UpdateChannels();
CAAudioError CAL1_ChannelManager::SetChannelStatus(uint32_t channel, AAChannelStatus status);
CAAudioError CAL1_ChannelManager::DeallocateChannel(uint32_t channel);
AAChannelStatus CAL1_ChannelManager::GetChannelStatus(uint32_t channel);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_instancetable.cpp
void CAL1_InstanceTable::CAL1_InstanceTable(uint32_t i_maxEntries, CAL1_AudioItemDatabase* i_AID);
void CAL1_InstanceTable::~CAL1_InstanceTable();
CAAudioError CAL1_InstanceTable::CreateInstance(uint32_t i_audioItemID, uint32_t& instance);
CAAudioError CAL1_InstanceTable::GetInstanceRuntimeID(uint32_t i_audioItemID, uint32_t i_instance, uint32_t& o_runtimeID);
CAAudioError CAL1_InstanceTable::CreateItemInstance(CAL1_AudioItem* i_item, uint32_t i_AudioItemID, uint32_t i_newInstance);
CAAudioError CAL1_InstanceTable::ClearAllInstances();
uint32_t CAL1_InstanceTable::GetNumInstances();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_levelmanager.cpp
void CAL1_LevelManager::CAL1_LevelManager(CAL1_AudioDriver* ad, CAL1_AudioItemDatabase* aid, int32_t maxScenes, bool globalLevel);
void CAL1_LevelManager::~CAL1_LevelManager();
CAAudioError CAL1_LevelManager::Initialise();
CAAudioError CAL1_LevelManager::Destroy();
CAAudioError CAL1_LevelManager::LoadLevel(char* levelPath, char* globalSceneName, uint32_t fileOffset, uint32_t languageMask);
CAAudioError CAL1_LevelManager::LoadScene(char* sceneName, uint32_t languageMask, char* levelPath, uint32_t offset);
CAAudioError CAL1_LevelManager::UnloadScene(char* sceneName);
CAAudioError CAL1_LevelManager::UnloadLevel();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_programloader.cpp
void CAL1_ProgramLoader::CAL1_ProgramLoader(CAL1_AudioDriver* i_AD, CAL1_AudioItemDatabase* i_AID);
void CAL1_ProgramLoader::~CAL1_ProgramLoader();
CAAudioError CAL1_ProgramLoader::LoadTheSection(char* type, uint32_t version, uint32_t dataSize);
CAAudioError CAL1_ProgramLoader::LoadCAL1(uint32_t version, uint32_t dataSize);
CAAudioError CAL1_ProgramLoader::ParseCAL1_V1_0(uint32_t* data, uint32_t dataSize);
int32_t CAL1_ProgramLoader::ReadItem(uint32_t* i_itemData);
CAAudioError CAL1_ProgramLoader::ReadSample(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
CAAudioError CAL1_ProgramLoader::ReadSampleGroup(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
CAAudioError CAL1_ProgramLoader::ReadSampleGroupPlayback(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
CAAudioError CAL1_ProgramLoader::ReadAudioItemFileLink(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
CAAudioError CAL1_ProgramLoader::ReadAudioEvent(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
CAAudioError CAL1_ProgramLoader::ReadAudioObject(uint32_t i_itemID, uint32_t i_textLength, char* i_textPtr, uint32_t i_itemAttn, uint32_t* i_Data);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_reverbmanager.cpp
void CAL1_ReverbManager::CAL1_ReverbManager(uint32_t numReverbTypes, CAL1_AudioDriver* ad);
void CAL1_ReverbManager::Reset();
void CAL1_ReverbManager::~CAL1_ReverbManager();
CAAudioError CAL1_ReverbManager::RecallPreset(uint32_t i_index, uint32_t fadeTimeMS);
CAAudioError CAL1_ReverbManager::Tick();
CAAudioError CAL1_ReverbManager::SetDefaultPreset(uint32_t defPreset);
CAAudioError CAL1_ReverbManager::StartConversationEffect();
CAAudioError CAL1_ReverbManager::EndConversationEffect();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_sample.cpp
void CAL1_Sample::CAL1_Sample(uint32_t id, char* name, CAL1_AudioDriver* ad, void* data);
void CAL1_Sample::~CAL1_Sample();
[! NO TYPE] CAL1_Sample::operator=();
CAAudioError CAL1_Sample::LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
CAAudioError CAL1_Sample::SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
CAAudioError CAL1_Sample::Update();
CAAudioError CAL1_Sample::End();
CAAudioError CAL1_Sample::Start();
CAAudioError CAL1_Sample::Set3DParams(int32_t panPosition, int32_t FRPan, uint32_t distAttn, uint32_t volume, ca_floatfp doppler);
bool CAL1_Sample::IsPlaying();
bool CAL1_Sample::IsDeferred();
CAAudioError CAL1_Sample::Tick();
void CAL1_Sample::SetAudioData(CAL1_AudioData* data, uint32_t mixVolume);
CAAudioError CAL1_Sample::SetWaitingToStream(bool waiting);
CAAudioError CAL1_Sample::Pause();
CAAudioError CAL1_Sample::Resume();
uint32_t CAL1_Sample::RestoreData(uint32_t* memPtr);
int32_t CAL1_Sample::Get3DPanPosition();
ca_floatfp CAL1_Sample::GetBaseFrequencyFactor();
CAAudioError CAL1_Sample::SetDataFormat(CAL1_Sample::ASampleDataFormat dataFormat);
CAAudioError CAL1_Sample::SetSampleData(uint32_t* data, uint32_t length, bool owned);
CAAudioError CAL1_Sample::SetPlaybackType(CAL1_Sample::ASamplePlaybackType playbackType);
CAAudioError CAL1_Sample::SetStreamStartOffset(uint32_t startOffset);
CAAudioError CAL1_Sample::SetStreamEndOffset(uint32_t endOffset);
CAAudioError CAL1_Sample::SetStreamLocation(uint32_t streamLocation);
CAAudioError CAL1_Sample::SetLoop(bool loop);
CAAudioError CAL1_Sample::ResetStreamer();
CAL1_Sample::ASampleDataFormat CAL1_Sample::GetDataFormat();
uint32_t CAL1_Sample::GetBaseFrequency();
CAL1_Sample* CAL1_Sample::GetGhostSample();
uint32_t* CAL1_Sample::GetSampleData();
uint32_t CAL1_Sample::GetDataLength();
CAL1_Sample::ASamplePlaybackType CAL1_Sample::GetPlaybackType();
uint32_t CAL1_Sample::GetChannelNumber();
uint32_t CAL1_Sample::GetBaseVolume();
int32_t CAL1_Sample::GetBasePan();
ca_floatfp CAL1_Sample::GetDopplerFactor();
uint32_t CAL1_Sample::Get3DDistanceAttn();
int32_t CAL1_Sample::Get3DPanPositionFR();
char* CAL1_Sample::GetStreamFileName();
uint32_t CAL1_Sample::GetStreamEndOffset();
uint32_t CAL1_Sample::GetStreamLocation();
bool CAL1_Sample::GetLoop();
CAL1_Sample* CAL1_Sample::GetNextSample();
CAL1_AudioStreamer* CAL1_Sample::GetStreamer();
CAAudioError CAL1_Sample::SetFileName(uint32_t* filename);
CAAudioError CAL1_Sample::DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* i_AID);
CAAudioError CAL1_AudioItem::DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
CAAudioError CAL1_Sample::DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
CAAudioError CAL1_AudioPlayback::DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_samplegroup.cpp
void CAL1_SampleGroup::CAL1_SampleGroup(uint32_t id, char* name, int32_t numEntries);
void CAL1_SampleGroup::~CAL1_SampleGroup();
CAL1_AudioItem* CAL1_SampleGroup::GetItem(uint32_t entry);
CAAudioError CAL1_SampleGroup::LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
CAAudioError CAL1_SampleGroup::SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
uint32_t CAL1_SampleGroup::GetNumberOfItems();
CAAudioError CAL1_SampleGroup::DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* aid);
CAAudioError CAL1_SampleGroup::DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_samplegroupplayback.cpp
void CAL1_SampleGroupPlayback::CAL1_SampleGroupPlayback(uint32_t id, char* name, uint32_t numParameters, CAL1_AudioDriver* ad);
void CAL1_SampleGroupPlayback::~CAL1_SampleGroupPlayback();
CAAudioError CAL1_SampleGroupPlayback::Update();
CAAudioError CAL1_SampleGroupPlayback::Trigger();
CAAudioError CAL1_SampleGroupPlayback::End();
CAAudioError CAL1_SampleGroupPlayback::Start();
CAAudioError CAL1_SampleGroupPlayback::Tick();
CAAudioError CAL1_SampleGroupPlayback::LoadItemData(uint32_t* i_Data, CAL1_AudioItemDatabase* i_aid, bool editor);
CAAudioError CAL1_SampleGroupPlayback::SaveItemData(uint32_t* i_Data, uint32_t& io_numBytes, bool optimise);
CAAudioError CAL1_SampleGroupPlayback::SetPlaybackType(PlaybackDataType type, uint32_t numItems);
CAAudioError CAL1_SampleGroupPlayback::StartChain();
CAAudioError CAL1_SampleGroupPlayback::StartDelay();
CAAudioError CAL1_SampleGroupPlayback::StartRandom();
void CAL1_SampleGroupPlayback::StartSample(uint32_t index, uint32_t additionalDelay, bool setCompletion);
void CAL1_SampleGroupPlayback::StopSample(uint32_t index);
CAAudioError CAL1_SampleGroupPlayback::AlmostCompleteTrigger(CAL1_AudioPlayback* from);
CAAudioError CAL1_SampleGroupPlayback::CompletionTrigger(CAL1_AudioPlayback* from);
CAAudioError CAL1_SampleGroupPlayback::DoTimer();
bool CoreBlenderBasic::AddImmediateBlend(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
CAAudioError CAL1_AudioPlayback::Trigger();
CAAudioError CAL1_SampleGroupPlayback::DuplicateSelf(uint32_t i_newID, CAL1_AudioItem*& o_newItem, CAL1_AudioItemDatabase* aid);
CAAudioError CAL1_SampleGroupPlayback::DuplicateSubItems(CAL1_AudioItem* item, CAL1_AudioItemDatabase* i_AID);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_sramloader.cpp
void CAL1_SRAMLoader::CAL1_SRAMLoader(CAL1_AudioDriver* i_AD, CAL1_AudioItemDatabase* i_AID);
void CAL1_SRAMLoader::~CAL1_SRAMLoader();
CAAudioError CAL1_SRAMLoader::LoadTheSection(char* type, uint32_t version, uint32_t dataSize);
CAAudioError CAL1_SRAMLoader::LoadSAMM(uint32_t version, uint32_t dataSize);
CAAudioError CAL1_SRAMLoader::LoadSAMD(uint32_t version, uint32_t dataSize);
CAAudioError CAL1_SRAMLoader::ParseSAMM_V1_0(uint32_t* data, uint32_t dataSize);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\cal1_streamloader.cpp
void CAL1_StreamLoader::CAL1_StreamLoader(CAL1_AudioDriver* i_AD, CAL1_AudioItemDatabase* i_AID);
void CAL1_StreamLoader::~CAL1_StreamLoader();
void CAL1_StreamLoader::SetLanguageMask(uint32_t langMask);
void CAL1_StreamLoader::SetGlobalStream(bool globalStream);
CAAudioError CAL1_StreamLoader::LoadTheSection(char* type, uint32_t version, uint32_t dataSize);
CAAudioError CAL1_StreamLoader::LoadSTMM(uint32_t version, uint32_t dataSize);
CAAudioError CAL1_StreamLoader::LoadSTMD(uint32_t version, uint32_t dataSize);
CAAudioError CAL1_StreamLoader::ParseSTMM_V1_0(uint32_t* data, uint32_t dataSize);
CAAudioError CAL1_StreamLoader::ReadSMAP(uint32_t* data, uint32_t language, uint32_t dataFormat);
CAAudioError CAL1_StreamLoader::ReadSMAP_V1_0(uint32_t* data, uint32_t language, uint32_t dataFormat);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\pc\cal1_api_pc.cpp
void CAL1_API_PC::CAL1_API_PC();
void CAL1_API_PC::~CAL1_API_PC();
CAAudioError CAL1_API_PC::Initialise_Platform(uint32_t i_heapSize, void* i_address, bool i_useSysMemory, uint32_t i_numChannels, uint32_t i_numStreams, uint32_t i_numEffects, uint32_t i_numDBItems, uint32_t i_creationFlags, uint32_t i_maxInstances, uint32_t i_SRAMSize, HWND* i_hWnd, _GUID* i_GUID);
CAAudioError CAL1_API_PC::CreatePlatformObjects();
CAAudioError CAL1_API_PC::DestroyPlatformObjects();
CAAudioError CAL1_API_PC::ResetPlatformObjects();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\pc\cal1_audiodriverpc.cpp
void CAL1_AudioDriverPC::CAL1_AudioDriverPC(uint32_t numChannels, uint32_t numReverbPresets, uint32_t* SRAMPtr, uint32_t SRAMSize, HWND* hwnd, _GUID* guid);
void CAL1_AudioDriverPC::~CAL1_AudioDriverPC();
CAAudioError CAL1_AudioDriverPC::CreateBuffer(uint32_t channel, uint32_t bufferLength, uint32_t bitsPerSample, uint32_t baseFrequency, bool hardware, bool threeD, uint32_t numChannels);
CAAudioError CAL1_AudioDriverPC::StartSample(CAL1_Sample* sample);
CAAudioError CAL1_AudioDriverPC::Create();
void CAL1_AudioDriverPC::BeginStreamThread();
bool CAL1_AudioDriverPC::IsChannelPlaying(uint32_t channel, bool ignoreDeferred);
CAAudioError CAL1_AudioDriverPC::StopChannel(uint32_t channel);
CAAudioError CAL1_AudioDriverPC::Update3DListener();
CAAudioError CAL1_AudioDriverPC::Set3DAndDopplerMode(uint32_t threeDMode, uint32_t dopplerMode);
uint32_t CAL1_AudioDriverPC::GetAccelCaps();
uint32_t CAL1_AudioDriverPC::Get3DCaps();
uint32_t CAL1_AudioDriverPC::GetDopplerCaps();
CAAudioError CAL1_AudioDriverPC::SetNextListener(CAL1_AudioListener* listener);
CAAudioError CAL1_AudioDriverPC::SetChannelVolume(uint32_t channel, uint32_t volume);
CAAudioError CAL1_AudioDriverPC::SetChannelPan(uint32_t channel, int32_t pan, int32_t panFR);
CAAudioError CAL1_AudioDriverPC::SetChannelFrequency(uint32_t channel, uint32_t frequency);
CAAudioError CAL1_AudioDriverPC::SetChannel3D(uint32_t channel, ca_3DPoint* position, ca_3DVelocity* velocity, ca_floatfp minDist, ca_floatfp maxDist);
CAAudioError CAL1_AudioDriverPC::WriteChannelBufferData(uint32_t channel, uint32_t offset, uint32_t length, void* data);
uint32_t CAL1_AudioDriverPC::GetChannelPlayCursor(uint32_t channel);
CAAudioError CAL1_AudioDriverPC::FrameEnd();
CAAudioError CAL1_AudioDriverPC::DeallocateAllStreams();
CAAudioError CAL1_AudioDriverPC::Stream();
uint32_t __stdcall CAL1_AudioDriverPC::_CA_AudioDriverPC_Stream(void* lpParameter);
int32_t CAL1_AudioDriverPC::TestExceptionCode(_EXCEPTION_POINTERS* exceptPtrs);
uint32_t __stdcall CAL1_AudioDriverPC::CA_AudioDriverPC_Stream(void* lpParameter);
void CAL1_AudioDriverPC::PauseAll();
void CAL1_AudioDriverPC::UnpauseAll();
uint32_t CAL1_AudioDriver::GetChannelPlayCursor(uint32_t channel);
CAAudioError CAL1_AudioDriverPC::ReleaseAdditionalChannelPropertySets(uint32_t channel);
uint32_t* CoreGraphicsDevice::ReserveDynamicDisplayList(uint32_t);
uint32_t CoreFX::GetMaxPrimitives(uint32_t idxPrim);
char* CoreMenuComponent::GetItemText(int32_t i_itemIndex);
CAAudioError CAL1_AudioPlayback::AlmostCompleteTrigger(CAL1_AudioPlayback* from);
CoreAnimSpec* CoreBlenderBasic::GetAnimSpecByHash(CoreHash& i_animID);
CAAudioError CAL1_AudioPlayback::CompletionTrigger(CAL1_AudioPlayback* from);
CAAudioError CAL1_AudioDriverPC::EnableAllHWAcceleration(bool enable);
CAAudioError CAL1_AudioDriverPC::EnableNon3DHWAcceleration(bool enable);
CAAudioError CAL1_AudioDriverPC::Enable3DHWAcceleration(bool enable);
CAAudioError CAL1_AudioDriverPC::PauseChannel(uint32_t channel);
CAAudioError CAL1_AudioDriverPC::ResumeChannel(uint32_t channel);
void CAL1_AudioDriverPC::GetDSCaps();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\ca_l1_audiodriver\pc\cal1_audiostreamerpc.cpp
void CAL1_AudioStreamerPC::CAL1_AudioStreamerPC(CAL1_AudioDriver* audioDriver);
void CAL1_AudioStreamerPC::~CAL1_AudioStreamerPC();
CAAudioError CAL1_AudioStreamerPC::TransferSectorToMemory(uint32_t sector, uint32_t channel, uint32_t startOffset, uint32_t source, uint32_t length);
CAAudioError CAL1_AudioStreamerPC::TransferStartBlockToMemory(uint32_t channel, uint32_t startOffset, uint32_t source, uint32_t length);
void CAL1_AudioStreamerPC::ResetStreamer();
uint32_t CAL1_AudioStreamerPC::ReadData(uint32_t fileID, void* dataBuffer, uint32_t length, uint32_t* bufferDataRead);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\include\cal0_float.h
bool ca_floatfp::operator<(ca_floatfp& aValue);
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\include\cal0_headerdata.h
void CAL0_HeaderData::CAL0_HeaderData();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\include\cal0_sectioninfo.h
void CAL0_SectionInfo::CAL0_SectionInfo();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\include\cal1_audioplayback.h
CoreBlenderGoalInfo* CoreBlenderSimple::GetBlenderGoalInfo();
int32_t CoreBlenderBasic::GetBlenderType();
uint32_t CAL1_AudioDriver::Get3DCaps();
CAAudioError CAL1_AudioStreamer::Stream();
CAAudioError CAL1_AudioPlayback::OnPaused();
CoreBlenderTimers* CoreBlenderSimple::GetBlenderTimers();
CoreBlenderFlags* CoreBlenderSimple::GetBlenderFlags();
CAAudioError CAL1_AudioPlayback::OnStopped();
uint32_t CoreGraphicsDevice::GetScreenWidth();
void* CoreGraphicsDevice::GetFastQuadPtrMax();
CoreAnimSpec* CoreBlenderBasic::GetPrimaryAnimSpec();
CAAudioError CAL1_AudioPlayback::OnStartedOnTimer();
CAAudioError CAL1_AudioPlayback::OnResumed();
CAAudioError CAL1_API::ResetPlatformObjects();
uint32_t CAL1_AudioDriver::GetDopplerCaps();
uint32_t CoreGraphicsDeviceNull::GetDisplayWidth();
uint32_t CAL1_SampleGroupPlayback::PlaybackData::GetPlayIndex();
uint32_t CAL1_AudioDriver::GetReverbCaps();
CAAudioError CAL1_API::DestroyPlatformObjects();
int32_t CoreMenuComponent::GetInternalSelection();
uint32_t CoreMenuComponent::GetNumberOfItems();
CAAudioError CAL1_AudioPlayback::OnResumedOnTimer();
uint32_t CoreGraphicsDevice::GetScreenHeight();
CAAudioError CAL1_API::CreatePlatformObjects();
uint32_t CAL1_AudioDriver::GetAccelCaps();
uint32_t CAL1_AudioDriverPC::GetReverbCaps();
CAAudioError CAL1_AudioPlayback::OnStarted();
void* CoreGraphicsDevice::GetFastQuadPtr();
uint32_t CoreGraphicsDeviceNull::GetDisplayHeight();
int32_t CoreMenuComponent::GetNumberOfVisibleItems();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\include\cal1_samplegroupplayback.h
uint32_t CAL1_SampleGroupPlayback::SamplePlaybackData::SaveItemData(uint32_t* i_Data);
uint32_t CAL1_SampleGroupPlayback::SamplePlaybackData::LoadItemData(uint32_t* i_Data);
void CAL1_SampleGroupPlayback::PlaybackData::PlaybackData(PlaybackDataType type, uint32_t numItems);
void CAL1_SampleGroupPlayback::PlaybackData::~PlaybackData();
CAAudioError CAL1_SampleGroupPlayback::PlaybackData::SetCommonData(CAL1_SampleGroupPlayback::PlaybackData* oldPBData);
uint32_t CAL1_SampleGroupPlayback::PlaybackData::SaveItemData(uint32_t* i_Data);
uint32_t CAL1_SampleGroupPlayback::PlaybackData::LoadItemData(uint32_t* i_Data);
void CAL1_SampleGroupPlayback::PlaybackData_Sequencial::PlaybackData_Sequencial(uint32_t numItems);
uint32_t CAL1_SampleGroupPlayback::PlaybackData_Chain::GetPlayIndex();
uint32_t CAL1_SampleGroupPlayback::PlaybackData_Sequencial::GetPlayIndex();
uint32_t CAL1_SampleGroupPlayback::PlaybackData_Random::GetPlayIndex();
void CAL1_SampleGroupPlayback::PlaybackData_Sequencial::Step();
void CAL1_SampleGroupPlayback::PlaybackData_Sequencial::Reset();
void CAL1_SampleGroupPlayback::PlaybackData_Random::Reset();
void CAL1_SampleGroupPlayback::PlaybackData_Random::PlaybackData_Random(uint32_t numItems);
void CAL1_SampleGroupPlayback::PlaybackData_Random::~PlaybackData_Random();
void CAL1_SampleGroupPlayback::PlaybackData_Random::Step();
uint32_t CAL1_SampleGroupPlayback::PlaybackData_Random::SaveItemData(uint32_t* i_Data);
uint32_t CAL1_SampleGroupPlayback::PlaybackData_Random::LoadItemData(uint32_t* i_Data);
void CAL1_SampleGroupPlayback::PlaybackData_Delay::PlaybackData_Delay(uint32_t numItems);
void CAL1_SampleGroupPlayback::PlaybackData_Delay::~PlaybackData_Delay();
uint32_t CAL1_SampleGroupPlayback::PlaybackData_Delay::SaveItemData(uint32_t* i_Data);
uint32_t CAL1_SampleGroupPlayback::PlaybackData_Delay::LoadItemData(uint32_t* i_Data);
void CAL1_SampleGroupPlayback::PlaybackData_Chain::PlaybackData_Chain(uint32_t numItems);
void CAL1_SampleGroupPlayback::PlaybackData_Chain::Step();
void CAL1_SampleGroupPlayback::PlaybackData_Chain::Reset();
#endif

#if 1 // c:\projects\source\tombraider\coreaudio\tools\memorywindow\mw.cpp
void MW::MWOpen();
void MW::MWClose();
void MW::MWInit(uint32_t start, uint32_t end, uint32_t numAllocs);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibanim\coreanim\coreanimationset.cpp
bool CoreAnimationSet::CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
uint32_t CoreTextureSet::GetVersion();
uint32_t CoreLevelCompiled::GetVersion();
uint32_t CoreModelCompiled::GetVersion();
uint32_t CoreAnimSequencer::GetVersion();
uint32_t CoreAnimationSet::GetVersion();
int32_t CoreAnimationSet::GetIndexByAnimID(CoreHash i_animID);
CoreAnimData* CoreAnimationSet::GetAnimPtr(CoreHash oAnimName);
float CoreAnimationSet::GetEndTime(CoreHash oAnimName);
CoreEulerAngle CoreAnimationSet::GetOrientationChange(CoreHash oAnimName, float fStartTime, float fEndTime, bool mirror);
CoreVector CoreAnimationSet::GetPositionChange(CoreHash oAnimName, float fStartTime, float fEndTime, bool mirror);
CoreVector CoreAnimationSet::GetVelocityPosition(CoreHash i_animName, float i_time, bool i_mirror);
int32_t CoreAnimationSet::GetNumTimeMarkers(CoreHash oAnimName);
float CoreAnimationSet::GetTimeMarkerStartTime(CoreHash oAnimName, int32_t index);
float CoreAnimationSet::GetTimeMarkerEndTime(CoreHash oAnimName, int32_t index);
uint32_t CoreAnimationSet::GetTimeMarkerName(CoreHash oAnimName, int32_t index);
CoreVector CoreAnimationSet::GetSubObjectMarkerPosition(CoreHash oAnimName, CoreHash oMarkerName, float fTime);
CoreEulerAngle CoreAnimationSet::GetSubObjectMarkerOrientation(CoreHash oAnimName, CoreHash oMarkerName, float fTime);
CoreVector CoreAnimationSet::GetSubObjectMarkerScale(CoreHash oAnimName, CoreHash oMarkerName, float fTime);
CoreSubObjectMarkerData::eSubObjectMarkerStateEnum CoreAnimationSet::GetSubObjectMarkerState(CoreHash oAnimName, CoreHash oMarkerName, float fTime);
int32_t CoreAnimationSet::GetNumSubObjectMarkers(CoreHash oAnimName);
CoreHash CoreAnimationSet::GetSubObjectMarkerHash(CoreHash oAnimName, int32_t iSubObjectMarkerIndex);
bool CoreAnimationSet::UpdateJointState(int32_t i_joint, CoreHash i_anim, float i_time, CoreHashArray* i_skeletonJointIndexTable, CoreJointState* o_jointState, bool i_mirror);
void CoreAnimationSet::UpdateJointStates(CoreHash oAnim, float fTime, CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates, bool mirror);
void CoreAnimationSet::UpdateJointStatesByBone(CoreHash oAnim, float fTime, CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates, bool mirror, bool* bones);
void CoreAnimationSet::UpdateBlendShapeTargetAlphaValues(CoreHash oAnim, float fTime, float* lpfBlendShapeAlphaValues, bool* lpbOverrideBlendShapeTarget);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibanim\coreanim\coreanimdata.cpp
CoreEulerAngle CoreAnimData::GetOrientationChange(float fStartTime, float fEndTime, bool mirror);
CoreQuat CoreAnimData::GetOrientationChangeQuat(float fStartTime, float fEndTime, bool mirror);
CoreVector CoreAnimData::GetPositionChange(float fStartTime, float fEndTime, bool mirror);
CoreVector CoreAnimData::GetPosition(float fTime);
CoreQuat CoreAnimData::GetOrientationAsQuat(float fTime);
bool CoreAnimData::HasVelocity(bool& o_posVel, bool& o_rotVel);
float CoreAnimData::GetTimeMarkerStartTime(int32_t index);
float CoreAnimData::GetTimeMarkerEndTime(int32_t index);
uint32_t CoreAnimData::GetTimeMarkerName(int32_t index);
CoreSubObjectMarkerData* CoreAnimData::GetSOMByName(CoreHash oSOMName);
CoreJointData* CoreAnimData::GetSOMJointDataByName(CoreHash oSOMName);
CoreVector CoreAnimData::GetSOMPosition(CoreHash oMarkerName, float fTime);
CoreEulerAngle CoreAnimData::GetSOMOrientation(CoreHash oMarkerName, float fTime);
CoreVector CoreAnimData::GetSOMScale(CoreHash oMarkerName, float fTime);
CoreSubObjectMarkerData::eSubObjectMarkerStateEnum CoreAnimData::GetSOMState(CoreHash oMarkerName, float fTime);
float CoreAnimData::GetSOMStartTime(CoreHash oMarkerName);
float CoreAnimData::GetSOMEndTime(CoreHash oMarkerName);
CoreHash CoreAnimData::GetSOMHash(int32_t iIndex);
uint32_t CoreAnimData::GetHashFromJointNumber(int32_t i_joint, CoreHashArray* i_jointIndexTable, bool& io_mirror);
bool CoreAnimData::UpdateJointState(int32_t i_joint, float i_time, CoreHashArray* i_skeletonJointIndexTable, CoreHashArray* i_animDataJointIndexTable, CoreJointState* o_jointState, bool i_mirror);
void CoreAnimData::UpdateJointStates(float fTime, uint32_t* uiJointHashes, CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates, bool mirror);
void CoreAnimData::UpdateJointStatesByBone(float fTime, uint32_t* uiJointHashes, CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates, bool mirror, bool* bones);
void CoreAnimData::UpdateBlendShapeTargetAlphaValues(float fTime, float* lpfBlendShapeAlphaValues, bool* lpbOverrideBlendShapeTarget);
CoreVector CoreAnimData::GetVelocityPosition(float i_time, bool i_mirror);
CoreEulerAngle CoreAnimData::GetVelocityOrientation(float i_time, bool i_mirror);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibanim\coreanim\corecurvedata.cpp
float CoreF32CurveData::GetValue(float fTime, bool& bNoKeys);
bool CoreF32CurveData::GetValueBool(float fTime);
int32_t CoreF32CurveData::FindKey(float fTime);
CoreQuat CoreQuatCurveData::GetValue(float fTime, bool& bNoKeys);
int32_t CoreQuatCurveData::FindKey(float fTime);
float CoreBezierCurveData::GetValueLong(float i_time);
int32_t CoreBezierCurveData::FindKeyLong(float i_time);
float CoreBezierCurveData::GetValueShort(float i_time);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibanim\coreanim\corecurvedata.h
CoreVector CoreBezierCurveData::ConvertValue(CoreVector i_value);
float CoreBezierCurveData::EvalCurveShort(CoreBezierAnimKeyDataShort* i_currKey, CoreBezierAnimKeyDataShort* i_nextKey, float i_time);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibanim\coreanim\corejointdata.cpp
void CoreJointData::UpdateJointStates(float fTime, CoreJointState* lpoJointState, bool mirror);
CoreVector CoreJointData::GetTranslation(float fTime);
CoreEulerAngle CoreJointData::GetRotationEuler(float fTime);
CoreVector CoreJointData::GetRotationVector(float fTime);
CoreQuat CoreJointData::GetRotationQuat(float fTime);
CoreVector CoreJointData::GetScale(float fTime);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibanim\coreanim\corejointdata.h
void* CoreJointData::GetCurve(CoreJointData::CoreCurveType eType);
float CoreJointData::GetCurveValue(CoreJointData::CoreCurveType eCurveType, float fTime);
CoreQuat CoreJointData::GetCurveValueQuat(CoreJointData::CoreCurveType eCurveType, float fTime);
float CoreJointData::GetCurveValueBezier(CoreJointData::CoreCurveType eCurveType, float fTime);
bool CoreJointData::GetVisible(float fTime);
bool CoreJointData::GetQuaternionSign(float fTime);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibanim\coreanimsequencer\coreanimsequencer.cpp
bool CoreAnimSequencer::CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
int32_t CoreAnimSequencer::GetAnimSpecIndexByID(CoreHash i_animSpecID);
CoreAnimSpec* CoreAnimSequencer::GetAnimSpecByID(CoreHash i_animSpecID);
int32_t CoreAnimSequencer::GetNumTimedBlends(int32_t i_specNumber);
CoreAnimBlend* CoreAnimSequencer::GetTimedBlend(int32_t i_specNumber, int32_t i_timedBlend, CoreHash& o_animSet, CoreHash& o_animSpec);
void CoreAnimSequencer::RemapStateByAnimPath(int32_t i_specNumber, CoreHash& i_goalState, CoreHash& o_remapState);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibanim\coreanimsequencer\coreanimspec.h
void CoreAnimSpec::RemapStateByAnimPath(CoreHash& i_goalState, CoreHash& o_remapState);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibanim\coreanimsequencer\corespecmapping.h
CoreHash CoreAnimCommandAudio::GetBoneHash();
CoreHash CoreAnimMapping::GetAnimHash();
CoreHash CoreVariable::GetName();
CoreHash CoreAnimSpec::GetState();
CoreHash CoreAnimCommandAutoBlend::GetNewStateHash();
CoreHash CoreSpecMapping::GetAnimSpecHash();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibaudio\coreaudiops2dummy.cpp
uint32_t CAL0_Util::GetHashValue(char* s);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corebase\coreerror.cpp
void CoreError::ErrorBox(char* i_string);
void CoreError::Print(char* i_string);
void CoreError::LogFile(char* i_fileName, char* i_string);
void CoreError::InitLogFile(char* i_fileName);
void CoreError::EnableErrorBox();
void CoreError::DisableErrorBox();
void CoreError::EnablePrint();
void CoreError::DisablePrint();
void CoreError::DisablePrintError();
void CoreError::EnableLogFile();
void CoreError::DisableLogFile();
void CoreError::SetExeName(char* exeName);
void CoreError::FatalError(char* i_string);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corebase\coremap.cpp
void CoreMapBase::CoreMapBase(uint32_t i_maxItems, CoreMemory* i_itemMemory);
void CoreMapBase::~CoreMapBase();
void CoreMapBase::Init(uint32_t i_maxItems, CoreMemory* i_itemMemory);
bool CoreMapBase::AddKey(CoreHash i_key, void* i_data);
void CoreMapBase::InsertFixup(CoreMapNode* i_node);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corebase\coremap.h
bool CoreMap<LoggerOutput::Logger>::AddKey(CoreHash i_key, LoggerOutput::Logger* i_data);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corebase\corestr.cpp
uint32_t AppendChars(char* o_to, uint32_t i_currentLength, uint32_t i_maxLength, int32_t i_number, char i_char);
uint32_t AppendString(char* o_to, uint32_t i_currentLength, uint32_t i_maxLength, char* i_append, uint32_t i_length, FormatFlags& i_flags);
uint32_t AppendNumber(char* o_to, uint32_t i_currentLength, uint32_t i_maxLength, int32_t i_value, FormatFlags& i_flags);
uint32_t AppendHex(char* o_to, uint32_t i_currentLength, uint32_t i_maxLength, uint32_t i_value, FormatFlags& i_flags);
uint32_t AppendFloat(char* o_to, uint32_t i_currentLength, uint32_t i_maxLength, float i_value, FormatFlags& i_flags);
uint32_t AppendBinary(char* o_to, uint32_t i_currentLength, uint32_t i_maxLength, uint32_t i_value, FormatFlags& i_flags);
uint32_t AppendVector(char* o_to, uint32_t i_currentLength, uint32_t i_maxLength, CoreVector* i_value, FormatFlags& i_flags);
uint32_t AppendHash(char* o_to, uint32_t i_currentLength, uint32_t i_maxLength, CoreHash i_value, FormatFlags& i_flags);
int32_t CoreStr::VSPrint(char* o_to, uint32_t i_maxLength, char* i_format, char*& i_list);
int32_t CoreStr::SPrint(char* o_to, uint32_t i_maxLength, char* i_format);
int32_t CoreStr::GetLength(char* i_string);
void CoreStr::Copy(char* o_to, char* i_from);
void CoreStr::NCopy(char* o_to, char* i_from, uint32_t i_maxLength);
bool CoreStr::IsSame(char* i_string, char* i_compare);
bool CoreStr::IsNSame(char* i_string, char* i_compare, uint32_t i_maxLength);
int32_t CoreStr::FindChar(char* i_string, char i_char);
int32_t CoreStr::ReverseFindChar(char* i_string, char i_char);
void CoreStr::Cat(char* o_to, char i_char);
void CoreStr::NCat(char* o_to, char* i_from, uint32_t i_maxLength);
float CoreStr::ToFloat(char* i_string);
int32_t CoreStr::ToInt(char* i_string);
bool CoreStr::IsSameIgnoreCase(char* i_string, char* i_compare);
bool CoreStr::IsNSameIgnoreCase(char* i_string, char* i_compare, uint32_t i_maxLength);
void CoreStr::ToUpper(char* o_to, char* i_from);
bool CoreStr::IsHex(char* i_string, uint32_t& o_value);
bool CoreStr::IsInt(char* i_string, int32_t& o_value);
int32_t CoreStr::FindTextIgnoreCaseIndex(char* i_string, char* i_find);
bool CoreStr::FindTextIgnoreCase(char* i_string, char* i_find);
int32_t CoreStr::Compare(char* i_string, char* i_compare);
uint32_t CoreStr::ReadUTF8(char*& io_char);
int32_t CoreStr::GetLengthUTF8(char* i_string);
uint32_t CoreStr::WriteUTF8(char*& io_char, uint32_t i_unicode);
bool CoreStr::CopyAfterMatchIgnoreCase(char* i_string, char* i_compare, char* o_buffer);
bool CoreStr::IsFirstPartSameIgnoreCase(char* i_string, char* i_compare);
bool CoreStr::SkipString(char*& i_string, char* i_stringToSkip);
bool CoreStr::SkipStringIgnoreCase(char*& i_string, char* i_stringToSkip);
int32_t CoreStr::ConvertSlashes(char* io_string, char i_slash);
char* CoreStr::SkipSlashes(char* i_string);
void CoreStr::RemoveSlashesFromEnd(char* io_string);
void CoreStr::MakeSureEndsWithSlash(char* io_string, char i_slash);
char* CoreStr::FindLastSlash(char* i_string);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corebase\coretypes.cpp
void CoreBreakPoint::EnableCoreBreakPoint(bool i_enable);
bool CoreBreakPoint::IsCoreBreakPointEnabled();
void CoreBreakPoint::SetAssertShouldBreakPoint(bool i_shouldBreakPoint);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corebase\pc\coreerrorpc.cpp
void LoggerOutput::LoggerOutput();
void LoggerOutput::~LoggerOutput();
LoggerOutput& LoggerOutput::GetOutput();
bool LoggerOutput::CreateLogger(char* i_name, uint32_t i_colour, uint32_t i_background);
void LoggerOutput::Register(char* i_name, uint32_t i_colour, uint32_t i_background);
bool LoggerOutput::ActivateLogWindow();
void LoggerOutput::LogMessage(CoreHash i_id, char* i_format);
void LoggerOutput::VLogMessage(CoreHash i_id, char* i_format, char* i_list);
void CoreError::PrintToConsole(char* i_string);
void CoreError::RealMessageBox(char* i_string);
void CoreError::PrintError(char* i_string);
void CoreError::Exit(int32_t i_code);
bool CoreError::CreateLog(char* i_name, uint32_t i_colour, uint32_t i_background);
void CoreError::Log(CoreHash i_id, char* i_string);
char* CoreError::GetSystemErrorString(uint32_t i_error);
char* CoreError::GetLastSystemErrorString();
void CoreError::RealFatalError(char* i_string);
void CoreError::RealPrint(char* i_string);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corecommon.cpp
uint32_t CoreCommon::GetVersion();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corecommondialog\corecommondialog.cpp
void CoreCommonDialogStatus::CoreCommonDialogStatus();
void CoreCommonDialogStatus::SetIdle();
void CoreCommonDialogStatus::SetFailed();
void CoreCommonDialogStatus::SetStarting();
void CoreCommonDialogStatus::SetActive();
void CoreCommonDialogStatus::SetStopping();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corebuildsysteminterfaceusingnamedpipe.cpp
bool CoreBuildSystemInterfaceUsingNamedPipe::InitForBuildSystem(CoreMemory* i_memoryInterface, char* i_pipeName, char* i_defaultPath, bool i_startApplication);
bool CoreBuildSystemInterfaceUsingNamedPipe::StartApplication(char* i_pipeName);
bool CoreBuildSystemInterfaceUsingNamedPipe::WaitUntilApplicationIsReady(float i_timeout);
void CoreBuildSystemInterfaceUsingNamedPipe::ExitForBuildSystem();
void CoreBuildSystemInterfaceUsingNamedPipe::CoreBuildSystemInterfaceUsingNamedPipe();
bool CoreBuildSystemInterfaceUsingNamedPipe::ProcessBuildSystemMessage(uint32_t i_startMessageID, uint32_t i_endMessageID, char* i_messagePrefix, char* o_returnMessageBuffer, int32_t i_returnMessageBufferSize);
bool CoreBuildSystemInterfaceUsingNamedPipe::BuildSystemCompleteTheFileName(char* i_fileName, char* i_devicePrefix, CoreStringBuffer<256>& o_fileName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corecluster.cpp
void CoreCluster::SetFileDevicePtr(CoreFileDevice* i_device);
void CoreCluster::CoreCluster();
void CoreCluster::~CoreCluster();
void CoreCluster::Reset();
void CoreCluster::SetClusterDataPtr(CoreClusterData* i_clusterData);
bool CoreCluster::Open(char* i_clusterName);
bool CoreCluster::CloseActive();
bool CoreCluster::Close();
uint32_t CoreCluster::OpenFile(char* i_fileName);
CoreClusterFileHeader* CoreCluster::GetOpenInfo(char* i_fileName);
bool CoreCluster::DoesFileExist(char* i_fileName);
int32_t CoreCluster::ReadFile(uint32_t i_fileHash, void* i_dest, int32_t i_size);
bool CoreCluster::SeekFile(uint32_t i_fileHash, int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin);
bool CoreCluster::CloseFile(uint32_t i_fileHash);
int32_t CoreCluster::FileSize(uint32_t i_fileHash);
int32_t CoreCluster::GetFileSize(char* i_fileName);
bool CoreCluster::IsActive();
int32_t CoreCluster::GetFileOffset(char* i_fileName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\coreclusterdata.cpp
bool CoreClusterData::CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
CoreClusterFileHeader* CoreClusterData::FindFile(char* i_fileName);
void CoreClusterData::ConvertFileNameToClusterFileFormat(char* clusterFileName, char* i_fileName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\coreclusterfilesystem.cpp
void CoreClusterFileSystem::CoreClusterFileSystem();
void CoreClusterFileSystem::~CoreClusterFileSystem();
void CoreClusterFileSystem::Init(int32_t i_maxNumberOfOpenFiles);
void CoreClusterFileSystem::SetFileDevice(CoreFileDevice* i_fileDevice);
CoreFileHandle CoreClusterFileSystem::Open(char* i_name, CoreFileOpenAttributes& i_attrib);
bool CoreClusterFileSystem::Close(CoreFileHandle& i_handle);
int32_t CoreClusterFileSystem::Read(CoreFileHandle& i_handle, void* i_dest, int32_t i_size);
int32_t CoreClusterFileSystem::Write(CoreFileHandle& i_handle, void* i_src, int32_t i_size);
bool CoreClusterFileSystem::Seek(CoreFileHandle& i_handle, int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin);
bool CoreClusterFileSystem::GenericOpen(char* i_name, CoreFileOpenAttributes& i_attrib);
bool CoreClusterFileSystem::GenericClose(CoreFileHandle& i_handle);
bool CoreClusterFileSystem::GenericFileCheck(uint32_t i_fileHash);
int32_t CoreClusterFileSystem::FileSize(char* i_name);
bool CoreClusterFileSystem::GetFileTimes(char* i_fileName, CoreDateTime* o_creationTime, CoreDateTime* o_lastAccessTime, CoreDateTime* o_lastWriteTime);
bool CoreClusterFileSystem::SetFileTimes(char* i_fileName, CoreDateTime* i_creationTime, CoreDateTime* i_lastAccessTime, CoreDateTime* i_lastWriteTime);
bool CoreClusterFileSystem::DoesFileExist(char* i_fileName);
bool CoreClusterFileSystem::IsReadOnly(char* i_fileName);
bool CoreClusterFileSystem::ChangeReadOnly(char* i_fileName, bool i_readOnly, bool* o_changed);
int32_t CoreClusterFileSystem::FileOffset(char* i_name);
CoreFileSystem::CoreFileSystemAsyncState CoreClusterFileSystem::AsyncStartLoadFile(char* i_name, int32_t i_startOffset, int32_t i_size, void* i_dest);
CoreFileSystem::CoreFileSystemAsyncState CoreClusterFileSystem::AsyncUpdate();
CoreFileSystem::CoreFileSystemAsyncState CoreClusterFileSystem::AsyncEndLoadFile(char* i_name);
bool CoreClusterFileSystem::OpenCluster(char* i_clusterName, uint32_t i_flags);
bool CoreClusterFileSystem::CloseCluster(char* i_clusterName, uint32_t i_flags);
CoreCluster* CoreClusterFileSystem::SetCurrentCluster(char* i_clusterName);
CoreCluster* CoreClusterFileSystem::FindFirstFreeCluster();
void CoreClusterFileSystem::ComputeMemoryUsage(uint32_t& o_minUsedMemory, uint32_t& o_maxUsedMemory);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corefile.cpp
void CoreFile::AttachFileSystem(CoreFileSystem* i_fileSystem);
CoreFileSystem* CoreFile::GetFileSystem();
void CoreFile::SetGlobalMemoryPtr(CoreMemory* i_memory);
void CoreFile::CoreFile();
void CoreFile::~CoreFile();
void CoreFile::Clear();
bool CoreFile::Save(char* i_name, char* i_attrib, void* i_buffer, int32_t i_bufferSize);
bool CoreFile::Open(char* i_name, char* i_attrib);
bool CoreFile::Close();
int32_t CoreFile::ReadFile(void* i_dest, int32_t i_dataSize, int32_t i_count);
int32_t CoreFile::WriteFile(void* i_src, int32_t i_dataSize, int32_t i_count);
bool CoreFile::SetPosFile(int32_t i_pos);
int32_t CoreFile::Read(void* i_dest, int32_t i_dataSize, int32_t i_count);
bool CoreFile::Write(uint32_t i_value);
bool CoreFile::Seek(int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin);
int32_t CoreFile::Tell();
int32_t CoreFile::Size();
void CoreFile::InitBuffer();
int32_t CoreFile::iReadBuffer(void* i_dest, int32_t i_dataSize, int32_t i_count);
int32_t CoreFile::iWriteBuffer(void* i_src, int32_t i_dataSize, int32_t i_count);
void CoreFile::FillBuffer();
void CoreFile::EmptyBuffer();
void CoreFile::BufferTransfer(void* i_dest, int32_t i_sizeBytes);
int32_t CoreFile::GetFileSize(char* i_fileName);
bool CoreFile::DoesFileExist(char* i_fileName);
bool CoreFile::CreateEmptyFile(char* i_fileName);
void CoreFile::SetDownLoadContentGamePath(char* i_gamePath);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corefiledevice.cpp
void CoreFileDevice::CoreFileDevice();
bool CoreFileDevice::IsErrorAsyncState(CoreFileDevice::CoreFileDeviceAsyncState i_state);
char* CoreFileDevice::GetAsyncState(CoreFileDevice::CoreFileDeviceAsyncState i_state);
CoreFileDevice::CoreFileDeviceAsyncState CoreFileDevice::AsyncUpdate();
CoreFileDevice::CoreFileDeviceAsyncState CoreFileDevice::AsyncStartLoadFile(char* i_name, int32_t iStartOffset, int32_t i_size, void* i_dest);
CoreFileDevice::CoreFileDeviceAsyncState CoreFileDevice::AsyncEndLoadFile(char* i_name);
void CoreFileDevice::ResetAsyncError();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corefiledevice.h
void CorePCStdCFileDevice::~CorePCStdCFileDevice();
void CoreFileDevice::~CoreFileDevice();
CoreHash CoreFileDevice::GetAsyncFileNameHash();
void CoreFileDevice::SetAsyncFileNameHash(CoreHash i_hash);
void CoreFileDevice::SetAsyncFileName(char* i_fileName);
void CoreFileDevice::ClearAsyncFileName();
float CoreFileDevice::GetElapsedTime();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corefilehandle.h
void CoreFileHandle::CoreFileHandle(CoreFileHandle& i_other);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corefileopenattributes.cpp
void CoreFileOpenAttributes::Set(char* i_attrib);
void CoreFileOpenAttributes::CoreFileOpenAttributes(int32_t i_attrib);
[! NO TYPE] CoreFileOpenAttributes::operator=();
bool CoreFileOpenAttributes::IsValid();
bool CoreFileOpenAttributes::bAscii(char* i_attrib);
bool CoreFileOpenAttributes::IsRead();
bool CoreFileOpenAttributes::IsWrite();
bool CoreFileOpenAttributes::IsAbsoluteAccessFromCluster();
void CoreFileOpenAttributes::Clear();
void CoreFileOpenAttributes::SetAbsoluteAccessFromCluster(bool i_set);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corefilesystem.cpp
void CoreFileSystem::SetFilePrefix(char* i_filePrefix);
void CoreFileSystem::CoreFileSystem();
void CoreFileSystem::~CoreFileSystem();
void CoreFileSystem::SetMaxNumberOfOpenFiles(int32_t i_maxOpenFiles);
bool CoreFileSystem::OpenFile();
bool CoreFileSystem::CloseFile();
bool CoreFileSystem::IsAsyncErrorState(CoreFileSystem::CoreFileSystemAsyncState i_state);
char* CoreFileSystem::GetAsyncState(CoreFileSystem::CoreFileSystemAsyncState i_state);
CoreFileSystem::CoreFileSystemAsyncState CoreFileSystem::AsyncStartLoadFile(char* i_name, int32_t i_startOffset, int32_t i_size, void* o_dest);
CoreFileSystem::CoreFileSystemAsyncState CoreFileSystem::AsyncUpdate();
CoreFileSystem::CoreFileSystemAsyncState CoreFileSystem::AsyncEndLoadFile(char* i_name);
bool CoreFileSystem::CompleteTheFileName(char* i_fileName, CoreStringBuffer<256>& o_fileName, bool i_convertToUppercase);
bool CoreFileSystem::IsAbsoluteFileName(char* i_fileName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corefilesystem.h
CoreHash CoreFileSystem::GetAsyncFileNameHash();
void CoreFileSystem::SetAsyncFileNameHash(CoreHash i_hash);
void CoreFileSystem::SetAsyncFileName(char* i_fileName);
void CoreFileSystem::ClearAsyncFileName();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corerecentfilenamelist.cpp
void CoreRecentFileName::Set(char* i_fileName, char* i_userString);
void CoreRecentFileNameList::CoreRecentFileNameList();
bool CoreRecentFileNameList::Init(CoreMemory* i_memoryInterface, uint32_t i_entryCount, float i_timeOutSeconds);
CoreRecentFileName* CoreRecentFileNameList::FindUnusedOrLeastRecent();
CoreRecentFileName* CoreRecentFileNameList::Add(char* i_fileName, char* i_userString, bool& o_alreadyAdded);
CoreRecentFileName* CoreRecentFileNameList::Find(char* i_fileName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corestdfilesystem.cpp
void CoreStdFileSystem::CoreStdFileSystem();
void CoreStdFileSystem::~CoreStdFileSystem();
void CoreStdFileSystem::Init(int32_t i_maxOpenFiles);
CoreFileHandle CoreStdFileSystem::Open(char* i_name, CoreFileOpenAttributes& i_attrib);
bool CoreStdFileSystem::Close(CoreFileHandle& i_handle);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\corestdfilesystem.h
int32_t CoreStdFileSystem::Read(CoreFileHandle& i_handle, void* o_dest, int32_t i_size);
int32_t CoreStdFileSystem::Write(CoreFileHandle& i_handle, void* i_src, int32_t i_size);
bool CoreStdFileSystem::Seek(CoreFileHandle& i_handle, int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin);
int32_t CoreStdFileSystem::FileSize(char* i_name);
bool CoreStdFileSystem::GetFileTimes(char* i_fileName, CoreDateTime* o_creationTime, CoreDateTime* o_lastAccessTime, CoreDateTime* o_lastWriteTime);
bool CoreStdFileSystem::SetFileTimes(char* i_fileName, CoreDateTime* i_creationTime, CoreDateTime* i_lastAccessTime, CoreDateTime* i_lastWriteTime);
bool CoreStdFileSystem::DoesFileExist(char* i_fileName);
bool CoreStdFileSystem::IsReadOnly(char* i_fileName);
bool CoreStdFileSystem::ChangeReadOnly(char* i_fileName, bool i_readOnly, bool* o_changed);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corefile\pc\corestdcfiledevicepc.cpp
void CorePCStdCFileDevice::CorePCStdCFileDevice();
CoreFileHandle CorePCStdCFileDevice::Open(char* i_name, CoreFileOpenAttributes& i_attrib, uint32_t i_flags);
bool CorePCStdCFileDevice::Close(CoreFileHandle& i_handle, uint32_t i_flags);
int32_t CorePCStdCFileDevice::Read(CoreFileHandle& i_handle, void* o_dest, int32_t i_size, uint32_t i_flags);
int32_t CorePCStdCFileDevice::Write(CoreFileHandle& i_handle, void* i_src, int32_t i_size);
bool CorePCStdCFileDevice::Seek(CoreFileHandle& i_handle, int32_t i_offset, CoreFileDevice::CoreFileSeekOrigin i_origin, uint32_t i_flags);
bool CorePCStdCFileDevice::AsyncFinished(CoreFileHandle& i_handle, CoreFileDevice::CoreFileDeviceAsyncState i_successfulState, CoreFileDevice::CoreFileDeviceAsyncState i_failedState);
int32_t CorePCStdCFileDevice::FileSize(CoreFileHandle& i_handle);
bool CorePCStdCFileDevice::GetFileTimes(char* i_fileName, CoreDateTime* o_creationTime, CoreDateTime* o_lastAccessTime, CoreDateTime* o_lastWriteTime);
bool CorePCStdCFileDevice::SetFileTimes(char* i_fileName, CoreDateTime* i_creationTime, CoreDateTime* i_lastAccessTime, CoreDateTime* i_lastWriteTime);
bool CorePCStdCFileDevice::DoesFileExist(char* i_fileName);
bool CorePCStdCFileDevice::IsReadOnly(char* i_fileName);
bool CorePCStdCFileDevice::ChangeReadOnly(char* i_fileName, bool i_readOnly, bool* o_changed);
bool CorePCStdCFileDevice::CompleteTheFileName(char* i_fileName, CoreStringBuffer<256>& o_fileName);
bool CorePCBuildSystemFileDevice::CompleteTheFileName(char* i_fileName, CoreStringBuffer<256>& o_fileName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corehash\corehash.cpp
bool CoreHashDebugString::SetNewBuffer(char* io_buffer, uint32_t i_bufferSize);
CoreHashDebugStringEntry* CoreHashDebugString::FindHash(uint32_t i_hash, uint32_t& o_hashIndex, bool& o_matchFound);
bool CoreHashDebugString::AddString(uint32_t i_hash, char* i_hashString);
bool CoreHash::AllocateDebugMemory(CoreMemory* i_memory, int32_t i_hashStringPoolSize);
void CoreHash::CoreHash(uint32_t i_hash, char* i_string);
void CoreHash::Set(char* i_string);
char* CoreHash::GetString();
void CoreHash::GenerateHashString(char* o_output);
uint32_t CoreHash::GenerateHash(char* i_string);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corehash\corehashelementtable.cpp
bool CoreHashElementTable::Find(CoreHash i_hash, uint32_t& o_foundData, CoreHashElement* i_elementBase);
bool CoreHashElementTable::FindIndex(CoreHash i_hash, uint32_t& o_index, CoreHashElement* i_elementBase);
bool CoreHashElementTable::Update(CoreHash i_hash, uint32_t i_newData, CoreHashElement* i_elementBase);
void CoreHashElementTable::RemoveAll(CoreHashElement* i_elementBase);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corehash\corehashtable.cpp
void CoreHashTable::Construct(int32_t i_maxItems, CoreMemory* i_memory);
void CoreHashTable::Destruct(CoreMemory* i_memory);
bool CoreHashTable::Add(CoreHash i_hash, uint32_t i_newData);
bool CoreHashTable::Remove(CoreHash i_hash);
bool CoreHashTable::Find(CoreHash i_hash, uint32_t& o_foundData);
bool CoreHashTable::FindIndex(CoreHash i_hash, uint32_t& o_index);
bool CoreHashTable::Update(CoreHash i_hash, uint32_t i_newData);
CoreHashElement* CoreHashTable::GetElementPtr(uint32_t i_index);
void CoreHashTable::RemoveAll();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coreinit\coreinit.cpp
void CoreInitArg::CoreInitArg();
bool CoreInitArg::IsWholeSame(char* i_argString);
bool CoreInitArg::GetAsBool(bool& o_value, char* i_argString1, bool i_value1, char* i_argString2, bool i_value2, char* i_argString3, bool i_value3, char* i_argString4, bool i_value4);
bool CoreInitArg::GetAsNumber(int32_t& o_value, char* i_argString);
bool CoreInitArg::GetAsString(char* i_argString, char* o_string, int32_t i_maxStringSize);
bool CoreInit::Init(int32_t i_argc, char** i_argv, bool i_firstArgIsExeName);
bool CoreInit::Insert(char* i_commandLine, char* o_buffer, int32_t i_bufferSize, bool i_firstArgIsExeName);
bool CoreInit::InsertFromRegistry(char* i_valueName, char* o_buffer, int32_t i_bufferSize);
bool CoreInit::Add(int32_t i_argc, char** i_argv, bool i_firstArgIsExeName, bool i_insert);
bool CoreInit::MakeSpaceForArgs(int32_t i_argc, int32_t i_where);
void CoreInit::ParseArg(CoreInitArg& io_arg);
void CoreInit::Parse();
void CoreInit::DisplayCommandLine();
void CoreInit::DisplayUnusedArguments();
bool CoreInit::FindPartArg(CoreInitArg& o_arg, char* i_argString);
bool CoreInit::FindWholeArg(CoreInitArg& o_arg, char* i_argString);
bool CoreInit::FindArgAsBool(bool& o_value, char* i_argString1, bool i_value1, char* i_argString2, bool i_value2, char* i_argString3, bool i_value3, char* i_argString4, bool i_value4);
bool CoreInit::FindArgAsNumber(int32_t& o_value, char* i_argString, int32_t i_minValue, int32_t i_maxValue);
bool CoreInit::FindArgAsString(char* i_argString, char* o_string, int32_t i_maxStringSize);
int32_t CoreInit::SplitCommandLine(char* i_commandLine, char* o_buffer, int32_t i_bufferSize, char**& o_argv, int32_t i_maxArgs);
bool CoreInit::RegistryInit(CoreMemory* i_memoryInterface, char* i_subKeyName);
bool CoreInit::AddIdleCallBack(void* i_callBack, void* i_callBackUserData);
bool CoreInit::AddExitCallBack(void* i_callBack, void* i_callBackUserData);
char* CoreInit::GetRegionExtension();
void CoreInit::SetLanguageAndVersionOverrides();
CoreInit::CoreLanguageEnum CoreInit::ConvertLanguageFromHash(CoreHash i_languageHash);
bool CoreInit::FindVersionFileParameter(char* i_versionFile, char* i_parameter, char* o_parameterBuffer, int32_t i_parameterBufferSize);
void CoreInit::LoadVersionFile(char* i_basePath);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coreinit\pc\coreinitpc.cpp
void CoreInit::PreParseSKU();
void CoreInit::ParseArgSKU(CoreInitArg& io_arg);
void CoreBreakPointPC::BreakPoint();
void CoreInit::SetVersion(CoreInit::CoreVersionEnum i_version);
void CoreInit::SetLanguage(CoreInit::CoreLanguageEnum i_language);
bool CoreSaveGameDummyInterface::Stop();
bool CoreMessageBoxDummyInterface::Update();
bool FRPlayerObject::FunctionNullFunction(FRPlayerObject* i_obj, int32_t i_temp);
bool CoreOnScreenKeyboardDummyInterface::Update();
bool CoreOnScreenKeyboardDummyInterface::ExtraUpdate();
bool CoreOnScreenKeyboardDummyInterface::Stop();
bool CoreBlenderBasic::GetUpdateAnimDir();
bool CoreSaveGameDummyInterface::IsReady();
bool CoreNetworkDialogDummyInterface::ExtraUpdate();
bool CAL1_AudioPlayback::IsDeferred();
bool CoreMessageBoxDummyInterface::ExtraUpdate();
bool CoreMessageBoxDummyInterface::Stop();
bool CoreSaveGameDummyInterface::ExtraUpdate();
bool CoreSaveGameDummyInterface::Update();
bool CoreNetworkDialogDummyInterface::Stop();
bool CoreBlenderBasic::IsBlenderSequenced();
bool CoreInit::SetLanguageFromSystem();
bool CoreNetworkDialogDummyInterface::Update();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\coreangle.cpp
float CoreAngle::ClampAngle(float i_angle);
float CoreAngle::ClosestAngle(float i_angleFrom, float i_angleTo);
bool CoreAngle::MoveSourceToTarget(float& io_angleSource, float i_angleTarget, float i_speed);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\coreeulerangle.cpp
void CoreEulerAngle::Clamp();
CoreEulerAngle CoreEulerAngle::Interpolate(CoreEulerAngle& i_targetAngles, float i_alpha);
CoreVector CoreEulerAngle::ToVector();
void CoreEulerAngle::FromVector(CoreVector& i_from);
void CoreEulerAngle::FromVector2(CoreVector& i_from);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\coregeometry.cpp
bool CoreGeometry::IsPointInFront2(CoreVector& i_origin, CoreEulerAngle& i_orient, CoreVector& i_target, float& o_dist);
bool CoreGeometry::IsPointOnLeft(CoreVector& i_origin, CoreVector& i_reference, CoreVector& i_target);
bool CoreGeometry::IsPointInPoly3D(CoreVector* i_verts, CorePlaneEquation& i_plane, CoreVector& i_point);
bool CoreGeometry::IsPointInPoly2D(CoreVector* i_verts, CoreVector& i_point, float i_tolerance);
bool CoreGeometry::LineIntersectsBBox(CoreVector& i_lineStart, CoreVector& i_lineEnd, CoreVector& i_boxMin, CoreVector& i_boxMax);
bool CoreGeometry::LineToSphereIntersection(CoreVector& i_sphereCentre, float i_detSphereCentre, CoreVector& i_lineOrigin, CoreVector& i_lineVector, float& o_intersection1, float& o_intersection2);
CoreVector CoreGeometry::PointOnSpline(float i_alpha, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3);
CoreVector CoreGeometry::TangentOnSpline(float i_alpha, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3);
float CoreGeometry::SpeedOnSpline(float i_alpha, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3);
float CoreGeometry::SplineLength(float i_min, float i_max, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3);
float CoreGeometry::DistanceFromPointToSpline(CoreVector& i_point, CoreVector& i_point0, CoreVector& i_point1, CoreVector& i_point2, CoreVector& i_point3, CoreVector& o_pointOnLineClosest, float& o_segmentDistance, float& o_segmentAlpha);
CoreVector CoreGeometry::PointOnLineClosestToPoint(CoreVector& i_point, CoreVector& i_lineA, CoreVector& i_lineB);
void CoreGeometry::MakeTriangleBoundingBox(CoreVector& i_pos0, CoreVector& i_pos1, CoreVector& i_pos2, CoreVector& o_min, CoreVector& o_max);
void CoreGeometry::MakeLineBoundingBox(CoreVector& i_start, CoreVector& i_end, CoreVector& o_min, CoreVector& o_max);
bool CoreGeometry::WithinBBox(CoreVector& i_pos, CoreVector& i_min, CoreVector& i_max, float i_tolerance);
void CoreGeometry::MakeBoxBoundingSphere(CoreVector& i_posA, CoreVector& i_posB, CoreVector& o_centre, float& o_radius);
bool CoreGeometry::LineToLineIntersect2D(CoreVector& i_line1Pos, CoreVector& i_line1Vect, CoreVector& i_line2Pos, CoreVector& i_line2Vect, float& o_howFar, CoreVector& o_pos);
bool CoreGeometry::KeepPointOnLineWithinLineLimits(CoreVector& i_lineA, CoreVector& i_lineB, CoreVector& o_point);
bool CoreGeometry::LineToCylinderIntersection(CoreVector& i_start, CoreVector& i_dir, CoreVector& i_cylBase, CoreVector& i_cylTop, float i_radius, float& o_pos1, float& o_pos2);
bool CoreGeometry::LineToPolygonIntersection(CoreVector& o_intersection, CoreVector& i_start, CoreVector& i_end, CoreVector& i_dir, CoreVector* i_verts);
float CoreGeometry::DistanceToBBox(CoreVector& i_point, CoreVector& i_min, CoreVector& i_max);
void CoreGeometry::ComputeAABB(CoreMatrix i_transform, CoreVector i_inputBboxMin, CoreVector i_inputBboxMax, CoreVector& o_bboxMin, CoreVector& o_bboxMax);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\coregeometry.h
bool CoreGeometry::BBoxesIntersect(CoreVector& i_min1, CoreVector& i_max1, CoreVector& i_min2, CoreVector& i_max2, float i_tolerance);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\coremaths.cpp
uint32_t CoreMaths::GetVersion();
bool CoreMaths::Init();
bool CoreMaths::IsPowerOfTwo(int32_t i_number);
bool CoreMaths::GetPowerOfTwo(int32_t i_number, int32_t& o_power);
int32_t CoreMaths::Rand31();
float CoreMaths::Rand(float i_max);
float CoreMaths::ClampValueToRange(float i_value, float i_lower, float i_upper);
float CoreMaths::Remainder(float i_valueA, float i_divider, float i_dividerBy2);
float CoreMaths::Part(float i_number);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\corematrix.cpp
CoreVector CoreMatrix::GetScale();
CoreEulerAngle CoreMatrix::GetAngles();
CoreEulerAngle CoreMatrix::ToEulerAnglesZYX();
CoreQuat CoreMatrix::ToQuat();
void CoreMatrix::LookAt(CoreVector& i_origin, CoreVector& i_target, CoreVector& i_worldUp, float i_roll);
void CoreMatrix::CoreMatrix(float i_angle, CoreVector& i_axis);
void CoreMatrix::InverseTransScaleRot();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\coreplaneequation.h
void CorePlaneEquation::MakePlane(CoreVector& i_pos0, CoreVector& i_pos1, CoreVector& i_pos2);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\corequat.cpp
void CoreQuat::Normalize();
CoreQuat CoreQuat::operator*=(CoreQuat& i_quat);
CoreEulerAngle CoreQuat::ToEulerAngle();
void CoreQuat::FromEulerAngle(CoreEulerAngle& i_euler);
void CoreQuat::RotateX(float i_angleX);
void CoreQuat::RotateY(float i_angleY);
void CoreQuat::RotateZ(float i_angleZ);
void CoreQuat::MayaXYZ(float i_angleX, float i_angleY, float i_angleZ);
void CoreQuat::MayaZXY(float i_angleX, float i_angleY, float i_angleZ);
CoreQuat CoreQuat::Squad(float i_alpha, CoreQuat& i_n, CoreQuat& i_a, CoreQuat& i_quat, CoreQuat& i_nPlus1);
CoreQuat CoreQuat::NormInverse();
CoreQuat CoreQuat::Inverse();
CoreEulerAngle CoreQuat::ToMayaXYZAngles();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\corerandom.cpp
void init_genrand(uint32_t s);
void next_state();
int32_t CoreRandom::GetRandom31();
uint32_t CoreRandom::GetRandom32();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremaths\pc\corematrixpc.cpp
void CoreMatrix::Identity();
void CoreMatrix::Zero();
void CoreMatrix::Transpose();
CoreMatrix CoreMatrix::Multiply(CoreMatrix& i_matrix);
CoreVector CoreMatrix::VecTransform(CoreVector& i_vector);
CoreVector CoreMatrix::NormalTransform(CoreVector& i_vector);
void CoreMatrix::TranslateRelative(CoreVector& i_trans);
void CoreMatrix::FromQuat(CoreQuat& i_quat);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corememory\coremem.cpp
void CoreMem::Copy(void* o_to, void* i_from, int32_t i_length);
void CoreMem::CopyBackwards(void* o_to, void* i_from, int32_t i_length);
void CoreMem::Zero(void* o_to, int32_t i_length);
void CoreMem::Fill(void* o_to, char cValue, int32_t i_length);
bool CoreMem::IsSame(void* i_memory, void* i_compare, int32_t i_length);
uint32_t CoreMem::SwapEndian2(uint32_t* i_data);
uint32_t CoreMem::SwapEndian4(uint32_t* i_data);
uint32_t CoreMem::SwapEndian8(uint32_t* i_data);
CoreU128 CoreMem::SwapEndian16(CoreU128* i_data);
uint32_t CoreMem::GetHash(uint32_t* i_memory, uint32_t i_length);
void* CoreMem::Alloc(uint32_t uiSize, CoreMemory* o_allocator, int32_t i_numItems, char* i_fileName, int32_t i_lineNumber);
void CoreMem::Delete(CoreMemory* o_allocator, void* i_memory, char* i_fileName, int32_t i_lineNumber);
void* CoreMem::MemAlign(int32_t i_size, int32_t i_alignment);
void* CoreMem::Malloc(int32_t i_size);
int32_t CoreMem::MemSize(int32_t i_bytesPerElement, int32_t i_numItems);
void CoreMem::CoreDelete(void* i_memory);
void* CoreMem::CoreNew(uint32_t i_size);
void CoreMem::SetDebugMemoryAllocator(CoreMemory* i_allocator);
bool CoreMem::GetDebugMemoryAllocator(CoreMemory*& o_allocator);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corememory\coremem.h
uint32_t* CoreMem::AllocArrayMemory<unsigned __int64>(CoreMemory* i_allocator, uint32_t i_numItems, char* i_fileName, int32_t i_lineNumber);
uint32_t* CoreMem::AllocArrayMemory<unsigned int>(CoreMemory* i_allocator, uint32_t i_numItems, char* i_fileName, int32_t i_lineNumber);
CoreU128* CoreMem::AllocArrayMemory<CoreU128>(CoreMemory* i_allocator, uint32_t i_numItems, char* i_fileName, int32_t i_lineNumber);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corememory\corememory.cpp
void CoreMemory::SetDebugName(char* i_name);
int32_t CoreMemory::DebugString(char* o_buffer);
void CoreMemory::DebugDetails(char* i_fileName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corememory\corememoryarray.cpp
void CoreMemoryArray::Construct();
void CoreMemoryArray::Destruct();
void* CoreMemoryArray::Alloc(uint32_t i_bytes, uint32_t i_alignment, char* i_fileName, uint32_t i_lineNumber);
void CoreMemoryArray::Free(void* i_memory, char* i_fileName, int32_t i_lineNumber);
int32_t CoreMemoryArray::GetMemoryAvailable();
int32_t CoreMemoryArray::GetMemoryUsed();
char* CoreMemoryArray::GetDebugTypeName();
void CoreMemoryArray::CoreMemoryArray();
bool CoreMemoryArray::Init(int32_t i_numBlocks, int32_t i_blockSize, CoreMemory* i_memory);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corememory\corememorypool.cpp
void CoreMemoryPool::Construct();
void CoreMemoryPool::Destruct();
void* CoreMemoryPool::Alloc(uint32_t i_bytes, uint32_t i_alignment, char* i_fileName, uint32_t i_lineNumber);
void CoreMemoryPool::Free(void* i_memory, char* i_fileName, int32_t i_lineNumber);
int32_t CoreMemoryPool::GetMemoryAvailable();
int32_t CoreMemoryPool::GetMemoryUsed();
char* CoreMemoryPool::GetDebugTypeName();
bool CoreMemoryPool::Init(int32_t i_poolSize, int32_t i_numBlocks, int32_t i_maxAlignment, CoreMemory* i_memory);
int32_t CoreMemoryPool::GetMaxSingleFree();
int32_t CoreMemoryPool::DebugString(char* i_buffer);
bool CoreMemoryPool::Reset();
int32_t CoreMemoryPool::ComputeMemNeeded(int32_t i_poolSize, int32_t i_numBlocks);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corememory\corememorypoolblock.h
bool CoreMemoryPoolBlock::Alloc(void* i_newPtr, char* i_fileName, int32_t i_lineNumber);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corememory\corememorystack.cpp
void CoreMemoryStack::Construct();
void CoreMemoryStack::Destruct();
void* CoreMemoryStack::Alloc(uint32_t i_bytes, uint32_t i_alignment, char* i_fileName, uint32_t i_lineNumber);
void CoreMemoryStack::Free(void* i_memory, char*, int32_t);
int32_t CoreMemoryStack::GetMemoryAvailable();
int32_t CoreMemoryStack::GetMemoryUsed();
char* CoreMemoryStack::GetDebugTypeName();
bool CoreMemoryStack::Init(int32_t i_poolSize, int32_t i_numMarkers, CoreMemory* i_memory);
bool CoreMemoryStack::Destroy(CoreMemory* i_memory);
bool CoreMemoryStack::ResetToStart();
bool CoreMemoryStack::ResetToNamedMarker(CoreHash i_markerName);
bool CoreMemoryStack::CreateMarker(CoreHash i_markerName);
CoreMemoryStackMarker* CoreMemoryStack::FindMarker(CoreHash i_markerName, bool& o_found);
uint32_t* CoreMemoryStack::GetMarkerMemoryPos(CoreHash i_markerName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremessagebox\coremessagebox.cpp
void CoreMessageBoxInterface::CoreMessageBoxInterface();
bool CoreMessageBoxInterface::Prepare(CoreMessageBoxInterface::CoreMessageBoxTypeTag i_type, int32_t i_defaultButtonIndex, bool i_useGameRendered);
bool CoreMessageBoxDummyInterface::Start(void* i_finishedCallBack, void* i_callBackUserData, char* i_fmtString);
char* CoreMessageBoxDummyInterface::GetCommonDialogTitle();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coremessagebox\pc\coremessageboxpc.cpp
CoreMessageBoxInterface* CoreMessageBoxInterface::CreateInstance(CoreMemory* i_memoryInterface);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corenamedpipe\corenamedpipe.cpp
bool CoreNamedPipeDummyInterface::Read(void* o_buffer, int32_t i_bufferSize, int32_t& o_sizeRead);
void CoreNamedPipeInterface::CoreNamedPipeInterface();
void CoreNamedPipeInterface::~CoreNamedPipeInterface();
void CoreNamedPipeDummyInterface::~CoreNamedPipeDummyInterface();
CoreNamedPipeInterface* CoreNamedPipeInterface::CreateInstance(CoreMemory* i_memoryInterface);
CoreNamedPipeInterface* CoreNamedPipeInterface::GetDummyInstance();
bool CoreNamedPipeInterface::ReadMessage(void* o_buffer, int32_t i_bufferSize, int32_t& o_messageSize, uint32_t& o_messageID);
bool CoreNamedPipeInterface::TrickleRead(void* o_buffer, int32_t i_bufferSize, CoreTimingSeconds& io_timeout);
bool CoreNamedPipeInterface::ReadHeader(CoreNamedPipeInterface::MessageHeader& o_header, CoreTimingSeconds& io_timeout);
bool CoreNamedPipeInterface::ReadFooter(CoreNamedPipeInterface::MessageFooter& o_footer, CoreTimingSeconds& io_timeout);
bool CoreNamedPipeInterface::SendMessage(uint32_t i_messageID, void* i_message, int32_t i_messageSize);
bool CoreNamedPipeInterface::SendMessageString(uint32_t i_messageID, char* i_fmtString);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corenamedpipe\pc\corenamedpipepc.cpp
CoreNamedPipeInterface* CoreNamedPipeInterface::CreateInstanceSKU(CoreMemory* i_memoryInterface);
void CoreNamedPipePC::DeleteInstance();
bool CoreNamedPipePC::Create(char* i_pipeName);
bool CoreNamedPipePC::Open(char* i_pipeName);
bool CoreNamedPipePC::IsReady();
bool CoreNamedPipePC::IsDataReady(int32_t i_size);
void CoreNamedPipePC::Close();
bool CoreNamedPipePC::Read(void* o_buffer, int32_t i_bufferSize, int32_t& o_sizeRead);
bool CoreNamedPipePC::Send(void* i_data, int32_t i_dataSize);
void CoreNamedPipePC::CoreNamedPipePC();
void CoreNamedPipePC::~CoreNamedPipePC();
bool CoreNamedPipePC::StartConnect();
void CoreNamedPipePC::Disconnect();
int32_t CoreNamedPipePC::GetSizeAvailable();
bool CoreNamedPipePC::StartRead(void* o_buffer, int32_t i_bufferSize);
bool CoreNamedPipePC::WaitUntilReadFinished(int32_t& o_sizeRead);
bool CoreNamedPipePC::StartSend(void* i_data, int32_t i_dataSize);
bool CoreNamedPipePC::WaitUntilSendFinished();
void CoreNamedPipePC::Cancel();
void CoreNamedPipePC::Async::Start(char* i_title, char* i_name, void* i_handle, _OVERLAPPED* io_overlapped);
void CoreNamedPipePC::Async::Update();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corenetworkdialog\corenetworkdialog.cpp
bool CoreNetworkDialogDummyInterface::Start(void* i_finishedCallBack, void* i_callBackUserData);
char* CoreNetworkDialogDummyInterface::GetCommonDialogTitle();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\corenetworkdialog\pc\corenetworkdialogpc.cpp
CoreNetworkDialogInterface* CoreNetworkDialogInterface::CreateInstance(CoreMemory* i_memoryInterface);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coreonscreenkeyboard\coreonscreenkeyboard.cpp
bool CoreOnScreenKeyboardDummyInterface::Prepare(char* i_title, char* i_string, int32_t i_maximumLength, int32_t i_inputLines, int32_t i_inputIndex);
bool CoreOnScreenKeyboardDummyInterface::Start(void* i_finishedCallBack, void* i_callBackUserData);
char* CoreOnScreenKeyboardDummyInterface::GetCommonDialogTitle();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coreonscreenkeyboard\pc\coreonscreenkeyboardpc.cpp
CoreOnScreenKeyboardInterface* CoreOnScreenKeyboardInterface::CreateInstance(CoreMemory* i_memoryInterface);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coreregistry\coreregistry.cpp
bool CoreAnimatingObject::GetFloorSurfaceType(CoreVector& i_detectPosition, uint32_t& o_surfaceType);
bool CoreRegistryDummyInterface::ReadNumber(char* i_valueName, uint32_t* o_number);
bool CoreRegistryEmulateUsingFile::WriteString(char* i_valueName, char* i_string);
bool CoreBlenderBasic::GetTimer(CoreHash i_timerName, float& o_time);
bool CoreRegistryDummyInterface::WriteString(char* i_valueName, char* i_string);
bool CoreCameraObject::AdjustCameraPitchTo(float i_toPitch, float i_speed);
bool CoreCameraObject::AdjustCameraAngleTo(float i_toAngle, float i_speed);
bool CoreBlenderSimple::GetTimer(CoreHash i_timerName, float& o_time);
bool CoreRegistryEmulateUsingFile::ReadNumber(char* i_valueName, uint32_t* o_number);
bool CoreNamedPipeDummyInterface::Send(void* i_data, int32_t i_dataSize);
bool CAL1_AudioDriver::IsChannelPlaying(uint32_t channel, bool ignoreDeferred);
bool CoreRegistryDummyInterface::WriteNumber(char* i_valueName, uint32_t i_number);
bool CoreRegistryEmulateUsingFile::WriteNumber(char* i_valueName, uint32_t i_number);
int32_t CoreRegistryDummyInterface::ReadBinary(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
int32_t CoreRegistryEmulateUsingFile::ReadString(char* i_valueName, char* o_stringBuffer, int32_t i_stringBufferSize);
int32_t CoreRegistryDummyInterface::ReadString(char* i_valueName, char* o_stringBuffer, int32_t i_stringBufferSize);
int32_t CoreRegistryEmulateUsingFile::ReadBinary(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
bool CoreBlenderBasic::AttachAnimationSequencer(CoreAnimSequencer* i_animSeq, uint32_t i_animationSetFile, uint32_t i_animSequencerAssetHash);
bool CoreRegistryEmulateUsingFile::WriteBinary(char* i_valueName, void* i_buffer, int32_t i_bufferSize);
bool CoreBlenderBasic::SetGoalState(CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
bool CoreRegistryDummyInterface::WriteBinary(char* i_valueName, void* i_buffer, int32_t i_bufferSize);
bool CoreCameraObject::AdjustCameraAngleOverride(float i_targetAngleX, float i_targetAngleY, float i_speed);
bool CoreMenuComponent::AddItem(char* i_text, uint32_t i_customColour, CoreHash i_icon);
bool CoreRegistryDummyInterface::DeleteValue(char* i_valueName);
bool CoreMenuComponent::GetItemIconVisibility(int32_t i_itemIndex);
bool CoreNamedPipeDummyInterface::Open(char* i_pipeName);
bool CoreBlenderBasic::IsAnimFlagSet(CoreHash& i_flagHash);
bool CoreRegistryEmulateUsingFile::DeleteValue(char* i_valueName);
bool CoreMenuComponent::InternalMovementHandler(CoreMenuComponent::CompDirection i_direction);
bool CoreNamedPipeDummyInterface::Create(char* i_pipeName);
bool CoreBlenderBasic::SetAnimFlag(CoreHash& i_flagHash);
bool CoreBlenderBasic::GetAnimStateLooping(CoreHash i_animState);
bool CoreNetworkDialogDummyInterface::Prepare(int32_t i_userValue);
void CoreRegistryEmulateUsingFile::DeleteInstance();
void CoreRegistryInterface::CoreRegistryInterface();
void CoreRegistryDummyInterface::~CoreRegistryDummyInterface();
void CoreRegistryInterface::~CoreRegistryInterface();
void CoreRegistryEmulateUsingFile::~CoreRegistryEmulateUsingFile();
CoreRegistryInterface* CoreRegistryInterface::CreateInstance(CoreMemory* i_memoryInterface);
CoreRegistryInterface* CoreRegistryInterface::GetDummyInstance();
void CoreRegistryInterface::SetSubKey(char* i_subKey);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coreregistry\pc\coreregistrypc.cpp
void CoreRegistryPC::CoreRegistryPC();
void CoreRegistryPC::~CoreRegistryPC();
char* CoreRegistryPC::TidySubKeyName(char* i_subKey);
char* CoreRegistryPC::AdjustSubKeyAndValueNames(char* i_subKey, char* i_valueName, CoreStringBuffer<256>& o_subKey);
char* CoreRegistryPC::OverrideMasterKeyHandle(char* i_name);
bool CoreRegistryPC::CloseSubKey();
bool CoreRegistryPC::OpenSubKey(char* i_subKey);
bool CoreRegistryPC::CreateSubKey(char* i_subKey);
bool CoreRegistryPC::GetValueTypeAndSizeFromOpenSubKey(char* i_valueName);
bool CoreRegistryPC::CheckProcessedValueTypeAndSizeFromOpenSubKey(char* i_valueName, CoreRegistryPC::RegistryValueType_TAG i_processedValueType, int32_t i_valueSize, bool i_reportSizeDifference);
int32_t CoreRegistryPC::GetValueFromOpenSubKey(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
bool CoreRegistryPC::SetValueFromOpenSubKey(char* i_valueName, void* i_data, int32_t i_dataSize, uint32_t i_valueType);
bool CoreRegistryPC::DeleteValueFromOpenSubKey(char* i_valueName);
bool CoreRegistryPC::ReadNumberFromOpenSubKey(char* i_valueName, uint32_t* o_number);
int32_t CoreRegistryPC::ReadStringFromOpenSubKey(char* i_valueName, char* o_stringBuffer, int32_t i_stringBufferSize);
int32_t CoreRegistryPC::ReadBinaryFromOpenSubKey(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
bool CoreRegistryPC::WriteNumberIfChangedFromOpenSubKey(char* i_valueName, uint32_t i_number);
bool CoreRegistryPC::WriteStringIfChangedFromOpenSubKey(char* i_valueName, char* i_string);
bool CoreRegistryPC::WriteBinaryIfChangedFromOpenSubKey(char* i_valueName, void* i_buffer, int32_t i_bufferSize);
bool CoreRegistryPC::WriteNumberIfChanged(char* i_subKey, char* i_valueName, uint32_t i_number);
bool CoreRegistryPC::WriteStringIfChanged(char* i_subKey, char* i_valueName, char* i_string);
bool CoreRegistryPC::WriteBinaryIfChanged(char* i_subKey, char* i_valueName, void* i_buffer, int32_t i_bufferSize);
CoreRegistryInterface* CoreRegistryInterface::CreateInstanceSKU(CoreMemory* i_memoryInterface);
void CoreRegistryPC::DeleteInstance();
bool CoreRegistryPC::ReadNumber(char* i_valueName, uint32_t* o_number);
int32_t CoreRegistryPC::ReadString(char* i_valueName, char* o_stringBuffer, int32_t i_stringBufferSize);
int32_t CoreRegistryPC::ReadBinary(char* i_valueName, void* o_buffer, int32_t i_bufferSize);
bool CoreRegistryPC::WriteNumber(char* i_valueName, uint32_t i_number);
bool CoreRegistryPC::WriteString(char* i_valueName, char* i_string);
bool CoreRegistryPC::WriteBinary(char* i_valueName, void* i_buffer, int32_t i_bufferSize);
bool CoreRegistryPC::DeleteValue(char* i_valueName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coresavegame\coresavegame.cpp
bool CoreSaveGameInterface::Prepare(CoreSaveGameInterface::CoreSaveGameTypeTag i_type, void* io_buffer, int32_t i_bufferSize);
bool CoreSaveGameDummyInterface::Start(void* i_finishedCallBack, void* i_callBackUserData);
char* CoreSaveGameDummyInterface::GetCommonDialogTitle();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coresavegame\pc\coresavegamepc.cpp
CoreSaveGameInterface* CoreSaveGameInterface::CreateInstance(CoreMemory* i_memoryInterface);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coresystem\coresystem.cpp
void CoreSystem::Sleep(uint32_t i_milliSeconds);
void OSKFinished(void* i_callBackUserData, char* i_resultString, CORE_OSK_RESULT_TAG i_result, int32_t i_inputIndex, bool i_lastCallBack);
void LoadGameFinished(CoreSaveGameInterface* i_saveGameInterface, void* i_callBackUserData, CORE_SAVEGAME_RESULT_TAG i_result, int32_t i_fileSize, bool i_shouldRetry);
void SaveGameGetAllSizesFinished(CoreSaveGameInterface* i_saveGameInterface, void* i_callBackUserData, CORE_SAVEGAME_RESULT_TAG i_result, int32_t i_fileSize, bool i_shouldRetry);
void SaveGameDeleteFinished(CoreSaveGameInterface* i_saveGameInterface, void* i_callBackUserData, CORE_SAVEGAME_RESULT_TAG i_result, int32_t i_fileSize, bool i_shouldRetry);
void SaveGameFinished(CoreSaveGameInterface* i_saveGameInterface, void* i_callBackUserData, CORE_SAVEGAME_RESULT_TAG i_result, int32_t i_fileSize, bool i_shouldRetry);
void MessageBoxFinished(void* i_callBackUserData, CORE_MB_RESULT_TAG i_result, int32_t i_selectedButtonIndex);
int32_t GetCommandLineOptionFrameCounter(char* i_option);
void CoreSystem::TimerFunction();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coresystem\pc\coresystempc.cpp
void* CoreSystem::LockScratchPad(bool i_lock);
void CoreSystem::SleepSKU(uint32_t i_milliSeconds);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coretiming\coretiming.cpp
uint32_t CoreTiming::GetRandomSeed();
int32_t CoreTimingMicroSeconds::Get64();
void CoreTimingSeconds::CoreTimingSeconds();
int32_t CoreTimingSeconds::SecondsToMicroSeconds64(float i_seconds);
float CoreTimingSeconds::Get();
void CoreTimingSeconds::Start();
float CoreTimingSeconds::GetTaken();
void CoreTimingSeconds::StartTimeOut(float i_timeOut);
bool CoreTimingSeconds::HasTimedOut();
float CoreTimingSeconds::GetTimedValue(float i_timePeriod, float i_min, float i_max);
void CoreDateTime::CoreDateTime();
void CoreDateTime::Set(int32_t i_year, int32_t i_month, int32_t i_day, int32_t i_hour, int32_t i_minute, int32_t i_second, int32_t i_milliSeconds);
void CoreDateTime::Reset();
bool CoreDateTime::IsTimeValid();
int32_t CoreDateTime::GetCompareValue(CoreDateTime& i_fileTime);
char* CoreDateTime::GetTimeString(char* o_timeStringBuffer, char dateSeperator, char timeSeperator);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coretiming\pc\coretimingpc.cpp
int32_t CoreTiming::Get64();
int32_t CoreVeryQuickTimer::GetRaw64();
bool CoreDateTime::SetFromPC(_FILETIME* i_fileTimePC);
bool CoreDateTime::ConvertToPC(_FILETIME* o_fileTimePC);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coreuseful\coreuseful.cpp
char* BuildSystemHelper::GetProjectName();
char* BuildSystemHelper::GetOptionsFileName();
void BuildSystemHelper::SetSimple(char* i_projectName);
void CoreDataStorer::CoreDataStorer(void* o_buffer, int32_t i_size);
void CoreDataStorer::StoreChar(char i_char);
void CoreDataStorer::StoreString(char* i_string);
uint32_t CoreDataStorer::ZeroTerminate();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibcommon\coreuseful\pc\coreusefulpc.cpp
bool CoreUseful::ExecuteApplicationOnPC(char* i_applicationName, char* i_commandLineArguments, bool i_waitUntilFinished);
int32_t CoreUseful::ReadFile(char* i_fileName, void* o_buffer, int32_t i_bufferSize, int32_t i_fromFilePosition);
int32_t CoreUseful::WriteFile(char* i_fileName, void* i_buffer, int32_t i_bufferSize);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibeffects\corefx\corefx.cpp
void CoreFX::Construct(CoreMemory* pMemPool, CoreFX::FXCreator iCreator);
void CoreFX::Reset();
void CoreFX::SignalGlobalEvent(CoreHash hEventName, CoreHash hEventSource);
void CoreFX::Update(CoreLevelUpdateStruct* pUpdate);
uint32_t CoreFX::UpdateParticles(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain);
uint32_t CoreFX::UpdateBeziers(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain);
uint32_t CoreFX::UpdateLines(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain);
CoreFXPrimitive* CoreFX::GetPrimitive(uint32_t idxPrim);
CoreFXPrimitive* CoreFX::CreateAnimPrimitive(CoreVector Pos, CoreHash animName, CoreVector Vel, bool bPostRender);
CoreFXPrimitive* CoreFX::InitialiseAnimPrimitive(CoreParticleFXPrimitive* pPrim, CoreVector Pos, int32_t* pAnim, CoreVector vel, bool bPostRender);
CoreFXPrimitive* CoreFX::CreateBezierPrimitive(CoreVector* pPosArray, CoreVector* pVelArray, uint32_t Life, uint32_t nSegs, int32_t* pAnim);
CoreFXPrimitive* CoreFX::CreateLinePrimitive(CoreVector Pos, int32_t* pAnim, CoreVector Vel);
CoreFXPrimitive* CoreFX::CreateAnimChildPrimitive(CoreParticleFXPrimitive* pParent, int32_t* pAnim, CoreVector vel, bool bClone);
CoreFXPrimitive* CoreFX::CreateBezierChildPrimitive(CoreBezierFXPrimitive* pParent, int32_t* pAnim);
void CoreFX::LoadMaterials();
void CoreFX::AddFont(CoreHash assetName);
void CoreFX::LoadFonts();
void CoreFX::LoadFont(CoreHash assetName);
void CoreFX::RegisterAssets(CoreTextureSet* pTexSet);
CoreHash CoreFX::GetTextureHash(CoreFX::Textures texID);
void CoreFX::UpdateAnimCmd(CoreFXControl* pCtrl);
CoreFXMaterial* CoreFX::GetMaterial(uint32_t nMat);
void CoreFX::Render(CoreGraphicsDevice* pGraphics, bool bPostRender);
float CoreFX::fxRandfB(float max);
float CoreFX::fxRandfC(float max);
int32_t CoreFX::SetRandSeed(int32_t newVal);
void CoreFX::CreateEmitters(CoreMemory* pMemPool);
void CoreFX::ResetEmittersToMarker(uint32_t nMarker);
void CoreFX::ResetEmitters();
CoreFXEmitter* CoreFX::GetFreeEmitter();
CoreFXEmitter* CoreFX::CreateAnimEmitter(char* pName, CoreVector Pos, uint32_t Shape, int32_t* pAnim);
void CoreFX::SetEmitterMinMax(CoreFXEmitter* pEmit, CoreVector Min, CoreVector Max);
void CoreFX::AddEmitterItem(CoreFXEmitter* pEmit, CoreFXEmitterItem* pSrcItem);
void CoreFX::AddEmitterItems(CoreFXEmitter* pEmit, CoreFXEmitterItem* pSrcItem);
void CoreFX::EmitterMapScriptVariable(CoreFXEmitter* pEmit, char* pMapName, CoreHash hVarName);
void CoreFX::EmitterAttachToObject(CoreFXEmitter* pEmit, CoreHash objectName, CoreHash boneName);
void CoreFX::eFnFXEmitter(CoreCommand* pCmd, CoreScripted* pOwner);
CoreFXEmitter* CoreFX::FindEmitter(CoreHash hID);
CoreFX::CoreFXInfoNode* CoreFX::FindInfoNode(CoreHash hName);
void CoreFX::UpdateEmitter(CoreFXEmitter* pEmit);
void CoreFX::UpdateEmitterItemControlled(CoreFXEmitter* pEmit, CoreVector Pos, CoreVector Min, CoreVector Max, CoreFXEmitterItem* pItem);
void CoreFX::GetControlOverride(uint32_t oIndex, uint32_t& oValue);
void CoreFX::RenderEmitterItemList();
void CoreFXMaterial::BuildMaterial(CoreFX* pFX, CoreFX::RawMaterial* pMat, CoreTextureSet* pTexSetOverride, CoreTextureInfo* pTexInfoOverride, uint32_t textureID);
void CoreFRGBA::Set(CoreRGBA rgba);
void CoreFRGBA::SetDelta(uint32_t drgba, uint32_t l_time);
CoreRGBA& CoreFRGBA::Get();
bool CoreFRGBA::Step();
void CoreFRGBA::Scale(float val);
void CoreFX::SetContext(CoreFX::Contexts iContext, CoreVector iPos);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibeffects\corefx\corefxdefault.cpp
CoreFX* CoreFX::CreateInstance(CoreMemory* pMemPool, CoreFX::FXCreator iCreator);
uint32_t CoreFXDefault::GetMaxPrimitives(uint32_t idxPrim);
void CoreFXDefault::Render(CoreGraphicsDevice* pGraphics, bool bPostRender);
void CoreFX::RenderParticles(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain, CoreGraphicsDevice* pDevice);
void CoreFXDefault::RenderSingleParticle(CoreParticleFXPrimitive* pPrim, CoreGraphicsDevice* pDevice);
void CoreFX::Render2DParticles(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain, CoreGraphicsDevice* pDevice);
void CoreFX::RenderBeziers(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain, CoreGraphicsDevice* pDevice);
void CoreFX::RenderLines(CoreFX* pObj, CoreFX::CoreFXPrimitiveChain* pChain, CoreGraphicsDevice* pDevice);
void CoreFX::AllocateMaterials(uint32_t nMaterials);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibeffects\corefx\corefxdefault.h
void CoreFXDefault::CoreFXDefault();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibeffects\corefx\corefxlibrary.cpp
void CoreFXLibrary::Construct(CoreMemory* pMemPool);
void CoreFXLibrary::RegisterCommandList(char* pName, int32_t* pCmd);
void CoreFXLibrary::RegisterItemGroup(char* pName, CoreFXEmitterItem* pItemGroup, void* i_controlFunction);
int32_t* CoreFXLibrary::GetRegisteredCommandList(char* pName);
CoreFXEmitterItem* CoreFXLibrary::GetRegisteredItemGroup(CoreHash hName);
char* CoreFXLibrary::GetFirstItemGroup();
char* CoreFXLibrary::GetNextItemGroup();
CoreHash CoreFXLibrary::GetRegisteredItemGroupHash(uint32_t iIndex);
uint32_t CoreFXLibrary::GetRegisteredItemGroupIndex(CoreHash iName);
void* CoreFXLibrary::GetRegisteredItemControlFunction(CoreHash hName);
uint32_t CoreFXLibrary::ExtractFromCommandList(int32_t* pCmd, uint32_t fxCmd);
void SetupWaterfallRockHitStatic(CoreFXPrimitive* i_particle);
void SetupWaterfallRockHitFall(CoreFXPrimitive* i_particle);
void CoreFXLibrary::RegisterFXCommands();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreassetmanager\coreassetmanager.cpp
void CoreAssetManagerData::CoreAssetManagerData();
void* CoreAssetManager::Alloc(uint32_t iBytes, uint32_t iByteAlignment, char* lpcFileName, uint32_t iLineNumber);
void CoreAssetManager::Free(void* lpPtr, char* lpcFileName, int32_t iLineNumber);
int32_t CoreAssetManager::GetMemoryAvailable();
int32_t CoreAssetManager::GetMemoryUsed();
char* CoreAssetManager::GetDebugTypeName();
char* CoreAssetManager::lpcReturnCode(CoreAssetManager::CoreAssetManagerReturnCode eReturnCode);
void CoreAssetManager::SetMemoryLocked(CoreAssetManagerMemoryBlock* io_memBlock, CoreHash i_assetType);
CoreAssetManagerAssetTypeInfo* CoreAssetManager::GetAssetTypeInfo(CoreHash i_assetType);
char* CoreAssetManager::GetAssetTypeName(CoreHash i_assetType);
bool CoreAssetManager::GetAssetTypeMemoryLocked(CoreHash i_assetType);
char* CoreAssetManager::lpcState(CoreAssetManager::CoreAssetManagerState eState);
void CoreAssetManager::CoreAssetManager();
void CoreAssetManager::~CoreAssetManager();
void CoreMemoryStack::~CoreMemoryStack();
void CoreMemoryArray::~CoreMemoryArray();
void CoreMemoryPool::~CoreMemoryPool();
void CoreAssetManager::Construct(CoreMemory* lpoMemory, uint32_t iMemoryArenaSizeInBytes, uint32_t iMaxNumBlocks, uint32_t iMaxNumClients);
void CoreAssetManager::Destruct(CoreMemory* lpoMemory);
void CoreAssetManager::Init(bool* bCanICreateAssetFunction, bool* bCreateAssetFunction, bool* bDeleteAssetFunction, bool* moveAssetFunction, void* lpCreateDeleteUserData);
void CoreAssetManager::Update();
void CoreAssetManager::Reset();
void CoreAssetManager::DoDebug(CoreDebugInput* i_input);
void CoreAssetManager::DumpDebugInfo();
void CoreAssetManager::ComputeDebugStats();
CoreAssetManagerMemoryBlock* CoreAssetManager::FindSpace(int32_t iSizeInBytes, int32_t& o_maxSingleFreeSpace, int32_t& o_maxSingleFreeInactiveSpace, int32_t& o_totalFreeSpace);
CoreAssetManagerMemoryBlock* CoreAssetManager::FindAllocation(char* i_name, CoreHash i_assetID, CoreHash i_assetType);
CoreAssetManager::CoreAssetManagerReturnCode CoreAssetManager::eAllocateMemory(CoreHash i_assetID, CoreHash i_assetType, int32_t iSizeInBytes, CoreAssetManagerMemoryBlock*& lpoMemBlock, CoreDateTime& i_fileTime, char* i_name);
void CoreAssetManager::HandleReturnCode(CoreAssetManager::CoreAssetManagerReturnCode eReturnCode);
CoreAssetManager::CoreAssetManagerReturnCode CoreAssetManager::eTryAllocateMemory(CoreHash i_assetID, CoreHash i_assetType, int32_t iSizeInBytes, CoreAssetManagerMemoryBlock*& o_memBlock, CoreDateTime& i_fileTime, char* i_name);
CoreAssetManager::CoreAssetManagerReturnCode CoreAssetManager::AllocateBlock(CoreAssetManagerMemoryBlock* i_memBlock, uint32_t i_SizeInBytes, CoreDateTime& i_fileTime, char* i_name, CoreHash i_assetID, CoreHash i_assetType, CoreAssetManagerMemoryBlock*& o_memBlock);
CoreAssetManager::CoreAssetManagerReturnCode CoreAssetManager::eDeAllocateMemory(CoreHash i_assetID, CoreHash i_assetType, void* lpMemoryPtr);
CoreAssetManager::CoreAssetManagerReturnCode CoreAssetManager::eDeAllocateMemoryBlock(CoreAssetManagerMemoryBlock* lpoMemBlock);
bool CoreAssetManager::Validate();
void* CoreAssetManager::lpAsyncLoadAsset(uint32_t i_clientID, char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType);
void* CoreAssetManager::lpHardLoadAsset(uint32_t i_clientID, char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType);
int32_t CoreAssetManager::GetAssetSizeInBytes(char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType);
void* CoreAssetManager::lpLoadAsset(char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType, bool bAsync, bool& o_failedToLoad);
void* CoreAssetManager::lpPostLoadAsset(char* lpcFileName, CoreAssetManagerMemoryBlock* lpoMemBlock, CoreHash i_assetID, CoreHash i_assetType, bool bAsync);
void* CoreAssetManager::TryAllocAsset(uint32_t i_clientID, CoreHash i_assetID, CoreHash i_assetType);
void* CoreAssetManager::InternalTryAllocAsset(CoreAssetManagerMemoryBlock* i_memBlock, CoreHash i_assetID, CoreHash i_assetType, bool i_allocAsset);
void* CoreAssetManager::GetAsset(uint32_t i_clientID, CoreHash i_assetID, CoreHash i_assetType);
bool CoreAssetManager::RemoveAsset(uint32_t i_clientID, CoreHash i_assetID, CoreHash i_assetType);
bool CoreAssetManager::RawRemoveAsset(CoreHash i_assetID, CoreHash i_assetType);
bool CoreAssetManager::RemoveAssetMemoryBlock(CoreAssetManagerMemoryBlock* lpoMemBlock);
bool CoreAssetManager::SetAssetActiveState(bool bActive, CoreHash i_assetID, CoreHash i_assetType);
bool CoreAssetManager::IsAssetActive(CoreHash i_assetID, CoreHash i_assetType);
int32_t CoreAssetManager::CountLargestFreeBlock();
int32_t CoreAssetManager::CountTotalFreeBytes();
int32_t CoreAssetManager::CountMaxSingleFreeInactive();
bool CoreAssetManager::RegisterClient(uint32_t i_clientID, void* lpClientCallbackFunc, void* lpUsrData1, void* lpUsrData2);
bool CoreAssetManager::UnRegisterClient(uint32_t i_clientID);
bool CoreAssetManager::RegisterAssetType(CoreHash i_assetType, char* i_assetTypeName, bool i_memoryLocked);
int32_t CoreAssetManager::ComputeMemNeeded(int32_t iMaxNumBlocks, int32_t iMaxNumClients);
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunOneCycle(CoreAssetManager::CoreAssetManagerState i_eRequestState);
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunStartDefragSingle();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunInDefragSingle();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunDoneDefragSingle();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunStartDefragAll();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunInDefragAll();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunDoneDefragAll();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunStartPurgeSingle();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunInPurgeSingle();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunDonePurgeSingle();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunStartPurgeAll();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunInPurgeAll();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunDonePurgeAll();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunStartUpdateClientsSingle();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunInUpdateClientsSingle();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunDoneUpdateClientsSingle();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunStartUpdateClientsAll();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunInUpdateClientsAll();
CoreAssetManager::CoreAssetManagerState CoreAssetManager::eRunDoneUpdateClientsAll();
void* CoreAssetManager::lpPostLoadFile(char* lpcFileName);
void CoreAssetManager::SetAssetLoadingDetails(char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType);
void CoreAssetManager::ClearFileLoadingDetails();
void CoreAssetManager::ClearCreateAssetDetails();
bool CoreAssetManager::CancelAssetLoading();
void* CoreAssetManager::LoadAsset(uint32_t i_clientID, char* i_assetName, CoreHash i_assetID, CoreHash i_assetType, bool i_asyncLoad);
void* CoreAssetManager::AllocAsset(uint32_t i_clientID, char* i_assetName, CoreHash i_assetID, CoreHash i_assetType, bool i_asyncLoad);
bool CoreAssetManager::DeAllocAsset(uint32_t i_clientID, CoreHash i_assetID, CoreHash i_assetType);
bool CoreAssetManager::IsStartPanicMode();
bool CoreAssetManager::IsInPanicMode();
bool CoreAssetManager::IsExitPanicMode();
void CoreAssetManager::RequestStartPanicMode();
void CoreAssetManager::RequestExitPanicMode();
bool CoreAssetManager::StartPanicMode();
bool CoreAssetManager::ExitPanicMode();
int32_t CoreAssetManager::CopyMemBlockToFreeMemBlock(CoreAssetManagerMemoryBlock* i_assetMemBlock, CoreAssetManagerMemoryBlock* i_freeMemBlock);
int32_t CoreAssetManager::CountOutOfDate();
void CoreAssetManager::CheckAllUpToDate(bool markAsDirty);
bool CoreAssetManager::LoadCluster(char* i_fileName, CoreHash i_assetID, CoreHash i_assetType, CoreClusterData* i_clusterData);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreassetmanager\coreassetmanagermemoryblock.h
void CoreAssetManagerMemoryBlock::Reset();
bool CoreAssetManagerMemoryBlock::IsFreeSpace();
void* CoreAssetManagerMemoryBlock::Allocate(CoreHash assetID, CoreHash assetType, uint32_t uiSizeInBytes, CoreDateTime& i_fileTime, char* i_name);
void CoreAssetManagerMemoryBlock::Create(void* lpMemoryPtr, int32_t iSizeInBytes, CoreAssetManagerMemoryBlock* lpoPrevBlock, CoreAssetManagerMemoryBlock* lpoNextBlock);
void CoreAssetManagerMemoryBlock::SetFree();
void CoreAssetManagerMemoryBlock::SetUnUsed();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreaudio\coreaudio.cpp
void PrintDebugMessage(char* message);
void CoreAudio::Construct(CoreMemory* lpoMemory, CoreHash i_audioType, char* lpcAppName, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize);
void CoreAudio::Init();
void CoreAudio::StopAll();
bool CoreAudio::LoadLevel(char* lpcLevelName, char* lpcSceneName, uint32_t languageMask);
bool CoreAudio::UnloadLevel();
bool CoreAudio::LoadLevelScene(char* lpcSceneName, uint32_t languageMask);
bool CoreAudio::MarkArea();
bool CoreAudio::UnmarkArea();
void CoreAudio::Destruct(CoreMemory* lpoMemory);
void CoreAudio::Update(CoreWorldUpdateStruct* lpoWorldUpdateStruct);
bool CoreAudio::PlayAnimatingSample(CoreHash i_ModelName, CoreHash i_hash, CoreVector i_position);
bool CoreAudio::PlaySound2D(CoreHash hash, int32_t iPercentage, uint32_t iGroupMask);
bool CoreAudio::PlaySound2DParam(CoreHash hash, int32_t iPercentage, uint32_t iIndex, uint32_t iGroupMask);
bool CoreAudio::PlaySound3D(CoreHash hash, CoreVector& vPosition, int32_t iPercentage, uint32_t iGroupMask);
bool CoreAudio::UpdateSound3D(CoreHash hash, CoreVector& vPosition);
bool CoreAudio::UpdateSoundVolume(CoreHash hash, int32_t iPercentage);
bool CoreAudio::StopSound(CoreHash hash);
bool CoreAudio::IsSoundPlaying(uint32_t i_ObjectID, uint32_t i_ObjectInstance, uint32_t iEventID);
void CoreAudio::DoDebug(CoreDebugInput* i_input, CoreWorldUpdateStruct* i_worldUpdateStruct);
void CoreAudio::SetMasterVolume(float factor);
void CoreAudio::Pause();
void CoreAudio::UnPause();
void CoreAudio::SetGlobalReverb(CoreHash reverbHash);
void CoreAudio::ResetAudioData();
void CoreAudio::SetAudioData_3D(bool is3D);
void CoreAudio::SetAudioData_FrequencyOffset(float freqOffset);
void CoreAudio::SetAudioData_MaxDist(float maxDist);
void CoreAudio::SetAudioData_MinDist(float minDist);
void CoreAudio::SetAudioData_Point(CoreVector point);
void CoreAudio::SetAudioData_VolumeOffset(uint32_t volumeOffset);
void CoreAudio::StartObjectEvent(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash);
void CoreAudio::StartObjectEventParam(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash, uint32_t i_Index);
void CoreAudio::UpdateObjectEvent(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash);
void CoreAudio::TriggerObjectEvent(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash);
void CoreAudio::StopObjectEvent(CoreHash i_ObjectHash, uint32_t i_ObjectInstance, CoreHash i_EventHash);
void CoreAudio::StartEvent(CoreHash i_EventHash, uint32_t i_EventInstance);
void CoreAudio::StartEventParam(CoreHash i_EventHash, uint32_t i_EventInstance, uint32_t i_Param);
void CoreAudio::TriggerEvent(CoreHash i_EventHash, uint32_t i_EventInstance);
void CoreAudio::StopEvent(CoreHash i_EventHash, uint32_t i_EventInstance);
bool CoreAudio::CreateInstance(CoreHash i_ObjectHash, uint32_t& o_instance);
bool CoreAudio::PlaySpeech(CoreHash hash, int32_t iPercentage, uint32_t iGroupMask);
bool CoreAudio::PlaySpeechParam(CoreHash hash, int32_t iPercentage, uint32_t param, uint32_t iGroupMask);
bool CoreAudio::StopSpeech();
bool CoreAudio::PlayMusic(CoreHash i_Hash);
bool CoreAudio::StopMusic();
void CoreAudio::UpdateMusic(CoreWorldUpdateStruct* lpoWorldUpdateStruct);
bool CoreAudio::DuckMusic(uint32_t i_Percentage);
bool CoreAudio::UnDuckMusic();
bool CoreAudio::DuckSFX(uint32_t i_Percentage);
bool CoreAudio::UnDuckSFX();
void CoreAudio::SetMenuMusicVolume(float musicVolume);
bool CoreAudio::AddSurfaceType(CoreHash hash, uint32_t index);
uint32_t CoreAudio::GetSurfaceTypeIndex(CoreHash hash);
bool CoreAudio::AddAdditionalEvent(CoreHash hash, CoreHash addHash);
uint32_t CoreAudio::GetAdditionalEvent(CoreHash hash);
void CoreAudio::GetHeapMemoryStats(int32_t& o_memUsed, int32_t& o_memFree, int32_t& o_memTotal);
void CoreAudio::GetSRAMMemoryStats(int32_t& o_memUsed, int32_t& o_memFree, int32_t& o_memTotal);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreaudio\coreaudio.h
void CoreAudioObjectData::Reset();
void CoreAudioObjectData::CoreAudioObjectData();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreaudio\coreaudiospeechqueue.cpp
void CoreAudio_SpeechQueue::CoreAudio_SpeechQueue();
void CoreAudio_SpeechQueue::Process();
void CoreAudio_SpeechQueue::Clear();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreaudio\coreaudiospeechqueue.h
void CoreAudio_SpeechQueueEntry::Clear();
void CoreAudio_SpeechQueueEntry::CoreAudio_SpeechQueueEntry();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreaudio\pc\coreaudio_pc.cpp
bool CoreAudio::CreateDevice(CoreMemory* i_memory, uint32_t i_audioMemSize, uint32_t i_audioSRAMSize);
bool CoreAudio::InitPlatformSpecific();
bool CoreAudio::LoadLevelPlatformSpecific(char* lpcLevelName, char* lpcSceneName, uint32_t languageMask);
void CoreAudio::Reset();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreaudiolocator\coreaudiolocatorobject.cpp
void* CoreAudioLocatorObject::GetVariablePointer(CoreHash i_variableName);
void* CoreGeometryObject::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreAudioLocatorObject::RunFunction(CoreCommand* io_command);
void CoreAudioLocatorObjectData::Reset();
void CoreAudioLocatorObjectData::CoreAudioLocatorObjectData();
void CoreAudioLocatorObject::Construct(CoreMemory* lpoMemory);
void CoreAudioLocatorObject::Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreRenderableObject::Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreAudioLocatorObject::Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreAudioLocatorObject::Reset();
void CoreRenderableObject::Reset();
void CoreFileHandle::~CoreFileHandle();
void CoreAudioLocatorObject::SetCullByDistanceFlag();
void CoreAudioLocatorObject::Update(CoreObjectUpdateStruct* lpoUpdateStruct);
CoreObject* CoreAudioLocatorObject::Create(CoreMemory* lpoMemory);
CoreScripted::CommandReturn CoreAudioLocatorObject::FnSetAudioObjectAndEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreAudioLocatorObject::FnUpdate(CoreCommand* io_command);
void CoreAudioLocatorObject::DoDebug(CoreWorldUpdateStruct* i_worldUpdateStruct);
uint32_t CoreAudioLocatorObject::GetAudioEventHash();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreaudiolocator\coreaudiolocatorobject.h
void CoreAudioLocatorObject::CoreAudioLocatorObject();
CoreHash CoreAudioLocatorObject::GetTypeID();
void* CoreAudioLocatorObject::GetMemoryStack();
int32_t CoreAudioLocatorObject::GetMemoryStackSize();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreanimlist.cpp
void CoreAnimList::Reset();
void CoreAnimList::PopList();
CoreAnimSlot* CoreAnimList::GetSlotPtr(int32_t iListIndex);
void CoreAnimList::SetAnim(int32_t iListIndex, CoreAnimSlot* lpAnimSlot, bool bLastInList);
void CoreAnimList::SetBlendTime(int32_t iListIndex, float fDeltaTimeInSeconds);
CoreHash CoreAnimList::GetAnim(int32_t iListIndex);
bool CoreAnimList::GetBlendLooping(int32_t iListIndex);
bool CoreAnimList::IsMirror(int32_t iListIndex);
bool CoreAnimList::IsActive(int32_t iListIndex);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreanimslot.h
void CoreAnimSlot::CoreAnimSlot();
[! NO TYPE] CoreAnimSlot::operator=();
int32_t CoreAnimSlot::GetFirstCallBackData(float& fTime, void*& oCallBackFunc, void*& lpUsrData);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreblender.cpp
void CoreBlender::Construct(CoreMemory* i_memory);
void CoreBlender::Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
void CoreBlender::BlendJointStates(CoreJointState* io_outputState, CoreJointState** io_inputState, float* i_weight, int32_t i_boneCount, CoreModelSkeleton* i_skeleton);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreblender.h
void CoreBlenderSimple::~CoreBlenderSimple();
void CoreBlender::~CoreBlender();
void CoreBlenderComplex::~CoreBlenderComplex();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreblenderbasic.cpp
void CoreBlenderBasic::Construct(CoreMemory* i_memory);
void CoreBlenderBasic::Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
CoreAnimationSet* CoreBlenderBasic::GetAnimationSet(CoreHash& i_animName);
uint32_t CoreBlenderSimple::AnimDataSet_GetAnimSetAssetHash(int32_t i_index);
CoreFileSystem::CoreFileLoadReturn CoreBlenderBasic::AttachAnimationSetFile(uint32_t i_clientID, CoreObjectUpdateStruct* i_updateStruct, char* i_animationSetName);
bool CoreBlenderBasic::AttachAnimationSet(CoreAnimationSet* i_animSet, uint32_t i_animationSetFile, uint32_t i_animationSetAssetHash);
void CoreBlenderBasic::HandleAssetManagerClientCallback(CoreAssetManager* i_assetManager, CoreWorld* i_world, CoreHash& i_assetID, CoreHash& i_assetType);
CoreVector CoreBlenderBasic::GetPositionChange(CoreAnimatingObject* i_ao, float i_startTime, float i_endTime);
CoreEulerAngle CoreBlenderBasic::GetOrientationChange(CoreAnimatingObject* i_ao, float i_startTime, float i_endTime);
void CoreBlenderBasic::GetAnimateVelocity(CoreVector* o_velocityPos, CoreEulerAngle* o_velocityRot, CoreVector* o_offsetPos, CoreEulerAngle* o_offsetRot);
void CoreBlenderBasic::RenderAnimList(CoreGraphicsDevice* i_graphicsDevice, CoreVector& io_screenPos1, CoreVector& io_screenPos2);
void CoreBlenderBasic::UpdateJointsState(CoreAnimatingObject* i_ao, CoreHashArray* i_jointIndexTable, CoreJointState* io_jointStates);
CoreHash CoreBlenderBasic::GetPrimaryAnimID();
CoreHash CoreBlenderBasic::GetPrimaryAnimNameHash();
float CoreBlenderBasic::GetPrimaryAnimTime();
float CoreBlenderBasic::GetPrimaryAnimEndTime();
float CoreBlenderBasic::GetPrimaryAnimPlaybackSpeed();
CoreHash CoreBlenderBasic::GetSlotAnimID(CoreHash& i_slotID);
CoreHash CoreBlenderBasic::GetSlotAnimNameHash(CoreHash& i_slotID);
float CoreBlenderBasic::GetSlotAnimTime(CoreHash& i_slotID);
float CoreBlenderBasic::GetSlotAnimEndTime(CoreHash& i_slotID);
bool CoreBlenderBasic::IsSlotAnimBlending(CoreHash& i_slotID);
bool CoreBlenderBasic::IsSlotAnimMirrored(CoreHash& i_slotID);
bool CoreBlenderBasic::IsSlotPlaying(CoreHash& i_slotID);
float CoreBlenderSimple::GetSlotWeight(CoreHash& i_slotID);
float CoreBlenderBasic::GetAnimStateEndTime(CoreHash i_animState);
float CoreBlenderBasic::GetSlotWeight(CoreHash& i_slotID);
void CoreBlenderBasic::SetSlotPlaybackSpeed(CoreHash& i_slotID, float i_playbackSpeed);
float CoreBlenderBasic::GetSlotPlaybackSpeed(CoreHash& i_slotID);
CoreHash CoreBlenderBasic::GetAnim(int32_t i_listIndex);
CoreAnimList::eAnimListPlace CoreBlenderBasic::GetListIndexFromSlotHash(CoreHash& i_slotID);
bool CoreBlenderBasic::AddAnim(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
void CoreBlenderBasic::UpdateBlendingFlag(float i_scaledDeltaTimeInSeconds, float i_deltaTimeInSeconds);
void CoreBlenderBasic::SetBlendingData(float i_time);
void CoreBlenderBasic::ResetAnimations();
void CoreBlenderBasic::ClearAnimList();
void CoreBlenderBasic::HandleCallBack(CoreObjectUpdateStruct* i_updateStruct, float i_lastTime, float i_presentTime);
void CoreBlenderBasic::Animate(CoreAnimatingObject* i_ao, CoreObjectUpdateStruct* i_updateStruct, float i_deltaTimeInSeconds);
CoreHash CoreBlenderBasic::GetAnimStateContext(CoreHash i_animState);
void CoreBlenderBasic::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderBasic::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
int32_t CoreBlenderBasic::GetNumAnimDataSets();
CoreHash CoreBlenderBasic::GetAnimDataSetHash(int32_t i_index);
void CoreBlenderSimple::GetBlenderStats(char* o_blenderStats);
void CoreBlenderBasic::GetBlenderStats(char* o_blenderStats);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreblendercomplex.cpp
int32_t CoreBlenderSlots::AddSlot(CoreHash& i_slotID, CoreSpecInfo& i_specInfo, CorePlayAnimInfo* i_animInfo);
bool CoreBlenderSlots::UpdateSlot(CoreHash& i_slotID, CoreSpecInfo& i_specInfo);
void CoreBlenderSlots::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderSlots::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
int32_t CoreBlenderAnimsComplex::AddAnim(CoreHash& i_slotID, int32_t i_animSetNumber, int32_t i_animSpecNumber, CoreHash& i_animID, float i_time, float i_playbackSpeed, bool i_primaryAnim, bool i_loopingAnim, bool i_mirrorAnim, bool i_playAnim);
int32_t CoreBlenderAnimsComplex::AddAltAnim(CoreHash& i_slotID, CoreAltAnim* i_altAnim, CoreSpecInfo& i_specInfo, CoreAnimDataSetComplex* i_animDataSet, CorePlayAnimInfo* i_animInfo, uint32_t i_blendFlags);
void CoreBlenderAnimsComplex::FreeUnused(CoreBlenderBlendsComplex* i_blends);
void CoreBlenderAnimsComplex::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderAnimsComplex::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderBlendsComplex::InsertBlends(int32_t i_insertPoint, int32_t i_count);
int32_t CoreBlenderBlendsComplex::GetBlendSlotIDUsageCount(int32_t i_index, CoreBlenderAnimsComplex* i_anims, CoreHash& i_slotID);
int32_t CoreBlenderBlendsComplex::GetBlendParent(int32_t i_index, int32_t& o_subIndex);
int32_t CoreBlenderBlendsComplex::GetEarliestSlotRef(CoreHash& i_slotID, CoreBlenderAnimsComplex* i_anims, int32_t& o_indexRef, bool& o_loneRef);
void CoreBlenderBlendsComplex::UpdateLoneStatus(int32_t i_blendIndex, int32_t& o_blendSubIndex, bool& o_isLone);
int32_t CoreBlenderBlendsComplex::FindLastBlendIndex(int32_t i_blendIndex, int32_t i_blendSubIndex);
void CoreBlenderBlendsComplex::SetBlendAnimPlayingFlag(CoreBlenderAnimsComplex* i_anims, int32_t i_blendIndex, int32_t i_blendSubIndex, bool i_playing);
bool CoreBlenderBlendsComplex::IsBlendingDifferentSlots(int32_t i_blendIndex, CoreBlenderAnimsComplex* i_anims, CoreHash& o_slotID);
bool CoreBlenderBlendsComplex::AddAltAnimBlends(CoreHash& i_slotID, CoreAltAnim* i_altAnim, CoreBlenderAnimsComplex* i_anims, CoreBlenderSlots* i_slots, int32_t i_animIndex, CorePlayAnimInfo* i_animInfo, uint32_t i_blendFlags, char i_goalInfoIndex, uint32_t i_ease);
void CoreBlenderBlendsComplex::KillBlend(int32_t i_index, int32_t i_subIndex);
void CoreBlenderBlendsComplex::FreeUnused(CoreBlenderAnimsComplex* i_anims);
void CoreBlenderSlots::FreeUnused(CoreBlenderAnimsComplex* i_anims);
bool CoreBlenderBlendsComplex::IsAnimUsed(int32_t i_animIndex);
void CoreBlenderBlendsComplex::RemapOnAnim(int32_t i_animIndex, int32_t i_offset);
void CoreBlenderBlendsComplex::RemapOnBlend(int32_t i_blendIndex, int32_t i_offset);
void CoreBlenderBlendsComplex::RemapOnBlendEquals(int32_t i_oldBlendIndex, int32_t i_newBlendIndex);
void CoreBlenderBlendsComplex::OnBlendFinishClearGoalInfoIndices(int32_t i_blendIndex, CoreBlenderGoalInfo* i_goalInfo);
void CoreBlenderBlendsComplex::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderBlendsComplex::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderComplex::Construct(CoreMemory* i_memory);
bool CoreBlenderComplex::AddAnim(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
void CoreBlenderComplex::GetAnimateVelocity(CoreVector* o_velocityPos, CoreEulerAngle* o_velocityRot, CoreVector* o_offsetPos, CoreEulerAngle* o_offsetRot);
bool CoreBlenderComplex::PerformTimedBlend(CoreAnimatingObject* i_ao, int32_t i_slotIndex, CoreSpecInfo& i_specInfoTgt);
bool CoreBlenderComplex::PerformImmediateBlend(CoreAnimatingObject* i_ao, int32_t i_slotIndex, CoreHash& i_state, float i_startTime, uint32_t i_flags);
void CoreBlenderComplex::EvaluateBlendTreeRecursive(CoreAnimatingObject* i_ao, int32_t i_blendNum, CoreHashArray* i_jointIndexTable, CoreJointState* o_jointStates, float i_parentWeight);
void CoreBlenderComplex::EvaluateBlendTreeRecursive_BuildBoneSets(int32_t i_blendNum, bool* i_parentBoneSet, int32_t i_boneCount);
void CoreBlenderComplex::EvaluateBlendTreeRecursive_BoneSet(CoreAnimatingObject* i_ao, int32_t i_blendNum, CoreHashArray* i_jointIndexTable, CoreJointState* o_jointStates, int32_t i_boneCount);
void CoreBlenderComplex::UpdateJointsState(CoreAnimatingObject* i_ao, CoreHashArray* i_jointIndexTable, CoreJointState* io_jointStates);
void CoreBlenderComplex::RenderAnimList(CoreGraphicsDevice* i_graphicsDevice, CoreVector& io_screenPos1, CoreVector& io_screenPos2);
void CoreBlenderComplex::ResetAnimations();
CoreHash CoreBlenderComplex::GetPrimaryAnimID();
CoreHash CoreBlenderComplex::GetPrimaryAnimNameHash();
float CoreBlenderComplex::GetPrimaryAnimTime();
float CoreBlenderComplex::GetPrimaryAnimEndTime();
float CoreBlenderComplex::GetPrimaryAnimPlaybackSpeed();
CoreHash CoreBlenderComplex::GetSlotAnimIDByIndex(int32_t i_slotIndex);
CoreHash CoreBlenderComplex::GetSlotAnimID(CoreHash& i_slotID);
CoreHash CoreBlenderComplex::GetSlotAnimNameHash(CoreHash& i_slotID);
float CoreBlenderComplex::GetSlotAnimTime(CoreHash& i_slotID);
float CoreBlenderComplex::GetSlotAnimEndTime(CoreHash& i_slotID);
float CoreBlenderComplex::GetSlotPlaybackSpeed(CoreHash& i_slotID);
int32_t CoreBlenderComplex::GetBlendControllingSlot(CoreHash& i_slotID, int32_t& o_index, int32_t& o_subIndex);
bool CoreBlenderComplex::IsSlotAnimBlending(CoreHash& i_slotID);
bool CoreBlenderComplex::IsSlotAnimMirrored(CoreHash& i_slotID);
bool CoreBlenderComplex::IsSlotPlaying(CoreHash& i_slotID);
void CoreBlenderComplex::SetSlotPlaybackSpeed(CoreHash& i_slotID, float i_playbackSpeed);
bool CoreBlenderBlendsComplex::GetSlotGlobalWeight(int32_t i_blendIndex, CoreHash& i_slotID, CoreBlenderAnimsComplex* i_anims, float i_parentGlobalWeight, float& o_weight);
bool CoreBlenderBlendsComplex::SetSlotGlobalWeight(int32_t i_blendIndex, CoreHash& i_slotID, CoreBlenderAnimsComplex* i_anims, float i_parentGlobalWeight, float i_targetWeight, float i_targetTime, bool& io_killOnZeroWeight, bool& o_globalWeightSet, float& o_weight);
float CoreBlenderComplex::GetSlotWeight(CoreHash& i_slotID);
void CoreBlenderComplex::SetSlotWeight(CoreHash& i_slotID, float i_weight, float i_time, bool i_killOnZeroWeight);
CoreAnimSpec* CoreBlenderComplex::GetPrimaryAnimSpec();
char CoreBlenderComplex::ProcessAnimInfoOnUserBlend(int32_t i_slotIndex, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo, CoreHash& i_currAnimID, float i_currAnimTime);
bool CoreBlenderComplex::SetGoalState(CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
bool CoreBlenderComplex::AddImmediateBlend(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
bool CoreBlenderComplex::CanAddAnim(CoreHash& i_slotID, CoreHash& i_animID);
bool CoreBlenderComplex::GetTimer(CoreHash i_timerName, float& o_time);
void CoreBlenderComplex::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderComplex::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderComplex::GetBlenderStats(char* o_blenderStats);
void CoreBlenderComplex::Animate(CoreAnimatingObject* i_ao, CoreObjectUpdateStruct* i_updateStruct, float i_deltaTimeInSeconds);
void CoreBlenderComplex::StepBlender(float i_deltaTime);
void CoreBlenderComplex::CheckForEvent_Command(float i_deltaTime);
void CoreBlenderComplex::CheckForEvent_BlendTree(float i_deltaTime);
void CoreBlenderComplex::ProcessEvent_BlendTree(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao, bool i_killSlot);
void CoreBlenderComplex::CheckForEvent_Anim(float i_deltaTime);
void CoreBlenderComplex::ProcessEvent_Anim(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
void CoreBlenderComplex::CheckForEvent_TimedBlend(float i_deltaTime);
void CoreBlenderComplex::ProcessEvent_TimedBlend(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
bool CoreBlenderComplex::GetBlendTreeOriginOffset(int32_t i_blendIndex, float i_deltaTime, CoreVector& o_offsetPos, CoreEulerAngle& o_offsetRot);
bool CoreBlenderComplex::GetVelocityByBlendTree(int32_t i_blendIndex, float i_deltaTime, CoreVector& o_velPos, CoreQuat& o_velRot, CoreVector& o_offsetPos, CoreEulerAngle& o_offsetRot);
void CoreBlenderComplex::ClearOffsetBlends();
void CoreBlenderBlendsComplex::CalculateGlobalAnimWeights(float* io_animWeights, int32_t* io_blendIndex, int32_t* io_blendSubIndex, int32_t i_blendIndex, float i_parentWeight);
void CoreBlenderComplex::CheckSpaceAvailableForNewAnims(int32_t i_requiredAnims);
bool CoreBlenderComplex::InitialiseSpecInfoFromIndex(int32_t& i_animSetIndex, int32_t& i_animSpecIndex, CoreSpecInfo& i_tbi);
bool CoreBlenderComplex::InitialiseSpecInfoFromState(CoreHash& i_state, CoreSpecInfo& i_tbi);
bool CoreBlenderComplex::InitialiseSpecInfoFromSlot(int32_t i_slotIndex, CoreSpecInfo& i_tbi);
CoreBlenderFlags* CoreBlenderComplex::GetBlenderFlags();
CoreBlenderGoalInfo* CoreBlenderComplex::GetBlenderGoalInfo();
CoreBlenderTimers* CoreBlenderComplex::GetBlenderTimers();
int32_t CoreBlenderComplex::AnimDataSet_AddItem();
uint32_t CoreBlenderComplex::AnimDataSet_GetAnimSetFile(int32_t i_index);
uint32_t CoreBlenderComplex::AnimDataSet_GetAnimSetAssetHash(int32_t i_index);
uint32_t CoreBlenderComplex::AnimDataSet_GetAnimSequencerAssetHash(int32_t i_index);
CoreAnimationSet* CoreBlenderComplex::AnimDataSet_GetAnimSet(int32_t i_index);
CoreAnimSequencer* CoreBlenderComplex::AnimDataSet_GetAnimSequencer(int32_t i_index);
int32_t CoreBlenderComplex::AnimDataSet_GetAnimSetIndexByHash(CoreHash& i_animSetHash);
CoreAnimationSet* CoreBlenderComplex::AnimDataSet_GetAnimSetByHash(CoreHash& i_animSetHash);
int32_t CoreBlenderComplex::AnimDataSet_GetIndexByAnimSpecID(CoreHash& i_animSpecID, int32_t& o_specIndex);
void CoreBlenderComplex::AnimDataSet_SetAnimSetFile(int32_t i_index, uint32_t i_animSetFile);
void CoreBlenderComplex::AnimDataSet_SetAnimSet(int32_t i_index, CoreAnimationSet* i_animSet);
void CoreBlenderComplex::AnimDataSet_SetAnimSequencer(int32_t i_index, CoreAnimSequencer* i_animSeq);
void CoreBlenderComplex::AnimDataSet_SetAnimSetAssetHash(int32_t i_index, uint32_t i_animationSetAssetHash);
void CoreBlenderComplex::AnimDataSet_SetAnimSequencerAssetHash(int32_t i_index, uint32_t i_animSequencerAssetHash);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreblendercomplex.h
int32_t CoreAnimDataSetComplex::GetIndexByAnimSpecID(CoreHash& i_animSpecID, int32_t& o_specIndex);
CoreHash CoreBlenderAnimsComplex::GetSlotID(int32_t i_index);
CoreHash CoreBlenderSlots::GetSlotID(int32_t i_index);
CoreHash CoreBlenderSlots::GetCurrentState(int32_t i_index);
CoreHash CoreBlenderSlots::GetGoalState(int32_t i_index);
bool CoreBlenderAnimsComplex::IsSlotUsed(CoreHash& i_slotID);
int32_t CoreBlenderAnimsComplex::GetPrimaryAnimBySlotID(CoreHash& i_slotID);
void CoreBlenderAnimsComplex::ClearPrimaryFlagBySlotID(CoreHash& i_slotID);
bool CoreBlenderAnimsComplex::IsSlotMirrored(CoreHash& i_slotID);
void CoreBlenderBlendsComplex::SetBlendTarget(int32_t i_index, int32_t i_subIndex, float i_targetWeight, float i_blendTime);
void CoreBlenderBlendsComplex::SetBlendTargetEx(int32_t i_index, int32_t i_subIndex, float i_targetWeight, float i_blendTime, bool i_killOnZeroWeight, bool i_blendingDifferentSlots);
void CoreBlenderBlendsComplex::ClearVelocityFlags();
void CoreBlenderBlendsComplex::GetIndexData(int32_t i_index, int32_t i_subIndex, CoreBlenderBlendIndexData& o_indexData);
void CoreBlenderBlendsComplex::SetIndexData(int32_t i_index, int32_t i_subIndex, CoreBlenderBlendIndexData& i_indexData);
void CoreBlenderBlendsComplex::CopyIndexData(int32_t i_tgtIndex, int32_t i_tgtSubIndex, int32_t i_srcIndex, int32_t i_srcSubIndex);
void CoreBlenderBlendsComplex::CopyWeightData(int32_t i_tgtIndex, int32_t i_tgtSubIndex, int32_t i_srcIndex, int32_t i_srcSubIndex);
int32_t CoreBlenderComplex::GetBlenderType();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreblendersequenced.cpp
void CoreBlenderTimers::Reset();
bool CoreBlenderTimers::AddNewTimer(CoreHash& i_name, uint32_t i_flags, float i_initialDelta);
void CoreBlenderTimers::UpdateTimers(float i_deltaTime, bool i_onBlend);
bool CoreBlenderTimers::GetTimer(CoreHash& i_name, float& o_time);
bool CoreBlenderTimers::StopTimer(CoreHash& i_name, float i_finalDelta);
void CoreBlenderTimers::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderTimers::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderGoalInfo::Reset();
bool CoreBlenderGoalInfo::HasOffsetBlend(int32_t i_index);
char CoreBlenderGoalInfo::Add(float i_subPlaybackSpeed, CoreVector& i_offsetPos, CoreEulerAngle& i_offsetRot);
void CoreBlenderGoalInfo::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderGoalInfo::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
bool CoreBlenderFlags::SetFlag(uint32_t i_flagHash);
void CoreBlenderFlags::ClearFlag(uint32_t i_flagHash);
void CoreBlenderFlags::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderFlags::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderSequenced::Construct(CoreMemory* i_memory);
void CoreBlenderSequenced::Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
void CoreBlenderSequenced::ClearAnimList();
CoreFileSystem::CoreFileLoadReturn CoreBlenderSequenced::AttachAnimationSetFile(uint32_t i_clientID, CoreObjectUpdateStruct* i_updateStruct, char* i_animationSetName);
bool CoreBlenderSequenced::AttachAnimationSet(CoreAnimationSet* i_animSet, uint32_t i_animationSetFile, uint32_t i_animationSetAssetHash);
bool CoreBlenderSequenced::AttachAnimationSequencer(CoreAnimSequencer* i_animSeq, uint32_t i_animationSetFile, uint32_t i_animSequencerAssetHash);
void CoreBlenderSequenced::HandleAssetManagerClientCallback(CoreAssetManager* i_assetManager, CoreWorld* i_world, CoreHash& i_assetID, CoreHash& i_assetType);
CoreAnimationSet* CoreBlenderSequenced::GetAnimationSet(CoreHash& i_animName);
void CoreBlenderSequenced::StepSequencer(CoreAnimatingObject* i_ao, float i_deltaTimeInSeconds);
uint32_t CoreBlenderSequenced::GetAudioParams(CoreAnimatingObject* i_ao, CoreAnimCommandAudio* i_command, CoreVector& o_detectPosition);
void CoreBlenderSequenced::ProcessEvent_Command(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
bool CoreBlenderSequenced::GetAnimSpecPrimaryAnimInfo(CoreSpecInfo& i_specInfo, CoreAnimDataInfo& o_animInfo);
int32_t CoreBlenderSequenced::FindTimedBlend(CoreSpecInfo& i_specInfoSrc, CoreSpecInfo& o_specInfoTgt, float i_deltaTime);
float CoreBlenderSequenced::CalcTimeBetweenAnims(CoreHash& i_startState, float i_startTime, CoreHash& i_targetState);
bool CoreBlenderSequenced::EvaluateCondition(CoreAnimSequencer* i_animSeq, int32_t i_conditionIndex);
CoreAltAnim* CoreBlenderSequenced::ChooseAltAnim(CoreSpecInfo& specInfo);
bool CoreBlenderSequenced::ValidateAltAnim(CoreAltAnim* i_altAnim, CoreSpecInfo& i_specInfo, bool i_displayError);
CoreVector CoreBlenderSequenced::GetPositionChange(CoreAnimatingObject* i_ao, float i_startTime, float i_endTime);
CoreEulerAngle CoreBlenderSequenced::GetOrientationChange(CoreAnimatingObject* i_ao, float i_startTime, float i_endTime);
bool CoreBlenderSequenced::CalculateOffsetBlend(CoreAnimatingObject* i_ao, CoreSpecInfo& i_specInfoSrc, CoreSpecInfo& i_specInfoTgt, CoreVector& o_offsetPos, CoreEulerAngle& o_offsetRot);
char CoreBlenderSequenced::SetupOffsetBlending(CoreAnimatingObject* i_ao, CoreHash& i_slotID, int32_t i_slotIndex, int32_t i_goalInfoIndex, CoreSpecInfo& i_specInfoTgt);
CoreHash CoreBlenderSequenced::GetAnimStateContext(CoreHash i_animState);
float CoreBlenderSequenced::GetAnimStateEndTime(CoreHash i_animState);
bool CoreBlenderSequenced::GetAnimStateLooping(CoreHash i_animState);
CoreAnimSpec* CoreBlenderSequenced::GetAnimSpecByHash(CoreHash& i_animID);
int32_t CoreBlenderSequenced::GetNumAnimDataSets();
CoreHash CoreBlenderSequenced::GetAnimDataSetHash(int32_t i_index);
bool CoreBlenderSequenced::SetAnimFlag(CoreHash& i_flagHash);
void CoreBlenderSequenced::ClearAnimFlag(CoreHash& i_flagHash);
bool CoreBlenderSequenced::IsAnimFlagSet(CoreHash& i_flagHash);
void CoreBlenderSequenced::ClearAllAnimFlags();
bool CoreBlenderSequenced::GetUpdateAnimDir();
void CoreGraphicsDevice::SetForceWireFrame(bool bVal);
void CoreBlenderSequenced::SetUpdateAnimDir(bool i_value);
float CoreBlenderSequenced::Ease(float i_time, float i_easeFrom, float i_easeTo);
void CoreBlenderSequenced::AutoBlendCallback(CoreAnimatingObject* i_ao, CoreHash i_slotID, CoreHash i_oldState, CoreHash i_newState);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreblendersequenced.h
void CoreBlenderGoalInfo::GetOffsetPos(int32_t i_index, CoreVector& o_value);
void CoreBlenderGoalInfo::GetOffsetRot(int32_t i_index, CoreEulerAngle& o_value);
float CoreBlenderSequenced::FrameSnap(float i_time);
void CoreBlenderEvents::AddEvent(CoreBlenderEvent* i_newEvent);
void CoreBlenderEvents::AddCommand(uint32_t i_eventID, float i_deltaTime, uint32_t i_animSetIndex, uint32_t i_animSpecIndex, CoreHash i_slotID, int32_t i_commandIndex, uint32_t i_commandType);
void CoreBlenderEvents::AddBlendTree(uint32_t i_eventID, float i_deltaTime, uint32_t i_blendIndex, uint32_t i_blendSubIndex);
void CoreBlenderEvents::AddAnim(uint32_t i_eventID, float i_deltaTime, int32_t i_animIndex, float i_newTime, uint32_t i_hasLooped);
void CoreBlenderEvents::AddTimedBlend(uint32_t i_eventID, float i_deltaTime, int32_t i_slotIndex, float i_targetTime, float i_blendTime, uint32_t i_blendFlags, uint32_t i_targetState, uint32_t i_flags, uint32_t i_ease);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreblender\coreblendersimple.cpp
void CoreBlenderSimple::Construct(CoreMemory* i_memory);
void CoreBlenderSimple::Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
void CoreBlenderComplex::Destruct(CoreMemory* i_memory, CoreObjectUpdateStruct* i_updateStruct);
void CoreBlenderSimple::ResetAnimations();
void CoreBlenderSimple::Animate(CoreAnimatingObject* i_ao, CoreObjectUpdateStruct* i_updateStruct, float i_deltaTimeInSeconds);
void CoreBlenderSimple::GetAnimateVelocity(CoreVector* o_velocityPos, CoreEulerAngle* o_velocityRot, CoreVector* o_offsetPos, CoreEulerAngle* o_offsetRot);
bool CoreBlenderSimple::GetVelocityByBlendTree(float i_deltaTime, CoreVector& o_velPos, CoreQuat& o_velRot);
void CoreBlenderSimple::StepBlender(float i_deltaTime);
bool CoreBlenderSimple::InitialiseSpecInfoFromIndex(int32_t& i_animSetIndex, int32_t& i_animSpecIndex, CoreSpecInfo& i_tbi);
bool CoreBlenderSimple::InitialiseSpecInfoFromState(CoreHash& i_state, CoreSpecInfo& i_tbi);
bool CoreBlenderSimple::InitialiseSpecInfoFromSlot(int32_t i_slotIndex, CoreSpecInfo& i_tbi);
void CoreBlenderSimple::CheckForEvent_Command(float i_deltaTime);
void CoreBlenderSimple::CheckForEvent_BlendTree(float i_deltaTime);
void CoreBlenderSimple::ProcessEvent_BlendTree(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao, bool i_killSlot);
void CoreBlenderSimple::CheckForEvent_Anim(float i_deltaTime);
void CoreBlenderSimple::ProcessEvent_Anim(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
void CoreBlenderSimple::CheckForEvent_TimedBlend(float i_deltaTime);
void CoreBlenderSimple::ProcessEvent_TimedBlend(CoreBlenderEvent& io_event, CoreAnimatingObject* i_ao);
int32_t CoreBlenderAnimsSimple::AddAltAnim(CoreAltAnim* i_altAnim, CoreSpecInfo& i_specInfo, CoreAnimDataSetSimple* i_animDataSet, CorePlayAnimInfo* i_animInfo, uint32_t i_blendFlags);
bool CoreBlenderBlendsSimple::AddAltAnimBlends(CoreBlenderAnimsSimple* i_anims, CorePlayAnimInfo* i_animInfo, uint32_t i_blendFlags, uint32_t i_ease);
bool CoreBlenderSimple::PerformTimedBlend(CoreAnimatingObject* i_ao, CoreSpecInfo& i_specInfoTgt);
bool CoreBlenderSimple::PerformImmediateBlend(CoreAnimatingObject* i_ao, CoreHash& i_state, float i_startTime, uint32_t i_flags);
bool CoreBlenderSimple::AddAnim(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
bool CoreBlenderSimple::SetGoalState(CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
bool CoreBlenderSimple::AddImmediateBlend(CoreAnimatingObject* i_ao, CoreHash& i_slotID, CoreHash& i_animID, CorePlayAnimInfo* i_animInfo);
void CoreBlenderSimple::UpdateJointsState(CoreAnimatingObject* i_ao, CoreHashArray* i_jointIndexTable, CoreJointState* io_jointStates);
void CoreBlenderSimple::RenderAnimList(CoreGraphicsDevice* i_graphicsDevice, CoreVector& io_screenPos1, CoreVector& io_screenPos2);
CoreHash CoreBlenderSimple::GetPrimaryAnimID();
float CoreBlenderSimple::GetPrimaryAnimTime();
float CoreBlenderSimple::GetPrimaryAnimEndTime();
float CoreBlenderSimple::GetPrimaryAnimPlaybackSpeed();
CoreHash CoreBlenderSimple::GetPrimaryAnimNameHash();
CoreHash CoreBlenderSimple::GetSlotAnimID(CoreHash& i_slotID);
float CoreBlenderSimple::GetSlotAnimTime(CoreHash& i_slotID);
float CoreBlenderSimple::GetSlotAnimEndTime(CoreHash& i_slotID);
float CoreBlenderSimple::GetSlotPlaybackSpeed(CoreHash& i_slotID);
CoreHash CoreBlenderSimple::GetSlotAnimNameHash(CoreHash& i_slotID);
bool CoreBlenderSimple::IsSlotAnimBlending(CoreHash& i_slotID);
bool CoreBlenderSimple::IsSlotAnimMirrored(CoreHash& i_slotID);
bool CoreBlenderSimple::IsSlotPlaying(CoreHash& i_slotID);
void CoreBlenderSimple::SetSlotPlaybackSpeed(CoreHash& i_slotID, float i_playbackSpeed);
CoreAnimSpec* CoreBlenderSimple::GetPrimaryAnimSpec();
void CoreBlenderAnimsSimple::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderAnimsSimple::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderBlendsSimple::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderBlendsSimple::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderSimple::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreBlenderSimple::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& i_DataRead, CoreObjectUpdateStruct* io_UpdateStruct);
int32_t CoreBlenderSimple::AnimDataSet_GetCount();
int32_t CoreBlenderSimple::AnimDataSet_AddItem();
uint32_t CoreBlenderSimple::AnimDataSet_GetAnimSetFile(int32_t i_index);
uint32_t CoreBlenderSimple::AnimDataSet_GetAnimSequencerAssetHash(int32_t i_index);
CoreAnimationSet* CoreBlenderSimple::AnimDataSet_GetAnimSet(int32_t i_index);
CoreAnimSequencer* CoreBlenderSimple::AnimDataSet_GetAnimSequencer(int32_t i_index);
int32_t CoreBlenderSimple::AnimDataSet_GetAnimSetIndexByHash(CoreHash& i_animSetHash);
CoreAnimationSet* CoreBlenderSimple::AnimDataSet_GetAnimSetByHash(CoreHash& i_animSetHash);
int32_t CoreBlenderSimple::AnimDataSet_GetIndexByAnimSpecID(CoreHash& i_animSpecID, int32_t& o_specIndex);
void CoreBlenderSimple::AnimDataSet_SetAnimSetFile(int32_t i_index, uint32_t i_animSetFile);
void CoreBlenderSimple::AnimDataSet_SetAnimSet(int32_t i_index, CoreAnimationSet* i_animSet);
void CoreBlenderSimple::AnimDataSet_SetAnimSequencer(int32_t i_index, CoreAnimSequencer* i_animSeq);
void CoreBlenderSimple::AnimDataSet_SetAnimSetAssetHash(int32_t i_index, uint32_t i_animationSetAssetHash);
void CoreBlenderSimple::AnimDataSet_SetAnimSequencerAssetHash(int32_t i_index, uint32_t i_animSequencerAssetHash);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\corecameraeffect.cpp
void CoreCameraEffect::Init();
void CoreCameraEffect::PushType(CoreCameraEffect::CameraEffectType i_type);
void CoreCameraEffect::PopType();
void CoreCameraEffect::SetupType();
CoreVector CoreCameraEffect::GetOffset();
CoreVector CoreCameraEffect::GetLookAtOffset();
void CoreCameraEffect::Update(float ut);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\corecameraobject.cpp
void* CoreCameraObject::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreCameraObject::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreCameraObject::FnSetCameraBlendType(CoreCommand* io_command);
CoreScripted::CommandReturn CoreCameraObject::FnSetCameraActive(CoreCommand* io_command);
void CoreCameraObject::SetCameraActive(bool i_var);
CoreScripted::CommandReturn CoreCameraObject::FnSetCameraSelectableAsNearest(CoreCommand* io_command);
CoreScripted::CommandReturn CoreCameraObject::FnSetCameraEffect(CoreCommand* io_command);
CoreScripted::CommandReturn CoreCameraObject::FnSetTriggerActive(CoreCommand* io_command);
CoreScripted::CommandReturn CoreCameraObject::FnSetTriggerShape(CoreCommand* io_command);
CoreScripted::CommandReturn CoreCameraObject::FnSetTriggerType(CoreCommand* io_command);
void CoreCameraObject::UpdateTriggerFromViewer(CoreObjectUpdateStruct* i_updateStruct);
void CoreCameraObject::SetTriggeringObject(CoreObject* i_obj);
void CoreCameraObject::Construct(CoreMemory* io_memory);
void CoreCameraObject::ClearTriggers();
CoreHash CoreCameraObject::GetCameraEffectName();
bool CoreCameraObject::GetSelectableAsNearestFlag();
CoreCameraObject::CameraStateType CoreCameraObject::GetStateType();
void CoreCameraObject::SetStateType(CoreCameraObject::CameraStateType i_var);
bool CoreCameraObject::IsActive();
bool CoreMessageBoxDummyInterface::IsReady();
bool CoreGameMessageBox::ExtraUpdate();
bool CoreGameOnScreenKeyboard::ExtraUpdate();
bool CoreNetDevice::GetWLANSwitchOnState();
bool CoreBlenderSequenced::IsBlenderSequenced();
bool CoreGraphicsDeviceNull::SpecificFunction(uint32_t);
bool CoreNamedPipeDummyInterface::IsReady();
bool FRPlayerObject::ContextSetAnim(FRPlayerObject* i_obj, int32_t i_temp);
bool CoreNetDevice::GetConnectedState();
bool CoreCameraObject::IsUpdatable();
void CoreGraphicsDevice::RenderGeometryCompiledBounds(CoreModelMesh* iModelMesh);
void CoreAIController::Update(CoreObjectUpdateStruct*);
void CoreGeometryObject::PhysicsUpdateModelSkeletonPtr(CoreModelSkeleton* lpoModelSkeleton);
void CoreInputDeviceNull::Init(bool);
void CoreFlexibleCamera::OnSwitchedFrom(CoreCameraObject* io_toCam);
void CoreWorld::ProcessGameSpecificNetworkPreInit(uint32_t i_GameSpecificData);
void CoreBlenderBasic::ClearAnimFlag(CoreHash& i_flagHash);
void CoreGraphicsDeviceNull::SelectLights(CoreGraphicsDeviceLightData*);
void CoreGraphicsDeviceNull::BeginFastQuadRender(uint32_t);
void CoreGraphicsDeviceNull::UnLoadModelData(CoreModelGeometry*);
void CoreGraphicsDeviceNull::MoveTextureData(CoreTextureSet*);
void CoreGraphicsDevice::SetFastQuadPtr(void*);
void TRFixedCamera::OnSwitchedFrom(CoreCameraObject* io_toCam);
void CorePCStdCFileDevice::Construct(CoreMemory*);
void CoreCameraObject::OnSwitchedTo(CoreCameraObject* io_fromCam);
void CoreGraphicsDeviceOpenGL::BeginFastQuadRender(uint32_t);
void CoreGraphicsDevice::SetZOffset(uint32_t val);
void CoreInputDeviceDirectInput::StopRumble(int32_t);
void CoreClusterFileSystem::Construct(CoreMemory*);
void CoreGraphicsDeviceOpenGL::UnLoadModelData(CoreModelGeometry*);
void TRNode::CreateNodeName(uint32_t);
void CoreMenuComponent::SetInternalSelection(uint32_t i_index);
void CoreGraphicsDeviceNull::SelectUnLit(uint32_t);
void CoreGraphicsDeviceOpenGL::MoveTextureData(CoreTextureSet* lpoTextureSet);
void CoreInputDeviceNull::Destruct(CoreMemory*);
void CoreAIController::DoDebug(CoreDebugInput*);
void CoreBlenderBasic::SetUpdateAnimDir(bool i_value);
void CoreGraphicsDevice::Set1BitAlphaMode(bool i_enable);
void CoreChaseCamera::OnSwitchedFrom(CoreCameraObject* io_toCam);
void CoreGraphicsDevice::DoDebugFullScreen(CoreDebugInput* i_input);
void CoreObjectController::OnDestroyObjects(CoreObjectUpdateStruct*);
void CoreAIController::Construct(CoreMemory*);
void TRMenuSystem::ConstructSKU(CoreMemory* io_memory);
void CoreMenuComponent::SetNumberOfVisibleItems(int32_t i_visibleItemCount);
void CoreGraphicsDevice::SetBGColour(uint32_t val);
void CoreStdFileSystem::Construct(CoreMemory*);
void CoreGraphicsDeviceNull::SetBlendState(bool);
void CoreRenderableObject::SetScaledFrameTime(float);
void CoreGraphicsDevice::ResetBatchRender(uint32_t);
void CoreGraphicsDevice::End3DScene(bool i_drawPostProcessEffects);
void CorePCStdCFileDevice::Destruct(CoreMemory*);
void CoreAIController::Destruct(CoreMemory*);
void CoreStdFileSystem::Destruct(CoreMemory*);
void CoreGraphicsDevice::FlushBatchRender(uint32_t);
void TRChaseCamera::OnSwitchedFrom(CoreCameraObject* io_toCam);
void CoreAIController::Init(CoreObjectUpdateStruct*);
void CoreCameraObject::UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
void CoreCameraObject::AdjustCameraDistance(float i_requiredDistance);
void CoreClusterFileSystem::Destruct(CoreMemory*);
void FRBackgroundObject::UpdateGameCycle(float i_time);
void CoreObjectController::Update(CoreWorldUpdateStruct* io_WorldUpdateStruct);
void CoreGraphicsDeviceOpenGL::MoveModelData(CoreModelGeometry* lpoModelGeometry);
void CAL1_ReverbManager::SetRemotePreset(void* data);
void CoreFlexibleCamera::OnSwitchedTo(CoreCameraObject* io_fromCam);
void CoreCameraObject::OnSwitchedFrom(CoreCameraObject* io_toCam);
void CoreGraphicsDevice::EndGeometryPass(int32_t);
void CoreGraphicsDeviceNull::DrawStaticMesh(CoreGeometryCompiled*);
void CoreGraphicsDeviceNull::DrawMeshGroup(CoreMeshGroup*);
void CoreGraphicsDeviceNull::MoveModelData(CoreModelGeometry*);
void CoreGraphicsDeviceNull::UnLoadTextureData(CoreTextureSet*);
void CoreNetDeviceNULL::Init(CoreNet::DeviceInitialisationData* i_Init);
void CoreBatchRender::Render(uint32_t);
void CoreInputDevice::StopRumble(int32_t i_pad);
bool CoreCameraObject::GetConnectedToViewerFlag();
void CoreCameraObject::SetConnectedToViewerFlag(bool i_var);
void CoreCameraObject::SetCurrentViewerObject(CoreViewerObject* i_var);
CoreViewerObject* CoreCameraObject::GetCurrentViewerObject();
void CoreCameraObject::Init(CoreHash i_nameHash, CoreHash i_scriptHash, CoreObjectUpdateStruct* io_updateStruct);
float CoreCameraObject::CoreCurveEquasionCalc(float i_inputval, CoreCameraObject::CoreCurveEquasion i_type);
void CoreCameraObject::SetNearClip(float val);
void CoreCameraObject::SetFarClip(float val);
float CoreCameraObject::GetNearClip();
float CoreCameraObject::GetFarClip();
float CoreCameraObject::GetVerticalFieldOfView();
float CoreCameraObject::GetDisplayAspectRatio();
void CoreCameraObject::LookAtLookAtPos();
void CoreCameraObject::SetLookAtPos(CoreVector& i_pos);
CoreVector CoreCameraObject::GetLookAtPos();
bool CoreCameraObject::IsFogOn();
float CoreCameraObject::GetFogRed();
float CoreCameraObject::GetFogGreen();
float CoreCameraObject::GetFogBlue();
float CoreCameraObject::GetFogAlpha();
float CoreCameraObject::GetFogNear();
float CoreCameraObject::GetFogFar();
bool CoreCameraObject::GetBloom();
float CoreCameraObject::GetBloomIntensity();
float CoreCameraObject::GetBloomFeedback();
float CoreCameraObject::GetBloomThreshold();
bool CoreCameraObject::GetFocalBlur();
float CoreCameraObject::GetFocalBlurZ();
float CoreCameraObject::GetFocalBlurAmount();
bool CoreCameraObject::GetMotionBlur();
float CoreCameraObject::GetMotionBlurAmount();
bool CoreCameraObject::GetRadialBlur();
float CoreCameraObject::GetRadialBlurAngle();
float CoreCameraObject::GetRadialBlurScale();
float CoreCameraObject::GetRadialBlurCenterX();
float CoreCameraObject::GetRadialBlurCenterY();
bool CoreCameraObject::GetFSFX0();
bool CoreCameraObject::GetFSFX1();
bool CoreCameraObject::GetFSFX2();
bool CoreCameraObject::GetFSFX3();
bool CoreCameraObject::GetFSFX4();
bool CoreCameraObject::GetFSFX5();
bool CoreCameraObject::GetFSFX6();
bool CoreCameraObject::GetFSFX7();
bool CoreCameraObject::GetFSFX8();
bool CoreCameraObject::GetFSFX9();
void CoreCameraObject::SetView(float i_nearPlane, float i_farPlane, float i_fieldOfView);
void CoreCameraObject::SetFog(bool i_onOff, float i_red, float i_green, float i_blue, float i_alpha, float i_near, float i_far);
void CoreCameraObject::SetMotionBlur(bool i_on, float i_motionBlurAmount);
float CoreCameraObject::GetRoll();
void CoreCameraObject::SetRoll(float i_roll);
void CoreGraphicsDeviceNull::TexturedTriBatch(float*, CoreRGBA, uint32_t);
void CoreGraphicsDeviceNull::FilledBox2D(CoreVector&, CoreVector&, CoreRGBA);
void CoreGraphicsDeviceNull::UnfilledBox2D(CoreVector&, CoreVector&, CoreRGBA);
void CoreGraphicsDeviceNull::TriBatchScreen(float*, CoreRGBA, uint32_t);
void CoreGraphicsDeviceNull::RenderVertexBuffer(void*, CoreGraphicsDevice::CoreVertexFormat, bool);
void CoreGraphicsDeviceNull::Circle(CoreVector&, float, CoreRGBA);
void CoreGraphicsDeviceOpenGL::SetMultipleDrawModes(uint32_t bTexture, uint32_t bCulling, uint32_t bLighting);
void CoreGraphicsDevice::RegisterRenderTextureSet(CoreMemory*, uint32_t, CoreTextureSet*);
void CoreGraphicsDeviceNull::TriBatch(float*, CoreRGBA, uint32_t);
void CoreGraphicsDeviceNull::SetMultipleDrawModes(uint32_t, uint32_t, uint32_t);
void CoreGraphicsDeviceNull::Line2D(CoreVector&, CoreVector&, CoreRGBA);
void CoreGraphicsDeviceNull::TexturedTriBatchScreen(float*, CoreRGBA, uint32_t);
void CoreGraphicsDeviceNull::CircleScreen(CoreVector&, float, CoreRGBA);
void CoreGraphicsDeviceNull::LineScreen(CoreVector&, CoreVector&, CoreRGBA);
void CoreCameraObject::AdjustCameraAngle(float i_deltaAngle, float i_deltaPitch, float i_deltaRoll);
void CoreGraphicsDeviceNull::Line(CoreVector&, CoreVector&, CoreRGBA);
void CoreGraphicsDeviceOpenGL::RenderVertexBuffer(void* lpVertexBuffer, CoreGraphicsDevice::CoreVertexFormat eVertexFormat, bool bFullClip);
void CoreGraphicsDeviceNull::CylinderObjectMatrix(CoreMatrix&, CoreRGBA);
void CoreGraphicsDeviceNull::SphereObjectMatrix(CoreMatrix&, CoreRGBA);
void CoreGraphicsDeviceNull::SolidCuboidObjectMatrix(CoreMatrix&, CoreRGBA);
void TRRoomEffects::UpdateWaterfalls(TRRoomEffectsMesh* i_meshPointers, int32_t i_numMeshes);
void CAL1_AudioDriver::ShowSamplePlayCursorDiff(CAL1_Sample* sample1, CAL1_Sample* sample2);
void CoreCameraObject::DoDebug(CoreDebugInput* i_input, CoreObjectUpdateStruct* i_updateStruct);
void TRRoomEffects::UpdateWaterGourauds(TRRoomEffectsMesh* i_meshPointers, int32_t i_numMeshes);
void CoreGraphicsDeviceNull::WireFrameCuboidObjectMatrix(CoreMatrix&, CoreRGBA);
void CoreObjectController::OnDestroyObject(CoreObject*, CoreObjectUpdateStruct*);
void CoreGraphicsDeviceNull::ConeObjectMatrix(CoreMatrix&, CoreRGBA);
void CorePanel::RenderGlobals(CoreGameRender* io_graphics, CoreObjectUpdateStruct* io_updateStruct);
void CoreGraphicsDeviceNull::SetBlendFunction(CoreGraphicsDevice::CoreBlendModeEnum, float);
void CoreGraphicsDeviceOpenGL::DrawDynamicLightVolume(CoreGraphicsDevice::CoreLightVolumeShape shape, CoreMatrix& transform);
void CoreGraphicsDevice::UpdateRenderTextureSet(uint32_t, CoreTextureSet*);
void CoreMenuComponent::SetItemIconVisibility(int32_t i_itemIndex, bool i_visible);
void CoreLevel::ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreWorld::RememberLevelName(char* i_level, char* i_area);
void CoreGraphicsDeviceNull::DrawDynamicLightVolume(CoreGraphicsDevice::CoreLightVolumeShape, CoreMatrix&);
void CoreFX::RenderSingleParticle(CoreParticleFXPrimitive* pPrim, CoreGraphicsDevice* pDevice);
void CoreInputDevice::Rumble(int32_t i_pad, CoreRumbleEnvelope* i_rumbleEnvelope);
void CoreObject::ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreInputDeviceDirectInput::Rumble(int32_t, CoreRumbleEnvelope*);
void CoreInputDeviceNull::Construct(CoreMemory*, char*);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\corechasecamera.cpp
void* CoreChaseCamera::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreChaseCamera::RunFunction(CoreCommand* io_command);
CoreHash CoreChaseCamera::GetTypeID();
CoreObject* CoreChaseCamera::Create(CoreMemory* io_memory);
void CoreChaseCamera::CoreChaseCamera();
void CoreChaseCamera::Construct(CoreMemory* io_memory);
void CoreChaseCamera::OnSwitchedTo(CoreCameraObject* io_fromCam);
void CoreChaseCamera::AdjustCameraAngle(float i_deltaAngle, float i_deltaPitch, float i_deltaRoll);
void CoreGroupCamera::AdjustCameraDistance(float i_requiredDistance);
void CoreGameMessageBoxParameters::SetTextureSetHash(CoreHash i_textureSetHash);
void CoreChaseCamera::AdjustCameraDistance(float i_requiredDistance);
void CoreChaseCamera::UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
CoreScripted::CommandReturn CoreChaseCamera::DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
CoreVector CoreChaseCamera::GetTargetPosition(float i_time, CoreObjectUpdateStruct* updateStruct);
void CoreChaseCamera::UpdateDistance(float i_distance, float i_time);
float CoreChaseCamera::GetAutoMove(float i_centreDistance, float i_rightDistance, float i_leftDistance);
void CoreChaseCamera::UpdateAngleVelocity(float i_angleDelta, float i_time);
void CoreChaseCamera::ExpandRegion(CoreVector& i_target, float i_distance, float i_angle, float i_pitch, CoreVector& io_min, CoreVector& io_max);
void TRChaseCamera::ExpandRegion(CoreVector& i_target, float i_distance, float i_angle, float i_pitch, CoreVector& io_min, CoreVector& io_max);
float CoreChaseCamera::TestRay(CoreVector& i_target, float i_distance, float i_angle, float i_pitch);
float TRChaseCamera::TestRay(CoreVector& i_target, float i_distance, float i_angle, float i_pitch);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\corechasecamera.h
char* CoreRecentFileName::GetUserString();
void* CoreChaseCamera::GetMemoryStack();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\corecutscenecamera.cpp
CoreScripted::CommandReturn CoreCutSceneCamera::RunFunction(CoreCommand* io_command);
void CoreCutSceneCamera::CoreCutSceneCamera();
CoreHash CoreCutSceneCamera::GetTypeID();
CoreObject* CoreCutSceneCamera::Create(CoreMemory* io_memory);
void CoreCutSceneCamera::UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
CoreScripted::CommandReturn CoreCutSceneCamera::DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\corecutscenecamera.h
void* CoreCutSceneCamera::GetMemoryStack();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\coreflexiblecamera.cpp
void* CoreFlexibleCamera::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreFlexibleCamera::RunFunction(CoreCommand* io_command);
void CoreFlexibleCamera::CoreFlexibleCamera();
CoreHash CoreFlexibleCamera::GetTypeID();
CoreObject* CoreFlexibleCamera::Create(CoreMemory* io_memory);
void CoreFlexibleCamera::Construct(CoreMemory* io_memory);
void CoreFlexibleCamera::UpdateTriggerJustEntered();
void CoreFlexibleCamera::UpdateTriggerJustLeft();
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetInputTargetRail(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetLookAtRail(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetLookAtBoneName(CoreCommand* io_command);
void CoreFlexibleCamera::SetLookAtBoneNameHash(CoreHash i_boneHash);
CoreScripted::CommandReturn CoreFlexibleCamera::FnAddLookatObject(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetMaxUpdateDistance(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetInputTime(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetStateType(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetLookAtType(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetPositionRailCatchupCoefficient(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetLookAtCatchupCoefficient(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetPositionType(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetLookAtOffsetRelativeFlag(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetLookAtOffset(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetZoomShotOffset(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetZoomShotHeight(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetZoomType(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetRoll(CoreCommand* io_command);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetInputType(CoreCommand* io_command);
void CoreFlexibleCamera::CalculateInputValue();
void CoreFlexibleCamera::GetUnitPointOnRail(float& i_result, CoreVector& vPoint, CoreCurveSetData* i_rail);
void CoreFlexibleCamera::CalculatePosition();
void CoreFlexibleCamera::GetObjectListAveragePos(CoreVector& o_finalpos);
CoreVector CoreFlexibleCamera::GetLookAtBonePosition(CoreGeometryObject* i_object);
void CoreFlexibleCamera::CalculateLookAtPosition();
float ScaleToF(float MinNew, float MaxNew, float MinOrig, float MaxOrig, float val);
void CoreFlexibleCamera::CalculateZoom();
void CoreFlexibleCamera::SetRail(CoreHash i_name);
CoreScripted::CommandReturn CoreFlexibleCamera::FnSetRail(CoreCommand* i_command);
void CoreFlexibleCamera::UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
CoreScripted::CommandReturn CoreFlexibleCamera::DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
void CoreFlexibleCamera::RenderDebug();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\coreflexiblecamera.h
void* CoreFlexibleCamera::GetMemoryStack();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\coregroupcamera.cpp
CoreScripted::CommandReturn CoreGroupCamera::RunFunction(CoreCommand* io_command);
CoreHash CoreGroupCamera::GetTypeID();
CoreObject* CoreGroupCamera::Create(CoreMemory* io_memory);
void CoreGroupCamera::CoreGroupCamera();
void CoreGroupCamera::Construct(CoreMemory* io_memory);
void CoreGroupCamera::AdjustCameraAngle(float i_deltaAngle, float i_deltaPitch, float i_deltaRoll);
CoreScripted::CommandReturn CoreGroupCamera::DefaultCameraLogic(CoreCommand* i_command);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\coregroupcamera.h
void* CoreGroupCamera::GetMemoryStack();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\coregrouprailcamera.cpp
CoreScripted::CommandReturn CoreGroupRailCamera::RunFunction(CoreCommand* io_command);
CoreHash CoreGroupRailCamera::GetTypeID();
CoreObject* CoreGroupRailCamera::Create(CoreMemory* io_memory);
void CoreGroupRailCamera::CoreGroupRailCamera();
void CoreGroupRailCamera::Construct(CoreMemory* io_memory);
CoreScripted::CommandReturn CoreGroupRailCamera::DefaultCameraLogic(CoreCommand* i_command);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\coregrouprailcamera.h
void* CoreGroupRailCamera::GetMemoryStack();
void* TRFixedCamera::GetMemoryStack();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\corerailcamera.cpp
void* TRFixedCamera::GetVariablePointer(CoreHash i_variableName);
void* CoreGroupCamera::GetVariablePointer(CoreHash i_variableName);
void* CoreCutSceneCamera::GetVariablePointer(CoreHash i_variableName);
void* CoreRailCamera::GetVariablePointer(CoreHash i_variableName);
void* CoreGroupRailCamera::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreRailCamera::RunFunction(CoreCommand* io_command);
void CoreRailCamera::CoreRailCamera();
CoreHash CoreRailCamera::GetTypeID();
CoreObject* CoreRailCamera::Create(CoreMemory* io_memory);
void CoreRailCamera::Construct(CoreMemory* io_memory);
void CoreRailCamera::SetRail(CoreHash i_name);
CoreScripted::CommandReturn CoreRailCamera::FnSetRail(CoreCommand* i_command);
CoreScripted::CommandReturn CoreRailCamera::DefaultCameraLogic(CoreCommand* i_command);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\corerailcamera.h
void* CoreRailCamera::GetMemoryStack();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\coreviewerobject.cpp
void* CoreViewerObject::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreViewerObject::RunFunction(CoreCommand* io_command);
CoreObject* CoreViewerObject::Create(CoreMemory* io_memory);
void CoreViewerObject::CoreViewerObject();
void CoreCutSceneCamera::Construct(CoreMemory* io_memory);
void CoreViewerObject::Construct(CoreMemory* io_memory);
void CoreViewerObject::Init(CoreHash i_nameHash, CoreHash i_scriptHash, CoreObjectUpdateStruct* io_updateStruct);
int32_t CoreViewerObject::GetDebugMode();
void CoreViewerObject::SetNameString(CoreStringBuffer<256> i_str);
void CoreViewerObject::SetRelatedObject(CoreObject* i_obj);
CoreObject* CoreViewerObject::GetRelatedObject();
void CoreViewerObject::SetRelatedObjectHash(CoreHash i_hash);
CoreHash CoreViewerObject::GetRelatedObjectHash();
bool CoreViewerObject::GetLookAtCatchupMode();
CoreScripted::CommandReturn CoreViewerObject::FnCreateCamera(CoreCommand* i_command);
CoreScripted::CommandReturn CoreViewerObject::FnSetCurrentCamera(CoreCommand* i_command);
CoreScripted::CommandReturn CoreViewerObject::FnPopCamera(CoreCommand* i_command);
CoreScripted::CommandReturn CoreViewerObject::FnSetDefaultCamera(CoreCommand* i_command);
CoreScripted::CommandReturn CoreViewerObject::FnAttachCamera(CoreCommand* i_command);
CoreScripted::CommandReturn CoreViewerObject::FnSetNearestCameraMode(CoreCommand* i_command);
CoreScripted::CommandReturn CoreViewerObject::FnSetCameraDirectMode(CoreCommand* i_command);
CoreScripted::CommandReturn CoreViewerObject::FnSetCameraDirectUseLookAtMode(CoreCommand* i_command);
CoreScripted::CommandReturn CoreViewerObject::FnTakeViewValuesFromCamera(CoreCommand* i_command);
CoreCameraObject* CoreViewerObject::GetCurrentCamera();
void CoreViewerObject::SetCameraDirectFlag(bool i_var);
void CoreViewerObject::SetBlendingFlag(bool i_var);
void CoreViewerObject::SetCameraDirectUseLookAtFlag(bool i_var);
void CoreViewerObject::TakeValuesFromCamera(CoreCameraObject* i_cam);
void CoreViewerObject::AttachCamera(CoreCameraObject* i_camera);
void CoreViewerObject::SetDefaultCamera(CoreCameraObject* i_camera);
void CoreViewerObject::SelectNearestCamera();
float RampValue(float from, float to, float maxAcc);
void CoreViewerObject::DebugUpdate(CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreViewerObject::Control(CoreObjectUpdateStruct* i_updateStruct);
void CoreViewerObject::UpdateBlendCamera();
void CoreViewerObject::BlendPos();
void CoreViewerObject::BlendLookAtPos();
void CoreViewerObject::BlendView();
void CoreViewerObject::SetCurrentCamera(CoreCameraObject* i_camera);
void CoreViewerObject::SetCurrentCameraByName(CoreHash i_cameraname);
void CoreViewerObject::PopCamera();
void CoreViewerObject::ApplyCameraEffect();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecameraobject\coreviewerobject.h
void* CoreViewerObject::GetMemoryStack();
CoreHash CoreViewerObject::GetTypeID();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreconsole\coreconsole.cpp
void CoreConsole::Construct(CoreMemory* lpoMemory);
CoreConsole* CoreConsole::GetInstance();
void CoreConsole::Destruct(CoreMemory* lpoMemory);
void CoreConsole::Init();
void CoreConsole::Clear();
void CoreConsole::Update(CoreWorldUpdateStruct* lpoUpdateStruct);
bool CoreConsole::IsActive();
void CoreConsole::ConPrint(char* lpcText);
void CoreConsole::Render(CoreGameRender* lpoGraphics);
void CoreConsole::AddToRenderList(CoreGameRender* lpoGraphics);
bool CoreConsole::bAddCharacter(char cChar);
bool CoreConsole::bParse(char* lpcCommand);
bool CoreConsole::bRunCommand(char* lpcCommandName, char** lplpcParams);
void CoreConsole::RegisterCommand(char* lpcName, char* lpcShortName, char* lpcDesc, void* Function);
void CoreConsole::ConHelp(CoreConsole* lpoCon, char**);
void CoreConsole::ConVersion(CoreConsole* lpoCon, char**);
void CoreConsole::ConClear(CoreConsole* lpoCon, char**);
void CoreConsole::ConSetColour(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConSetTimeScale(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConQuit(CoreConsole* lpoCon, char**);
void CoreConsole::ConListObjects(CoreConsole* lpoCon, char**);
void CoreConsole::ConListObjectVars(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConSetVar(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConHash(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConResetGame(CoreConsole* lpoCon, char**);
void CoreConsole::ConResetWorld(CoreConsole* lpoCon, char**);
void CoreConsole::ConResetLevel(CoreConsole* lpoCon, char**);
void CoreConsole::ConLoadLevel(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConDebug(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConMemory(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConSingleStep(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConSoakTest(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConGraphics(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConTestMessage(CoreConsole* Con, char** Params);
void CoreConsole::ConSimulatePSP(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConProfile(CoreConsole* Con, char** Params);
void CoreConsole::ConLanguage(CoreConsole* i_con, char** i_params);
void CoreConsole::PrintChar(char cChar);
void CoreConsole::NewLine();
CoreScripted* CoreConsole::GetObjectA(char* lpcString);
void CoreConsole::ConPositionSave(CoreConsole* lpoCon, char** lplpcParams);
void CoreConsole::ConPositionLoad(CoreConsole* lpoCon, char** lplpcParams);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecutsceneplayer\corecutsceneobject.cpp
void CoreCutSceneObject::Construct(CoreMemory* lpoMemory);
void CoreCutSceneObject::Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
CoreObject* CoreCutSceneObject::Create(CoreMemory* lpoMemory);
bool CoreCutSceneObject::IsReady();
void CoreCutSceneObject::SetPosOrientAndScaleFromKeys(CoreObjectUpdateStruct* lpoUpdateStruct, float fTime);
void* CoreCutSceneObject::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreCutSceneObject::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreCutSceneObject::eFnAnimate(CoreCommand* lpoCommand);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecutsceneplayer\corecutsceneobject.h
void CoreCutSceneObject::CoreCutSceneObject();
CoreHash CoreCutSceneObject::GetTypeID();
int32_t CoreCutSceneObject::GetMemoryStackSize();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecutsceneplayer\corecutsceneplayer.cpp
void CoreCutScenePlayer::Construct(CoreMemory* lpoMemory);
void CoreCutScenePlayer::Destruct(CoreMemory* lpoMemory);
void CoreCutScenePlayer::Init();
void CoreCutScenePlayer::Reset();
void CoreCutScenePlayer::Update(CoreObjectUpdateStruct* i_updateStruct);
void CoreCutScenePlayer::SetCamera(CoreObjectUpdateStruct* i_updateStruct);
void CoreCutScenePlayer::PlayCutScene(CoreObjectUpdateStruct* i_updateStruct, CoreHash oCutScene, CoreHash cutSceneParent);
void CoreCutScenePlayer::EndCutScene(CoreObjectUpdateStruct* i_updateStruct);
bool CoreCutScenePlayer::IsRequestedPlay();
CoreHash CoreCutScenePlayer::GetCutScenePlaying();
bool CoreCutScenePlayer::IsCutScenePlaying();
float CoreCutScenePlayer::GetTime();
void CoreCutScenePlayer::DoDebug(CoreDebugInput* i_input);
CoreStringBuffer<256> CoreCutScenePlayer::GetOverrideModelName();
CoreStringBuffer<256> CoreCutScenePlayer::GetOverrideTextureName();
void* CoreCutScenePlayer::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreCutScenePlayer::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnStartTimer(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnWaitForFadeDown(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnWaitForTime(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnSetCamera(CoreCommand* i_command);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnInstanceObject(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnCopyObjectPos(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnSetObjectPos(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnSetSound(CoreCommand* io_command);
void CoreCutScenePlayer::SetSound(CoreHash iSoundHash);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnEnd(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnPlaySound2D(CoreCommand* io_command);
CoreScripted::CommandReturn CoreCutScenePlayer::eFnStopSound(CoreCommand* io_command);
float CoreCutScenePlayer::AnimTimeAdjust(float time);
float CoreCutScenePlayer::GetSpeedFactor();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corecutsceneplayer\corecutsceneplayer.h
void CoreCutScenePlayer::~CoreCutScenePlayer();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coredetect\coredetect.cpp
void CoreDetectCache::Reset();
void CoreDetect::Construct(CoreMemory* lpoMemory, CoreWorld* lpoWorld, int32_t i_numCaches);
void CoreDetect::Destruct(CoreMemory* lpoMemory);
void CoreDetect::AddCollisionEvent(CoreDetectHit eWhatHit, uint32_t i_subType1, uint32_t i_subType2, CoreGeometryObject* i_objectPtr);
CoreDetectResult* CoreDetect::Detect(CoreVector& vOldPos, CoreVector& vNewPos, CoreGeometryObject* lpoObject, uint32_t i_flags);
CoreDetectResult* CoreDetect::SingleSphereDetect(CoreVector& vOldPos, CoreVector& vNewPos, CoreVector i_singleSpherePos, float i_singleSphereRadius, uint32_t i_flags);
void CoreDetect::ResetCaches();
void CoreDetect::SetCacheLocked(int32_t i_cache, bool i_value);
void CoreDetect::SetFloorHeightCacheRadius(float i_value);
bool CoreDetect::FillDetectPolyList(CoreVector i_oldPos, CoreVector i_newPos, CoreGeometryObject* i_myObject, uint32_t i_flags);
bool CoreDetect::SetupDetect(CoreVector& vPosA, CoreVector& vPosB, CoreVector i_singleSphereLocalPos, float i_singleSphereRadius);
bool CoreDetect::ChooseDetectionCache(CoreVector& i_posA, CoreVector& i_posB, float i_radius, bool i_wantFloorCache);
bool CoreDetect::GetDetectionPolys(CoreVector& i_posA, CoreVector& i_posB, float i_radius);
bool CoreDetect::GetDetectionPolysIntoCurrentCache(CoreVector& i_posA, CoreVector& i_posB, float i_radius);
bool CoreDetect::InternalSetupDetect(CoreVector& vPosA, CoreVector& vPosB);
void CoreDetect::DetectPolysAndObjects();
void CoreDetect::SphereDetectAllCollidables();
void CoreDetect::HitTransformedCollidableSausage(CoreTransformedCollidable* lpoTransformedCollidable, float fIntersectDistance, CoreVector& vClosestPoint);
void CoreDetect::HitTransformedCollidableSphere(CoreTransformedCollidable* lpoTransformedCollidable, float fIntersectDistance);
bool CoreDetect::SphereDetectMesh(uint32_t currentCycle);
void CoreDetect::HitFloor(CoreDetectPoly* lpoPoly);
void CoreDetect::HitWall(CoreDetectPoly* lpoPoly);
void CoreDetect::HitCeiling(CoreDetectPoly* lpoPoly);
bool CoreDetect::bSphereToPolyDetection(CoreDetectPoly* i_poly);
void CoreDetect::TransformAllCollidables(bool bIgnoreYCullingLevelCollidables, bool bIgnoreYCullingObjectCollidables);
bool CoreDetect::AddObjectDetectionMesh(CoreDetectionMesh* i_detectionMesh, CoreAnimatingObject* i_parentObject, bool i_ignoreYCulling);
bool CoreDetect::bTransformSingleCollidable(CoreSingleCollidable* lpoCollidable, CoreAnimatingObject* lpoParentObject, CoreDetectHit eHitResult, bool bIgnoreYCulling);
void CoreDetect::AddBoxToDetectPolyList(CoreVector* vTransformedBox, CoreGeometryObject* lpoParent, CoreDetectPolyType ePolyType_SpecialAttributes);
void CoreDetect::AddRectangleToDetectPolyList(CoreVector& vVert0, CoreVector& vVert1, CoreVector& vVert2, CoreVector& vVert3, CoreGeometryObject* lpoParent, CoreDetectPolyType ePolyType_SpecialAttributes);
void CoreDetect::GenerateTransformedBox(CoreVector* vTransformedBox, CoreVector* vTransformedBoxBounds, CoreEulerAngle& eaBoxRotation, CoreMatrix& mBone);
void CoreDetect::GenerateSortedPolyList();
void CoreDetect::AddPolyToList(CoreDetectPoly* lpoPoly, int32_t iWhichList);
bool CoreDetect::bLineOfSight(CoreVector& vFrom, CoreVector& vTo, CoreVector& vIntersection, CorePlaneEquation& peIntersectPlane, int32_t accurate);
uint32_t CoreDetect::GetCeilingHeight(CoreVector& i_startPos, float& o_ceilingAbove, CoreDetectPoly*& o_ceilingAbovePoly);
uint32_t CoreDetect::GetFloorHeight(CoreVector& i_startPos, float& o_floorHeightBelow, float& o_floorHeightAbove, CoreDetectPoly*& o_floorBelowPoly, CoreDetectPoly*& o_floorAbovePoly);
bool CoreDetect::GetFloorHeightsInternal(CoreVector& i_startPos, uint32_t i_maxNumFloors, float& o_bestHeightBelow, float& o_bestHeightAbove, float& o_lowestCeilingAbove, CoreFloorHeightInfo* o_floors, uint32_t& o_numFloorsFound, CoreDetectPoly*& o_floorBelowPoly, CoreDetectPoly*& o_floorAbovePoly, CoreDetectPoly*& o_ceilingAbovePoly);
void CoreDetect::Update();
void CoreDetect::DoDebug(CoreDebugInput* i_input);
void CoreDetect::DebugDrawPoly(uint32_t i_debugFlags, CoreDetectPoly* i_poly);
void CoreDetect::DebugDrawCollidable(uint32_t i_debugFlags, CoreTransformedCollidable* i_collidable);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corefont\corefont.cpp
bool CoreFont::CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
CoreHash CoreFont::GetTextureSetName();
CoreHash* CoreFont::GetTextureIDs();
void CoreFont::SetButtonTextures(CoreHash i_textureSetHash, CoreHash i_triangleButtonHash, CoreHash i_circleButtonHash, CoreHash i_crossButtonHash, CoreHash i_squareButtonHash, CoreHash i_leftShoulderButtonHash, CoreHash i_rightShoulderButtonHash);
bool CoreFont::OverrideChar(uint32_t i_unicode, CoreRGBA& io_colour);
float CoreFont::DrawChar(CoreGameRender* io_graphics, uint32_t i_unicode, CoreVector& i_pos, float i_xOffset, CoreTextureSet* i_texSet, CoreHash* i_textureHashes, float i_scaleX, float i_scaleY, CoreRGBA i_col, int32_t i_flags);
void CoreFont::DrawStringID(CoreGameRender* io_graphics, CoreVector& i_pos, CoreHash i_stringID, float i_scaleX, float i_scaleY, CoreRGBA i_col, int32_t i_flags);
void CoreFont::DrawString(CoreGameRender* io_graphics, CoreVector& i_pos, char* i_string, float i_scaleX, float i_scaleY, CoreRGBA i_col, int32_t i_flags);
bool CoreFont::RenderStart(CoreTextureSet*& o_texSet, CoreHash*& o_textureHashes);
void CoreFont::ResetCache();
CoreVector CoreFont::GetStringIDSize(CoreHash i_stringID, float i_scaleX, float i_scaleY);
CoreVector CoreFont::GetStringSize(char* i_string, float i_scaleX, float i_scaleY);
CoreFontGlyph* CoreFont::FindGlyph(uint32_t i_char);
bool CoreFont::IsCharacterInFont(uint32_t i_unicode);
float CoreRenderTextSettings::GetJustifyMultiplierX();
float CoreRenderTextSettings::GetJustifyMultiplierY();
void cRT_LineWH::AddToLineW(float i_charW, float i_charH, float i_extraX);
void cRT_StringWH::cRT_StringWH(char* i_string);
void cRT_StringWH::StartGetWH(int32_t i_stringIndex, float i_fixedH, float i_extraX, float i_extraY, float i_wordWrapWidth);
void cRT_StringWH::AddLine(int32_t i_stringIndex);
void cRT_StringWH::AddToLineW(int32_t& io_stringIndex, float i_charW, float i_charH, bool i_isSpace);
void CoreRenderText::__GetStringWH(cRT_StringWH& io_stringWH);
void CoreRenderText::__Render(cRT_StringWH& io_stringWH, float i_x, float i_y, CoreRGBA& i_rgba);
void CoreRenderText::Construct(CoreFont* i_font);
void CoreRenderText::CoreRenderText(CoreGameRender* io_graphics, CoreFont* i_font, char* i_textString, int32_t i_flags);
void CoreRenderText::Render(float i_x, float i_y, float* o_width, float* o_height);
void CoreRenderText::GetWidthAndHeight(float* o_width, float* o_height);
bool CoreRenderText::ScaleToArea(float i_areaW, float i_areaH, float i_scaleX, float i_scaleY, float i_startMultiplier, float i_endMultiplier, int32_t i_multiplierSteps);
float CoreRenderText::iGetFixedWidthAndHeight(float* o_width, float* o_height, float i_scaleX, float i_scaleY);
float CoreRenderText::iRender(CoreTextureSet* i_texSet, CoreHash* i_textureHashes, CoreRGBA& i_rgba, float i_x, float i_y, int32_t i_char, float i_scaleX, float i_scaleY);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coregamecontroller\coregamecontroller.cpp
void CoreGameController::GameInit(int32_t iNumParams, char** lplpcParams, int32_t MemSize, uint32_t* lpucMemory, CoreHash i_graphicsType, CoreHash i_inputType, CoreHash i_audioType, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize, CoreHash i_networkType, CoreNet::DeviceInitialisationData* io_CoreNetInit);
void CoreGameController::GameMain(void*);
void CoreGameController::SetGameController(CoreGameController* io_gameController);
void CoreGameController::OneCycle();
void CoreGameController::Construct(int32_t iNumParams, char** lplpcParams, CoreHash i_graphicsType, CoreHash i_inputType, CoreHash i_audioType, CoreHash i_networkType, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize);
void CoreGameController::Destruct();
void CoreGameController::Init(CoreNet::DeviceInitialisationData* io_CoreNetInit);
void CoreGameController::GetGlobalLinkedScripts();
void CoreGameController::GetGlobalTextFileName(CoreStringBuffer<256>& o_fileName);
void CoreGameController::LoadGlobalTextFile();
void CoreGameController::GetGlobalTextFile();
void CoreGameController::Reset();
void CoreGameController::OutputTGAs(bool i_onOff);
void CoreGameController::Render();
CoreGameController* CoreGameController::GetInstance();
CoreMemory* CoreGameController::GetStaticMemory();
CoreMemory* CoreGameController::GetDynamicMemory();
CoreMemory* CoreLevel::GetMemory();
CoreVariableStore* CoreGameController::GetVariableStore();
CoreScriptStore* CoreGameController::GetScriptStore();
CoreWorld* CoreGameController::GetWorld();
CoreGameRender* CoreGameController::GetGraphics();
CoreObjectController* CoreLevel::GetObjectController();
CoreInput* CoreGameController::GetInput();
CoreNet* CoreGameController::GetNet();
CoreWorldUpdateStruct* CoreGameController::GetUpdateStruct();
void CoreGameController::SetQuit(bool bQuit);
void CoreGameController::Update();
void CoreGameController::UpdateInput(float i_deltaTime);
void CoreGameController::DoDebugCallback(CoreDebugInput* lpoDebugInput, CoreWorldUpdateStruct* lpoWorldUpdateStruct, int32_t iLevel, void* lpUserData);
void CoreGameController::DoDebug(CoreDebugInput* i_debugInput);
void CoreGameController::DumpVariableStore();
void CoreGameController::DoLogicDebug(CoreDebugInput* i_debugInput);
void CoreGameController::DoInputDebug(CoreDebugInput* i_debugInput);
void CoreGameController::DoAudioLocDebug(CoreDebugInput* i_debugInput);
void CoreGameController::DoMemoryDebug(CoreDebugInput* i_debugInput);
CoreConsole* CoreGameController::CreateConsole(CoreMemory* io_memory);
void CoreGameController::ToggleSingleStep();
bool CoreGameController::IsSingleStepActive();
void* CoreGameController::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreGameController::RunFunction(CoreCommand* io_command);
void CoreGameController::EnterAssetManagerPanicMode();
void CoreGameController::ExitAssetManagerPanicMode();
void CoreGameController::AssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType, void* lpUsrData1, void* lpUsrData2);
void CoreGameController::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType);
void CoreGameController::SetLanguage(CoreInit::CoreLanguageEnum i_language);
bool CoreGameController::SetLanguageByHash(CoreHash i_language);
float CoreGameController::GetDeltaFrameTime();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coregamedialogs\coregamedialogs.cpp
float CoreFader::Update();
void CoreGameDialogs::Render(CoreGameRender* io_graphics, int32_t i_renderFlags);
bool CoreGameDialogs::RenderFlat(CoreGameRender* io_graphics, float i_x1, float i_y1, float i_x2, float i_y2, CoreRGBA i_rgba, float i_alphaScaler, int32_t i_renderFlags);
bool CoreGameDialogs::RenderFlatWholeScreen(CoreGameRender* io_graphics, CoreRGBA i_rgba, float i_alphaScaler, int32_t i_renderFlags);
bool CoreGameDialogs::RenderTexture(CoreGameRender* io_graphics, CoreTextureSet* i_textureSet, CoreHash i_textureHash, float i_x1, float i_y1, float i_x2, float i_y2, CoreRGBA i_rgba, float i_alphaScaler, int32_t i_renderFlags);
bool CoreGameDialogs::RenderTextureOrFlat(CoreGameRender* io_graphics, CoreTextureSet* i_textureSet, CoreHash i_textureHash, float i_x1, float i_y1, float i_x2, float i_y2, CoreRGBA i_rgba, float i_alphaScaler, int32_t i_renderFlags);
void CoreGameButtonText::CoreGameButtonText(char* i_text);
char* CoreGameButtonText::Get();
void CoreGameFrame::CoreGameFrame();
bool CoreGameFrame::SetTexture(CoreGameFrame::TEXTURE_INDEX_TAG i_index, CoreHash i_textureID);
void CoreGameFrame::Render(CoreGameRender* io_graphics, CoreTextureSet* i_textureSet, float i_x1, float i_y1, float i_x2, float i_y2, float i_alphaScaler, int32_t i_renderFlags);
void CoreGameMessageBoxParameters::SetDefaults();
void CoreGameMessageBoxParameters::CoreGameMessageBoxParameters();
CoreGameMessageBoxParameters* CoreGameMessageBoxParameters::GetDefaults();
void CoreGameMessageBoxParameters::SetDefaultsFromThis();
void CoreGameMessageBoxParameters::SetThisFromDefaults();
CoreFont* CoreGameMessageBoxParameters::GetFont();
CoreTextureSet* CoreGameMessageBoxParameters::GetTextureSet();
int32_t CoreGameMessageBoxButtons::Prepare(CoreMessageBoxInterface::CoreMessageBoxTypeTag i_type, int32_t i_selectedButtonIndex);
bool CoreGameMessageBoxButtons::Add(CoreGameButtonText* i_buttonText);
bool CoreGameMessageBoxButtons::GetWidthsAndHeights(CoreGameMessageBoxParameters* i_messageBoxParameters, CoreFont* i_font, float& o_width, float& o_height, float& o_totalWidth, float& o_nextOffsetX, int32_t i_renderFlags);
void CoreGameMessageBoxButtons::Render(CoreGameMessageBoxParameters* i_messageBoxParameters, CoreGameRender* io_graphics, CoreFont* i_font, float i_startX, float i_y, float i_buttonWidth, float i_buttonHeight, float i_nextOffsetX, bool i_shouldFlash, float i_alphaScaler, int32_t i_renderFlags);
bool CoreGameMessageBoxButtons::UpdateInput(CoreGameMessageBoxParameters* i_messageBoxParameters, CoreHash& o_soundHash, int32_t i_controllerInputIndex);
bool CoreGameMessageBox::Start(void* i_finishedCallBack, void* i_callBackUserData, char* i_fmtString);
bool CoreGameMessageBox::Update();
bool CoreGameMessageBox::Stop();
bool CoreGameMessageBox::IsReady();
char* CoreGameMessageBox::GetCommonDialogTitle();
void CoreGameMessageBox::Finished();
void CoreGameMessageBox::Render(CoreGameRender* io_graphics, int32_t i_renderFlags);
void CoreGameOnScreenKeyboardCharacterTable::Reset(bool i_isEmpty);
void CoreGameOnScreenKeyboardCharacterTable::SetLanguageSpecificCharacters();
int32_t CoreGameOnScreenKeyboardCharacterTable::GetCurrentIndex();
int32_t CoreGameOnScreenKeyboardCharacterTable::CountNonSpacers(int32_t i_y);
int32_t CoreGameOnScreenKeyboardCharacterTable::GetUsedLinesCount();
void CoreGameOnScreenKeyboardCharacterTable::MoveLeft();
void CoreGameOnScreenKeyboardCharacterTable::MoveRight();
void CoreGameOnScreenKeyboardCharacterTable::MoveUp();
void CoreGameOnScreenKeyboardCharacterTable::MoveDown();
bool CoreGameOnScreenKeyboardCharacterTable::FindAction(int32_t i_action, int32_t& o_x, int32_t& o_y);
void CoreGameOnScreenKeyboardCharacterTable::Render(CoreGameRender* io_graphics, CoreFont* i_font, CoreGameOnScreenKeyboardParameters* i_oskParameters, float i_centreX, float i_centreY, float i_scaleX, float i_scaleY, float i_totalWidth, float i_totalHeight, float i_alphaScaler, int32_t i_renderFlags);
void CoreGameOnScreenKeyboardParameters::SetDefaults();
void CoreGameOnScreenKeyboardParameters::CoreGameOnScreenKeyboardParameters();
CoreGameOnScreenKeyboardParameters* CoreGameOnScreenKeyboardParameters::GetDefaults();
void CoreGameOnScreenKeyboardParameters::SetDefaultsFromThis();
void CoreGameOnScreenKeyboardParameters::SetThisFromDefaults();
CoreFont* CoreGameOnScreenKeyboardParameters::GetFont();
CoreTextureSet* CoreGameOnScreenKeyboardParameters::GetTextureSet();
void CoreOnScreenKeyboardInputFieldInfo::CoreOnScreenKeyboardInputFieldInfo();
void CoreOnScreenKeyboardInputFieldInfo::Prepare(char* i_title, char* i_string, int32_t i_maximumLength, int32_t i_inputLines);
void CoreOnScreenKeyboardInputFieldInfo::Start(int32_t i_index, CoreFont* i_font, uint32_t i_changeMissingCharsTo);
int32_t CoreOnScreenKeyboardInputFieldInfo::DoAction();
void CoreOnScreenKeyboardInputFieldInfo::DoCallBack(bool i_hasFailed, bool i_canceled, void* i_finishedCallBack, void* i_callBackUserData, bool i_lastCallBack);
void CoreGameOnScreenKeyboard::CoreGameOnScreenKeyboard();
void CoreGameOnScreenKeyboard::~CoreGameOnScreenKeyboard();
CoreOnScreenKeyboardInputFieldInfo* CoreGameOnScreenKeyboard::GetInputFieldInfo(int32_t i_inputIndex);
bool CoreGameOnScreenKeyboard::Prepare(char* i_title, char* i_string, int32_t i_maximumLength, int32_t i_inputLines, int32_t i_inputIndex);
bool CoreGameOnScreenKeyboard::Start(void* i_finishedCallBack, void* i_callBackUserData);
bool CoreGameOnScreenKeyboard::Update();
bool CoreGameOnScreenKeyboard::Stop();
void CoreGameOnScreenKeyboard::Finished();
int32_t CoreGameOnScreenKeyboard::GetNextInputIndex(int32_t i_inputIndex);
int32_t CoreGameOnScreenKeyboard::GetPreviousInputIndex(int32_t i_inputIndex);
void CoreGameOnScreenKeyboard::Render(CoreGameRender* io_graphics, int32_t i_renderFlags);
char* CoreGameOnScreenKeyboard::GetCommonDialogTitle();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coregamedialogs\coregamedialogs.h
void CoreGameFrame::SetCornerTextures(CoreHash i_topLeft, CoreHash i_topRight, CoreHash i_bottomRight, CoreHash i_bottomLeft);
void CoreGameFrame::SetEdgeTextures(CoreHash i_top, CoreHash i_right, CoreHash i_bottom, CoreHash i_left);
void CoreGameFrame::SetBackGroundTextures(CoreHash i_backGround, CoreHash i_backGround2, CoreHash i_backGround3);
void CoreGameMessageBoxParameters::SetButtonTextureID(CoreHash i_textureID);
CoreHash CoreGameMessageBoxParameters::GetButtonTextureID();
void CoreGameMessageBoxParameters::SetFontHash(CoreHash i_fontHash);
void CoreGameOnScreenKeyboardParameters::SetFontHash(CoreHash i_fontHash);
void CoreGameMessageBoxParameters::SetStartSoundHash(CoreHash i_soundHash);
CoreHash CoreGameMessageBoxParameters::GetStartSoundHash();
void CoreGameOnScreenKeyboardParameters::SetTextureSetHash(CoreHash i_textureSetHash);
void CoreGameMessageBoxParameters::SetSelectSoundHash(CoreHash i_soundHash);
CoreHash CoreGameMessageBoxParameters::GetSelectSoundHash();
void CoreGameMessageBoxParameters::SetLeftSoundHash(CoreHash i_soundHash);
CoreHash CoreGameMessageBoxParameters::GetLeftSoundHash();
void CoreGameMessageBoxParameters::SetRightSoundHash(CoreHash i_soundHash);
CoreHash CoreGameMessageBoxParameters::GetRightSoundHash();
CoreHash CoreGameOnScreenKeyboardParameters::GetStartSoundHash();
void CoreGameOnScreenKeyboardParameters::SetSelectSoundHash(CoreHash i_soundHash);
CoreHash CoreGameOnScreenKeyboardParameters::GetSelectSoundHash();
void CoreGameOnScreenKeyboardParameters::SetCancelSoundHash(CoreHash i_soundHash);
CoreHash CoreGameOnScreenKeyboardParameters::GetCancelSoundHash();
CoreHash CoreGameOnScreenKeyboardParameters::GetMoveSoundHash();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coregamerender\coregamerender.cpp
void CoreGameRender::Construct(CoreMemory* i_memory);
void CoreGameRender::Destruct(CoreMemory* lpoMemory);
void CoreGameRender::Init(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreGameRender::Reset(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreGameRender::ResetLevelOnly(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
int32_t CoreGameRender::GetVersion();
void CoreNet::Update(CoreWorldUpdateStruct* io_WorldUpdateStruct);
void CoreGameRender::Update(CoreWorldUpdateStruct* lpoUpdateStruct);
void CoreCameraObject::Update(CoreObjectUpdateStruct* i_updateStruct);
void CoreGameRender::StartRenderList();
void CoreGameRender::EndRenderList();
void CoreGameRender::SwapBuffers();
bool CoreGameRender::bAddLevelToRenderList(CoreLevel* lpoLevel);
bool CoreGameRender::bAddWorldToRenderList(CoreWorld* lpoWorld);
bool CoreGameRender::bAddConsoleToRenderList(CoreConsole* lpoConsole);
bool CoreGameRender::bAddPanelObjectToRenderList(CoreRenderableObject* lpoObject);
bool CoreGameRender::bAddObjectToRenderList(CoreRenderableObject* lpoObject);
bool CoreGameRender::bAddBeforeLevelObjectToRenderList(CoreRenderableObject* lpoObject);
bool CoreGameRender::bAddLastObjectToRenderList(CoreRenderableObject* lpoObject);
void CoreGameRender::DoDebug(CoreDebugInput* i_input);
void CoreGameRender::DrawFgScreenQuadBounds(CoreVector& vTopLeft, CoreVector& vBottomRight, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV& oUV0, CoreUV& oUV1, CoreRGBA oColour, int32_t iFlags);
void CoreGameRender::DrawFgScreenQuadPoints(CoreVector* lpvPoints, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV* lpoUVs, CoreRGBA oColour, int32_t iFlags);
void CoreGameRender::DrawFgTransformedScreenQuadBounds(CoreVector& vTopLeft, CoreVector& vBottomRight, float fRotate, float fScale, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV& oUV0, CoreUV& oUV1, CoreRGBA oColour, int32_t iFlags);
void CoreGameRender::DrawFgTransformedScreenQuadCentreSize(CoreVector& vCentre, float fWidth, float fHeight, float fRotate, float fScale, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV& oUVCentre, float fUVWidth, float fUVHeight, CoreRGBA oColour, int32_t iFlags);
void CoreGameRender::DrawUntexturedFgScreenQuadBounds(CoreVector& vTopLeft, CoreVector& vBottomRight, CoreRGBA oColour, int32_t iFlags);
CoreVector CoreGameRender::vRotate2D(CoreVector& vVector, float fAngle);
void CoreGameRender::SetQuadStoreScale(CoreVector i_scale);
void CoreGameRender::SetQuadBlendModes(int32_t iFlags);
void CoreGameRender::RenderSingleTriBatch(TriBatchStore* i_triStore, float* i_triStoreData, CoreGraphicsDevice* i_device);
void CoreGameRender::StoreQuad(CoreVector* lpvPoints, float fRotate, float fScale, CoreTextureSet* i_texSet, CoreHash i_textureHash, CoreUV* lpoInputUVs, CoreRGBA oColour, int32_t iFlags);
void CoreGameRender::AddTriBatch(int32_t i_startIndex, int32_t i_triangleCount, uint32_t i_flags, CoreRGBA i_colour, CoreTextureSet* i_textureSet, CoreHash i_textureHash);
void CoreGameRender::RenderTriBatches();
void CoreGameRender::SelectLights(CoreVector& vWorldPos, CoreGraphicsDeviceLightData* lpoLightData);
bool CoreGameRender::IsBBoxInView(CoreVector i_min, CoreVector i_max);
void* CoreGameRender::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreGameRender::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreGameRender::eFnGraphicsUpdate(CoreCommand* lpoCommand);
CoreViewerObject* CoreGameRender::SelectViewer(CoreWorldUpdateStruct* i_updateStruct, uint32_t i_numViewers, uint32_t i_view);
void CoreGameRender::EnableSplitScreen(bool i_enable);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coregamerender\coregamerender.h
void CoreGameRenderInternalData::CoreGameRenderInternalData();
void CoreGameRender::CoreGameRender();
void CoreGameRender::~CoreGameRender();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corekernel\corekernel.cpp
void CoreKernel::SetGameDirName(char* i_gameDirName);
void CoreKernel::UseStdFileSystem();
void CoreKernel::UseClusterFileSystem();
bool CoreKernel::OpenCluster(char* lpcClusterName);
bool CoreKernel::CloseCluster(char* lpcClusterName);
bool CoreKernel::OpenGlobalCluster();
bool CoreKernel::OpenRegionCluster();
void CoreKernel::SetCurrentLevelCluster(char* i_levelClusterName);
bool CoreKernel::OpenCurrentLevelCluster();
bool CoreKernel::CloseCurrentLevelCluster();
void CoreKernel::SetSecondLevelCluster(char* i_levelClusterName);
bool CoreKernel::OpenSecondLevelCluster();
bool CoreKernel::CloseSecondLevelCluster();
void CoreKernel::InitTimers();
void CoreKernel::SetTimer(int32_t iIndex, int32_t iIntervalInTimerCycles, int32_t iMaxCyclesToRun, void* Function, void* lpData);
void CoreKernel::UpdateTimer(int32_t i_index, int32_t i_intervalInTimerCycles);
int32_t CoreKernel::FindUnusedTimer();
void CoreKernel::MainLoop();
void CoreKernel::Exit(int32_t iErrCode);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corekernel\corekernelinitgame.cpp
void CoreKernel::SetGameController(CoreGameController* io_gameController);
void CoreKernel::InitCommon(int32_t iNumParams, char** lplpcParams, uint32_t* lpucGlobalMem, int32_t iGlobalMemSize, CoreHash i_graphicsType, CoreHash i_inputType, CoreHash i_audioType, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize, CoreHash i_networkType, CoreNet::DeviceInitialisationData* io_CoreNetInit, int32_t iGameMaxFrameRate);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corekernel\pc\corekernelpc.cpp
int32_t CoreKernel::GetTimeInTimerCycles();
void CoreKernel::RunTimerFunction(CoreKernelTimer* lpoTimer);
int32_t CoreKernel::ComputeGameMaxFrameRateInterval();
void CoreKernel::InitPC(char* i_BSIPipeName, char* i_localPath, char* i_commonPath, int32_t i_globalMemorySize, bool i_banNewDelete, bool i_banMallocFree, char* i_networkGameID, CoreGameController* io_gameController, int32_t i_maxFrameRate, uint32_t i_audioHeapSize, uint32_t i_audioSRAMSize, int32_t i_ignore);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corelevel\corelevel.cpp
void CoreLevel::Construct(CoreMemory* lpoGlobalMemory);
CoreMenuSystem* CoreLevel::CreateMenuSystem(CoreMemory* io_memory);
void CoreLevel::Destruct(CoreMemory* lpoGlobalMemory);
void CoreLevel::Init(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreLevel::Reset(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreLevel::UpdateObjectUpdateStruct(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreLevel::GetDetectionBBox(CoreVector& o_min, CoreVector& o_max);
bool CoreLevel::IsLevelLoaded();
CoreKeyedObject* CoreLevel::GetKeyedObject(CoreHash oName);
CoreCurveSetData* CoreLevel::GetCurveData(CoreHash oName);
CoreLevelCompiled* CoreLevel::GetLevelCompiled();
int32_t* CoreLevel::GetLevelRTreeIndexBuffer();
CoreObjectUpdateStruct* CoreLevel::GetObjectUpdateStruct();
CoreFX* CoreLevel::GetCoreFX();
CoreCutScenePlayer* CoreLevel::GetCutScenePlayer();
CoreMenuSystem* CoreLevel::GetMenuSystem();
void CoreLevel::SetLevelName(CoreHash oLevelHash, char* lpcLevelName, char* lpcAreaName);
char* CoreLevel::GetLevelName();
char* CoreLevel::GetAreaName();
bool CoreLevel::IsReady();
void CoreLevel::SetReady(bool i_ready);
void CoreLevel::UnLoad(CoreHash oNewLevelToLoad, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
bool CoreLevel::InitLoad(CoreHash oNewLevelHash, char* lpcLevelName, char* lpcAreaName, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
bool CoreLevel::PostLoad(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreLevel::Update(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreLevel::AddToRenderList(CoreGameRender* lpoGraphics);
void CoreLevel::LevelCycle(CoreLevelUpdateStruct* lpoUpdateStruct);
void CoreLevel::PlayCutScene(CoreHash i_cutscene, CoreHash i_audio);
bool CoreLevel::IsCutScenePlaying();
void* CoreLevel::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreLevel::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreLevel::eFnLevelUpdate(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnInstanceObject(CoreCommand* io_command);
CoreScripted::CommandReturn CoreLevel::eFnSetObjectPosAndOrient(CoreCommand* io_command);
CoreScripted::CommandReturn CoreLevel::eFnInstanceNetworkObject(CoreCommand* i_Command);
CoreScripted::CommandReturn CoreLevel::eFnWaitForObject(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnInstanceObjectIf(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnInstanceObjectIfNot(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnStartGlobalAudioEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreLevel::eFnTriggerGlobalAudioEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreLevel::eFnStopGlobalAudioEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnStartMusic(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnStartMusic(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnDuckMusic(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreMenuSystem::FnDuckSFX(CoreCommand* io_command);
CoreScripted::CommandReturn CoreLevel::eFnDuckSFX(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnSetGlobalReverb(CoreCommand* io_command);
CoreScripted::CommandReturn CoreLevel::eFnFX(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreObject::eFnFXEmitter(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnFXEmitter(CoreCommand* pCmd);
CoreScripted::CommandReturn CoreLevel::eFnSetTextureFilter(CoreCommand* command);
CoreScripted::CommandReturn CoreLevel::eFnCreateViewer(CoreCommand* i_command);
CoreScripted::CommandReturn CoreLevel::eFnLoadModel(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnLoadTextureSet(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnLoadFont(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnLoadGeometry(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::fnScrollMaterial(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::efnMaterialDepthOffset(CoreCommand* lpoCommand);
uint32_t CoreLevel::MaterialDepthOffset(CoreStringBuffer<256> matNameString);
CoreScripted::CommandReturn CoreLevel::efnMaterialEnvmap(CoreCommand* lpoCommand);
uint32_t CoreLevel::MaterialEnvmap(CoreStringBuffer<256> matNameString);
CoreScripted::CommandReturn CoreLevel::efnMaterialDepthAlpha(CoreCommand* lpoCommand);
uint32_t CoreLevel::MaterialDepthAlpha(CoreStringBuffer<256> matNameString);
CoreScripted::CommandReturn CoreLevel::efnMaterialAdditive(CoreCommand* lpoCommand);
uint32_t CoreLevel::MaterialAdditive(CoreStringBuffer<256> matNameString);
CoreScripted::CommandReturn CoreLevel::eFnLoadAnimSet(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::fnLoadCluster(CoreCommand* io_command);
CoreScripted::CommandReturn CoreLevel::eFnPause(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreLevel::eFnNetWaitForLevelStart(CoreCommand* lpoCommand);
CoreFileSystem::CoreFileLoadReturn CoreLevel::LoadClusterData(char* i_levelName, char* i_areaName, bool i_asyncLoad);
CoreFileSystem::CoreFileLoadReturn CoreLevel::LoadScriptData(bool i_asyncLoad);
bool CoreLevel::UnLoadScriptData();
CoreCurveSetData* CoreLevel::GetCurveDataByIndex(int32_t iIndex);
int32_t CoreLevel::GetNumCurves();
void CoreLevel::SetScriptMenu(CoreHash hashMenu);
void CoreLevel::DoDebug(CoreDebugInput* i_input);
void CoreLevel::AssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType, void* lpUsrData1, void* lpUsrData2);
void CoreLevel::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType);
uint32_t CoreLevel::GetClientID();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corelevel\corelevelasync.cpp
void CoreLevel::AsyncConstruct(CoreMemory* lpoGlobalMemory);
void CoreLevel::AsyncDestruct(CoreMemory* lpoGlobalMemory);
void CoreLevel::AsyncReset(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreLevel::AsyncZero();
void CoreLevel::AsyncSetLevelName(char* lpcLevelName, char* lpcAreaName);
void CoreLevel::AsyncUnLoad(CoreHash oNewLevelToLoad, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreLevel::AsyncLoad(CoreHash oLevelHash, char* lpcLevelName, char* lpcAreaName, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void CoreLevel::AsyncDoDebug(CoreDebugInput* i_input);
void CoreLevel::AsyncUpdate(CoreLevelUpdateStruct* lpoUpdateStruct);
void CoreLevel::AsyncHandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corelevel\coreleveldetect.cpp
bool CoreLevel::GetDetectPolyListPointInfiniteHeightRT(CoreVector& vPosA, CoreDetectPoly* lpoPolyList, int32_t iMaxNumDetectPolys, int32_t& iNumPolys, uint32_t uiDetectFlags, bool bUseFXMesh, float i_floorRadius);
bool CoreLevel::GetDetectPolyListRT(CoreVector& vPosA, CoreVector& vPosB, float fMaxRadiusDetectSphere, CoreDetectPoly* lpoPolyList, int32_t iMaxNumDetectPolys, int32_t& iNumPolys);
bool CoreLevel::GetDetectCollidableList(CoreVector& vPosA, CoreVector& vPosB, CoreVector& vBoundSpherePos, float fBoundSphereRadius, CoreSingleCollidable* lpoCollidables, int32_t& iNumCollidables, uint32_t uiDetectFlags);
bool CoreLevel::GetDetectCollidableListPointInfiniteHeight(CoreVector& vPosA, CoreSingleCollidable* lpoCollidables, int32_t& iNumCollidables, uint32_t, float i_floorRadius);
bool CoreLevel::GetNumBoundedEngineData(CoreHash i_dataType, uint32_t& i_numEntries);
bool CoreLevel::GetBoundedEngineDataByIndex(CoreHash i_dataType, uint32_t i_index, void*& o_dataPtr);
bool CoreLevel::GetBoundedEngineDataRTBox(CoreHash i_dataType, CoreVector i_detectMin, CoreVector i_detectMax, uint32_t i_dataPtrListSize, void** io_dataPtrList, uint32_t& io_numFound, bool i_addToList);
bool CoreLevel::GetBoundedEngineData(CoreHash i_dataType, CoreVector i_centre, float i_radius, uint32_t i_dataPtrListSize, void** o_dataPtrList, uint32_t& o_numFound);
int32_t CoreDetectionData::GetIntersectingRecords();
int32_t* CoreDetectionData::GetIndexListFromRTree(CoreVector& tMin, CoreVector& tMax, int32_t type, int32_t* buffer, int32_t buffMax);
int32_t CoreDetectionData::GetIndexListFromRTreeByRoom(CoreVector& tMin, CoreVector& tMax, int32_t type, uint32_t i_room, int32_t* buffer, int32_t buffMax);
void CoreLevel::ComputeDetectionBBox();
uint32_t CoreLevel::GetCollidableObjectList(CoreAnimatingObject** io_collidableObjectList, uint32_t i_maxNumItems);
uint32_t CoreLevel::GetDetectionDataList(CoreDetectionMeshInfo* io_detectionMeshList, uint32_t i_maxNumItems);
void CoreLevel::SetDetectionRoomActive(uint32_t i_roomNumber, bool i_active);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corelevel\corelevelgeometry.cpp
void CoreLevel::UpdateGeometry(float deltaGameTime, bool bUpdateLights);
CoreFileSystem::CoreFileLoadReturn CoreLevel::LoadGeometry(char* i_levelName, char* i_areaName, bool i_fake);
bool CoreLevel::UnLoadGeometry();
CoreLevelLightSet* CoreLevel::GetLevelLightSet();
void CoreLevel::InitRender();
void CoreLevel::Render(uint32_t i_drawFlags);
void CoreLevel::GetValidOccluders(int32_t occluderNum, CoreVector& cameraPos, CoreVector& cameraDir, float nearPlane);
void CoreLevel::InitialiseOccluders(bool i_levelLoaded);
void CoreLevel::InitialiseOccludersInternal(CoreLevelCompiled* i_levelCompiled);
void CoreLevel::RenderLevelCompiled(CoreLevelCompiled* i_levelCompiled, uint32_t i_drawFlags);
void CoreLevel::RenderDebug();
bool CoreLevel::ScrollMaterial(char* i_materialName, float i_deltaS, float i_deltaT, bool i_decal);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corelevel\corelevelnavigation.cpp
int32_t CoreLevel::GetNavTriangleFromPos(CoreNavigationMesh* i_navMesh, CoreVector& vPos, int32_t iLastTriangle);
bool CoreLevel::GetNavPoint(CoreNavigationMesh* i_navMesh, CoreVector& vStart, int32_t iPrevStartTri, CoreVector& vDest, int32_t iPrevDestTri, CoreVector& vNavPoint, int32_t iLookAhead);
void CoreLevel::DrawNavigationMesh(CoreNavigationMesh* i_navMesh);
void CoreLevel::DrawNavigationRoute(CoreVector& vStart, CoreVector& vDest, int32_t iLookAhead);
uint32_t CoreLevel::GetNumNavMeshes();
CoreNavigationMesh* CoreLevel::GetNavMeshByIndex(uint32_t i_index);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corelevel\corenode.cpp
char* CoreNode::GetNodeTypeString();
char* CoreNode::GetPositionString(uint32_t iAxis);
char* CoreNode::GetRotationString(uint32_t iAxis);
char* CoreNode::GetScaleString(uint32_t iAxis);
void CoreNode::SetTransformFromText(uint32_t iTransType, uint32_t iTransAxis, char* iString);
void CoreNodeChain::Construct();
uint32_t CoreNodeChain::GetCount();
void CoreNode::Construct();
void CoreNode::ClearExtraCapacity();
void CoreNode::SetExtraCapacity(CoreNodeType iNodeType, uint32_t iNum);
uint32_t CoreNode::GetExtraCapacity(CoreNodeType iNodeType);
void CoreNode::AddToScene();
void CoreNode::SetupFromCoreObject(CoreObject* iObject);
void CoreNode::RenderDebug();
void CoreNode::AddNodeToFreePool(CoreNode* pNode);
void CoreNode::UpdateChain(CoreNode* pFirstNode);
CoreNode* CoreNode::CreateNode(CoreNodeType iType);
CoreNode* CoreNode::GetFreeNode(CoreNodeType iType);
void CoreNodeRoot::GetNodeColourID(uint32_t iType, CoreRGBA& iRGB0, CoreRGBA& iRGB1);
void CoreNode::DeleteNode(CoreNode* pNode);
CoreNode* CoreNode::FindNodeByHash(uint32_t iHash);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coremenusystem\coremenubase.cpp
CoreMenuComponent* CoreMenuBase::FindComponent(CoreCommand* io_command, int32_t i_paramIndex);
void CoreMenuBase::UpdateAssets(CoreHash i_assetID, CoreHash i_assetType);
void CoreMenuBase::UpdateComponentTexture(uint32_t i_index);
void CoreMenuBase::UpdateComponentFont(uint32_t i_index);
CoreScripted::CommandReturn CoreMenuBase::FnAddComponent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnGetComponentX(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnGetComponentY(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnGetComponentW(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnGetComponentH(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnGetComponentRotation(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentRotation(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentAnchor(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentXY(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentWH(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentHorizontalSplitScreenXY(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentVerticalSplitScreenXY(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentUV0(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentUV1(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentRGBA(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentVisibility(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetAllComponentVisibility(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentVisibilityUpHoldFade(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentTexture(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentFrameCornerTextures(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentFrameStraightTextures(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentFrameBackGroundTextures(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentFrameCornerSizes(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentFrameBackGroundOffsets(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentCentreScale(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentNoPlatformScale(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentFont(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentSpaceTextEvenly(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnSetComponentTextMode(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuBase::FnLoadTextureSet(CoreCommand* io_command);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coremenusystem\coremenucomponent.cpp
void CoreMenuComponent::Init(CoreHash i_name, CoreHash i_type);
void CoreMenuComponent::SetAnchor(int32_t i_horiz, int32_t i_vert);
void CoreMenuComponent::SetRotation(float i_rotation, int32_t i_mode, float i_time);
void CoreMenuComponent::SetXY(float i_x, float i_y, int32_t i_mode, float i_time);
void CoreMenuComponent::SetWH(float i_width, float i_height, int32_t i_mode, float i_time);
void CoreMenuComponent::SetUV0(float i_u0, float i_v0, int32_t i_mode, float i_time);
void CoreMenuComponent::SetUV1(float i_u1, float i_v1, int32_t i_mode, float i_time);
void CoreMenuComponent::SetRGBA(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
void CoreMenuComponent::SetVisibility(float i_visibility, int32_t i_mode, float i_time);
void CoreMenuComponent::SetVisibilityHoldTimer(float i_timeUp, float i_timeHold, float i_timeDown);
void CoreMenuComponent::SetDirection(int32_t i_dir, CoreHash i_comp);
void CoreMenuComponent::SetTextureID(CoreHash i_textureID);
void CoreMenuComponent::SetFrameTextureID(CoreMenuComponent::CompFrameTag i_index, CoreHash i_textureID);
void CoreMenuComponent::SetFrameCornerSizes(float i_cornerWidths, float i_cornerHeights);
void CoreMenuComponent::SetFrameBackGroundOffsets(float i_offsetX, float i_offsetY);
void CoreMenuComponent::SetTextureSet(CoreTextureSet* i_texSet);
void CoreMenuComponent::SetSelectable(bool i_selectable);
void CoreMenuComponent::SetRequireCallbacks(bool i_requireCallbacks);
void CoreMenuComponent::SetCentreScale(bool i_centreScale);
void CoreMenuComponent::SetNoPlatformScale(bool i_noPlatformScale);
void CoreMenuComponent::SetFontID(CoreHash i_fontID);
void CoreMenuComponent::SetFont(CoreFont* i_font);
void CoreMenuComponent::SetText(CoreHash i_text);
void CoreMenuComponent::SetTextMode(int32_t i_xMode, int32_t i_yMode, float i_width, float i_height);
void CoreMenuComponent::SpaceTextEvenly(CoreMenuComponent* i_withinComponent, int32_t i_itemCount, int32_t i_itemIndex, float i_itemOffset, float i_itemHeight);
float CoreMenuComponent::GetX();
float CoreMenuComponent::GetY();
float CoreMenuComponent::GetWidth();
float CoreMenuComponent::GetHeight();
float CoreMenuComponent::GetRotation();
float CoreMenuComponent::GetU0();
float CoreMenuComponent::GetV0();
float CoreMenuComponent::GetU1();
float CoreMenuComponent::GetV1();
float CoreMenuComponent::GetAlpha();
float CoreMenuComponent::GetVisibility();
CoreHash CoreMenuComponent::GetDirection(int32_t i_dir);
CoreHash CoreMenuComponent::GetTextureID();
CoreTextureSet* CoreMenuComponent::GetTextureSet();
bool CoreMenuComponent::GetActive();
bool CoreMenuComponent::GetSelectable();
bool CoreMenuComponent::GetRequireCallbacks();
bool CoreMenuComponent::GetCentreScale();
bool CoreMenuComponent::GetNoPlatformScale();
CoreHash CoreMenuComponent::GetFontID();
CoreHash CoreMenuComponent::GetText();
CoreRGBA CoreMenuComponent::GetRGBAHighlight(float i_visMult);
CoreRGBA CoreMenuComponent::GetRGBANormalText(float i_visMult);
CoreHash CoreMenuComponent::GetItemHash(int32_t i_itemIndex);
CoreRGBA CoreMenuComponent::GetRGBABackground(float i_visMult);
CoreRGBA CoreMenuComponent::GetRGBA(float i_visMult);
CoreUV CoreMenuComponent::GetUV0();
CoreUV CoreMenuComponent::GetUV1();
void CoreMenuComponent::Update(float i_time);
float CoreMenuComponent::GetRatio();
void CoreMenuComponent::GetScreenXYWH(float& o_x, float& o_y, float& o_width, float& o_height);
void CoreMenuComponent::RenderFrameTexture(CoreGameRender* io_graphics, int32_t i_frameTextureIndex, float i_x1, float i_y1, float i_x2, float i_y2, CoreRGBA i_rgba, int32_t i_flags);
void CoreMenuComponent::GetRenderXYWH(float& o_x, float& o_y, float& o_w, float& o_h);
void CoreMenuComponent::Render(CoreGameRender* io_graphics, float i_visibilityMultiplier);
void CoreMenuComponent::RenderCustomString(CoreGameRender* io_graphics, char* i_str, float i_visibilityMultiplier);
void CoreMenuComponent::DoDebug(int32_t i_debugLevel, CoreDebugInput* i_input);
void CoreMenuComponent::SetHorizontalSplitScreenXY(float i_x, float i_y);
void CoreMenuComponent::SetVerticalSplitScreenXY(float i_x, float i_y);
float CoreMenuComponent::GetHorizontalSplitScreenX();
float CoreMenuComponent::GetHorizontalSplitScreenY();
float CoreMenuComponent::GetVerticalSplitScreenX();
float CoreMenuComponent::GetVerticalSplitScreenY();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coremenusystem\coremenucomponent.h
void CoreMenuComponent::CoreMenuComponent();
void CoreMenuComponent::~CoreMenuComponent();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coremenusystem\coremenucomponentlistbox.cpp
void CoreMenuComponentListBox::Init(CoreHash i_name, CoreHash i_type);
void CoreMenuComponentListBox::SetRGBABackground(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
void CoreMenuComponentListBox::SetRGBAHighlight(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
void CoreMenuComponentListBox::SetRGBANormalText(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
bool CoreMenuComponentListBox::AddItem(char* i_text, uint32_t i_customColour, CoreHash i_icon);
void CoreMenuComponentListBox::SetItemIconVisibility(int32_t i_itemIndex, bool i_visible);
bool CoreMenuComponentListBox::GetItemIconVisibility(int32_t i_itemIndex);
void CoreMenuComponentListBox::SetNumberOfVisibleItems(int32_t i_visibleItemCount);
int32_t CoreMenuComponentListBox::GetNumberOfVisibleItems();
void CoreMenuComponentListBox::ClearContents();
CoreRGBA CoreMenuComponentListBox::GetCustomRGBA(uint32_t i_index, float i_visMult);
CoreRGBA CoreMenuComponentListBox::GetRGBABackground(float i_visMult);
CoreRGBA CoreMenuComponentListBox::GetRGBAHighlight(float i_visMult);
CoreRGBA CoreMenuComponentListBox::GetRGBANormalText(float i_visMult);
CoreHash CoreMenuComponentListBox::GetItemHash(int32_t i_itemIndex);
char* CoreMenuComponentListBox::GetItemText(int32_t i_itemIndex);
bool CoreMenuComponentListBox::GetSelectable();
void CoreMenuComponentListBox::Update(float i_time);
void CoreMenuComponentListBox::Render(CoreGameRender* io_graphics, float i_visibilityMultiplier);
void CoreMenuComponentListBox::RenderBackground(CoreGameRender* io_graphics, float i_visibilityMultiplier, int32_t i_drawFlags);
void CoreMenuComponentListBox::RenderHighlight(CoreGameRender* io_graphics, float i_visibilityMultiplier, int32_t i_drawFlags);
void CoreMenuComponentListBox::RenderText(CoreGameRender* io_graphics, float i_visibilityMultiplier, int32_t i_drawFlags);
bool CoreMenuComponentListBox::InternalMovementHandler(CoreMenuComponent::CompDirection i_direction);
int32_t CoreMenuComponentListBox::GetInternalSelection();
void CoreMenuComponentListBox::SetInternalSelection(uint32_t i_index);
uint32_t CoreMenuComponentListBox::GetNumberOfItems();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coremenusystem\coremenucomponentslider.cpp
void CoreMenuComponentSlider::SetValue(float i_to, int32_t i_mode, float i_time);
void CoreMenuComponentSlider::Update(float i_time);
float CoreMenuComponentSlider::GetValue();
char* CoreMenuComponentSlider::DebugOutput(CoreStringBuffer<256>& o_buffer, bool i_full);
void CoreMenuComponentSlider::DebugShift(float i_diff);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coremenusystem\coremenusystem.cpp
void* CoreMenuSystem::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreMenuSystem::RunFunction(CoreCommand* io_command);
void CoreMenuSystem::CoreMenuSystem();
void CoreMenuSystem::~CoreMenuSystem();
void CoreMenuSystem::Construct(CoreMemory* io_memory);
void CoreMenuSystem::Destruct(CoreMemory* io_memory);
void CoreMenuSystem::Init();
void CoreMenuSystem::Reset();
void CoreMenuSystem::Update(CoreObjectUpdateStruct* io_updateStruct);
void CoreMenuSystem::UpdateComponent(CoreMenuComponent* i_component, float i_time);
void CoreMenuSystem::SetCamera();
void CoreMenuSystem::Render(CoreGameRender* io_graphics);
void CoreMenuSystem::RenderComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
void CoreMenuSystem::DoDebug(CoreDebugInput* i_input);
void CoreMenuSystem::InitMenu(CoreObjectUpdateStruct* io_updateStruct, CoreHash i_menu);
void CoreMenuSystem::EndMenu(CoreObjectUpdateStruct* io_updateStruct);
CoreHash CoreMenuSystem::GetCurrentMenu();
bool CoreMenuSystem::IsMenuActive();
int32_t CoreMenuSystem::FindComponent(CoreHash i_name);
CoreMenuComponent* CoreMenuSystem::GetComponent(int32_t i_index);
void CoreMenuSystem::SelectComponent(CoreHash i_name);
void CoreMenuSystem::ClickSelectedComponent();
void CoreMenuSystem::SetComponentDirection(CoreHash i_name, int32_t i_dir, CoreHash i_to, bool i_overWrite);
void CoreMenuSystem::AddComponent(CoreHash i_componentName, CoreHash i_Type);
int32_t CoreMenuSystem::GetNumComponents();
CoreTextureSet* CoreMenuSystem::GetTextureSet();
CoreHash CoreMenuSystem::GetTextureSetID();
void CoreMenuSystem::SetTextureSet(CoreTextureSet* i_textureSet, CoreHash i_textureSetID);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuReset(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetComponentSelectable(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetComponentRequireCallbacks(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetComponentUp(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetComponentDown(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetComponentLeft(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetComponentRight(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSelectComponent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetPreFadeRGBA(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetPreFadeVisibility(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetPostFadeRGBA(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetPostFadeVisibility(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetBack(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetCamera(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuSetCameraFOV(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuWaitForCamera(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuUpdate(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuPause(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnMenuPlaySound(CoreCommand* io_command);
void FinishedOSK(void* i_callBackUserData, char* i_resultString, CORE_OSK_RESULT_TAG i_result, int32_t i_inputIndex, bool i_lastCallBack);
CoreScripted::CommandReturn CoreMenuSystem::FnChangeNameOSK(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnWasOSKCanceled(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnSetComponentRGBABackground(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnSetComponentRGBAHighlight(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnSetComponentRGBANormalText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnGetInternalSelection(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnSetInternalSelection(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnSetComponentVisibleItems(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnGetNumberOfItems(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnSetMenuTimeScale(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnStartScreenTimeOut(CoreCommand* io_command);
void CoreMenuSystem::UpdateScreenTimeOut();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobject\coreanimatingobject.cpp
void CoreAnimatingObject::Construct(CoreMemory* lpoMemory);
void CoreAnimatingObject::Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreAnimatingObject::Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreAnimatingObject::Reset();
CoreFileSystem::CoreFileLoadReturn CoreAnimatingObject::AttachAnimationSetFile(CoreObjectUpdateStruct* i_updateStruct, char* i_animationSetName);
void CoreAnimatingObject::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreAnimatingObject::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, int32_t& iDataRead, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreAnimatingObject::Animate(CoreObjectUpdateStruct* updateStruct, float deltaTimeInSeconds);
void CoreAnimatingObject::ResetAnimations();
float CoreAnimatingObject::GetDefaultEndTime(CoreHash oAnimName);
CoreEulerAngle CoreAnimatingObject::GetOrientationChange(CoreHash oName, float fStartTime, float fEndTime, float fAnimEndTime, bool bLooping, bool mirror);
CoreVector CoreAnimatingObject::GetPositionChange(float fDeltaTime);
void CoreAnimatingObject::GetAnimateVelocity(CoreVector* o_velocityPos, CoreEulerAngle* o_velocityRot, CoreVector* o_offsetPos, CoreEulerAngle* o_offsetRot);
void CoreAnimatingObject::SetBoneOrientationOverride(CoreHash oBoneName, CoreEulerAngle& eaNewOrient, uint32_t uiOverrideFlags);
void CoreAnimatingObject::SetBoneTranslationOverride(CoreHash oBoneName, CoreVector& vNewTranslation, uint32_t uiOverrideFlags);
void CoreAnimatingObject::SetBoneTranslationXYZAbs(CoreHash oBoneName, CoreVector& vNewTranslation);
CoreVector CoreAnimatingObject::GetSubObjectMarkerPosition(CoreHash oMarkerName);
CoreEulerAngle CoreAnimatingObject::GetSubObjectMarkerOrientation(CoreHash oMarkerName);
CoreVector CoreAnimatingObject::GetSubObjectMarkerScale(CoreHash oMarkerName);
void CoreAnimatingObject::SetVisible(CoreHash oBoneName, bool bVisible);
void CoreAnimatingObject::UnSetVisible(CoreHash oBoneName);
void CoreAnimatingObject::AddToRenderList(CoreGameRender* lpoGraphics);
void CoreAnimatingObject::Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
void CoreAnimatingObject::RenderAnimList(CoreGameRender* lpoGraphics);
void CoreAnimatingObject::UpdateJointsState(CoreHashArray* lpoJointIndexTable, CoreJointState* lpoJointStates);
void CoreAnimatingObject::ApplyBoneOverrides(CoreJointState* io_jointStates, bool i_hasAnim);
void CoreAnimatingObject::UpdateBlendShapeTargetAlphaValues(float* lpfBlendShapeAlphaValues);
void CoreAnimatingObject::CreateSkeletonOverrideValues(int32_t iNumBlendShapeTargets);
void* CoreAnimatingObject::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreAnimatingObject::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreAnimatingObject::eFnNetUpdateAnimatingObject(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreAnimatingObject::eFnSetAnimTemplate(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreAnimatingObject::eFnSetAnimTemplateSimple(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreAnimatingObject::eFnSetAnimTemplateComplex(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreAnimatingObject::eFnSetAnim(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreAnimatingObject::eFnSetAnimNonLoop(CoreCommand* lpoCommand);
void CoreAnimatingObject::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
bool CoreAnimatingObject::AddAnimNormal(CoreHash i_slotID, CoreHash i_animID);
bool CoreAnimatingObject::AddAnim(CoreHash i_slotID, CoreHash i_animID, CorePlayAnimInfo* i_animInfo);
CoreHash CoreAnimatingObject::GetPrimaryAnimID();
float CoreAnimatingObject::GetPrimaryAnimTime();
float CoreAnimatingObject::GetPrimaryAnimEndTime();
CoreHash CoreAnimatingObject::GetSlotAnimID(CoreHash i_slotID);
float CoreAnimatingObject::GetSlotAnimTime(CoreHash i_slotID);
float CoreAnimatingObject::GetSlotAnimEndTime(CoreHash i_slotID);
void CoreAnimatingObject::SetSlotWeight(CoreHash i_slotID, float i_weight, float i_time, bool i_killOnZeroWeight);
CoreAnimationSet* CoreAnimatingObject::GetAnimationSet(CoreHash i_animName);
CoreEulerAngle CoreAnimatingObject::GetAnimationDirection();
bool CoreAnimatingObject::IsPrimaryAnimSpecFlagSet(int32_t i_flag);
bool CoreAnimatingObject::IsAnimSpecFlagSet(CoreHash i_animSpec, int32_t i_flag);
CoreHash CoreAnimatingObject::GetAnimSpecAltState(CoreHash i_animSpec);
CoreHash CoreAnimatingObject::GetPrimaryAnimContext();
bool CoreAnimatingObject::SetGoalState(CoreHash i_slotID, CoreHash i_animID);
bool CoreAnimatingObject::AddImmediateBlend(CoreHash i_slotID, CoreHash i_animID, CorePlayAnimInfo* i_animInfo);
void CoreAnimatingObject::CreateBlender(int32_t i_blenderType, CoreObjectUpdateStruct* i_updateStruct);
CoreHashArray* CoreAnimatingObject::GetSkeletonJointIndexTable();
CoreScripted::CommandReturn CoreAnimatingObject::eFnSetAnimFlag(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreAnimatingObject::eFnClearAnimFlag(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreAnimatingObject::eFnClearAllAnimFlags(CoreCommand* lpoCommand);
void CoreAnimatingObject::InitialiseAnimFlagsFromModel();
void CoreAnimatingObject::AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
CoreVector CoreAnimatingObject::GetVelocityPosition();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobject\coreanimatingobject.h
CoreHash CoreAnimatingObject::GetSubObjectMarkerHash(int32_t iSubObjectMarkerIndex);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobject\coregeometryobject.cpp
void CoreGeometryObject::Construct(CoreMemory* lpoMemory);
void CoreGeometryObject::Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreGeometryObject::RemoveGeometryFiles();
CoreFileSystem::CoreFileLoadReturn CoreGeometryObject::AttachTextureSetFile(CoreObjectUpdateStruct* i_updateStruct, char* i_textureSetName, uint32_t i_index);
void CoreGeometryObject::AttachTextureSet(CoreTextureSet* i_textureSet, uint32_t i_textureSetFile, uint32_t i_index);
void CoreGeometryObject::ComputeTextureOffsets();
CoreFileSystem::CoreFileLoadReturn CoreGeometryObject::AttachModelCompiledFile(CoreObjectUpdateStruct* i_updateStruct, char* i_modelCompiledName);
CoreFileSystem::CoreFileLoadReturn CoreGeometryObject::AttachModelCompiledEngineFile(CoreObjectUpdateStruct* i_updateStruct, char* i_modelCompiledEngineName);
void CoreGeometryObject::AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
void CoreGeometryObject::Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreGeometryObject::Reset();
bool CoreGeometryObject::SetDetectorSphere(int32_t i_index, CoreVector i_origin, float i_radius, CoreHash i_exclusiveSubtype);
void CoreGeometryObject::SetNumDetectorSpheres(int32_t i_numSpheres);
CoreDetectorSpheres* CoreGeometryObject::GetDetectorSpheres();
CorePhysicsArticulate* CoreGeometryObject::GetPhysicsArticulate();
CoreCollidables* CoreGeometryObject::GetCollidables();
CoreDetectionData* CoreGeometryObject::GetDetectionData();
CoreDetectionMesh* CoreGeometryObject::GetDetectionMesh();
CoreMatrix CoreGeometryObject::mtGetBone2ObjectMatrix(CoreHash oBoneHash);
bool CoreGeometryObject::HasValidSkeleton();
bool CoreGeometryObject::UpdateState(float fTime);
void CoreGeometryObject::SetLightOffsetPoint(CoreVector& vOffsetPoint);
void CoreGeometryObject::RenderShadow(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
void CoreGeometryObject::AddToRenderList(CoreGameRender* lpoGraphics);
void CoreGeometryObject::Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
void CoreGeometryObject::DebugRender(uint32_t ulDrawFlags, CoreGraphicsDevice* lpoDevice);
void CoreGeometryObject::RenderNoModel(CoreGraphicsDevice* lpoDevice);
void CoreGeometryObject::RenderModelCompiled(float, uint32_t ulDrawFlags, CoreGraphicsDevice* lpoDevice, uint32_t uiMeshFlags, CoreModelCompiled* i_modelCompiled);
CoreModelSkeleton* CoreGeometryObject::GetModelSkeletonPtr();
CoreModelCompiled* CoreGeometryObject::GetModelCompiledPtr();
void CoreGeometryObject::MakeLocal2WorldMatrix();
void CoreGeometryObject::SetStateChanged();
CoreScripted::CommandReturn CoreGeometryObject::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreGeometryObject::eFnSetPhysicsControl(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreGeometryObject::eFnSetPhysicsRagdoll(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreGeometryObject::eFnSetObjectTemplate(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreGeometryObject::eFnSetCutSceneObjectTemplate(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreGeometryObject::fnSetShadowTemplate(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreGeometryObject::fnSetEngineTemplate(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreGeometryObject::fnOverrideBaseTexture(CoreCommand* i_command);
CoreScripted::CommandReturn CoreGeometryObject::eFnSetTextureTemplate(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreGeometryObject::eFnSetCutSceneTextureTemplate(CoreCommand* lpoCommand);
bool CoreGeometryObject::DoesBoneExist(CoreHash oBoneHash);
CoreVector CoreGeometryObject::GetBoneObjectPosition(CoreHash oBoneName);
CoreMatrix CoreGeometryObject::mtGetLocal2WorldMatrix();
int32_t CoreGeometryObject::GetJointIndex(CoreHash oJointHash);
void CoreGeometryObject::ResetLights();
void CoreGeometryObject::ResetDirectionalLights();
void CoreGeometryObject::SetFadeValue(float i_value);
void CoreGeometryObject::SetAmbientLight(CoreVector& vAmbientColour);
void CoreGeometryObject::SetDirectionalLight(int32_t iIndex, CoreVector& vDirection, CoreVector& vColour, CoreVector& vPosition, float fSpecularIntensity);
void CoreGeometryObject::AssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType, void* lpUsrData1, void* lpUsrData2);
void CoreGeometryObject::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
bool CoreGeometryObject::HasPhysics();
bool CoreGeometryObject::HasRemotePhysicsState();
void CoreGeometryObject::RecordLocalPhysicsState(CoreObject::CoreObjectNetworkUpdate* io_Data);
void CoreGeometryObject::CalculateDeltaPhysicsState(CoreObject::CoreObjectNetworkUpdate* io_Data, int32_t& io_DataRead, float* o_boneDelta, float i_blend);
void CoreGeometryObject::ApplyDeltaPhysicsState(float* i_boneDelta);
bool CoreGeometryObject::PhysicsPreUpdate(CoreMatrix* lpoMatrixList, CoreMatrix& mtObject2World);
bool CoreGeometryObject::PhysicsUpdateState(CoreMatrix* lpoMatrixList, CoreMatrix& mtObject2World, CoreVector& vNewPos, CoreEulerAngle& eaNewOrient, CoreVector& vScale);
bool CoreGeometryObject::PhysicsPostUpdate(CoreMatrix* lpoMatrixList, CoreMatrix& mtObject2World);
bool CoreGeometryObject::ActivatePhysics(CoreVector& velocity);
bool CoreGeometryObject::SetPhysicsBlendScaleMode(float blendScale, int32_t blendMode);
bool CoreGeometryObject::SetPhysicsAnimVelocityScale(float animVelScale);
bool CoreGeometryObject::DeactivatePhysics();
bool CoreGeometryObject::GetBlindDataByIndex(CoreHash i_dataType, uint32_t i_index, void*& o_dataPtr);
char* CoreGeometryObject::GetPhysicsMaterial();
CoreModelInfo* CoreGeometryObject::GetModelInfo();
void CoreGeometryObject::SetExtraDrawFlags(uint32_t i_drawFlags);
void CoreGeometryObject::SetUseCharacterLights(bool i_enable);
bool CoreGeometryObject::SetBoneControlCallback(CoreHash i_boneHash, void* i_callbackFunction, void* i_data);
void CoreGeometryObject::ComputeAnimationMatrices(CoreMatrix* io_matrixList);
void CoreGeometryObject::GetSkeletonWorldPositions(CoreVector* o_bonePos);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobject\coregeometryobject.h
CoreMatrix CoreGeometryObject::mtGetBone2WorldMatrix(uint32_t uiBoneHash);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobject\coreobject.cpp
void CoreObject::Construct(CoreMemory*);
void CoreObject::Destruct(CoreMemory*, CoreObjectUpdateStruct*);
void CoreObject::Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreObject::ResetMemory();
void* CoreObject::GetMemory(int32_t inSize);
void CoreObject::Update(CoreObjectUpdateStruct* lpoUpdateStruct);
int32_t CoreObject::GetTypeIndex();
uint32_t CAL1_Sample::GetStreamStartOffset();
void CoreObject::SetType(CoreHash i_type, int32_t i_typeIndex);
void CoreObject::SetWorldPosOrient(CoreVector& i_worldPos, CoreEulerAngle& i_worldOrient);
void CoreObject::SetWorldOrient(CoreEulerAngle& i_worldOrient);
CoreVector CoreObject::GetWorldPos();
CoreEulerAngle CoreObject::GetWorldOrient();
CoreQuat CoreObject::GetWorldOrientQuat();
CoreVector CoreObject::GetWorldScale();
CoreMatrix CoreObject::MakeLocalToWorldMatrix();
void CoreObject::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, CoreObjectUpdateStruct*);
void CoreObject::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate*, int32_t& iDataRead, CoreObjectUpdateStruct*);
uint32_t CoreObject::GetNetworkUpdateFrequency();
void CoreObject::SetNetworkUpdateFrequency(uint32_t i_FrameCount);
bool CoreObject::IsNetworkUpdateRequired();
void* CoreObject::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreObject::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::eFnSetPosAndOrient(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreObject::eFnRotate(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreObject::eFnSetScale(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreObject::eFnInstanceObject(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreObject::eFnInstanceObjectJoint(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreObject::eFnUnParentObject(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreObject::eFnGetObjectName(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreObject::eFnWaitForVariable(CoreCommand* lpoCommand);
bool CoreObject::Pause(float i_time, float i_deltaTime);
CoreScripted::CommandReturn CoreObject::eFnPause(CoreCommand* lpoCommand);
CoreAudioObjectData* CoreObject::GetAudioObjectData();
CoreScripted::CommandReturn CoreObject::FnSetAudioObjectAndCreateInstance(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnSetAudioObject(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnSetMaxDist(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnSetMinDist(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnSetAttenuation(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnSetFrequency(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnSetProcessingType(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnSetSourceType(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnSetOcclusion(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnStartEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnStartEventParam(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnStopEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnTriggerEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnUpdateEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnStartGlobalEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnStartGlobalEventParam(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnStopGlobalEvent(CoreCommand* io_command);
CoreScripted::CommandReturn CoreObject::FnSetMaxUpdateDistance(CoreCommand* io_command);
bool CoreObject::SetAudioObjectAndCreateInstance(CoreHash i_AudioObjectID);
bool CoreObject::SetAudioObject(CoreHash i_AudioObjectID);
bool CoreObject::SetAttenuation(uint32_t i_Attenuation);
bool CoreObject::SetProcessingType(CoreHash i_ProcessingType);
bool CoreObject::StartEvent(uint32_t i_EventID, bool i_Looping);
bool CoreObject::StartEventParam(uint32_t i_EventID, bool i_Looping, uint32_t i_Param);
bool CoreObject::StopEvent(uint32_t i_EventID);
bool CoreObject::TriggerEvent(uint32_t i_EventID);
bool CoreObject::UpdateEvent(uint32_t i_EventID);
bool CoreObject::StartGlobalEvent(uint32_t i_EventID);
bool CoreObject::StartGlobalEventParam(uint32_t i_EventID, uint32_t i_Param);
bool CoreObject::StopGlobalEvent(uint32_t i_EventID);
bool CoreObject::IsAudioSupported();
bool CoreObject::SupportAudio();
uint32_t CoreObject::GetAudioObjectID();
uint32_t CoreObject::GetAudioObjectInstance();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobject\coreobject.h
void CoreObject::SetOrientZYX(float i_x, float i_y, float i_z);
void CoreObject::SetLocalName(CoreHash i_localName);
CoreQuat CoreObject::GetOrientQuat();
CoreHash CoreObject::GetParentBone();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobject\coreplayaniminfo.h
CoreHash CorePlayAnimInfo::GetBoneSetHash();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobject\corerenderableobject.cpp
void CoreRenderableObject::SetNoZWrite(bool i_enable);
void CoreRenderableObject::SetNoZTest(bool i_enable);
void CoreRenderableObject::SetBeforeLevel(bool i_enable);
void CoreRenderableObject::SetPanelObject(bool i_enable);
void CoreRenderableObject::SetNoViewCulling(bool i_enable);
bool CoreRenderableObject::GetNoZWrite();
bool CoreRenderableObject::GetNoZTest();
bool CoreRenderableObject::GetSingleViewObject();
void CoreRenderableObject::Construct(CoreMemory* lpoMemory);
void CoreRenderableObject::Init(CoreHash oNameHash, CoreHash oScriptHash, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreRenderableObject::SetBoundingBox(CoreVector i_bboxMin, CoreVector i_bboxMax);
void CoreRenderableObject::GetBoundingBox(CoreVector& o_bboxMin, CoreVector& o_bboxMax);
void CoreRenderableObject::AddToRenderList(CoreGameRender* lpoGraphics);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobjectcontroller\coreevent.cpp
bool CoreEvent::CreateLogger();
bool CoreEvent::Create(uint32_t i_Type, uint32_t i_To, uint32_t i_From, void* i_Data, uint32_t i_Size);
uint32_t CoreEvent::Serialise(void* i_Buffer, uint32_t i_BufferSize);
bool CoreEvent::DeSerialise(void* i_SerialisedBuffer, void* i_DataBuffer, uint32_t i_DataBufferSize);
bool CoreEvent::StoreEvent(CoreEvent& i_TargetEvent, void* i_DataBuffer, uint32_t i_DataBufferSize);
uint32_t CoreModelCompiled::GetNameHash();
uint32_t CoreEvent::GetOwner();
uint32_t CAL1_AudioDriver::GetDefaultStreamFileID();
uint32_t CAL0_List::GetMaximumNumberOfItems();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreobjectcontroller\coreobjectcontroller.cpp
void CoreObjectController::Construct(CoreMemory* lpoMemory);
void CoreObjectController::RegisterType(int32_t i_index, CoreHash oType, int32_t iMax, CoreObject** create);
void CoreObjectController::Destruct(CoreMemory* lpoMemory);
void CoreObjectController::Init();
CoreMemory* CoreObjectController::GetMemory();
int32_t CoreObjectController::GetNumObjectsInType(int32_t i_type);
int32_t CoreObjectController::GetObjectTypeByTypeHash(uint32_t i_hash);
CoreObject* CoreObjectController::GetObjectByType(int32_t i_type, int32_t i_index);
int32_t CoreObjectController::GetNumObjects();
int32_t CoreObjectController::GetObjectNumberWithNameHash(CoreHash oNameHash);
CoreObject* CoreObjectController::GetObjectByIndex(int32_t iIndex);
int32_t CoreObjectController::GetCurrentViewerObjectID();
CoreViewerObject* CoreObjectController::GetCurrentViewerObject();
void CoreObjectController::SetCurrentViewerObject(CoreViewerObject* i_viewer);
int32_t CoreObjectController::GetNumCutSceneObjectObjects();
CoreCutSceneObject* CoreObjectController::GetCutSceneObjectObject(int32_t iIndex);
CoreCutSceneCamera* CoreObjectController::GetCutSceneCameraObject(int32_t iIndex);
int32_t CoreObjectController::GetNumCutSceneCameraObjects();
CoreViewerObject* CoreObjectController::GetViewerObject(int32_t iIndex);
int32_t CoreObjectController::GetNumViewerObjects();
CoreViewerObject* CoreObjectController::FindViewerObject(CoreHash oName);
CoreAudioLocatorObject* CoreObjectController::GetAudioLocatorObject(int32_t iIndex);
int32_t CoreObjectController::GetNumAudioLocatorObjects();
CoreObject* CoreObjectController::ServerCreateNamedObject(CoreHash oMsgType, void* lpMsg, int32_t iMsgLength, CoreObjectUpdateStruct* lpoUpdateStruct);
CoreObject* CoreObjectController::ClientCreateNamedObject(CoreHash oMsgType, void* lpMsg, CoreObjectUpdateStruct* lpoUpdateStruct);
CoreObject* CoreObjectController::CreateNamedObject(CoreHash oObjectName, CoreHash oScriptName, CoreHash oType, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreObjectController::DestroyObject(int32_t i_index, CoreObjectUpdateStruct* i_updateStruct);
void CoreObjectController::DestroyObjects(CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreObjectController::SetPauseObjects(bool bPause);
void CoreObjectController::SendServerObject(CoreObject* lpoObject, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreObjectController::UpdateClientObject(void* lpData, CoreObjectUpdateStruct* lpoUpdateStruct);
void CoreObjectController::MakeObjectLists();
void CoreObjectController::UpdateSingleObject(CoreObjectUpdateStruct* i_updateStruct, CoreObject* i_object);
void CoreObjectController::UpdateObjects(CoreObjectUpdateStruct* i_updateStruct);
void CoreObjectController::PostEvent(CoreEvent& i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreObjectController::ProcessNetworkEvent(void* i_Data, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreObjectController::ProcessEvents(CoreObjectUpdateStruct* io_UpdateStruct);
void CoreObjectController::AddToRenderList(CoreGameRender* lpoGraphics);
int32_t CoreObjectController::ComputeMemNeeded();
CoreObjectListNode* CoreObjectController::GetObjectListByProperty(uint32_t i_propertyIndex);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\corepanel\corepanel.cpp
void* CorePanel::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CorePanel::RunFunction(CoreCommand* io_command);
void CorePanel::CorePanel();
void CorePanel::~CorePanel();
void CorePanel::Construct(CoreMemory* io_memory);
void CorePanel::Destruct(CoreMemory* io_memory);
void CorePanel::Init(CoreObjectUpdateStruct* io_updateStruct);
void CorePanel::Reset(CoreObjectUpdateStruct* io_updateStruct);
void CorePanel::Update(CoreObjectUpdateStruct* io_updateStruct, float fTimeElapsed);
void CorePanel::Render(CoreGameRender* io_graphics);
void CorePanel::RenderComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
void CorePanel::DoDebug(CoreDebugInput* i_input);
float CorePanel::GetGlobalVisibility();
int32_t CorePanel::FindComponent(CoreHash i_name);
CoreMenuComponent* CorePanel::GetComponent(int32_t i_index);
CoreTextureSet* CorePanel::GetTextureSet();
CoreHash CorePanel::GetTextureSetID();
void CorePanel::SetTextureSet(CoreTextureSet* i_textureSet, CoreHash i_textureSetID);
void CorePanel::AddComponent(CoreHash i_componentName, CoreHash i_Type);
int32_t CorePanel::GetNumComponents();
void CorePanel::AddOnScreenMessage(CorePanel::OnScreenMessage* i_OnScreenMessage);
void CorePanel::SendOnScreenMessage(char* i_message, uint32_t i_GameTextHash, bool i_RemoteStationsOnly);
CoreScripted::CommandReturn CorePanel::FnPanelSetVisibility(CoreCommand* io_command);
void CorePanel::SetActiveView(uint32_t i_view);
uint32_t CorePanel::GetActiveView();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgame\coreworld\coreworld.cpp
CoreHash CoreWorld::GetAnimationSetAssetType();
CoreHash CoreWorld::GetAnimSequencerAssetType();
CoreHash CoreWorld::GetModelCompiledAssetType();
CoreHash CoreWorld::GetTextureSetAssetType();
CoreHash CoreWorld::GetFontAssetType();
CoreHash CoreWorld::GetScriptStoreAssetType();
CoreHash CoreWorld::GetLevelAssetType();
CoreHash CoreWorld::GetGenericFileAssetType();
CoreHash CoreWorld::GetClusterAssetType();
void CoreWorld::Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams);
void CoreWorld::Destruct(CoreMemory* lpoMemory);
void CoreWorld::Init(CoreWorldUpdateStruct* lpoWorldUpdateStruct);
void CoreWorld::Reset(CoreWorldUpdateStruct* lpoWorldUpdateStruct);
void CoreWorld::ReLoadCurrentLevel();
void CoreWorld::SetLoadLevel(CoreHash newLevel);
void CoreWorld::Update(CoreWorldUpdateStruct* lpoWorldUpdateStruct, float fTimeElapsed);
void CoreWorld::UpdateFade(float fTimeInput);
void CoreWorld::ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
void CoreWorld::AddToRenderList(CoreGameRender* lpoGraphics);
void CoreWorld::RenderPanel(CoreGameRender* lpoGraphics);
void CoreWorld::Render(CoreGameRender* lpoGraphics);
void CoreWorld::RenderLevelSelect(CoreGameRender* lpoGraphics);
void CoreWorld::UpdateLevelSelect(CoreWorldUpdateStruct* lpoUpdateStruct);
int32_t CoreWorld::iCountLevels();
bool CoreWorld::IsLevelLoaded();
bool CoreWorld::NoNetworking();
uint32_t CoreWorld::GetNetworkAdapter();
void CoreWorld::SetLoadingScreenTexSet(char* i_fileName, int32_t i_index);
void CoreWorld::RenderLoadingScreen(CoreGameRender* i_graphics, CoreTextureSet** i_textureSet);
void CoreWorld::SetLoadingScreen(CoreHash i_loadingScreen);
void CoreWorld::RoutePackets(CoreWorldUpdateStruct* lpoUpdateStruct);
void CoreWorld::SetWhiteFade(bool i_whiteFade);
void CoreWorld::SetFadeDown();
void CoreWorld::SetFadeUp();
void CoreWorld::SetFadeTime(float iFadeTime);
void CoreWorld::SetAudioFadeFactor(float iFadeFactor);
void CoreWorld::SetFadeValue(float fFadeVal);
bool CoreWorld::bHasFinishedFadeDown();
bool CoreWorld::CanPause();
char* CoreWorld::GetCurrentProfileName();
bool CoreWorld::GetLevelName(CoreHash oNewLevel, char* lpcLevelName, char* lpcAreaName);
void CoreWorld::WorldCycle(CoreWorldUpdateStruct* lpoUpdateStruct);
void CoreWorld::WaitForAssetToLoad();
void CoreWorld::DoDebugCallback(CoreDebugInput* i_input, CoreWorldUpdateStruct* lpoWorldUpdateStruct, int32_t iLevel, void* lpUserData);
CoreAIController* CoreWorld::CreateAIController(CoreMemory* io_memory);
CoreDetect* CoreWorld::CreateDetect(CoreMemory* io_memory);
CorePhysicsWorld* CoreWorld::CreatePhysicsWorld(CoreMemory* io_memory);
CorePanel* CoreWorld::CreatePanel(CoreMemory* io_memory);
void* CoreWorld::LoadAsset(uint32_t i_clientID, char* i_assetName, CoreHash i_assetHash, CoreHash i_assetType, bool i_asyncLoad, bool& o_fileExists, bool i_allocAsset);
void* CoreWorld::GetAsset(CoreHash i_assetHash, CoreHash i_assetType);
bool CoreWorld::UnLoadAsset(CoreHash i_assetHash, CoreHash i_assetType);
uint32_t CoreWorld::GetClientID();
CoreHash CoreWorld::GetAnimationSetAssetHash(char* i_assetName);
CoreHash CoreWorld::GetModelCompiledAssetHash(char* i_assetName);
CoreHash CoreWorld::GetTextureSetAssetHash(char* i_assetName);
CoreHash CoreWorld::GetFontAssetHash(char* i_assetName);
CoreClusterData* CoreWorld::LoadLevelCluster(uint32_t i_clientID, char* i_levelName, char* i_areaName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
uint32_t* CoreWorld::LoadLevelScript(uint32_t i_clientID, char* i_levelName, char* i_areaName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreAnimationSet* CoreWorld::LoadAnimationSet(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreAnimSequencer* CoreWorld::LoadAnimSequencer(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreModelCompiled* CoreWorld::LoadModelCompiled(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreTextureSet* CoreWorld::LoadTextureSet(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreFont* CoreWorld::LoadFont(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
void* CoreWorld::LoadSpecificFile(uint32_t i_clientID, char* i_assetName, CoreHash i_assetType, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
void* CoreWorld::LoadDataFile(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
bool CoreWorld::LoadCluster(char* i_clusterName, bool i_allocateAssets, bool i_asyncLoad, bool& o_clusterExists);
CoreAnimSequencer* CoreWorld::PreLoadAnimSequencer(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreAnimationSet* CoreWorld::PreLoadAnimationSet(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreModelCompiled* CoreWorld::PreLoadModelCompiled(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreModelCompiled* CoreWorld::PreLoadEngine(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreTextureSet* CoreWorld::PreLoadTextureSet(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
CoreFont* CoreWorld::PreLoadFont(uint32_t i_clientID, char* i_assetName, bool i_asyncLoad, CoreHash& o_assetHash, bool& o_fileExists);
bool CoreWorld::UnLoadScritpStore(CoreHash i_assetHash);
bool CoreWorld::UnLoadAnimationSet(CoreHash i_assetHash);
bool CoreWorld::UnLoadAnimSequencer(CoreHash i_assetHash);
bool CoreWorld::UnLoadModelCompiled(CoreHash i_assetHash);
bool CoreWorld::UnLoadTextureSet(CoreHash i_assetHash);
bool CoreWorld::UnLoadSpecificFile(CoreHash i_assetHash, CoreHash i_assetType);
bool CoreWorld::UnLoadDataFile(CoreHash i_assetHash);
uint32_t* CoreWorld::GetScriptStore(CoreHash i_scriptStoreName);
CoreAnimationSet* CoreWorld::GetAnimationSet(CoreHash i_animationSetName);
CoreAnimSequencer* CoreWorld::GetAnimSequencer(CoreHash i_animSequencerName);
CoreModelCompiled* CoreWorld::GetModelCompiled(CoreHash i_modelName);
void* CoreWorld::GetSpecificFile(CoreHash i_assetHash, CoreHash i_assetType);
void* CoreWorld::GetDataFile(CoreHash i_assetHash);
CoreTextureSet* CoreWorld::GetTextureSet(char* i_textureSet, CoreHash& o_assetHash);
CoreFont* CoreWorld::GetFont(char* i_font, CoreHash& o_assetHash);
bool CoreWorld::DoesLevelScriptExist(char* i_levelName, char* i_areaName);
bool CoreWorld::DoesLevelClusterExist(char* i_levelName, char* i_areaName);
bool CoreWorld::DoesDataFileExist(char* i_assetName);
bool CoreWorld::CanICreateAsset(char* lpcFileName, CoreHash i_assetID, CoreHash assetType, void* lpUserData);
bool CoreWorld::CreateAsset(char* lpcFileName, CoreHash i_assetID, CoreHash i_assetType, void* lpAssetPtr, void* lpUserData, CoreAssetManager* lpoAssetManager, bool bAsync);
bool CoreWorld::DeleteAsset(CoreHash i_assetID, CoreHash i_assetType, void* lpAssetPtr, void* lpUserData);
bool CoreWorld::MoveAsset(CoreHash i_assetID, CoreHash i_assetType, void* lpAssetPtr, void* lpUserData);
CoreLevel* CoreWorld::GetLevel();
CoreDetect* CoreWorld::GetDetect();
CoreAIController* CoreWorld::GetAIController();
CorePhysicsWorld* CoreWorld::GetPhysicsWorld();
CorePanel* CoreWorld::GetPanel();
CoreAssetManager* CoreWorld::GetAssetManager();
bool CoreWorld::IsPaused();
bool CoreWorld::IsRemoteMachinePaused();
void CoreWorld::SetPaused(bool bPaused, bool bPauseAudio);
uint32_t CoreWorld::GetActivePadIDForMenu();
float CoreWorld::GetTimeScale();
void CoreWorld::SetTimeScale(float fTimeScale);
bool CoreWorld::IsSimulatingPSP();
void CoreWorld::SetSimulatePSP(bool i_simulatePSP);
void CoreWorld::AssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType, void* lpUsrData1, void* lpUsrData2);
void CoreWorld::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreHash i_assetID, CoreHash i_assetType);
void* CoreWorld::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreWorld::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::eFnWorldUpdateWhileFade(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreWorld::eFnLoadModel(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreWorld::eFnLoadTextureSet(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreWorld::eFnLoadFont(CoreCommand* lpoCommand);
bool CoreWorld::LoadFontFiles(char* i_name, bool i_asyncLoad, bool& o_exists);
CoreScripted::CommandReturn CoreWorld::eFnLoadAnimSet(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreWorld::eFnFXFont(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreWorld::eFnLoadLevel(CoreCommand* lpoCommand);
CoreScripted::CommandReturn CoreWorld::eFnPauseFrames(CoreCommand*);
CoreScripted::CommandReturn CoreWorld::eFnLoadingScreen(CoreCommand* lpoCommand);
void CoreWorld::CancelAssetLoading();
CoreScripted::CommandReturn CoreWorld::fnLoadCluster(CoreCommand* io_command);
float CoreWorld::GetNumDetectCaches();
CoreScripted::CommandReturn CoreWorld::FnIsQuickStart(CoreCommand* io_command);
CoreScripted::CommandReturn CoreMenuSystem::FnIsQuickStart(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetFontButtonTextures(CoreCommand* io_command);
CoreHash CoreWorld::HandleFont(CoreCommand* io_command);
CoreHash CoreWorld::HandleTextureSet(CoreCommand* io_command);
CoreHash CoreWorld::HandleSoundHash(CoreCommand* io_command);
void CoreWorld::HandleColour(CoreRGBA& o_colour, CoreCommand* io_command);
void CoreWorld::HandleButtonText(CoreGameButtonText& o_buttonText, CoreCommand* io_command);
void CoreWorld::HandleFrameCornerTextures(CoreGameFrame& o_frame, CoreCommand* io_command);
void CoreWorld::HandleFrameEdgeTextures(CoreGameFrame& o_frame, CoreCommand* io_command);
void CoreWorld::HandleFrameBackGroundTextures(CoreGameFrame& o_frame, CoreCommand* io_command);
void CoreWorld::HandleFrameEdgeSizes(CoreGameFrame& o_frame, CoreCommand* io_command);
void CoreWorld::HandleFrameBackGroundOffsets(CoreGameFrame& o_frame, CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFont(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxTextureSet(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxCentre(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxMaximumWidth(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxMaximumHeight(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxMessageTextScales(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxButtonsTextScales(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxSpaceBetweenTextAndFrame(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxSpaceBetweenTextAndButtons(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxSpaceBetweenTextButtons(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxButtonSurround(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxButtonMinimumWidth(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxButtonTexture(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxButtonInputWrap(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxSelectedButtonFlash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFadeTimes(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxScreenBackGroundColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxTextColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxButtonTextColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxSelectedButtonTextColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxButtonBackGroundColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFrameCornerTextures(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFrameEdgeTextures(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFrameBackGroundTextures(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFrameEdgeSizes(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFrameBackGroundOffsets(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFrameBackGroundColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFrameEdgeColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxFrameTextureColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxOkButtonText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxNoButtonText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxYesButtonText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxRetryButtonText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxCancelButtonText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxStartSoundHash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxSelectSoundHash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxLeftSoundHash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetMessageBoxRightSoundHash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnMessageBoxSaveSettings(CoreCommand* io_command);
void MessageBoxFinishedCallBack(void* i_callBackUserData, CORE_MB_RESULT_TAG i_result, int32_t i_selectedButtonIndex);
CoreScripted::CommandReturn CoreWorld::HandleMessageBox(CoreCommand* io_command, CoreMessageBoxInterface::CoreMessageBoxTypeTag i_type);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFont(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKTextureSet(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKSpaceButtonText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKDeleteButtonText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKCancelButtonText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKDoneButtonText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKCentre(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKSize(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKTitleTextScales(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKButtonsTextScales(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKEditedTextScales(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKSpacesBetweenTextAndFrame(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKSpaceBetweenTitleAndButtons(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKSpaceBetweenButtonsAndEditedText(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKHighLightFlash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFadeTimes(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKStartSoundHash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKSelectSoundHash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKCancelSoundHash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKMoveSoundHash(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKScreenBackGroundColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKTitleTextColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKTitleAreaBackGroundColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKButtonsTextColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKButtonsHighLightedTextColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKButtonsAreaBackGroundColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKEditedTextColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKEditedTextAreaBackGroundColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFrameCornerTextures(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFrameEdgeTextures(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFrameBackGroundTextures(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFrameEdgeSizes(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFrameBackGroundOffsets(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFrameBackGroundColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFrameEdgeColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnSetOSKFrameTextureColour(CoreCommand* io_command);
CoreScripted::CommandReturn CoreWorld::FnOSKSaveSettings(CoreCommand* io_command);
void OSKFinishedCallBack(void* i_callBackUserData, char* i_resultString, CORE_OSK_RESULT_TAG i_result, int32_t i_inputIndex, bool i_lastCallBack);
CoreScripted::CommandReturn CoreWorld::FnOSK(CoreCommand* io_command);
void CoreWorld::SetSoakTest(bool i_enable);
bool CoreWorld::GetSoakTest();
void CoreWorld::ToggleSoakTest();
void CoreWorld::StartANewLevelGoing();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corebatchrender.cpp
void CoreBatchRender::CoreBatchRender();
void CoreBatchRender::~CoreBatchRender();
void CoreBatchRender::Init(CoreMemory* pMemory, CoreTextureSet* pTexSet, bool i_alloc);
void CoreBatchRender::Update(CoreTextureSet* pTexSet);
void CoreBatchRender::BeginScene();
void CoreBatchRender::AddMesh(CoreGeometryCompiled* pMesh, uint32_t iFlags, CoreTextureInfo* pTexInfo, CoreTexturePage* pTexPage, uint32_t pass);
void CoreBatchRender::Reset(uint32_t i_pass);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coredebug\coredebug.cpp
int32_t CoreProfileEntry::GetAverageCount();
bool CoreDebug::bCreateList(int32_t iCommandListLength, int32_t iMinCommandListLength, int32_t iMaxNumProfileEntries, CoreMemory* lpoMemory);
bool CoreDebug::bAddHeaderToList(int32_t iNumQuadWords, CoreDebug::CoreCommandEnum eCommand, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
bool CoreDebug::bAddVectorToList(CoreVector& vPos);
bool CoreDebug::bAddStringToList(char* lpcText, int32_t iLen);
bool CoreDebug::bReadMatrixFromList(CoreMatrix& o_transform);
bool CoreDebug::bReadVectorFromList(CoreVector& vVec);
bool CoreDebug::bReadStringFromList(char*& lpcText, int32_t iLen);
void CoreDebug::DrawTriangleWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos0, CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawLineWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawGouraudLineWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, CoreRGBA oColour2, bool bForeground);
void CoreDebug::DrawArrowWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawQuadScreen(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vCentre, CoreVector& vSize, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawSphereWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vCentre, float fRadius, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawSausageWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos1, CoreVector& vPos2, float fRadius, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawConeWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos1, CoreVector& vPos2, float fAngle, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawWireBBoxWorld(CoreDebug::CoreDebugLevelEnum i_level, CoreVector& i_min, CoreVector& i_max, CoreRGBA i_colour, bool i_foreground);
void CoreDebug::DrawBBoxWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& i_min, CoreVector& i_max, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawCubeWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vCentre, CoreVector& vSize, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawWireCubeWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vCentre, CoreVector& vSize, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawTextScreen(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos, CoreRGBA oColour, bool bForeground, char* lpcText);
void CoreDebug::DrawTextWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreVector& vPos, CoreRGBA oColour, bool bForeground, char* lpcText);
void CoreDebug::Message(CoreDebug::CoreDebugLevelEnum eLevel, char* lpcText);
void CoreDebug::Printf(CoreDebug::CoreDebugLevelEnum eLevel, char* lpcText);
void CoreDebug::DrawConsoleText(CoreDebug::CoreDebugLevelEnum eLevel, CoreRGBA oColour, char* lpcText);
void CoreDebug::DrawCurveNameWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreCurveSetData* lpoCurve, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawCurveCVsWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreCurveSetData* lpoCurve, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawCurveHullWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreCurveSetData* lpoCurve, CoreRGBA oColour, bool bForeground);
void CoreDebug::DrawCurveSplineWorld(CoreDebug::CoreDebugLevelEnum eLevel, CoreCurveSetData* lpoCurve, CoreRGBA oColour, bool bForeground);
void CoreDebug::AddTriangleToList(CoreVector& vPos0, CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddFlatLineToList(CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddGouraudLineToList(CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour1, CoreRGBA oColour2, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddArrowToList(CoreVector& vFrom, CoreVector& vTo, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddQuadToList(CoreVector& vCentre, CoreVector& vSize, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddSphereToList(CoreVector& vCentre, float fRadius, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddCubeToList(CoreVector& vCentre, CoreEulerAngle& eaOrient, CoreVector& vSize, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddWireCubeToList(CoreVector& vCentre, CoreEulerAngle& eaOrient, CoreVector& vSize, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddConeToList(CoreVector& vPos1, CoreVector& vPos2, float fAngle, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddSausageToList(CoreVector& vPos1, CoreVector& vPos2, float fRadius, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddDebugTextToList(char* lpcText, CoreVector& vPos, CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::AddConsoleTextToList(char* lpcText, CoreRGBA oColour, CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::Render(CoreGraphicsDevice* io_graphicsDevice, int32_t iGameFrameRate, bool i_renderZ);
void CoreDebug::RenderCommandList(CoreGraphicsDevice* io_graphicsDevice, CoreQWORD* lpqwListEnd, CoreDebug::CoreDrawTypeEnum eIgnoreDrawType1, CoreDebug::CoreDrawTypeEnum eIgnoreDrawType2);
void CoreDebug::RenderFlatLine(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderGouraudLine(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderArrow(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderCircle(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderSphereMatrix(CoreRGBA i_colour, CoreDebug::CoreDrawTypeEnum i_drawType, CoreGraphicsDevice* i_device);
void CoreDebug::RenderSphere(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderCylinder(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderSausage(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderCube(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderWireCube(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderCone(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderConeMatrix(CoreRGBA i_colour, CoreDebug::CoreDrawTypeEnum i_drawType, CoreGraphicsDevice* i_device);
void CoreDebug::RenderQuad(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderTriangle(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice);
void CoreDebug::RenderDebugText(CoreRGBA oColour, CoreDebug::CoreDrawTypeEnum eDrawType, CoreGraphicsDevice* io_graphicsDevice, int32_t iStringLen);
void CoreDebug::RenderConsoleText(CoreRGBA oColour, CoreGraphicsDevice* io_graphicsDevice, int32_t iStringLen);
void CoreDebug::ChangeDebugLevel(CoreDebug::CoreDebugLevelEnum eNewLevel);
void CoreDebug::CycleDebugLevel(int32_t iDelta);
void CoreDebug::SetActive(bool bActive);
void CoreDebug::Update(bool bRunDoDebug, CoreDebugInput* i_input, CoreWorldUpdateStruct* lpoWorldUpdateStruct);
void CoreDebug::StartProfilerInternal(uint32_t uiTimerCount);
void CoreDebug::ProfilerPushInternal();
void CoreDebug::ProfilerPopInternal();
void CoreDebug::EndProfilerInternal(uint32_t uiTimerCount);
CoreProfileEntry* CoreDebug::FindFreeProfileEntry(uint32_t uiHash, bool& bFound);
void CoreDebug::ProfileInternal(uint32_t uiTimerCount, CoreRGBA oColour, char* i_name);
void CoreDebug::CycleProfileLevel(int32_t iDelta);
void CoreDebug::RenderProfiler(CoreGraphicsDevice* io_graphicsDevice, int32_t iGameFrameRate);
void CoreDebug::ToggleProfileTextDisplay();
bool CoreDebug::bRegisterClient(char* i_name, int32_t iLevel, void* lpDoDebugFunc, void* lpUserData);
bool CoreDebug::bAddClientToList(char* i_name, int32_t iLevel, void* lpDoDebugFunc, void* lpUserData);
void CoreDebug::SortClientList();
bool CoreDebug::IsLevelActive(CoreDebug::CoreDebugLevelEnum eLevel);
void CoreDebug::SetDebugVar(uint32_t val);
void CoreDebug::SetDebugLevelFromCommandLine();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coredebug\coredebuginput.cpp
void CoreDebugInput::CoreDebugInput();
void CoreDebugInput::~CoreDebugInput();
bool CoreDebugInput::IsKeyPressed(CoreHash i_key);
bool CoreDebugInput::IsKeyClicked(CoreHash i_key);
uint32_t CoreDebugInput::GetLastKeyClicked();
void CoreDebugInput::InitData();
void CoreDebugInput::SetKeyPressed(CoreHash i_pressedKey);
void CoreDebugInput::SetLastKeyClicked(uint32_t i_lastKeyClicked);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coregraphicsdevice.cpp
CoreGraphicsDevice* CoreGraphicsDevice::CreateDevice(CoreMemory* i_memory, CoreHash i_type);
void CoreGraphicsDevice::CoreGraphicsDevice();
void CoreGraphicsDevice::Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams, char* lpcAppName);
void CoreGraphicsDevice::Destruct(CoreMemory* lpoMemory);
void CoreGraphicsDevice::Init();
void CoreGraphicsDevice::Reset();
void CoreGraphicsDevice::DoDebug(CoreDebugInput* i_input);
void CoreGraphicsDevice::SetDisplayAspectRatio(float fWidth, float fHeight);
void CoreGraphicsDevice::SetCamera(CoreVector& vPos, CoreEulerAngle& eaOrient);
CoreMatrix CoreGraphicsDevice::MakeViewMatrix();
void CoreGraphicsDevice::SetCameraProperties(float fVerticalFieldOfView, float fNearClip, float fFarClip, float fDisplayAspectRatio, bool i_fogOn, float i_fogNear, float i_fogFar, float i_fogRed, float i_fogGreen, float i_fogBlue, float i_fogAlpha, bool i_bloom, float i_bloomIntensity, float i_bloomFeedback, float i_bloomThreshold, bool i_focalBlur, float i_focalBlurZ, float i_focalBlurAmount, bool i_motionBlur, float i_motionBlurAmount, bool i_radialBlur, float i_radialBlurAngle, float i_radialBlurScale, float i_radialBlurCenterX, float i_radialBlurCenterY, bool i_FSFX0, bool i_FSFX1, bool i_FSFX2, bool i_FSFX3, bool i_FSFX4, bool i_FSFX5, bool i_FSFX6, bool i_FSFX7, bool i_FSFX8, bool i_FSFX9);
void CoreGraphicsDevice::PrintString(CoreVector& vPos, CoreRGBA oColour, char* lpcText);
void CoreGraphicsDevice::PrintStringScreen(CoreVector& vPos, CoreRGBA oColour, char* lpcText);
void CoreGraphicsDevice::PrintString2D(CoreVector& vPos, CoreRGBA oColour, char* lpcText);
void CoreGraphicsDevice::Line2D(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
void CoreGraphicsDevice::LineStrip2D(CoreVector& vPos, CoreVector& vScale, float* lpfCoordPointer, int32_t iNumCoords, CoreRGBA oColour);
void CoreGraphicsDevice::UnfilledBox2D(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour);
void CoreGraphicsDevice::FilledBox2D(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour);
void CoreGraphicsDevice::Triangle2D(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreRGBA oColour);
void CoreGraphicsDevice::Quad2D(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour);
void CoreGraphicsDevice::TexturedQuad2D(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour, CoreUV oUV0, CoreUV oUV1, CoreUV oUV2, CoreUV oUV3);
void CoreGraphicsDevice::SetFontScale(float i_scale);
float CoreGraphicsDevice::GetFontWidth();
float CoreGraphicsDevice::GetFontHeight();
void CoreGraphicsDevice::UnfilledBoxScreen(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour);
void CoreGraphicsDevice::FilledBoxScreen(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour);
void CoreGraphicsDevice::TexturedFilledBoxScreen(CoreVector& vPos1, CoreVector& vPos4, CoreRGBA oColour, CoreUV oUV1, CoreUV oUV4);
void CoreGraphicsDevice::ArrowScaled(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour, float i_arrowScale);
void CoreGraphicsDevice::Arrow(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
void CoreGraphicsDevice::ArrowScreenScaled(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour, float i_arrowScale);
void CoreGraphicsDevice::ArrowScreen(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
void CoreGraphicsDevice::Circle(CoreVector& vCentre, float fRadius, CoreRGBA oColour);
void CoreGraphicsDevice::CircleScreen(CoreVector& vCentre, float fRadius, CoreRGBA oColour);
void CoreGraphicsDevice::Sphere(CoreVector& vCentre, float fRadius, CoreRGBA oColour);
void CoreGraphicsDevice::SphereScreen(CoreVector& vCentre, float fRadius, CoreRGBA oColour);
void CoreGraphicsDevice::Cylinder(CoreVector& vBaseCentre, float fRadius, float fHeight, CoreRGBA oColour);
void CoreGraphicsDevice::CylinderScreen(CoreVector& vBaseCentre, float fRadius, float fHeight, CoreRGBA oColour);
void CoreGraphicsDevice::Sausage(CoreVector& vPos1, CoreVector& vPos2, float fRadius, CoreRGBA oColour);
void CoreGraphicsDevice::Cone(CoreVector& vPos1, CoreVector& vPos2, float fAngle, CoreRGBA oColour);
void CoreGraphicsDevice::DrawModelCompiled(CoreGraphicsDeviceModelCompiledInfo* lpoModelInfo);
void CoreGraphicsDevice::SetMatrixList(CoreMatrix* lpmtMatrixList, char* lpcVisibleList, uint32_t uiNumEntriesInMatrixList);
void CoreGraphicsDevice::SphereObject(CoreVector& vCentre, CoreEulerAngle& eaOrient, CoreVector& vScale, CoreRGBA oColour);
void CoreGraphicsDevice::CylinderObject(CoreVector& vBaseCentre, CoreEulerAngle& eaOrient, CoreVector& vScale, CoreRGBA oColour);
void CoreGraphicsDevice::WireFrameCuboidObject(CoreVector& vPos, CoreEulerAngle& eaOrient, CoreVector& vScale, CoreRGBA oColour);
void CoreGraphicsDevice::SolidCuboidObject(CoreVector& vPos, CoreEulerAngle& eaOrient, CoreVector& vScale, CoreRGBA oColour);
void CoreGraphicsDevice::SetObject2World(CoreMatrix& mtObject2World);
void CoreGraphicsDevice::SetLocal2Object(CoreMatrix& mtLocal2Object);
void CoreGraphicsDevice::SetTexture(CoreTextureSet* i_texSet, CoreTextureInfo* i_texInfo, uint32_t i_pass);
void CoreGraphicsDevice::SetUnLit(CoreTextureSet* i_texSet, CoreTextureInfo* i_texInfo, uint32_t i_flags, uint32_t i_pass);
void CoreGraphicsDevice::EnableAlphaBlend();
void CoreGraphicsDevice::DisableAlphaBlend();
void CoreGraphicsDevice::SetAlphaBlendFunc();
void CoreGraphicsDevice::SetAdditiveBlendFunc();
void CoreGraphicsDevice::SetSubtractiveBlendFunc();
void CoreGraphicsDevice::SetFixedAlphaBlendFunc(float fFixedAlpha);
void CoreGraphicsDevice::SetDestinationAlphaBlendFunc();
void CoreGraphicsDevice::SetDestinationAlphaAdditiveBlendFunc();
void CoreGraphicsDevice::SetAlphaWriteOnlyBlendFunc();
void CoreGraphicsDevice::DisableTexturing();
void CoreGraphicsDevice::EnableTexturing();
void CoreGraphicsDevice::GouraudShading(bool bEnable);
void CoreGraphicsDevice::CycleTextureShading();
uint32_t CoreGraphicsDevice::uiBeginGeometryPass(int32_t);
void CoreGraphicsDevice::StartSortedMeshRendering();
void CoreGraphicsDevice::EndSortedMeshRendering();
void CoreGraphicsDevice::RenderMeshInfo(CoreGraphicsDeviceMeshInfo* i_meshInfo, uint32_t i_lastObjectHash);
bool CoreGraphicsDevice::AddMeshInfo(CoreHash i_type, char* i_name, CoreGraphicsDeviceModelCompiledInfo* lpoModelCompiledInfo, int32_t iMaterialIndex, uint32_t uiMaterialHash, CoreModelMaterial* lpoModelMaterial, bool i_sorted);
uint32_t CoreGraphicsDevice::FindMeshInfoIndex(CoreHash i_type, CoreGraphicsDeviceMeshInfo* i_meshInfo);
bool CoreGraphicsDevice::AddSortedMeshInfo(CoreGraphicsDeviceMeshInfo* i_meshInfo);
void CoreGraphicsDevice::SetLevelLightSet(CoreLevelLightSet* lpoLevelLightSet);
int32_t CoreGraphicsDevice::ActivateLightVolume(CoreGraphicsDevice::CoreLightVolumeShape i_shape);
bool CoreGraphicsDevice::DeActivateLightVolume(int32_t i_index);
bool CoreGraphicsDevice::SetLightVolumeTransform(int32_t i_index, CoreVector& i_position, CoreEulerAngle& i_orientation, CoreVector& i_scale);
CoreGeometry::CoreInViewEnum CoreGraphicsDevice::IsSphereInView(CoreVector centre, float radius);
CoreGeometry::CoreInViewEnum CoreGraphicsDevice::IsBBoxInView(CoreVector i_min, CoreVector i_max);
CoreTextureInfo* CoreGraphicsDevice::GetDrawBufferTexture();
void CoreGraphicsDevice::ResetRenderStates();
void CoreGraphicsDevice::ComputeFrustrumPlanes();
CorePlaneEquation* CoreGraphicsDevice::GetFrustrumPlanes();
bool CoreGraphicsDevice::SnapshotDrawBuffer(char* i_name);
bool CoreGraphicsDevice::SnapshotVideoMemory(char* i_name);
bool CoreGraphicsDevice::WriteTGA(uint32_t* i_img, uint32_t i_width, uint32_t i_height, char* i_name);
void CoreGraphicsDevice::ClearZBuffer();
void CoreGraphicsDevice::PanicModeRender();
void CoreGraphicsDevice::RenderLevelMeshList(CoreModelMaterial*** iModelMaterialLists, uint32_t* iNumModelsPerList, uint32_t* iInViewList, uint32_t iNumTotalLists, CoreTextureSet* iTextureSet);
void CoreGraphicsDevice::DrawStaticModelCompiledNonDebug(CoreGraphicsDeviceModelCompiledInfo* i_modelInfo);
void CoreGraphicsDevice::SetNumScreens(uint32_t i_count);
void CoreGraphicsDevice::InitScreen(uint32_t i_index);
void CoreGraphicsDevice::GetGeometryCompiledReport(CoreModelMesh* iModelMesh, CoreStringBuffer<256>& iStr);
void CoreGraphicsDevice::GetGeometryCompiledInfo(CoreModelMesh* iModelMesh, uint32_t& nVerts);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coregraphicsdevice.h
void CoreGraphicsDeviceNull::QuadScreen(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA);
void CoreGraphicsDeviceNull::SausageObject(CoreVector&, CoreEulerAngle&, float, float, CoreRGBA);
void CoreGraphicsDeviceNull::LineStrip(CoreVector&, CoreVector&, float*, int32_t, CoreRGBA);
void CoreGraphicsDeviceOpenGL::SetShadowDirection(CoreVector shadowDir, float maxShadowLength);
void CoreGraphicsDeviceNull::SetShadowDirection(CoreVector, float);
void CoreGraphicsDeviceNull::ConeObject(CoreVector&, float, float, CoreEulerAngle&, CoreRGBA);
void CoreGraphicsDeviceNull::Quad(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA);
void CoreGraphicsDeviceNull::LineStripScreen(CoreVector&, CoreVector&, float*, int32_t, CoreRGBA);
void CoreGraphicsDevice::AddStaticMesh(CoreGeometryCompiled*, uint32_t, CoreTextureInfo*, CoreTexturePage*, uint32_t);
void CoreGraphicsDeviceNull::LineStrip2D(CoreVector&, CoreVector&, float*, int32_t, CoreRGBA);
void CoreGraphicsDeviceNull::GouraudLine(CoreVector&, CoreVector&, CoreRGBA, CoreRGBA);
void CoreGraphicsDeviceNull::GouraudLineScreen(CoreVector&, CoreVector&, CoreRGBA, CoreRGBA);
void CorePhysicsArticulate::initJoints(CoreMemory* mem, CorePhysicsWorld* pWorld, CoreModelSkeleton* skele, int32_t numJoints);
void CoreBlenderBasic::SetSlotWeight(CoreHash& i_slotID, float i_weight, float i_time, bool i_killOnZeroWeight);
void CoreObjectController::CreateDealWithExtendedData(CoreHash, CoreObject*, void*, CoreObjectUpdateStruct*);
void CoreGraphicsDeviceNull::TriangleScreen(CoreVector&, CoreVector&, CoreVector&, CoreRGBA);
void CoreBlenderSimple::SetSlotWeight(CoreHash& i_slotID, float i_weight, float i_time, bool i_killOnZeroWeight);
void CoreGraphicsDeviceNull::SelectTexture(CoreTexturePage*, CoreTextureInfo*, CoreGraphicsDevice::CoreTextureFilterTypes, uint32_t);
void CoreGraphicsDeviceNull::Triangle(CoreVector&, CoreVector&, CoreVector&, CoreRGBA);
void CoreGraphicsDevice::SetRenderProfileMark(char*, uint32_t, uint32_t, uint32_t);
CoreModelMaterial* CoreGraphicsDevice::CopyAndLightMaterialMesh(CoreModelMaterial*, CoreVector, CoreVector);
CoreVector CoreGraphicsDevice::unProject(float iX, float iY, float iZ);
CoreVector CoreGraphicsDevice::Project(float iX, float iY, float iZ);
void CoreGraphicsDevice::getLocalMousePos(float& oX, float& oY);
void CoreGraphicsDevice::getLocalMouseDelta(float& oX, float& oY);
CoreMatrix CoreGraphicsDevice::GetWorldToScreenMatrix();
void CoreMenuComponent::SetRGBABackground(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
void CoreMenuComponent::SetRGBAHighlight(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
void CoreMenuComponent::SetRGBANormalText(float i_red, float i_green, float i_blue, float i_alpha, int32_t i_mode, float i_time);
void CoreGraphicsDevice::UpdateMeshTagColours(CoreGeometryCompiled* iModelCompiled, uint32_t iLightID, uint32_t iblendFrameStart, uint32_t iblendFrameEnd, uint32_t iblendTime, uint32_t iblendTimeMax);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coregraphicsdevicenull.h
void CoreGraphicsDeviceNull::Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams, char* lpcAppName);
void CoreGraphicsDeviceNull::Destruct(CoreMemory* lpoMemory);
void CoreGraphicsDeviceNull::Init();
void CoreGraphicsDeviceNull::SetCamera(CoreVector& i_pos, CoreEulerAngle& i_angle);
CoreVector CoreGraphicsDeviceNull::vViewToScreen(CoreVector&, bool& bZclipped);
CoreVector CoreGraphicsDeviceNull::vWorldToScreen(CoreVector&, bool& bZclipped);
void CoreGraphicsDeviceNull::TexturedQuad(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA, CoreUV, CoreUV, CoreUV, CoreUV);
void CoreGraphicsDeviceNull::TexturedQuadScreen(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA, CoreUV, CoreUV, CoreUV, CoreUV);
void CoreGraphicsDeviceOpenGL::TexturedQuadFast(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA, uint32_t*, uint32_t*);
void CoreGraphicsDeviceNull::SelectMaterialProperties(CoreVector&, CoreVector&, float, CoreVector&, float, uint32_t, uint32_t);
void CoreGraphicsDevice::SetTextureFilterSettings(bool overrideTextureFilterSettings, int32_t lcmValue, int32_t maxMipMapLevel, int32_t mmagValue, int32_t mminValue, int32_t lodLValue, int32_t lodKValue);
void CoreGraphicsDeviceNull::TexturedQuadFast(CoreVector&, CoreVector&, CoreVector&, CoreVector&, CoreRGBA, uint32_t*, uint32_t*);
float CoreGraphicsDeviceNull::GetFontHeight();
float CoreGraphicsDeviceNull::GetFontWidth();
float CoreGraphicsDevice::GetDisplayListUsage();
bool CoreGraphicsDeviceNull::bCanILoadModelData(char*);
bool CoreGraphicsDeviceOpenGL::bCanILoadTextureData(char*);
bool CoreNamedPipeDummyInterface::IsDataReady(int32_t i_size);
bool CoreGraphicsDeviceNull::bCanILoadTextureData(char*);
bool CoreGraphicsDeviceOpenGL::bCanILoadModelData(char*);
bool CoreGraphicsDeviceNull::bLoadTextureData(char*, CoreTextureSet*, CoreAssetManager*, bool);
bool CoreGraphicsDeviceOpenGL::bLoadModelData(char*, CoreModelGeometry*, CoreAssetManager* lpoAssetManager, bool bAsync);
bool CoreGraphicsDeviceNull::bLoadModelData(char*, CoreModelGeometry*, CoreAssetManager*, bool);
bool CoreAnimatingObject::HandleAnimCommandCallback(CoreHash i_slotID, CoreAnimCommand* i_command);
bool CoreBlenderBasic::CanAddAnim(CoreHash& i_slotID, CoreHash& i_animID);
bool CoreBlenderSimple::CanAddAnim(CoreHash& i_slotID, CoreHash& i_animID);
bool CoreGraphicsDeviceNull::bCanILoadLevelData(char*, char*);
bool CoreGraphicsDeviceOpenGL::bCanILoadLevelData(char*, char*);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corebglightcontroller.cpp
CoreBGLightController* CoreBGLightController::GetLightControllerFromID(CoreLevelCompiled* iLevelCompiled, uint32_t iID);
uint32_t CoreBGLightController::GetNumLightControllers(CoreLevelCompiled* iLevelCompiled);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corecurveset\corecurvesetdata.cpp
CoreVector CoreCurveSetData::GetPosition(float fLength);
CoreVector CoreCurveSetData::GetTangent(float fLength);
CoreVector CoreCurveSetData::GetSegmentPosition(int32_t iSegment, float fAlpha);
CoreVector CoreCurveSetData::GetSegmentTangent(int32_t iSegment, float fAlpha);
float CoreCurveSetData::GetNearestPoint(CoreVector& vPoint, CoreVector& vNearestPoint, float& fDistance, int32_t& iBestSegment, float& fSegmentAlpha);
float CoreCurveSetData::GetNearestPointFast(CoreVector& vPoint, CoreVector& vNearestPoint, float& fDistance, int32_t& iBestSegment, float& fSegmentAlpha);
void CoreCurveSetData::GetControlPoints(int32_t iSegment, CoreVector& vPoint0, CoreVector& vPoint1, CoreVector& vPoint2, CoreVector& vPoint3);
bool CoreCurveSetData::IsWithinVolume(CoreVector& vPoint);
int32_t CoreCurveSetData::iLineIntersectsVolumeXZ(CoreVector& vStart, CoreVector& vEnd, int32_t iMaxNumCrossingPoints, CoreVector* lpvCrossingPoints, bool* lpbCrossingPointsEnteringVolume);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corecurveset\corecurvesetdata.h
CoreVector CoreCurveSetData::GetOrigin();
CoreVector CoreCurveSetData::GetPoint(int32_t iPoint);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corelevelcompiled.cpp
bool CoreLevelCompiled::CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
void CoreDetectionData::ComputeBBox(CoreVector& o_bboxMin, CoreVector& o_bboxMax);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\coreleveldynamicflap.cpp
[! NO TYPE] CoreLevelDynamicFlap::operator=();
void CoreLevelDynamicFlap::SetPosition(CoreVector& vPosition);
void CoreLevelDynamicFlap::SetOrientation(CoreEulerAngle& eaOrient);
void CoreLevelDynamicFlap::SetSize(float fXSize, float fYSize);
void CoreLevelDynamicFlap::SetSoftnessDistance(float fSoftnessDistance);
void CoreLevelDynamicFlap::SetOpen(bool bLeft, bool bRight, bool bTop, bool bBottom);
CoreVector CoreLevelDynamicFlap::GetPosition();
CoreEulerAngle CoreLevelDynamicFlap::GetOrient();
float CoreLevelDynamicFlap::GetXSize();
float CoreLevelDynamicFlap::GetYSize();
float CoreLevelDynamicLight::GetInnerRadius();
float CoreLevelDynamicFlap::GetSoftnessDistance();
bool CoreLevelDynamicFlap::GetOpenLeft();
uint32_t CAL1_Sample::GetBitsPerSample();
bool CoreLevelDynamicFlap::GetOpenRight();
bool CoreLevelDynamicFlap::GetOpenTop();
bool CoreLevelDynamicFlap::GetOpenBottom();
uint32_t CAL1_Sample::GetNumberOfChannels();
void CoreLevelDynamicFlap::MakeLevelFlap(CoreLevelFlap* lpoLevelFlap);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\coreleveldynamiclight.cpp
void CoreLevelDynamicLight::CoreLevelDynamicLight();
[! NO TYPE] CoreLevelDynamicLight::operator=();
void CoreLevelDynamicLight::SetType(CoreLevelLight::CoreLevelLightTypeEnum eType);
void CoreLevelDynamicLight::SetColours(CoreVector& vInnerColour, CoreVector& vOuterColour);
void CoreLevelDynamicLight::SetIntensity(float fIntensity);
void CoreLevelDynamicLight::SetPosition(CoreVector& vPosition);
void CoreLevelDynamicLight::SetRadii(float fInnerRadius, float fOuterRadius);
void CoreLevelDynamicLight::SetSpotDirection(CoreVector& vDirection);
void CoreLevelDynamicLight::SetCylinderDirection(CoreVector& vDirection);
void CoreLevelDynamicLight::SetDirectionalDirection(CoreVector& vDirection);
void CoreLevelDynamicLight::SetSpotConeAngles(float fInnerConeAngle, float fOuterConeAngle);
void CoreLevelDynamicLight::SetAreaOrientation(CoreEulerAngle& eaOrient);
void CoreLevelDynamicLight::SetAreaSize(float fXSize, float fYSize);
void CoreGameOnScreenKeyboardParameters::SetMoveSoundHash(CoreHash i_soundHash);
void CoreLevelDynamicLight::SetAreaSoftnessDistance(float fSoftnessDistance);
void CoreLevelDynamicLight::SetCylinderLength(float fLength);
char* CoreLevelDynamicLight::GetTypeName();
CoreVector CoreLevelDynamicLight::GetInnerColour();
CoreVector CoreLevelDynamicLight::GetOuterColour();
float CoreLevelDynamicLight::GetIntensity();
CoreVector CoreObject::GetScale();
CoreVector CoreLevelDynamicLight::GetPosition();
CoreEulerAngle CoreLevelDynamicLight::GetOrient();
float CoreLevelDynamicLight::GetOuterRadius();
float CoreLevelDynamicLight::GetSpotInnerConeAngle();
float CoreLevelDynamicLight::GetSpotOuterConeAngle();
float CoreLevelDynamicLight::GetAreaXSize();
float CoreLevelDynamicLight::GetAreaYSize();
float CoreLevelDynamicLight::GetAreaSoftnessDistance();
float CoreLevelDynamicLight::GetCylinderLength();
void CoreLevelDynamicLight::MakeLevelLight(CoreLevelLight* lpoLevelLight);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corelevelfileflap.cpp
void CoreLevelFileFlap::SetPosition(float fX, float fY, float fZ);
void CoreLevelFileFlap::SetPlane(float fX, float fY, float fZ, float fW);
void CoreLevelFileFlap::SetSize(float fXSize, float fYSize);
void CoreLevelFileFlap::SetXNormal(float fX, float fY, float fZ);
void CoreLevelFileFlap::SetYNormal(float fX, float fY, float fZ);
void CoreLevelFileFlap::SetDX(float fDXMinus, float fDXPlus);
void CoreLevelFileFlap::SetDY(float fDYMinus, float fDYPlus);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corelevelfilelight.cpp
void CoreLevelFileFlap::SetName(char* lpcName);
void CoreLevelFileLight::SetName(char* lpcName);
void CoreLevelFileLight::SetHash(uint32_t uiHash);
void CoreNodeRoot::SetHitIndex(int32_t iIndex);
void CoreLevelFileFlap::SetHash(uint32_t uiHash);
void CoreAssetManagerMemoryBlock::SetID(CoreHash assetID);
void CoreLevelFileLight::SetType(int32_t iType);
void CoreLevelFileLight::SetInnerMinusOuterColour(float fRed, float fGreen, float fBlue);
void CoreLevelFileLight::SetOuterColour(float fRed, float fGreen, float fBlue);
void CoreLevelFileLight::SetIntensity(float fIntensity);
void CoreLevelFileLight::SetPosition(float fX, float fY, float fZ);
void CoreLevelFileLight::SetPlane(float fX, float fY, float fZ, float fW);
void CoreLevelFileLight::SetOuterMinusInnerRadius(float fOuterMinusInnerRadius);
void CoreLevelFileLight::SetOuterRadius(float fOuterRadius);
void CoreLevelFileLight::SetSpotCosInnerMinusCosOuterConeAngle(float CosInnerMinusCosOuterConeAngle);
void CoreLevelFileLight::SetAreaXSize(float fXSize);
void CoreLevelFileLight::SetCylinerLength(float fLength);
void CAL1_API::SetAudioData_FrequencyOffset(ca_floatfp freqOffset);
void CoreLevelFileLight::SetAreaYSize(float fYSize);
void CoreLevelFileLight::SetSpotCosOuterConeAngle(float CosOuterConeAngle);
void CAL1_API::SetAudioData_MinDist(ca_floatfp minDist);
void CoreLevelFileLight::SetCylinderEndPoint1(float fX, float fY, float fZ);
void CoreLevelFileLight::SetAreaXNormal(float fX, float fY, float fZ);
void CoreLevelFileLight::SetCylinderEndPoint2(float fX, float fY, float fZ);
void CoreLevelFileLight::SetAreaYNormal(float fX, float fY, float fZ);
void CoreLevelFileLight::SetAreaDXMinus(float fDXMinus);
void CoreLevelFileLight::SetAreaDXPlus(float fDXPlus);
void CoreLevelFileLight::SetAreaDYMinus(float fDYMinus);
void CoreLevelFileLight::SetAreaDYPlus(float fDYPlus);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corelevellight.cpp
char* CoreLevelLight::GetTypeName();
bool CoreLevelLight::bIsInfluenceBox(CoreVector iMin, CoreVector iMax);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corelevellight.h
CoreRGBA CoreLevelLight::GetInnerColour();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corelevellightset.cpp
void CoreLevelLightSetDebugData::CoreLevelLightSetDebugData();
void CoreLevelLightSet::DoDebug(CoreDebugInput* i_input, CoreGraphicsDevice* lpoGraphicsDevice);
void CoreLevelLightSet::DebugDrawLight(int32_t iLight, bool bDrawText, bool bDrawGraphics);
void CoreLevelLightSet::DebugDrawFlap(int32_t iFlap, bool bDrawText, bool bDrawGraphics, bool bFG, bool bActive);
void CoreLevelLightSet::ResetDynamicLights();
int32_t CoreLevelLightSet::FindDynamicLight(CoreHash oName);
bool CoreLevelLightSet::StartEditingDynamicLight(CoreHash oName);
bool CoreLevelLightSet::ResetDynamicLightToBaseValues();
bool CoreLevelLightSet::SetDynamicLightType(CoreLevelLight::CoreLevelLightTypeEnum eType);
bool CoreLevelLightSet::SetDynamicLightPosition(CoreVector& vPosition);
bool CoreLevelLightSet::SetDynamicLightColours(CoreVector& vInnerColour, CoreVector& vOuterColour);
bool CoreLevelLightSet::SetDynamicLightRadii(float fInnerRadius, float fOuterRadius);
bool CoreLevelLightSet::SetDynamicLightIntensity(float fIntensity);
bool CoreLevelLightSet::SetDynamicDirectionalLightDirection(CoreVector& vDirection);
bool CoreLevelLightSet::SetDynamicCylinderLightDirection(CoreVector& vDirection);
bool CoreLevelLightSet::SetDynamicSpotLightDirection(CoreVector& vDirection);
bool CoreLevelLightSet::SetDynamicSpotLightConeAngles(float fInnerConeAngle, float fOuterConeAngle);
bool CoreLevelLightSet::SetDynamicAreaLightOrientation(CoreEulerAngle& eaOrient);
bool CoreLevelLightSet::SetDynamicAreaLightSize(float fXSize, float fYSize);
bool CoreLevelLightSet::SetDynamicAreaLightSoftness(float fSoftness);
bool CoreLevelLightSet::SetDynamicCylinderLightLength(float fLength);
bool CoreLevelLightSet::EndEditingDynamicLight();
void CoreLevelLightSet::ResetDynamicFlaps();
int32_t CoreLevelLightSet::FindDynamicFlap(CoreHash oName);
bool CoreLevelLightSet::StartEditingDynamicFlap(CoreHash oName);
bool CoreLevelLightSet::ResetDynamicFlapToBaseValues();
bool CoreLevelLightSet::SetDynamicFlapPosition(CoreVector& vPosition);
bool CoreLevelLightSet::SetDynamicFlapOrientation(CoreEulerAngle& eaOrient);
bool CoreLevelLightSet::SetDynamicFlapSize(float fXSize, float fYSize);
bool CoreLevelLightSet::SetDynamicFlapEdges(bool bLeftOpen, bool bRightOpen, bool bTopOpen, bool bBottomOpen);
bool CoreLevelLightSet::SetDynamicFlapSoftness(float fSoftness);
bool CoreLevelLightSet::EndEditingDynamicFlap();
void CoreLevelLightSet::SetNumEngineDynamicLights(uint32_t i_num);
void CoreAnimSlot::SetName(CoreHash oName);
void CoreProgramCounter::SetCurrentScript(CoreHash i_scriptName);
void CoreMemoryStackMarker::SetName(CoreHash i_name);
void CoreAnimCommandAutoBlend::SetOldStateHash(CoreHash i_value);
void CoreLevelLightSet::SetEngineDynamicLevelLightPtr(CoreLevelLight* i_ptr);
void CoreLevelLightSet::SettleLights();
void CoreLevelLightSet::SetDynamicLight(uint32_t iIndex);
uint32_t CoreLevelLightSet::GetInfluenceLights(CoreVector iMin, CoreVector iMax, CoreLevelLight** oLightList, uint32_t iMaxLights);
void CoreLevelLightSet::SelectLightsFromList(CoreLevelLight** iLightList, uint32_t iNumLights, CoreVector& vWorldPos, CoreGraphicsDeviceLightData* ioLightData);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corenavigationmesh.cpp
CoreVector CoreNavigationMesh::GetVertex(int32_t iIndex);
int32_t CoreNavigationMesh::GetTriangleVertexIndex(int32_t iTriangle, int32_t iVertex);
CoreNavMeshExit* CoreNavigationMesh::GetExit(int32_t i_exitNum);
CoreNavMeshExit* CoreNavigationMesh::GetExitToMesh(int32_t i_destNM, CoreVector i_closestTo, int32_t i_creatureDef);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\corelevel\corescenecontainer.cpp
void CoreSceneContainer::BindData();
void CoreSceneContainer::ReleaseData();
void CoreSceneContainer::BuildMeshPartitionList(uint32_t iConIndex);
uint32_t CoreSceneContainer::GetLightList(CoreVector iPos, CoreLevelLight**& ioList);
int32_t CoreSceneContainer::PointInContainerIndex(CoreLevelCompiled* iLevelCompiled, CoreVector iPoint);
CoreSceneContainer* CoreSceneContainer::GetPhysicalSceneContainer(CoreVector iPoint, bool iFlipped);
int32_t CoreSceneContainer::GetPhysicalSceneContainerIndex(CoreVector iPoint, bool iFlipped);
int32_t CoreSceneContainer::GetLogicalSceneContainerIndex(CoreVector iPoint, bool iFlipped);
CoreSceneContainer* CoreSceneContainer::GetSceneContainer(uint32_t iIndex);
CoreSceneContainer* CoreSceneContainer::GetLogicalSceneContainer(uint32_t iIndex);
void CoreSceneContainer::SetDynamicLight(bool bActive, uint32_t iLightNum, CoreVector iPos, float iRad, CoreRGBA iRGB);
void CoreSceneContainer::SetRoomCentricView(bool iStatus, uint32_t iRoomNumber, uint32_t iDepth);
void CoreSceneContainer::RecurseRoomCentricView(uint32_t iRoomNumber, uint32_t& iRootDepth, uint32_t& iListIndex);
uint32_t CoreSceneContainer::calculateScene(CoreLevelCompiled* iLevelCompiled, CoreModelMaterial*** iMeshList, uint32_t* iMeshCounts, uint32_t* iMeshFlags);
void CoreSceneContainer::renderDebug(CoreLevelCompiled* iLevelCompiled, uint32_t useContainer);
void CoreSceneContainer::RenderBounds(CoreRGBA iRGBA);
uint32_t CoreSceneContainer::getVisibleRoomList(uint32_t*& ilistPtr);
void CoreSceneContainer::SetFlipStatus(uint32_t iFlip);
uint32_t CoreSceneContainer::GetFlipStatus();
bool CoreSceneContainer::IsPointVisible(CoreVector iPoint, uint32_t iRoom);
bool CoreSceneContainer::IsSphereVisible(CoreVector iPoint, float iRadius, uint32_t iRoom);
void CoreSceneContainer::calcVisibleContainers(CoreLevelCompiled* iLevelCompiled, int32_t iContainer, float* iClip);
bool CoreSceneContainer::cullPortal(CoreVector* pBounds);
bool CoreSceneContainer::calcClipBounds(float* iClipRect, CoreVector* iChkPortal, float* iDstRect);
bool CoreSceneContainer::GetWaterHeightAbovePoint(CoreVector i_pos, float& oWaterHeight, bool iFlipped);
bool CoreSceneContainer::PointInWater(CoreVector iPos, bool iFlipped);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coremodel\coremeshinstanceinfo.h
CoreMatrix CoreMeshInstanceInfo::GetTransform();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coremodel\coremodelcompiled.cpp
bool CoreModelCompiled::CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
bool CoreModelCompiled::IsAnimating();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coremodel\coremodelgeometry.cpp
int32_t CoreModelGeometry::Render(CoreTextureSet* lpoTextureSet, CoreGraphicsDevice* lpoGraphicsDevice, CoreVector i_eyePos, CoreGraphicsDeviceModelCompiledInfo* lpoModelCompiledInfo, int32_t i_materialIndexToDraw, uint32_t uiMeshFlags, uint32_t i_materialNameToDraw, bool i_setMaterial);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coremodel\coremodeljoint.cpp
void CoreModelJoint::DrawParentToChildLine(CoreMatrix* lpoMatrixList, CoreMatrix* lpoJointMatrix, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
void CoreModelJoint::DrawJointBBox(CoreMatrix* lpoJointMatrix, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
void CoreModelJoint::DrawAxes(CoreMatrix* lpoJointMatrix, CoreMatrix& mtLocal2World, CoreGraphicsDevice* lpoDevice);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coremodel\coremodeljoint.h
CoreVector CoreModelJoint::GetBBoxPos();
CoreVector CoreModelJoint::GetBBoxScale();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coremodel\coremodelskeleton.cpp
void CoreModelSkeleton::DrawOrigin(CoreMatrix& mtLocal2World, CoreGraphicsDevice* lpoDevice);
void CoreModelSkeleton::DrawSkeleton(CoreMatrix* lpoMatrixList, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
void CoreModelSkeleton::DrawBBox(CoreMatrix* lpoMatrixList, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
void CoreModelSkeleton::DrawBoneNames(CoreMatrix* lpoMatrixList, CoreMatrix& mtLocal2World, CoreRGBA oColour, CoreGraphicsDevice* lpoDevice);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coretexture\coretextureinfo.h
void CoreTextureInfo::Construct(char* i_debugName, CoreHash i_hash, uint32_t i_pageIndex, uint32_t i_pageX, uint32_t i_pageY, uint32_t i_width, uint32_t i_height, uint32_t i_flags);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coretexture\coretextureset.cpp
bool CoreTextureSet::CheckHeader(char* i_fileName, uint32_t i_platformVersionBit);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\coretexture\pc\coretexturepagepc.h
uint32_t* CoreTexturePagePC::GetMipMapImage32(int32_t iLevel);
uint32_t* CoreTexturePagePC::GetMipMapImage24(int32_t iLevel);
uint32_t* CoreTexturePagePC::GetMipMapImage8(int32_t iLevel);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\pc\corebatchrenderpc.cpp
void CoreBatchRenderPC::CopyTargetMatrix(float* pTarget, CoreMatrix* pSrc);
void CoreBatchRenderPC::RenderBatchedMesh(CoreBatchRender::CoreBatchRenderChainElementFull* pElement);
void CoreBatchRenderPC::GetDeviceCaps();
void CoreBatchRenderPC::Render(uint32_t i_pass);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\pc\corebatchrenderpc.h
void CoreBatchRenderPC::~CoreBatchRenderPC();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\pc\coregraphicsdeviceopengl.cpp
void CoreToGLMatrixNoFiddle(float* fOutput, CoreMatrix& mtInput);
void GLToCoreMatrixNoFiddle(CoreMatrix& mtOutput, float* fInput);
void FiddleMatrix(CoreMatrix& mtInput);
void CoreGraphicsDeviceOpenGL::idleFunction();
void CoreGraphicsDeviceOpenGL::MainLoop(void* i_idleFunction);
void CoreGraphicsDeviceOpenGL::ReshapeCallback(int32_t iWidth, int32_t iHeight);
void CoreGraphicsDeviceOpenGL::Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams, char* lpcAppName);
void CoreGraphicsDeviceOpenGL::Destruct(CoreMemory* lpoMemory);
bool bGlTestForError(char* lpcMsg);
void CoreGraphicsDeviceOpenGL::Init();
void CoreGraphicsDeviceOpenGL::InitCommon();
void CoreGraphicsDeviceOpenGL::Reset();
void CoreGraphicsDevice::ResetLevelOnly();
void CoreGraphicsDeviceNull::Reset();
void CoreGraphicsDeviceNull::DoDebug(CoreDebugInput* i_input);
void CoreGraphicsDeviceOpenGL::DoDebug(CoreDebugInput* i_input);
void CoreGraphicsDeviceOpenGL::SetCamera(CoreVector& vPosition, CoreEulerAngle& eaDirection);
void CoreGraphicsDeviceOpenGL::ClearScreen();
void CoreGraphicsDeviceOpenGL::AddStaticMesh(CoreGeometryCompiled* i_staticMesh, uint32_t iFlags, CoreTextureInfo* pTexInfo, CoreTexturePage* pTexPage, uint32_t pass);
CoreVector CoreGraphicsDeviceOpenGL::vWorldToScreen(CoreVector& vWorld, bool& bZclipped);
CoreVector CoreGraphicsDeviceOpenGL::vViewToScreen(CoreVector& vWorld, bool& o_bZclipped);
void CoreGraphicsDeviceOpenGL::FinishBuffer();
void CoreGraphicsDeviceOpenGL::SwapBuffer();
void CoreGraphicsDeviceOpenGL::SetProjection();
void CoreGraphicsDeviceOpenGL::GouraudLine(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour1, CoreRGBA oColour2);
void CoreGraphicsDeviceOpenGL::Line(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::Triangle(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::Quad(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::TexturedQuad(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour, CoreUV oUV0, CoreUV oUV1, CoreUV oUV2, CoreUV oUV3);
void CoreGraphicsDeviceOpenGL::LineStrip(CoreVector& vPos, CoreVector& vScale, float* lpfCoordPointer, int32_t iNumCoords, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::TriBatch(float* i_triStoreData, CoreRGBA i_colour, uint32_t i_vertexCount);
void CoreGraphicsDeviceOpenGL::TexturedTriBatch(float* i_triStoreData, CoreRGBA i_colour, uint32_t i_vertexCount);
void CoreGraphicsDeviceOpenGL::GouraudLineScreen(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour1, CoreRGBA oColour2);
void CoreGraphicsDeviceOpenGL::LineScreen(CoreVector& vPos1, CoreVector& vPos2, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::TriangleScreen(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::QuadScreen(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::TexturedQuadScreen(CoreVector& vPos1, CoreVector& vPos2, CoreVector& vPos3, CoreVector& vPos4, CoreRGBA oColour, CoreUV oUV0, CoreUV oUV1, CoreUV oUV2, CoreUV oUV3);
void CoreGraphicsDeviceOpenGL::LineStripScreen(CoreVector& vPos, CoreVector& vScale, float* lpfCoordPointer, int32_t iNumCoords, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::TriBatchScreen(float* i_triStoreData, CoreRGBA i_colour, uint32_t i_vertexCount);
void CoreGraphicsDeviceOpenGL::TexturedTriBatchScreen(float* i_triStoreData, CoreRGBA i_colour, uint32_t i_vertexCount);
void CoreGraphicsDeviceOpenGL::SolidCuboidObjectMatrix(CoreMatrix& mtLocal2World, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::WireFrameCuboidObjectMatrix(CoreMatrix& mtLocal2World, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::DrawCylinder(float fX1, float fX2, float fRadius1, float fRadius2, float fRadiusMult, float fNX1, float fNX2);
void CoreGraphicsDeviceOpenGL::DrawSphere(float fRadius);
void CoreGraphicsDeviceOpenGL::DrawSausage(float fLength, float fRadius);
void CoreGraphicsDeviceOpenGL::SphereObjectMatrix(CoreMatrix& mtLocal2World, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::CylinderObjectMatrix(CoreMatrix& mtLocal2World, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::SausageObject(CoreVector& vCentre, CoreEulerAngle& eaOrient, float fLength, float fRadius, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::ConeObject(CoreVector& vPos, float fLength, float fAngle, CoreEulerAngle& eaOrient, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::ConeObjectMatrix(CoreMatrix& mtObject2World, CoreRGBA oColour);
void CoreGraphicsDeviceOpenGL::DrawStaticMesh(CoreGeometryCompiled* lpoStaticMesh);
void CoreGraphicsDeviceOpenGL::DrawGeometryCompiled(CoreGeometryCompiled* lpoModel, CoreGraphicsDevice::CoreGeometryDrawEnum eGeometryType, int32_t iNumBlendShapeTargets, int32_t iBlendShapeSkeletonIndex);
void CoreGraphicsDeviceOpenGL::DrawMeshGroup(CoreMeshGroup* lpoMeshGroup);
void CoreGraphicsDeviceOpenGL::DisableZTest();
void CoreGraphicsDeviceOpenGL::DisableZWrite();
void CoreGraphicsDeviceOpenGL::DisableZTestAndWrite();
void CoreGraphicsDeviceOpenGL::EnableZTest();
void CoreGraphicsDeviceOpenGL::EnableZWrite();
void CoreGraphicsDeviceOpenGL::EnableZTestAndWrite();
void CoreGraphicsDeviceOpenGL::Set2DProjection();
void CoreGraphicsDeviceOpenGL::SelectTexture(CoreTexturePage* i_texturePage, CoreTextureInfo* i_textureInfo, CoreGraphicsDevice::CoreTextureFilterTypes i_filtering, uint32_t i_pass);
void CoreGraphicsDeviceOpenGL::SelectUnLit(uint32_t i_flags);
void CoreGraphicsDeviceOpenGL::SelectMaterialProperties(CoreVector& vMaterialColour, CoreVector& vIncandescenceColour, float fDiffuseIntensity, CoreVector& vSpecularColour, float fSpecularCosinePower, uint32_t i_flags, uint32_t i_pass);
void CoreGraphicsDeviceOpenGL::SetLights();
void CoreGraphicsDeviceOpenGL::SelectMatrixPalette();
void CoreGraphicsDeviceOpenGL::SetBlendState(bool bEnable);
void CoreGraphicsDeviceOpenGL::SetBlendFunction(CoreGraphicsDevice::CoreBlendModeEnum eBlendMode, float fAlpha);
void CoreGraphicsDeviceOpenGL::EnableOverbrightMode();
void CoreGraphicsDeviceOpenGL::DisableOverbrightMode();
void CoreGraphicsDeviceOpenGL::SelectLights(CoreGraphicsDeviceLightData* lpoLightData);
void CoreGraphicsDeviceOpenGL::GouraudShading(bool bEnable);
bool CoreGraphicsDeviceOpenGL::bLoadTextureData(char* lpcFileName, CoreTextureSet* lpoTextureSet, CoreAssetManager* lpoAssetManager, bool bAsync);
void CoreGraphicsDeviceOpenGL::GetGeometryCompiledReport(CoreModelMesh* iModelMesh, CoreStringBuffer<256>& iStr);
void CoreGraphicsDeviceOpenGL::GetGeometryCompiledInfo(CoreModelMesh* iModelMesh, uint32_t& nVerts);
void CoreGraphicsDeviceOpenGL::UnLoadTextureData(CoreTextureSet* lpoTextureSet);
bool CoreGraphicsDeviceOpenGL::SpecificFunction(uint32_t i_functionName);
bool CoreGraphicsDeviceOpenGL::SnapshotDrawBuffer(char* i_name);
void CoreGraphicsDeviceOpenGL::SetNumScreens(uint32_t i_count);
void CoreGraphicsDeviceOpenGL::InitScreen(uint32_t i_index);
void CoreGraphicsDeviceOpenGL::SetSingleViewMode();
void CoreGraphicsDeviceOpenGL::RegisterRenderTextureSet(CoreMemory* io_memory, uint32_t rType, CoreTextureSet* pTexSet);
void CoreGraphicsDeviceOpenGL::UpdateRenderTextureSet(uint32_t rType, CoreTextureSet* pTexSet);
void CoreGraphicsDeviceOpenGL::FlushBatchRender(uint32_t i_pass);
void CoreGraphicsDeviceOpenGL::ResetBatchRender(uint32_t i_pass);
uint32_t CoreGraphicsDeviceOpenGL::uiBeginGeometryPass(int32_t);
CoreVector CoreGraphicsDeviceOpenGL::Project(float iX, float iY, float iZ);
CoreVector CoreGraphicsDeviceOpenGL::unProject(float iX, float iY, float iZ);
void CoreGraphicsDeviceOpenGL::getLocalMousePos(float& oX, float& oY);
void CoreGraphicsDeviceOpenGL::getLocalMouseDelta(float& oX, float& oY);
void CoreGraphicsDeviceOpenGL::RenderGeometryCompiledBounds(CoreModelMesh* iModelMesh);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\pc\coregraphicsdeviceopengl.h
void CoreGraphicsDeviceNull::~CoreGraphicsDeviceNull();
void CoreGraphicsDeviceOpenGL::~CoreGraphicsDeviceOpenGL();
uint32_t CoreGraphicsDeviceOpenGL::GetDisplayWidth();
uint32_t CoreGraphicsDeviceOpenGL::GetScreenWidth();
uint32_t CoreGraphicsDeviceOpenGL::GetScreenHeight();
uint32_t CoreGraphicsDeviceOpenGL::GetDisplayHeight();
void CoreGraphicsDeviceOpenGL::SetDisplayWidthPreInit(uint32_t i_width);
void CoreGraphicsDeviceOpenGL::SetDisplayHeightPreInit(uint32_t i_height);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibgraphics\pc\coregraphicsdevicepc.cpp
CoreGraphicsDevice* CoreGraphicsDevice::CreateSpecificDevice(CoreMemory* i_memory, CoreHash i_type);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibinput\coreinput.cpp
void CoreInput::Construct(CoreMemory* i_memory, CoreHash i_type, char* i_appName);
void CoreInput::Destruct(CoreMemory* io_memory);
void CoreInput::Init(bool i_enableMouse);
void CoreInput::Update(float i_frameTime);
float CoreInput::GetUpdateTime();
void CoreInput::Rumble(uint32_t i_pad, CoreRumbleEnvelope* i_rumbleEnvelope);
bool CoreInput::IsInputClicked(CoreInputID i_id);
bool CoreInput::IsInputReleased(CoreInputID i_id);
bool CoreInput::IsInputHeld(CoreInputID i_id);
float CoreInput::GetInputValue(CoreInputID i_id);
CoreInputAction* CoreInput::GetDefaultAction(CoreHash i_actionID);
char CoreInput::GetLastKeyClicked();
void CoreInputConnectedControllers::Update(bool i_isValid1, bool i_isValid2);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibinput\coreinputaction.cpp
bool CoreInputAction::IsClickedRepeat(float i_repeatPeriod);
void CoreInputAction::Update(float i_value, float i_frameTime);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibinput\coreinputcontext.cpp
void CoreInputContext::CoreInputContext();
bool CoreInputContext::Construct(uint32_t i_maxActions, CoreMemory* io_memory);
void CoreInputContext::Destruct(CoreMemory* io_memory);
bool CoreInputContext::RegisterAction(CoreHash i_action, CoreHash i_text);
CAL1_Sample* CAL1_AudioStreamer::GetSample();
uint32_t CoreProgramCounter::GetCurrentPosition();
uint32_t CoreInputContext::GetNumberActions();
CoreFileDevice* CoreFileSystem::GetFileDevice();
uint32_t CAL0_List::GetNumberOfItems();
uint32_t CoreEvent::GetTarget();
CoreHash CoreInputContext::GetAction(uint32_t i_index);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibinput\coreinputdevice.cpp
CoreInputDevice* CoreInputDevice::CreateDevice(CoreMemory* i_memory, CoreHash i_type);
void CoreInputDevice::InitGeneral(bool i_enableMouse);
void CoreInputDevice::UpdateGeneral(float i_frameTime, CoreInput* i_input);
float CoreInputDevice::GetUpdateTime();
CoreInputState* CoreInputDevice::GetState(CoreInputID i_id);
void CoreInputDevice::UpdateValue(CoreInputID i_id, float i_value);
CoreInputAction* CoreInputDevice::GetDefaultAction(CoreHash i_actionID);
CoreInputID CoreInputDevice::GetLastState();
void CoreInputDevice::SetMouseSensitivity(float i_sensitivity);
void CoreInputDevice::CoreInputDevice();
void CoreInputDevice::~CoreInputDevice();
void CoreInputDeviceNull::~CoreInputDeviceNull();
void CoreStickData::CoreStickData();
void CoreStickData::Update(float i_axisX, float i_axisY);
float CoreStickData::GetRight();
float CoreStickData::GetLeft();
float CoreStickData::GetUp();
float CoreStickData::GetDown();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibinput\coreinputdevicenull.h
void CoreInputDeviceNull::Update(CoreKeyboardData* io_keyboardData, CorePadData* io_padsData, CoreMouseData* io_mouseData, float);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibinput\coreinputid.cpp
void CoreInputID::CoreInputID(CorePadID i_padInput, uint32_t i_padNumber);
bool CoreInputID::IsValid();
bool CoreInputID::IsKeyboardInput();
bool CoreInputID::IsMouseInput();
bool CoreInputID::IsPadInput();
CoreInputDeviceID CoreInputID::GetDeviceType();
uint32_t CoreInputID::GetInputID();
uint32_t CoreInputID::GetDeviceNumber();
char* CoreInputID::GetInputName();
char CoreInputID::GetInputChar(bool i_shifted);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibinput\coreinputmapping.cpp
bool CoreInputMapping::Construct(CoreInputContext* i_context, CoreMemory* io_memory);
void CoreInputMapping::Destruct(CoreMemory* io_memory);
void CoreInputMapping::SetActionMapping(CoreHash i_action, uint32_t i_slot, CoreInputID i_id);
CoreInputAction* CoreInputMapping::GetAction(CoreHash i_action);
void CoreInputMapping::Update(CoreInput* i_input);
void CoreInputMapping::ManualUpdate(CoreInput* i_input);
void CoreInputMapping::ManualUpdateAction(CoreHash i_action, float i_value);
float CoreInputMapping::GetAxisValue(CoreHash i_positive, CoreHash i_negative, float i_deadZone);
float CoreInputMapping::GetDirection(CoreHash i_up, CoreHash i_down, CoreHash i_left, CoreHash i_right, float i_deadZone, float& o_speed);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibinput\pc\coreinputdevicedirectinput.cpp
int32_t __stdcall CoreInputDeviceDirectInput::EnumJoysticksCallback(DIDEVICEINSTANCEA* i_instance, void* io_context);
int32_t __stdcall CoreInputDeviceDirectInput::EnumAxesCallback(DIDEVICEOBJECTINSTANCEA* i_objectInstance, void* io_context);
int32_t __stdcall CoreInputDeviceDirectInput::EnumEffects(DIEFFECTINFOA* i_effectInfo, void* io_context);
void CoreInputDeviceDirectInput::~CoreInputDeviceDirectInput();
void CoreInputDeviceDirectInput::Construct(CoreMemory* i_memory, char* i_appName);
void CoreInputDeviceDirectInput::Destruct(CoreMemory* i_memory);
void CoreInputDeviceDirectInput::Init(bool i_enableMouse);
void CoreInputDeviceDirectInput::Update(CoreKeyboardData* io_keyboardData, CorePadData* io_padData, CoreMouseData* io_mouseData, float i_frameTime);
void CoreInputDeviceDirectInput::InitKeyboard();
void CoreInputDeviceDirectInput::UpdateKeyboard(CoreKeyboardData* io_keyboardData);
void CoreInputDeviceDirectInput::ReMapKeyboard(CoreInputState* i_states);
void CoreInputDeviceDirectInput::InitPads();
void CoreInputDeviceDirectInput::EnableRumble();
void CoreInputDeviceDirectInput::DisableRumble();
void CoreInputDeviceDirectInput::UpdatePads(CorePadData* io_padData);
void CoreInputDeviceDirectInput::InitMouse();
void CoreInputDeviceDirectInput::UpdateMouse(CoreMouseData* io_mouseData);
CoreInputDevice* CoreInputDevice::CreateSpecificDevice(CoreMemory* i_memory, CoreHash i_type);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibnet\corenet.cpp
void CoreNet::Construct(CoreMemory* io_Memory, CoreHash& i_Type);
void CoreNet::Destruct(CoreMemory* io_Memory);
void CoreNet::Init(CoreWorldUpdateStruct* i_WorldUpdateStruct, CoreNet::DeviceInitialisationData* i_Init);
void CoreNet::Reset();
void CoreNet::ExitCallBack(void* i_callBackUserData);
char* CoreNet::GetIPAddress(uint32_t i_IPAddress);
uint32_t CoreNet::GetHostIPAddress(char* i_HostName);
void CoreNet::SendPacket(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
void CoreNet::SendCodedPacket(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
void CoreNet::BroadcastPacket(CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
void CoreNet::BroadcastCodedPacket(CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
bool CoreNet::IsPacketWaiting();
uint32_t CoreNet::GetPacketFromAddress();
uint32_t CoreNet::GetPacketType();
void* CoreNet::GetPacketData();
void CoreNet::IgnoreRestOfPackets();
void CoreNet::NextPacket();
bool CoreNet::IsValid();
uint32_t CoreNet::GetNumberOfNetworkPlayers();
uint32_t CoreNet::GetNetworkPlayerIPAddress(int32_t i_PlayerIndex);
char* CoreNet::GetNetworkPlayerName(int32_t i_PlayerIndex);
CoreNet::CoreNetAsynchronous CoreNet::GetAsynchronousStatus();
bool CoreNet::GameJoined();
uint32_t CoreNet::GetDiscoveredServerCount();
CoreNet::CoreNetServer* CoreNet::GetDiscoveredServerList();
bool CoreNet::GetConnectedState();
void CoreNet::SetConnectionLost();
int32_t CoreNet::GetPlayerID();
bool CoreNet::IsServer();
bool CoreNet::IsClient();
bool CoreNet::IsNetworkGame();
bool CoreNet::IsInLobby();
void CoreNet::SetIsInLobby(bool i_State);
uint32_t CoreNet::GetGameSpecificServerData();
bool CoreNet::GetWLANSwitchOnState();
bool CoreNet::GetStartGameState();
void CoreNet::SetStartGameState(bool i_StartGameState);
void CoreNet::DoDebug(CoreDebugInput* i_Input, float i_Timestamp);
void CoreNet::DrawRXTXActivity(CoreGraphicsDevice* i_GraphicsDevice);
void* CoreNet::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn CoreNet::RunFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreNet::FnJoinGame(CoreCommand* io_Command);
CoreScripted::CommandReturn CoreNet::FnHostGame(CoreCommand* io_Command);
CoreScripted::CommandReturn CoreNet::FnStartGame(CoreCommand* io_Command);
CoreScripted::CommandReturn CoreNet::FnSetAsynchronousTimeout(CoreCommand* io_Command);
CoreScripted::CommandReturn CoreNet::FnSynchronise(CoreCommand* io_Command);
CoreScripted::CommandReturn CoreNet::FnNetworkUpdate(CoreCommand* io_Command);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibnet\corenetdevice.cpp
CoreNetDevice* CoreNetDevice::InstantiateDevice(CoreMemory* io_Memory, CoreHash& i_Type);
void CoreNetDevice::Construct(CoreMemory* i_Memory);
void CoreNetDevice::Destruct(CoreMemory* i_Memory);
void CoreNetDevice::Init(CoreNet::DeviceInitialisationData* i_Init);
void CoreNetDevice::Shutdown();
void CoreNetDevice::Reset();
char* CoreNetDevice::GetIPAddress(uint32_t i_IPAddress);
void CoreNetDevice::UpdateWhenBlocked(void* i_callBackUserData);
void CoreNetDevice::Update();
void CoreNetDevice::ProcessInbound(CoreNetDevice::CorePacket* i_Packet, uint32_t i_Length);
void CoreNetDevice::SendPacketInternal(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength, bool i_IsCoded);
bool CoreNetDevice::IsValid();
void CoreNetDevice::SetAcceptBroadcastPackets(bool i_Accept);
bool CoreNetDevice::GetAcceptBroadcastPackets();
void CoreNetDevice::SendPacket(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
void CoreNetDevice::SendCodedPacket(uint32_t i_To, CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
void CoreNetDevice::BroadcastPacket(CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
void CoreNetDevice::BroadcastCodedPacket(CoreHash& i_Type, void* i_Data, uint32_t i_DataLength);
float CoreNetDevice::GetHandshakePingInterval();
void CoreNetDevice::SetHandshakePingInterval(float i_DesiredSeconds);
float CoreNetDevice::GetConnectionReliability();
void CoreNetDevice::SetConnectionReliability(float i_DesiredPercentage);
float CoreNetDevice::GetKeepAlivePingInterval();
void CoreNetDevice::SetKeepAlivePingInterval(float i_DesiredSeconds);
float CoreNetDevice::GetKeepAliveMaxTimeout();
void CoreNetDevice::SetKeepAliveMaxTimeout(float i_DesiredMaxTimeout);
float CoreNetDevice::GetKeepAliveForLobbyMaxTimeout();
void CoreNetDevice::SetKeepAliveForLobbyMaxTimeout(float i_DesiredMaxTimeout);
uint32_t CoreNetDevice::GetGameHash();
void CoreNetDevice::SetGameHash(uint32_t i_Hash);
uint32_t CoreNetDevice::GetSendMessagesQueued();
uint32_t CoreNetDevice::GetSendMessagesSent();
CoreNetDevice::CorePacket* CoreNetDevice::GetNextUnsentPacket();
uint32_t CoreNetDevice::GetHostIPAddress();
void CoreObjectController::SetNumObjectTypes(int32_t i_numTypes);
void CoreNetDevice::SetHostIPAddress(uint32_t i_IPAddress);
bool CoreNetDevice::IsPacketWaiting();
uint32_t CoreNetDevice::GetPacketFromAddress();
uint32_t CoreNetDevice::GetPacketType();
void* CoreNetDevice::GetPacketData();
void CoreNetDevice::NextPacket();
void CoreNetDevice::IgnoreRestOfPackets();
void CoreNetDevice::IncrementCodedMessageSendStats(CoreNetDevice::CorePacket* i_Packet);
void CoreNetDevice::IncrementNormalMessageSendStats(CoreNetDevice::CorePacket* i_Packet);
void CoreNetDevice::SetCoreNetLatency(uint32_t i_Latency);
void CoreNetDevice::SetServerIPAddress(uint32_t i_IPAddress);
uint32_t CoreNetDevice::GetNumberOfNetworkPlayers();
uint32_t CoreNetDevice::GetNetworkPlayerIPAddress(int32_t i_PlayerIndex);
char* CoreNetDevice::GetNetworkPlayerName(int32_t i_PlayerIndex);
uint32_t CoreNetDevice::GetNetworkPlayerColour(int32_t i_PlayerIndex);
int32_t CoreNetDevice::GetPlayerID();
int32_t CoreNetDevice::GetServerID();
bool CoreNetDevice::IsServer();
bool CoreNetDevice::IsClient();
void CoreNetDevice::SetCoreNetInstance(CoreNet* i_CoreNet);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibnet\corenetdevicedebug.cpp
void CoreNetDevice::DoDebug(CoreDebugInput* i_Input, float i_Timestamp);
void CoreNetDevice::DoDebug_General(CoreDebugInput* i_Input, float i_Timestamp);
void CoreNetDevice::DoDebug_GameState(CoreDebugInput* i_Input, float i_Timestamp);
void CoreNetDevice::DoDebug_CodedMessages(CoreDebugInput* i_Input, float i_Timestamp);
void CoreNetDevice::DrawRXTXActivity(CoreGraphicsDevice* i_GraphicsDevice);
char* CoreNetDevice::DecodeSyncState(CoreNet::CoreNetSyncState i_SyncState);
char* CoreNetDevice::DecodeCoreHash(uint32_t i_CoreHash);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibnet\corenetdevicelobbying.cpp
void CoreNetDevice::ProcessLobby(CoreNetDevice::CorePacket* i_Packet);
void CoreNetDevice::SendNetworkPlayerList();
void CoreNetDevice::SendStartGame();
void CoreNetDevice::FindServers();
void CoreNetDevice::JoinServer(uint32_t i_ServerIPAddress);
void CoreNetDevice::LeaveGame();
bool CoreNetDevice::GameJoined();
bool CoreNetDevice::GameRejected();
void CoreNetDevice::ClearDiscoveredServersList();
void CoreNetDevice::ClearNetworkPlayerList();
uint32_t CoreNetDevice::GetDiscoveredServerCount();
CoreNet::CoreNetServer* CoreNetDevice::GetDiscoveredServerList();
void CoreNetDevice::RemovePlayer(uint32_t i_IPAddress);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibnet\corenetdevicenull.h
uint32_t CoreNetDeviceNULL::GetHostIPAddress(char* i_HostName);
uint32_t CoreNetDeviceNULL::inet_addr(char* i_IPAddress);
uint32_t CoreNetDeviceNULL::htons(uint32_t hostshort);
uint32_t CoreNetDeviceNULL::htonl(uint32_t hostlong);
int32_t CoreNetDeviceNULL::sendto(uint32_t i_Socket, char* i_Buffer, int32_t i_BufferLength, int32_t i_Flags, CoreNetDevice::Core_sockaddr* i_To, int32_t i_ToLength);
int32_t CoreNetDeviceNULL::recvfrom(uint32_t i_Socket, char* o_Buffer, int32_t i_BufferLength, int32_t i_Flags, CoreNetDevice::Core_sockaddr* o_From, int32_t* io_FromLength);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibnet\corenetdevicesynchronisation.cpp
void CoreNetDevice::ProcessHandshake(CoreNetDevice::CorePacket* i_Packet);
CoreNet::CoreNetAsynchronous CoreNetDevice::SetAsynchronousTimeout(float i_Seconds);
void CoreNetDevice::ClearAsynchronousTimeout();
CoreNet::CoreNetAsynchronous CoreNetDevice::GetAsynchronousStatus();
CoreNet::CoreNetAsynchronous CoreNetDevice::IsServerReady();
CoreNet::CoreNetAsynchronous CoreNetDevice::AreClientsReady();
void CoreNetDevice::SetSyncState(CoreNet::CoreNetSyncState i_SyncState);
void CoreNetDevice::SetSyncStateCache(CoreNet::CoreNetSyncState i_SyncState);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibnet\pc\corenetdevicepc.cpp
CoreNetDevice* CoreNetDevice::InstantiatePlatformSpecificDevice(CoreMemory* io_Memory, CoreHash& i_Type);
void _CoreNetReceiveThread(void* i_Data);
void _CoreNetSendThread(void* i_Data);
void CoreNetDevicePC::Construct(CoreMemory* i_Memory);
void CoreNetDevicePC::Destruct(CoreMemory* i_Memory);
void CoreNetDevicePC::Init(CoreNet::DeviceInitialisationData* i_Init);
void CoreNetDevicePC::Shutdown();
uint32_t CoreNetDevicePC::GetHostIPAddress(char* i_HostName);
uint32_t CoreNetDevicePC::htons(uint32_t i_hostshort);
uint32_t CoreNetDevicePC::htonl(uint32_t i_hostlong);
int32_t CoreNetDevicePC::recvfrom(uint32_t i_Socket, char* o_Buffer, int32_t i_BufferLength, int32_t i_Flags, CoreNetDevice::Core_sockaddr* o_From, int32_t* io_FromLength);
int32_t CoreNetDevicePC::sendto(uint32_t i_Socket, char* i_Buffer, int32_t i_BufferLength, int32_t i_Flags, CoreNetDevice::Core_sockaddr* i_To, int32_t i_ToLength);
uint32_t CoreNetDevicePC::inet_addr(char* i_IPAddress);
int32_t CoreNetDevicePC::WSAGetLastError(char** o_Message);
bool CoreNetDevicePC::InitTCPIPStack();
bool CoreNetDevicePC::InitSocket();
void CoreNetDevicePC::ReceiveThread();
void CoreNetDevicePC::SendThread();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibnet\pc\corenetdevicepc.h
void CoreNetDevicePC::~CoreNetDevicePC();
void CoreNetDeviceNULL::~CoreNetDeviceNULL();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibphysics\corephysicsarticulate.cpp
void CorePhysicsArticulate::initBodies(CoreMemory* mem, CorePhysicsWorld* pWorld, CoreSingleCollidable* collidables, int32_t numCollidables, int32_t objID);
void CorePhysicsArticulate::initializeRagdoll(CoreMemory* io_mem, CorePhysicsWorld* i_world, CoreModelCollidable* i_collidables, int32_t i_numCollidables, CoreModelSkeleton* i_engineSkeleton, CoreModelSkeleton* i_renderSkeleton, int32_t i_objID);
void CorePhysicsArticulate::destroy(CoreMemory* mem, CorePhysicsWorld* pWorld);
void CorePhysicsArticulate::setUp(CoreMatrix& matrix, CoreMatrix* matrixList);
void CorePhysicsArticulate::getUp(CoreVector& newPos, CoreEulerAngle& newOrient, CoreMatrix* matrixList);
void CorePhysicsArticulate::setCur(CoreMatrix& matrix, CoreMatrix* matrixList, float animVelScale);
void CorePhysicsArticulate::addBlast(CoreVector& i_pos, float i_power);
void CorePhysicsArticulate::activate(CoreVector& vel);
void CorePhysicsArticulate::deactivate();
void CorePhysicsArticulate::setBlendScaleMode(float blendScale, int32_t blendMode);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibphysics\corephysicsbody.cpp
void CorePhysicsBody::initialize(CoreMemory* mem, CorePhysicsWorld* pWorld, CoreSingleCollidable* collidables, int32_t numCollidables, int32_t objID);
void CorePhysicsBody::destroy(CoreMemory* mem, CorePhysicsWorld* pWorld);
void CorePhysicsBody::setUp(CoreMatrix& matrix);
void CorePhysicsBody::setCur(CoreMatrix& matrix, float velScale);
void CorePhysicsBody::calcCurPosRot();
void CorePhysicsBody::getUp(CoreMatrix& newMat);
void CorePhysicsBody::clearAcc();
void CorePhysicsBody::addAcc(CoreVector& acc);
void CorePhysicsBody::integrate(float timeStep, float velDamp);
CoreVector CorePhysicsBody::getRelToCur(CoreVector& rel);
CoreVector CorePhysicsBody::getRelToOld(CoreVector& rel);
CoreVector CorePhysicsBody::getCurToRel(CoreVector& cur);
void CorePhysicsBody::calcSafeFlag(float threshold);
void CorePhysicsBody::updateCollisionPrimsLag();
void CorePhysicsBody::updateCollisionPrims();
void CorePhysicsBody::drawCollisionPrims(CoreRGBA drawColour, CoreRGBA oldColour);
int32_t CorePhysicsBody::collide(CoreVector& v0, CoreVector& v1, CoreVector& v2, int32_t flag);
void CorePhysicsBody::resolveRods();
void CorePhysicsBody::resolveConstraintA(CorePhysicsConstraint* con, float massB);
void CorePhysicsBody::resolveConstraintB(CorePhysicsConstraint* con, float massA);
void CorePhysicsBody::resolveConstraints(CorePhysicsConstraint* fixedCon, CorePhysicsConstraint* freeCon, int32_t bIndex);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibphysics\corephysicscollision.cpp
int32_t CoreCollisionBall::collideWithFixedVert(CoreVector& vpos);
int32_t CoreCollisionBall::collideWithFixedEdge(CoreVector& e0, CoreVector& e1);
int32_t CoreCollisionBall::collideWithFixedTriangle(CoreVector& v0, CoreVector& v1, CoreVector& v2, CoreVector& normal);
void CoreCollisionBall::collideWithBall(CoreCollisionBall& ball);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibphysics\corephysicsjoint.cpp
void CorePhysicsJoint::initialize(CorePhysicsWorld* world, int32_t bodIndexA, int32_t bodIndexB, int32_t setupBodIndex);
void CorePhysicsJoint::destroy(CoreMemory* mem, CorePhysicsWorld* pWorld);
void CorePhysicsJoint::setUp(CoreVector& pos);
void CorePhysicsJoint::setCur();
void CorePhysicsJoint::setLimits(CoreVector& lowerEulerLim, CoreVector& upperEulerLim);
void CorePhysicsJoint::setBindInfo(CoreMatrix& parentBind, CoreMatrix& childBind);
void CorePhysicsJoint::enforceJointPos();
void CorePhysicsJoint::collideJointVsPlanePair(CoreVector& sPos, int32_t jindexC, int32_t jindexP, CoreVector& jposC, CoreVector& jposP, CoreVector& pnorm0, CoreVector& pnorm1, float len);
void CorePhysicsJoint::enforceEulerLimits(int32_t debugFlag);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibphysics\corephysicsworld.cpp
void CorePhysicsWorld::Init();
void CorePhysicsWorld::updatePhysicsWorld(float i_timeStep, CoreDetectionMeshInfo* detMeshInfos, int32_t numMeshes, int32_t* i_rTreeBuffer);
void CorePhysicsWorld::addLimitConstraint(int32_t bodIndexA, int32_t bodIndexB, CoreVector& posA, CoreVector& posB);
void CorePhysicsWorld::addCollision(int32_t bodIndexA, int32_t bodIndexB, CoreVector& posA, CoreVector& posB, CoreVector& norm, float depth);
void CorePhysicsWorld::addFixedCollision(int32_t bodIndex, CoreVector& newpos, CoreVector& norm, float depth, int32_t type);
void CorePhysicsWorld::integrate(float timeStep);
void CorePhysicsWorld::collideDynamic();
void CorePhysicsWorld::collideFixed(CoreDetectionData* detectionData, int32_t* rTreeIndexBuffer);
bool CorePhysicsWorld::resolve();
CorePhysicsCollision* CorePhysicsWorld::getPhysicsCollsionList(float impactThreshold);
void CorePhysicsWorld::DoDebug(CoreDebugInput* i_input);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\script\corecommand.cpp
void CoreCommand::DoAssignment();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\script\coreprogramcounter.cpp
void CoreProgramCounter::CoreProgramCounter();
void CoreMemoryStackMarker::Zero();
void CoreProgramCounter::Reset();
CoreScript* CoreProgramCounter::GetCurrentScript(CoreScriptStore* i_scriptStore);
bool CoreProgramCounter::IsReset();
void CoreLevelLightSet::SetEngineDynamicLightPtr(CoreLevelDynamicLight* i_ptr);
void CoreAnimCommandAutoBlend::SetNewStateHash(CoreHash i_value);
void CoreProgramCounter::SetCurrentPosition(uint32_t i_position);
void CoreFileSystem::SetFileDevice(CoreFileDevice* i_fileDevice);
void CoreGameButtonText::Set(CoreHash i_textID);
void CoreProgramCounter::JumpToRepeatPosition();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\script\corescript.cpp
CoreVariable* CoreScript::InitVariables(CoreScripted* io_object, CoreVariableStore* io_variableStore, int32_t& io_numVariables);
void CoreScript::ResetVariables(CoreScripted* io_object);
CoreScript* CoreScript::GetCommand(CoreCommand* o_command, CoreScripted* io_object, CoreProgramCounter* io_PC, CoreScriptUpdate* io_update);
void CoreScript::NextCommand(CoreProgramCounter* io_PC);
void CoreScript::ReadCommand(CoreCommand* o_command, CoreScripted* io_object, CoreProgramCounter* io_PC, CoreScriptUpdate* io_update);
uint32_t* CoreScript::FindState(CoreScripted* i_object, CoreVariableStore* i_variableStore);
void CoreScript::ReadConditionParam(CoreVariable* o_var, int32_t& io_condRead, int32_t i_type, uint32_t* i_currentCond, CoreScripted* i_object, CoreVariableStore* i_variableStore);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\script\corescript.h
CoreHash CoreScript::GetHash(uint32_t i_value);
CoreHash CoreScript::GetScriptName();
CoreHash CoreMenuComponent::GetName();
CoreHash CoreScript::GetParentName();
CoreScript* CoreScript::GetScript(CoreScriptStore* i_scriptStore, CoreHash i_scriptName);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\script\corescripted.cpp
CoreScripted::CommandReturn CoreScripted::RunFunction(CoreCommand* io_command);
void* CoreScripted::GetVariablePointer(CoreHash i_variableName);
void $E3();
void CoreScripted::CoreScripted();
void CoreScripted::~CoreScripted();
void CoreScripted::Reset();
void CoreScripted::InitScript(CoreHash i_objectName, CoreHash i_scriptName, CoreScriptUpdate* io_update);
void CoreScripted::ResetScript(CoreScriptUpdate* io_update);
void CoreScripted::UpdateScript(CoreScriptUpdate* io_update);
void CoreScripted::DeleteScript(CoreScriptUpdate* io_update);
CoreVariable* CoreScripted::AddDynamicVariable(CoreVariableStore* i_variableStore, CoreHash i_varName, int32_t i_varType, void* i_valuePtr);
int32_t CoreScripted::FindVariableIndex(CoreHash i_varName);
CoreVariable* CoreScripted::FindVariable(CoreHash i_varName);
void CoreScripted::CalcFirstVariable(CoreVariableStore* io_variableStore);
CoreScripted::CommandReturn CoreScripted::RunInternalFunction(CoreCommand* io_command);
CoreScripted::CommandReturn CoreScripted::FnDebug(CoreCommand* io_command);
CoreScripted::CommandReturn CoreScripted::FnIf(CoreCommand* io_command);
CoreScripted::CommandReturn CoreScripted::FnWaitFor(CoreCommand* io_command);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\script\corescripted.h
bool CoreScripted::IsScriptInited();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\script\corevariable.cpp
int32_t CoreVariable::GetIntValue();
float CoreVariable::GetFloatValue();
bool CoreVariable::GetBoolValue();
char* CoreVariable::GetCharPointerValue();
CoreHash CoreVariable::GetHashValue();
bool CoreVariable::operator==(CoreVariable& i_compare);
bool CoreVariable::operator<(CoreVariable& i_compare);
bool CoreVariable::operator>(CoreVariable& i_compare);
void CoreVariable::SetValue(CoreVariable& i_value);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\script\corevariable.h
bool CoreVariable::HasChanged();
void CoreVariable::Init(CoreHash i_owner, CoreHash i_name, int32_t i_type, void* i_valuePointer);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\storage\corebinaryscriptstore.cpp
void CoreBinaryScriptStore::CoreBinaryScriptStore();
void CoreBinaryScriptStore::SetParent(CoreScriptStore* i_parent);
void CoreProgramCounter::SetRepeatPosition(uint32_t i_position);
void CoreBinaryScriptStore::Init(uint32_t* i_data);
char* CoreBinaryScriptStore::GetScriptObject(uint32_t i_type, uint32_t i_version, CoreHash i_name);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibscripted\storage\corevariablestore.cpp
void CoreVariableStore::CoreVariableStore();
void CoreVariableStore::Init(CoreMemory* io_memory, int32_t i_maxVariables);
void CoreVariableStore::Destruct(CoreMemory* io_memory);
void CoreVariableStore::Reset();
CoreVariable* CoreVariableStore::Allocate(CoreHash i_owner, int32_t i_numRequired);
void CoreVariableStore::Remove(CoreVariable* i_firstVariable, int32_t i_variableCount);
int32_t CoreVariableStore::GetDebugNumVariables();
uint32_t CoreEvent::GetType();
CoreVariable* CoreVariableStore::GetDebugVariable(int32_t i_index);
CoreVariable* CoreVariableStore::GetFirstVariable(CoreHash i_owner);
bool CoreVariableStore::IsFirstVariable(CoreHash i_owner, CoreVariable* i_predictedFirst);
CoreVariable* CoreVariableStore::FindVariable(CoreHash i_owner, CoreHash i_name);
int32_t CoreVariableStore::BinarySearch(int32_t i_start, int32_t i_end, uint32_t i_searchValue);
int32_t CoreVariableStore::GetFirstVariableIndexOrAbove(CoreHash i_owner);
int32_t CoreVariableStore::GetFirstVariableIndex(CoreHash i_owner);
int32_t CoreVariableStore::FindVariableIndex(CoreHash i_owner, CoreHash i_name);
void CoreVariableStore::MoveBlock(int32_t i_start, int32_t i_distance);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\corelibtext\coregametext.cpp
char* CoreGameTextUnit::RetrieveString(CoreHash i_id);
void CoreGameText::SetGlobalInstance(CoreGameTextUnit* i_gameText, uint32_t i_platformVersionBit);
char* CoreGameText::GetString(CoreHash i_id);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\include\corelibanim2.h
float CoreAnimBlend::GetBlendedDestTime(float i_time);
void CoreAnimCommandCreate::CoreAnimCommandCreate(uint32_t i_type, float i_time);
CoreHash CoreAnimBoneSet::GetBoneSetNameHash();
CoreHash CoreAnimCommandTimerStop::GetNameHash();
CoreHash CoreVariable::GetOwner();
CoreHash CoreAnimCommandAutoBlend::GetOldStateHash();
CoreHash CoreAnimSpec::GetContext();
CoreHash CoreAnimCommandTimerStart::GetNameHash();
CoreHash CoreMemoryStackMarker::GetName();
CoreHash CoreAnimCommandEvent::GetNameHash();
CoreHash CoreAnimCommandFlag::GetNameHash();
CoreHash CoreCommand::GetFunction();
CoreHash CoreProgramCounter::GetCurrentScriptName();
CoreHash CoreAnimSlot::GetName();
CoreHash CoreAnimCommandFX::GetNameHash();
CoreHash CoreTextureAnimationFrameInfo::GetTextureHash();
CoreHash CoreAnimCommandAudio::GetEventHash();
CoreHash CoreSpecMapping::GetAnimSetHash();
CoreHash CoreAnimMapping::GetAnimSetHash();
void CoreAnimBoneSet::UpdateBonesUsed(bool* o_bonesUsed, bool* i_parentBones, int32_t i_numBones);
int32_t CoreAnimSequencer::GetAnimBoneSetIndexByHash(CoreHash i_hash);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\include\corelibcommon2.h
void CoreStringBuffer<128>::CoreStringBuffer<128>(char* i_format);
void CoreStringBuffer<256>::CoreStringBuffer<256>(char* i_format);
int32_t CoreStringBuffer<128>::SPrint(char* i_format);
int32_t CoreStringBuffer<256>::SPrint(char* i_format);
void CoreInputDeviceDirectInput::Reset();
void CoreLevelCompiled::Reset();
void CoreHash::~CoreHash();
void CoreGraphicsDeviceOpenGL::BeginDrawDynamicLightVolume();
void CoreGraphicsDeviceNull::EnableZTest();
void CoreInit::ParseVersionFileSKU(char* i_versionFile);
void NewRatControl(TRItem* item);
void TRLevelDescription::~TRLevelDescription();
void CoreGraphicsDeviceNull::EndFastQuadRender();
void aiCharacterAnim::~aiCharacterAnim();
void CoreOnScreenKeyboardDummyInterface::DeleteInstance();
void NewInitialiseRollingBlock(TRGameObject* i_object);
void TRMenuSystem::InitSKU();
void NewVoleControl(TRItem* item);
void TRManipNode::RenderDebug();
void FakeGlobalRenderCallback();
void NewCrocControl(TRItem* item);
void NewCentaurControl(TRItem* item);
void CoreUseful::ReportSystemMemory(char* i_title);
void FRActionStatus::~FRActionStatus();
void CoreNamedPipeDummyInterface::DeleteInstance();
void TRSceneryNode::RenderDebug();
void CAL1_AudioDriver::BeginStreamThread();
void CoreGraphicsDevice::SetSingleViewMode();
void NewCreatureCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
void CAL1_AudioDriverPC::BeginCompletionThread();
void CoreAnimSlot::~CoreAnimSlot();
void CoreBlenderBasic::ClearOffsetBlends();
void CoreBlenderSimple::ClearOffsetBlends();
void TRTriggerController::LoadTriggersFile();
void NewDamoclesSwordControl(TRItem* item);
void TRCameraNode::ForceUpdate();
void CoreMenuComponent::ClearContents();
void CoreObjectController::DoDebug();
void CoreGraphicsDeviceNull::DisableZWrite();
void CoreInputDeviceNull::Reset();
void TRInventoryItem::~TRInventoryItem();
void CoreFX::TextureRef::~TextureRef();
void CoreGraphicsDeviceNull::SwapBuffer();
void FRFunctions::~FRFunctions();
void TRItem::AnimateItem();
void CoreSaveGameDummyInterface::DeleteInstance();
void CoreNode::ForceUpdate();
void TRECameraNode::Update();
void CoreProgramCounter::~CoreProgramCounter();
void TRNode::Duplicate();
void CoreNamedPipeDummyInterface::Close();
void TRHitItem::~TRHitItem();
void NewTrapDoorInitialise(TRGameObject* i_object);
void CoreSystem::TimerFunctionSKU();
void CoreObject::Reset();
void NewThorsHeadCollision(TRItem* item, TRItem* laraItem, TRCollInfo* coll);
void NewSpiderControl(TRItem* item);
void CoreGraphicsDeviceNull::EnableZWrite();
void CoreGraphicsDeviceNull::EnableOverbrightMode();
void CoreOnScreenKeyboardInputFieldInfo::~CoreOnScreenKeyboardInputFieldInfo();
void CoreGraphicsDeviceNull::FinishBuffer();
void CoreBatchRender::LocalInit();
void TRManipNode::Update();
void CoreGraphicsDevice::ReleaseRenderer();
void NewInitialiseDamoclesSword(TRItem* item);
void NewThorsHandleCollision(TRItem* item, TRItem* laraItem, TRCollInfo* coll);
void CoreCameraObject::UpdateTriggerJustLeft();
void CoreGeometryObject::UpdateMarkersState();
void CoreInputDevice::EnableRumble();
void TRMenuSystem::UpdateSKU();
void NewMummyControl(TRGameObject* i_object);
void CoreNode::Update();
void CoreLevelLight::~CoreLevelLight();
void TRWadFileManager::wadElementCreate::~wadElementCreate();
void TRTriggerNode::ForceUpdate();
void CoreNetDeviceNULL::Shutdown();
void WeaponInfoStruct::~WeaponInfoStruct();
void TREdItemNode::Update();
void TriBatchStore::~TriBatchStore();
void CoreAIController::UnLoad();
void CoreGraphicsDeviceNull::DisableZTestAndWrite();
void CAL1_SampleGroupPlayback::PlaybackData::Reset();
void CoreGraphicsDeviceNull::DisableZTest();
void CoreBlenderBasic::ClearAllAnimFlags();
void CoreCameraObject::UpdateTriggerJustEntered();
void CoreFileOpenAttributes::~CoreFileOpenAttributes();
void CoreFXLibrary::Update();
void NewApeControl(TRItem* item);
void CoreGraphicsDeviceNull::LockOrthogonal();
void NewSwitchInitialise(TRGameObject* i_object);
void CoreCollisionBall::~CoreCollisionBall();
void CAL1_ReverbManager::BroadcastPreset();
void CoreVariableStore::~CoreVariableStore();
void TRECameraNode::ForceUpdate();
void TRCameraNode::Update();
void CoreGraphicsDeviceNull::BeginDrawDynamicLightVolume();
void CoreGraphicsDeviceNull::EndDrawDynamicLightVolume();
void CoreGraphicsDeviceNull::SelectMatrixPalette();
void NewThorsHandleControl(TRItem* item);
void CoreMenuComponentListBox::ListBoxItem::~ListBoxItem();
void NewLightningControl(TRItem* item);
void CoreLevel::PostRender();
void CoreGraphicsDeviceNull::DisableOverbrightMode();
void CoreUV::~CoreUV();
void CoreGraphicsDeviceOpenGL::LockOrthogonal();
void CoreNetworkDialogDummyInterface::DeleteInstance();
void CAL1_AudioStreamer::ResetStreamer();
[! NO TYPE] CoreFX::__unnamed::~__unnamed();
void CoreConsole::RegisterGameCommands();
void CoreGameOnScreenKeyboard::DeleteInstance();
void CorePCStdCFileDevice::Init();
void TRTriggerNode::Update();
void TRNode::onChangeCodeBits();
void NewAlligatorControl(TRItem* item);
void CoreAIController::Reset();
void CoreGraphicsDevice::SetMatrices();
void CoreGraphicsDeviceOpenGL::EndDrawDynamicLightVolume();
void CAL1_SampleGroupPlayback::PlaybackData::Step();
void CAL1_ReverbManager::UnPause();
void CoreNetDevice::ErrorDialogue();
void CoreGraphicsDeviceOpenGL::UnlockOrthogonal();
void CoreRegistryDummyInterface::DeleteInstance();
void CoreGraphicsDeviceOpenGL::EndFastQuadRender();
void CoreVariable::~CoreVariable();
void CAL1_ReverbManager::Pause();
void CoreGraphicsDeviceNull::EnableZTestAndWrite();
void CoreGraphicsDeviceNull::UnlockOrthogonal();
void CAL1_ReverbManager::WriteHeaderFile();
void TRRoomEffects::GetWaterMeshPointers();
void CoreGameMessageBox::DeleteInstance();
void TRCameraNode::RenderDebug();
void CoreMessageBoxDummyInterface::DeleteInstance();
void CoreGraphicsDeviceNull::ClearScreen();
void TRRoomEffects::GetWaterfallMeshPointers();
void TRPanelPolyGroup::~TRPanelPolyGroup();
void CoreLevel::LevelSpecialRender();
void CoreInputDevice::DisableRumble();
void NewObjectCollision(TRItem* item, TRItem* laraItem, TRCollInfo* coll);
void CoreObjectController::OnPostRender();
void CoreAudio_SpeechQueueEntry::~CoreAudio_SpeechQueueEntry();
void CoreInit::PostParseSKU();
void TRETriggerNode::Update();
bool CoreHash::operator==(CoreHash i_compare);
bool CoreHash::operator!=(CoreHash i_compare);
float CoreMaths::Min(float i_valueA, float i_valueB);
float CoreMaths::Max(float i_valueA, float i_valueB);
CoreVector CoreVector::operator+=(CoreVector& i_vec);
CoreVector CoreVector::operator-=(CoreVector& i_vec);
CoreVector CoreVector::operator*=(float i_value);
CoreVector CoreVector::operator/=(float i_value);
CoreVector CoreVector::operator+(CoreVector& i_vec);
CoreVector CoreVector::operator-(CoreVector& i_vec);
CoreVector CoreVector::operator*(float i_value);
CoreVector CoreVector::operator/(float i_value);
float CoreVector::MagnitudeXYZ();
CoreVector CoreVector::GetNormalizeXYZ();
CoreVector CoreVector::GetMinimize(CoreVector& i_vec);
CoreVector CoreVector::GetMaximize(CoreVector& i_vec);
CoreVector CoreVector::CrossProductXYZ(CoreVector& i_vec);
float CoreVector::BezierInterpolateDeCasteljau(float i_time);
bool CoreVector::IsEqualToXYZ(CoreVector& i_vec, float i_tolerance);
void CoreVector::NormalizeXYZ();
void CoreVector::Maximize(CoreVector& i_vec);
float CoreVector::GetSquaredDistanceToPoint(CoreVector& i_vec);
float CoreVector::CosAngleBetweenVectors(CoreVector& i_vec);
void CoreRGBA::SetRGBA(uint32_t i_red, uint32_t i_green, uint32_t i_blue, uint32_t i_alpha);
void CoreRGBA::FromVector(CoreVector i_value);
void CoreRGBA::ScaleAlpha(float i_scale);
CoreMapNode* CoreMapBase::FindNode(CoreHash i_key);
void* CoreMapBase::FindKey(CoreHash i_key);
void CoreMap<CoreHash const >::CoreMap<CoreHash const >(uint32_t i_maxItems, CoreMemory* i_itemMemory);
LoggerOutput::Logger* CoreMap<LoggerOutput::Logger>::FindKey(CoreHash i_key);
bool* CoreMap<bool __cdecl(FRPlayerObject * const,int)>::FindKey(CoreHash i_key);
FRActionStatus* CoreMap<FRActionStatus>::FindKey(CoreHash i_key);
bool CoreEulerAngle::IsEqualTo(CoreEulerAngle& i_euler, float i_tolerance);
CoreEulerAngle& CoreEulerAngle::operator+=(CoreEulerAngle& i_euler);
CoreEulerAngle& CoreEulerAngle::operator-=(CoreEulerAngle& i_euler);
CoreEulerAngle& CoreEulerAngle::operator*=(float i_scale);
CoreEulerAngle operator+(CoreEulerAngle& i_eulerA, CoreEulerAngle& i_eulerB);
CoreEulerAngle operator-(CoreEulerAngle& i_eulerA, CoreEulerAngle& i_eulerB);
void CoreQuat::FromAngleAxis(CoreAngleAxis& angleAxis);
CoreQuat operator*(CoreQuat& i_quatA, CoreQuat& i_quatB);
CoreQuat CoreQuat::Slerp(CoreQuat& i_target, float i_alpha);
void CoreQuat::CompleteWFromSign(bool i_sign);
CoreVector CoreMatrix::MultiplyByVector(CoreVector& i_vector);
CoreVector CoreMatrix::MultiplyByNormal(CoreVector& i_vector);
void CoreMatrix::RotateX(float i_rotX);
void CoreMatrix::RotateY(float i_rotY);
void CoreMatrix::RotateZ(float i_rotZ);
void CoreMatrix::Scale(CoreVector& i_scale);
void CoreMatrix::ScaleY(float i_scaleY);
void CoreMatrix::ScaleXYZ(float i_scale);
void CoreMatrix::RemoveScale();
void CoreMatrix::RotateYXZ(float i_rotX, float i_rotY, float i_rotZ);
void CoreMatrix::FromEulerAngle(CoreEulerAngle& i_euler);
void CoreMatrix::Rotate(float i_angle, CoreVector& i_axis);
void CorePlaneEquation::CorePlaneEquation(CoreVector& i_normal, CoreVector& i_point);
void CorePlaneEquation::Invert();
bool CoreGeometry::SpheresIntersect(CoreVector& i_centre1, float i_radius1, CoreVector& i_centre2, float i_radius2);
float CoreGeometry::DistanceFromPointToLine(CoreVector& i_point, CoreVector& i_lineA, CoreVector& i_lineB, CoreVector& o_pointOnLineClosest);
CoreVector CoreGeometry::LineToPlaneIntersect(CorePlaneEquation& i_plane, CoreVector& i_lineA, CoreVector& i_lineVector);
bool CoreGeometry::SphereInViewFustrum(CoreVector* clipPlane, CoreVector* guardPlane, CoreVector& pos, float sqRadius);
bool CoreGeometry::BBoxInViewFustrum(CoreVector* clipPlane, CoreVector* guardPlane, CoreVector& bbMin, CoreVector& bbMax);
bool CoreGeometry::SphereAABBIntersect(CoreVector iBoxMin, CoreVector iBoxMax, CoreVector iSpherePos, float iSphereRad);
bool CoreHashArray::Find(CoreHash i_hash, uint32_t& o_foundData);
[! NO TYPE] CoreMem::AllocArrayMemory<REC_ENTRY>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreVariable>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreLevelDynamicLight>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreProfileEntry>();
CorePhysicsConstraint* CoreMem::AllocArrayMemory<CorePhysicsConstraint>(CoreMemory* i_allocator, uint32_t i_numItems, char* i_fileName, int32_t i_lineNumber);
[! NO TYPE] CoreMem::AllocArrayMemory<TRObjectNode>();
[! NO TYPE] CoreMem::AllocArrayMemory<TRBGLightNode>();
[! NO TYPE] CoreMem::AllocArrayMemory<CorePhysicsVert>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreAssetManagerMemoryBlock>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreLevelLight>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreAssetManagerAssetTypeInfo>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreFXEmitter>();
[! NO TYPE] CoreMem::AllocArrayMemory<TRETriggerNode>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreFXMaterial>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreInputAction>();
[! NO TYPE] CoreMem::AllocArrayMemory<TREdItemNode>();
[! NO TYPE] CoreMem::AllocArrayMemory<TRECameraNode>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreNodeChain>();
CoreRecentFileName* CoreMem::AllocArrayMemory<CoreRecentFileName>(CoreMemory* i_allocator, uint32_t i_numItems, char* i_fileName, int32_t i_lineNumber);
[! NO TYPE] CoreMem::AllocArrayMemory<CoreFXEmitterItem>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreInputContext::ContextAction>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreSceneContainer::meshPartition>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreGraphicsDeviceMeshInfo>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreCollisionBall>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreDetectCache>();
[! NO TYPE] CoreMem::AllocArrayMemory<CoreHash>();
char* CoreMem::AllocArrayMemory<char>(CoreMemory* i_allocator, uint32_t i_numItems, char* i_fileName, int32_t i_lineNumber);
[! NO TYPE] CoreMem::AllocArrayMemory<CoreFXMappedVariable>();
[! NO TYPE] CoreMem::AllocArrayMemory<TRSceneryNode>();
[! NO TYPE] CoreMem::AllocArrayMemory<TRFXNode>();
[! NO TYPE] CoreMem::AllocArrayMemory<TRTriggerNode>();
[! NO TYPE] CoreMem::AllocArrayMemory<TRCameraNode>();
[! NO TYPE] CoreMem::AllocArrayMemory<CorePhysicsBody>();
[! NO TYPE] CoreMem::DeleteArrayMemory<TRECameraNode>();
[! NO TYPE] CoreMem::DeleteArrayMemory<TRETriggerNode>();
[! NO TYPE] CoreMem::DeleteArrayMemory<TRCameraNode>();
[! NO TYPE] CoreMem::DeleteArrayMemory<TRObjectNode>();
[! NO TYPE] CoreMem::DeleteArrayMemory<TREdItemNode>();
[! NO TYPE] CoreMem::DeleteArrayMemory<TRFXNode>();
[! NO TYPE] CoreMem::DeleteArrayMemory<TRSceneryNode>();
[! NO TYPE] CoreMem::DeleteArrayMemory<TRBGLightNode>();
[! NO TYPE] CoreMem::DeleteArrayMemory<TRTriggerNode>();
void CoreMem::PushGlobalNewDeleteMemory(CoreMemory* i_memory);
void CoreMem::PopGlobalNewDeleteMemory();
void CoreMemoryStack::CoreMemoryStack();
void CoreMemoryPool::CoreMemoryPool();
char* CoreFileSystem::GetCurrentAsyncState(CoreHash i_fileNameHash);
bool CoreFileSystem::IsAsyncLoadingIdle(CoreHash i_fileNameHash);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\include\corelibeffects2.h
void CoreFXDefault::~CoreFXDefault();
void CoreFX::~CoreFX();
void CoreFXMaterial::~CoreFXMaterial();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\include\corelibgame2.h
void $E1();
void $E4();
void $E7();
void CoreObject::SetPos(CoreVector& i_pos);
void CoreObject::SetOrient(CoreEulerAngle& i_orient);
void CoreObject::SetOrientX(float i_x);
void CoreObject::SetOrientY(float i_y);
void CoreObject::SetOrientZ(float i_z);
void CoreObject::SetScale(CoreVector& i_scale);
CoreEulerAngle CoreObject::GetOrient();
bool CoreObject::IsDead();
void CoreObject::SetParentBone(CoreHash i_parentBone);
void CAL1_API::SetAudioData_MaxDist(ca_floatfp maxDist);
void CoreWorld::~CoreWorld();
void FRWorld::~FRWorld();
void CorePlayAnimInfo::CorePlayAnimInfo();
void CorePlayAnimInfo::SetDefaults();
CoreObject* CoreObjectController::GetObjectWithNameHash(CoreHash oNameHash);
void CoreAIController::~CoreAIController();
float CoreKernel::GetElapsedTimeInSeconds();
void CoreGameController::~CoreGameController();
void FRGameController::~FRGameController();
void CoreLevel::~CoreLevel();
void FRLevel::~FRLevel();
bool CoreLevel::FindTriggerByType(uint32_t, bool, CoreVector&, CoreVector&);
void* CoreEvent::GetData();
uint32_t CoreLevelDynamicFlap::GetHash();
uint32_t CAL1_AudioDriver::GetDefaultStreamFileOffset();
int32_t CoreNodeRoot::GetHitIndex();
uint32_t CoreLevelDynamicLight::GetHash();
void CoreNodeChain::CoreNodeChain();
void CoreNodeChain::~CoreNodeChain();
[! NO TYPE] CoreNode::AllocateNodeArray<TRTriggerNode>();
[! NO TYPE] CoreNode::AllocateNodeArray<TRETriggerNode>();
[! NO TYPE] CoreNode::AllocateNodeArray<TRBGLightNode>();
[! NO TYPE] CoreNode::AllocateNodeArray<TRSceneryNode>();
[! NO TYPE] CoreNode::AllocateNodeArray<TRECameraNode>();
[! NO TYPE] CoreNode::AllocateNodeArray<TRObjectNode>();
[! NO TYPE] CoreNode::AllocateNodeArray<TRCameraNode>();
[! NO TYPE] CoreNode::AllocateNodeArray<TREdItemNode>();
[! NO TYPE] CoreNode::AllocateNodeArray<TRFXNode>();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\include\corelibgraphics2.h
CoreTextureInfo* CoreTextureSet::GetTextureInfoByHash(CoreHash i_hash);
CoreHash CoreTextureSet::GetTextureInfoHashByIndex(uint32_t i_index);
CoreVector CoreGraphicsDevice::GetViewDirection();
void CoreDebug::Profile(CoreDebug::CoreProfileLevelEnum i_level, CoreRGBA i_colour, char* i_name);
void CoreDebug::ProfilerPop();
void CoreOccluder::calcPlanes(CoreVector& pos);
bool CoreOccluder::isReallyInView(CoreVector* clipPlane, CoreVector& pos, float nearClip);
bool CoreOccluder::isSphereOccluded(CoreVector& pos, float sqRadius);
bool CoreOccluder::isSphereIntersects(CoreVector& pos, float sqRadius);
bool CoreOccluder::isBBOccluded(CoreVector& min, CoreVector& max);
CoreRTreeData* CoreDetectionData::GetRTreeData(uint32_t i_type, uint32_t i_roomNumber);
int32_t CoreNavigationMesh::GetTriangleFromPos(CoreVector& vPos, float fTolerance, int32_t iLastTriangle);
CoreVector CoreNavigationMesh::GetCentreOfTriangle(int32_t iTriangle);
void CoreLevelLight::CoreLevelLight();
int32_t CoreModelGeometry::FindMaterialIndexByHash(uint32_t i_materialHash);
CoreVector CoreCurveSetData::GetBBOXmin();
CoreVector CoreCurveSetData::GetBBOXmax();
CoreCurveSetData* CoreCurveSet::GetCurveByName(uint32_t uiHash);
CoreKeyedObject* CoreCurveSet::GetKeyedObjectByName(uint32_t uiHash);
CoreBlindDataGroup* CoreBlindDataSection::GetBlindDataGroupPtr(CoreHash i_type);
int32_t CoreModelSkeleton::GetJointIndex(uint32_t uiJointHash);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\include\corelibinput2.h
bool CoreInputState::IsClicked();
#endif

#if 1 // c:\projects\source\tombraider\coreengine\include\corelibphysics2.h
void CorePhysicsWorld::Construct(CoreMemory* mem);
void CorePhysicsWorld::removeBody(CorePhysicsBody* bod);
void CorePhysicsWorld::removeJoint(CorePhysicsJoint* joint);
#endif

#if 1 // c:\projects\source\tombraider\coreengine\include\corelibscripted2.h
bool CoreScripted::IsDead();
bool CAL1_SampleGroupPlayback::PlaybackData_Random::GetValidSelection();
void CoreScripted::SetDead(bool i_dead);
CoreHash CoreScripted::GetScriptName();
CoreHash CoreAssetManagerMemoryBlock::GetType();
CoreHash CoreAssetManagerMemoryBlock::GetID();
CoreHash CoreAnimSpec::GetAnimPathAltState();
CoreHash CoreScripted::GetObjectName();
CoreHash CoreMenuComponent::GetType();
void CoreVariable::ReadValue(void* o_valuePointer);
void CoreVariable::CoreVariable(int32_t i_type, void* i_valuePointer);
void CoreCommand::CoreCommand();
void CoreCommand::~CoreCommand();
CoreVariable* CoreCommand::GetParameter(int32_t i_index);
void CoreCommand::SetReturnValue(CoreVariable& i_returnValue);
#endif

#if 1 // c:\projects\source\tombraider\frbackgroundobject\frbackgroundobject.cpp
void* FRBackgroundObject::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn FRBackgroundObject::RunFunction(CoreCommand* io_command);
CoreObject* FRBackgroundObject::Create(CoreMemory* io_memory);
void FRBackgroundObject::Construct(CoreMemory* io_memory);
void FRBackgroundObject::Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
bool FRBackgroundObject::SimpleRoute(float i_x, float i_z, float i_turnSpeed, float i_moveSpeed);
void FRBackgroundObject::Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
void FRBackgroundObject::Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
void FRBackgroundObject::DoEffects(CoreObjectUpdateStruct* io_updateStruct);
void FRBackgroundObject::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
CoreScripted::CommandReturn FRBackgroundObject::eFnMoveTo(CoreCommand* io_command);
CoreScripted::CommandReturn FRBackgroundObject::eFnTurnTo(CoreCommand* io_command);
CoreScripted::CommandReturn FRBackgroundObject::eFnAnimate(CoreCommand* io_command);
void FRBackgroundObject::InitOnSpline(int32_t i_objectType, CoreCurveSetData* i_curve, CoreHash i_curveName, float i_startPos, float i_speed, float i_waitTime);
CoreScripted::CommandReturn FRBackgroundObject::FnUpdateOnSpline(CoreCommand* io_command);
CoreScripted::CommandReturn FRBackgroundObject::eFnNPCAddAnim(CoreCommand* io_command);
CoreScripted::CommandReturn FRBackgroundObject::eFnNPCSetStartPoint(CoreCommand* io_command);
CoreScripted::CommandReturn FRBackgroundObject::eFnNPCSetFacePlayer(CoreCommand* io_command);
CoreScripted::CommandReturn FRBackgroundObject::eFnNPCSetInteractionDistance(CoreCommand* io_command);
CoreScripted::CommandReturn FRBackgroundObject::eFnNPCSetNearMode(CoreCommand* io_command);
CoreScripted::CommandReturn FRBackgroundObject::eFnNPCSetMode(CoreCommand* io_command);
bool FRBackgroundObject::HandleDistance();
CoreScripted::CommandReturn FRBackgroundObject::FnSetFadeValue(CoreCommand* io_command);
CoreScripted::CommandReturn FRBackgroundObject::eFnSetFadeDistance(CoreCommand* io_command);
bool FRBackgroundObject::GetFloorSurfaceType(CoreVector& i_detectPosition, uint32_t& o_surfaceType);
#endif

#if 1 // c:\projects\source\tombraider\frbackgroundobject\frbackgroundobject.h
void FRBackgroundObject::FRBackgroundObject();
CoreHash FRBackgroundObject::GetTypeID();
int32_t FRBackgroundObject::GetMemoryStackSize();
#endif

#if 1 // c:\projects\source\tombraider\freffects\frfxlibrary.cpp
CoreFXLibrary* CoreFXLibrary::CreateInstance(CoreMemory* pMemPool);
void FxControlBulletCasing(CoreFXPrimitive* i_particle);
void SetupUnderwaterParticle(CoreFXPrimitive* i_particle);
void SetupFogParticle(CoreFXPrimitive* i_particle);
void SetupFireflyParticle(CoreFXPrimitive* i_particle);
void SetupDustflyParticle(CoreFXPrimitive* i_particle);
void SetupDustflyParticle2(CoreFXPrimitive* i_particle);
void SetupTorchFireExtras1(CoreFXPrimitive* i_particle);
void SetupTorchFireExtras2(CoreFXPrimitive* i_particle);
void SetupLargeFireExtras1(CoreFXPrimitive* i_particle);
void SetupLargeFireExtras2(CoreFXPrimitive* i_particle);
void SetupFireBitsExtras(CoreFXPrimitive* i_particle);
void SetupTorchFireHandExtras1(CoreFXPrimitive* i_particle);
void SetupTorchFireHandExtras2(CoreFXPrimitive* i_particle);
void SetupFireBitsHandExtras(CoreFXPrimitive* iBasicPrim);
void SetupPlayerBurningExtras1(CoreFXPrimitive* i_particle);
void SetupPlayerBurningExtras2(CoreFXPrimitive* i_particle);
void smartBubbleCallback(CoreParticleFXPrimitive* iPrim);
void smartBubbleUpdateCallback(CoreParticleFXPrimitive* iPrim);
void smartBubbleUpdateCallbackNoRipple(CoreParticleFXPrimitive* iPrim);
void createMuzzleFlare(CoreParticleFXPrimitive* iPrim);
void smallSplashCallback(CoreParticleFXPrimitive* iPrim);
void fxControlExplosionTendril(CoreFXPrimitive* i_particle);
void fxControlExplosion(CoreFXPrimitive* i_particle);
void SetupSnowGlintStart(CoreFXPrimitive* i_particle);
void SetupSmartSnowStart(CoreFXPrimitive* iParticle);
void SmartSnowCallback(CoreParticleFXPrimitive* iParticle);
void fxFireDripCallBack(CoreFXPrimitive* iParticle);
void fxSetupFireDrip(CoreFXPrimitive* iParticle);
void fxFireLeapCallBack(CoreFXPrimitive* iParticle);
void FRFXLibrary::UpdateFireLeap(CoreFXEmitter* i_emitter);
void FRFXLibrary::RegisterFXCommands();
void FRFXLibrary::InitFREffects();
void FRFXLibrary::CreateDust(CoreVector pos);
void FRFXLibrary::TriggerPickupGlow(CoreVector i_pos);
void FRFXLibrary::PlayerDroppedIntoWater(float iMagVel);
void FRFXLibrary::UpdatePlayerWaterFX();
void FRFXLibrary::Update();
void SetupFlameThrowerExtras1(CoreFXPrimitive* i_particle);
void FRFXLibrary::UpdateFlameThrower(CoreFXEmitter* i_emitter);
void SetupDartEmitExtras1(CoreFXPrimitive* i_particle);
void SetupGroundMistParticle(float i_yPos);
void FRFXLibrary::UpdateGroundMist(CoreFXEmitter* iEmitter);
void FRFXLibrary::UpdateLavaMist(CoreFXEmitter* iEmitter);
void FRFXLibrary::UpdateGenericMist(CoreFXEmitter* i_emitter, int32_t* iUseParticle, bool iInteract);
void FRFXLibrary::UpdateCavesDoorBeam(CoreFXEmitter* iEmit);
void FRFXLibrary::UpdateCavesDoorSnow(CoreFXEmitter* iEmit);
void FRFXLibrary::UpdatePlayerFireTorch(FRPlayerObject* iPlayer, CoreVector iPos);
#endif

#if 1 // c:\projects\source\tombraider\freffects\frfxlibrary.h
void FRFXLibrary::FRFXLibrary();
void FRFXLibrary::~FRFXLibrary();
#endif

#if 1 // c:\projects\source\tombraider\freffects\trroomeffects.cpp
void TRRoomEffects::TRRoomEffects();
void TRRoomEffects::InitialiseRoomEffects();
int32_t TRRoomEffects::SetupVine(int32_t i_index, CoreVector i_pos, int32_t i_numSpheres, float i_radius, float i_width, float i_weight, int32_t i_vineType);
void TRRoomEffects::UpdateVines();
bool TRRoomEffects::ProcessFogBulb(TRFogBulbStruct* i_fogBulb);
void TRRoomEffects::UpdateRoomEffects();
#endif

#if 1 // c:\projects\source\tombraider\frgamecontroller\frgamecontroller.cpp
CoreWorld* FRGameController::CreateWorld(CoreMemory* io_memory);
void FRGameController::Init(CoreNet::DeviceInitialisationData* io_CoreNetInit);
void FRGameController::OneCycle();
void FRGameController::UpdateInput(float i_deltaTime);
#endif

#if 1 // c:\projects\source\tombraider\frgamecontroller\frgamecontroller.h
void FRGameController::FRGameController();
#endif

#if 1 // c:\projects\source\tombraider\frglobals\frglobals.cpp
void TRGlobals::Init();
void TRGlobals::SetupPointers();
void TRGlobals::UpdateDarts();
int32_t TRGlobals::GetFreePlayerDart();
int32_t TRGlobals::GetFreeDart();
void TRGlobals::RenderDarts();
void TRGlobals::RenderPlayerDarts(FRPlayerObject* i_player);
#endif

#if 1 // c:\projects\source\tombraider\frlevel\frlevel.cpp
void* FRLevel::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn FRLevel::RunFunction(CoreCommand* io_command);
void FRLevel::Construct(CoreMemory* io_memory);
CoreObjectController* FRLevel::CreateObjectController(CoreMemory* io_memory);
CoreMenuSystem* FRLevel::CreateMenuSystem(CoreMemory* io_memory);
void FRLevel::Init(CoreLevelUpdateStruct* io_LevelUpdateStruct);
void FRLevel::Reset(CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void FRLevel::UnLoad(CoreHash oNewLevelToLoad, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void FRLevel::RestartLevel();
bool FRLevel::InitLoad(CoreHash oLevelHash, char* lpcLevelName, char* lpcAreaName, CoreLevelUpdateStruct* lpoLevelUpdateStruct);
void FRLevel::UpdateCheats(CoreLevelUpdateStruct* pUpdate);
void TempSetVines();
void FRLevel::Update(CoreLevelUpdateStruct* pUpdate);
void FRLevel::Render(uint32_t ulDrawFlags);
void FRLevel::LevelSpecialRender();
void FRLevel::PostRender();
CoreScripted::CommandReturn FRLevel::FnResetFX(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnSendRestartLevelEvent(CoreCommand* io_command);
void FRLevel::LoadObjectDatabase(CoreStringBuffer<256> i_fileName, bool i_reset);
CoreScripted::CommandReturn FRLevel::FnLoadObjectDatabase(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnPreLoadAllObjects(CoreCommand* io_command);
void FRLevel::LoadItemsFile();
CoreScripted::CommandReturn FRLevel::FnLoadItems(CoreCommand* io_command);
void FRLevel::ItemNewRoom(TRItem* item, int32_t room_number);
void FRLevel::InitialiseGameFlags();
void FRLevel::InitialiseLevelFlags();
void FRLevel::InitFlipRooms();
void FRLevel::FlipMap();
CoreScripted::CommandReturn FRLevel::FnResetTriggerBoxes(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnSetTriggerBoxPos(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnSetTriggerBoxType(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnSetTriggerBoxSize(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnSetObjectPos(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnInstanceObjectOnSpline(CoreCommand* io_command);
bool FRLevel::CanPause();
void FRLevel::ActivatePlayers(bool i_activate);
CoreScripted::CommandReturn FRLevel::FnResetPlayerToStart(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnObjectExists(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnSetObjectAlwaysVisible(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnWaitForAllObjects(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnSetViewerTarget(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::FnSetFogValues(CoreCommand* io_command);
CoreScripted::CommandReturn FRLevel::eFnUnPauseForMenu(CoreCommand* lpoCommand);
CoreScripted::CommandReturn FRLevel::eFnShowObject(CoreCommand* lpoCommand);
CoreScripted::CommandReturn FRLevel::FnAddFoliage(CoreCommand* io_command);
void FRLevel::ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
#endif

#if 1 // c:\projects\source\tombraider\frlevel\frlevel.h
void FRLevel::FRLevel();
#endif

#if 1 // c:\projects\source\tombraider\frlevel\trcollision.cpp
CAAudioError CAL1_AudioDriverPC::GetAdditionalChannelPropertySets(uint32_t channel, bool threeD, bool hardware);
void* CoreGraphicsDeviceNull::GetVertexBuffer(int32_t, CoreGraphicsDevice::CoreVertexFormat, CoreGraphicsDevice::CoreGeometryType);
void* CoreGraphicsDeviceOpenGL::GetVertexBuffer(int32_t iNumVerts, CoreGraphicsDevice::CoreVertexFormat eVertexFormat, CoreGraphicsDevice::CoreGeometryType eGeometryType);
CAAudioError CAL0_FileLoader::LoadTheSection(char* type, uint32_t version, uint32_t dataSize);
int32_t TRCollision::TestBoundsCollide(TRGameObject* i_object, FRPlayerObject* i_laraObject, int32_t radius);
void LaraBaddieCollision(FRPlayerObject* i_laraObject, TRCollInfo* coll);
void NewGameObjectCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
void NewTrapCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
int32_t TRCollision::TestCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject);
int32_t TRCollision::TestLaraPosition(float* fBounds, TRGameObject* i_object, FRPlayerObject* i_laraObject);
#endif

#if 1 // c:\projects\source\tombraider\frlevel\trobjectdb.cpp
void TRObjectDB::TRObjectDB();
void TRObjectDB::InitialiseObjects();
void TRObjectDB::InitBaddyObjects();
void TRObjectDB::InitTrapObjects();
void TRObjectDB::InitObjectObjects();
#endif

#if 1 // c:\projects\source\tombraider\frlevel\trsavegame.cpp
void TRSaveGame::StorePlayerWeapons(int32_t nPlayer);
void TRSaveGame::StorePlayerItems(int32_t nPlayer);
void TRSaveGame::CreateSaveGameData();
void TRSaveGame::RetrievePlayerPosition(int32_t nPlayer);
void TRSaveGame::RetrievePlayerWeapons(int32_t nPlayer, TRInventory* pInventory);
void TRSaveGame::RetrievePlayerItems(int32_t nPlayer, TRInventory* pInventory);
void TRSaveGame::RetrievePlayerData(int32_t nPlayer, TRInventory* pInventory);
#endif

#if 1 // c:\projects\source\tombraider\frlevel\trtriggers.cpp
void TRTriggerController::ClearAllTriggers();
void TRTriggerController::CreateScriptTriggerBox();
TRTB_Type TRTriggerController::CheckTriggerBoxes(CoreVector i_pos, int32_t i_room, float* o_lowestY, int32_t* o_eventIndex, uint32_t* o_eventHash);
#endif

#if 1 // c:\projects\source\tombraider\frmain\pc\frmain.cpp
void* operator new(uint32_t i_size);
void operator delete(void* ptr);
void operator delete[](void* ptr);
void* operator new[](uint32_t i_size);
int32_t main(int32_t i_numParams, char** i_params);
#endif

#if 1 // c:\projects\source\tombraider\frobjectcontroller\frobjectcontroller.cpp
void FRObjectController::RegisterTypes();
CoreCameraObject* FRObjectController::GetChaseCameraObject();
CoreCameraObject* FRObjectController::GetFixedCameraObject();
CoreObject* FRObjectController::GetPlayerObject();
int32_t FRObjectController::GetNumPlayerObjects();
CoreObject* FRObjectController::GetPlayerObj(int32_t id);
void FRObjectController::UpdateGameObjects();
void FRObjectController::DoDebug();
void FRObjectController::InitialiseItemArray(int32_t numItems);
void FRObjectController::AddActiveItem(TRGameObject* i_object);
void FRObjectController::RemoveActiveItem(TRGameObject* i_object);
void FRObjectController::RemoveDrawnObject(TRGameObject* i_object);
void FRObjectController::RemoveDrawnItem(TRItem* item);
int32_t FRObjectController::CreateItem(ITEM_TYPE i_type, CoreHash i_script, int32_t i_itemNum);
void FRObjectController::KillItem(TRItem* item);
void FRObjectController::OnPostRender();
#endif

#if 1 // c:\projects\source\tombraider\frobjectcontroller\frobjectcontroller.h
void FRObjectController::FRObjectController();
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\franimcontrol.cpp
bool FRPlayerObject::HandleWallSlide(bool i_glance);
bool FRPlayerObject::ContextMoveOffClearInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCheckWalkBehind(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCanWalkForward(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClearInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClearLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClearRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClearBack(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::CheckWallInFront(CoreDetectResult* i_det, float i_height, bool i_align);
bool FRPlayerObject::CheckWallAtAngle(CoreDetectResult* i_det, float i_height, bool i_align, float i_angle);
bool FRPlayerObject::Context0mBelowWall(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCheckSprintInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionDropLoopHitWall(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context1mBelowWall(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context1mBelowWallLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context1mBelowWallRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context1mBelowWallBack(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextNoFloorUnderneath(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context1mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context1_5mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Check2mPlusClimbs(float i_minHeight, float i_maxHeight, float i_actualHeight);
bool FRPlayerObject::Context2mPlusClimbMustHang(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context2mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context2_5mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context3mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context3_5mWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextEndOfAnim(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::Context180DegreesOut(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextReverse(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextLastChanceGrab(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextLastChanceGrabAlways(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::HandleLastChanceGrab(float i_deadlyHeight);
bool FRPlayerObject::ContextClimbOntoLedge(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbOntoLedgeOverhang(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextSetTurnAngleAndAnim(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCanSprint(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextSetAverageForwardVelocity(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::StepHeightTest(float i_idealHeight, float i_idealDist, float i_heightTolerance, float i_lookAhead);
bool FRPlayerObject::ContextStepUpRun0_5m(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextStepUpRun0_25m(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextStepUpWalk0_5m(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextStepUpWalk0_25m(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextSlowTurnLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextSlowTurnRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionHandleAnalog(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionHandleIdling(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionAdjustToWidthOfPole(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::MovePlayerDownSlope(bool i_backSlide);
bool FRPlayerObject::FunctionMovePlayerDownSlopeFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionMovePlayerDownSlopeBack(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::AlignPlayerToSlope(bool i_initialise, bool i_backSlide);
bool FRPlayerObject::OnSlope();
bool FRPlayerObject::FunctionAlignPlayerToSlopeFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionAlignPlayerToSlopeBack(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextLandedOnSlopeFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextLandedOnSlopeBack(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextSlopeUnderfoot(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextSlopeNormal(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextSlopeSteep(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionResetOrient(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionSetActionWalk(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextTurnOnSpotLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextTurnOnSpotRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextRunTurnLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextRunTurnRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionResetStanceTimer(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCloseToStance(FRPlayerObject* i_obj, int32_t i_temp);
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\franimscriptcontrol.cpp
void FRPlayerObject::SetupMaps(CoreMemory* io_memory);
bool FRPlayerObject::HandleCaseStatement(CoreHash*& io_scriptPtr, bool i_interruptFlag, bool& io_onlyFunctions);
void FRPlayerObject::UpdateAnimStates();
void FRPlayerObject::PlayerControl();
bool FRPlayerObject::RequestAnimInternal(int32_t slotNo, CoreHash i_animState, uint32_t i_flags);
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\frjumpcontrol.cpp
bool FRPlayerObject::LedgeGrab();
bool FRPlayerObject::LedgeGrabBlend(float i_planeBlendTime, float i_offsetBlendTime, float i_delayBlendTime);
void FRPlayerObject::GetLedgeGrabHandsHeightDiff(float& o_minHeightDiff, float& o_maxHeightDiff, float i_tolerance);
bool FRPlayerObject::ContextCatchHPole(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableLedgeFromJumpUp(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableHangLedgeFromDropLoop(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableHangLedgeFromJumpUp(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableLedgeFromDropLoop(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableLeftArm(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableRightArm(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableShort(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableNormal(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextJumpWaiting(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextLandOnFloor(FRPlayerObject* i_obj, int32_t i_temp);
void FRPlayerObject::HandleFallingDamage();
bool FRPlayerObject::ContextPassedDownwardVelocityThreshold(FRPlayerObject* i_obj, int32_t i_temp);
void FRPlayerObject::SetJumpVelocity(float i_jumpDistance, float i_extraRotY);
bool FRPlayerObject::ContextStartJumpUp(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextStartJumpForward(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextStartJumpLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextStartJumpRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextStartJumpBack(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextStartJumpRun(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextStartJumpHPole(FRPlayerObject* i_obj, int32_t i_temp);
void FRPlayerObject::SetJumpVelocityOnEvent();
bool FRPlayerObject::ContextFalling(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyJumpToDrop(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::AddAttractorJumpCalculate(jumpAttractor* jaPtr, AttractorJumpStatics* atrStatics, bool footlanding);
void FRPlayerObject::AddAttractorToJumpList(jumpAttractor*& jaPtr, int32_t& attractorIndex, AttractorJumpStatics* atrStatics);
bool FRPlayerObject::AddAttractorJumpClimb(float minPos, float maxPos, float hOff, float vOff, jumpAttractor*& jaPtr, int32_t& attractorIndex, AttractorJumpStatics* atrStatics);
bool FRPlayerObject::CalculateAttractorJumpValues();
void FRPlayerObject::CalculateAttractorJumpCurve(CoreVector& o_jumpVector, float i_jumpDistance, float& o_jumpTime, float i_vOff, float i_jumpVel);
bool FRPlayerObject::CalculateAttractorJumpVerticalVelocity(jumpAttractor* ja, bool i_footlanding);
bool FRPlayerObject::SetAttractorJumpVelocity();
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\frmisccontrolfunctions.cpp
float CoreAnimatingObject::AnimTimeAdjust(float time);
float FRPlayerObject::AnimTimeAdjust(float i_time);
float CoreCutSceneObject::AnimTimeAdjust(float time);
void FRPlayerObject::SetEffect(CoreHash i_name, float i_time, float i_param1, float i_param2);
void FRPlayerObject::InitEffects();
bool FRPlayerObject::AdjustEffectValueLog(float& io_current, float i_target, float i_amount);
bool FRPlayerObject::AdjustEffectValueLin(float& io_current, float i_target, float i_amount);
void FRPlayerObject::ResetCameraEffects();
void FRPlayerObject::UpdateCameraEffects();
void FRPlayerObject::ExtraAnimstateDependentBits();
void FRPlayerObject::ExtraRagdollDependentBits();
void FRPlayerObject::AnimSpecificEffects();
void FRPlayerObject::SetWallFacing(CorePlaneEquation i_plane);
void FRPlayerObject::AlignToPlane(CorePlaneEquation i_plane, float i_dist, float i_blendTime, float i_blendDelay);
void FRPlayerObject::AlignToPlaneSeparate(CorePlaneEquation i_plane, float i_dist, float i_blendTimeOffset, float i_blendTimeAngle, float i_blendDelay);
void FRPlayerObject::AlignToPlaneAtAngle(CorePlaneEquation i_plane, float i_dist, float i_blendTime, float i_blendDelay, float i_angle);
void FRPlayerObject::GetAttractorPlane(AttractorTable* i_aPtr, CorePlaneEquation& o_attractorPlane);
void FRPlayerObject::GetAttractorToPlayerData(AttractorTable* i_aPtr, bool i_perpIntersect);
void FRPlayerObject::GetAttractorToPlayerDataClimbableWall(AttractorTable* i_aPtr, bool i_perpIntersect);
void FRPlayerObject::GetJumpIntersectionInfo(AttractorTable* i_aPtr, CoreVector i_intersect, float& o_wallPos, float& o_floorPos, float& o_angleDiff);
float FRPlayerObject::GetAttractorPosFloorDrop(CoreVector& i_pos, CoreVector& i_attractorNormal);
CoreHash FRPlayerObject::GetWallPolyHeight(CorePlaneEquation& io_attractorPlane, float& o_angleDiff, float& o_wallHeight);
float FRPlayerObject::GetCeilingHeightAboveLedge(CoreVector& i_pos, CorePlaneEquation& i_plane);
bool FRPlayerObject::IsCeilingHeightAboveLedgeByPoly(CorePlaneEquation& i_plane, float& i_ledgeHeight);
bool FRPlayerObject::CheckGrabbableLedge(float i_dist, float i_yMove, float i_minHeightDiff, float i_maxHeightDiff, float i_maxLedgeHeight, float i_maxDist, float i_maxAngle, bool i_allowPoles);
bool FRPlayerObject::CheckGrabbableHangLedge(float i_dist, float i_yMove, float i_minHeightDiff, float i_maxHeightDiff, float i_maxLedgeHeight, float i_maxDist, float i_maxAngle);
void FRPlayerObject::DoFlyCheat(CoreVector i_pos, CoreEulerAngle i_orient, TRChaseCamera* i_camera, CoreInput* i_input);
bool FRPlayerObject::FunctionSetNoGrabbingTimer(FRPlayerObject* i_obj, int32_t i_temp);
void FRPlayerObject::DoMenuDisplay(TRChaseCamera* i_camera);
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\frplayercollision.cpp
void FRPlayerObjectData::SetPosDetectResultData(CoreDetectResult* i_detectPtr);
void FRPlayerObjectData::SetControlDetectResultData(CoreDetectResult* i_detectPtr);
void FRPlayerObjectData::SetFrontLeftRightHands(CoreVector i_pos);
CoreDetectResult* FRPlayerObject::GetControlCollision();
CoreDetectResult* FRPlayerObject::GetFrontCollision();
CoreDetectResult* FRPlayerObject::GetLeftCollision();
CoreDetectResult* FRPlayerObject::GetRightCollision();
CoreDetectResult* FRPlayerObject::GetBackCollision();
float FRPlayerObject::GetFrontHeight();
float FRPlayerObject::GetHeightBehind();
float FRPlayerObject::GetPositionHeight();
float FRPlayerObject::GetCeilingHeight();
void FRPlayerObject::GetAttractorInfo();
void FRPlayerObject::GetCollisionInfo(CoreObjectUpdateStruct* i_updateStruct);
void FRPlayerObject::ClearCollisionInfo(CoreObjectUpdateStruct* i_updateStruct);
void FRPlayerObject::SetupCurrentAttractors();
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\frplayercontrol.cpp
void FRPlayerObject::NetworkPlayerLogic(CoreObjectUpdateStruct* i_UpdateStruct);
void FRPlayerObject::PrimeDetectionCache();
void FRPlayerObject::UpdateLaraNav();
void FRPlayerObject::UpdateLaraRoom(float height);
void FRPlayerObject::DefaultPlayerLogic();
void FRPlayerObject::ResetPlayerToStand(bool killRagdoll);
bool FRPlayerObject::HandleAnimCommandCallback(CoreHash i_slotID, CoreAnimCommand* i_command);
bool FRPlayerObject::GetFloorSurfaceType(CoreVector& i_detectPosition, uint32_t& o_surfaceType);
void FRPlayerObject::CameraRelativeControls(CoreCameraObject* io_cameraObject);
void FRPlayerObject::GetControlInput(CoreInput* i_input, CoreEulerAngle& i_orient);
void FRPlayerObject::ClearControlInput(CoreInput* i_input, CoreEulerAngle& i_orient);
void FRPlayerObject::ResetAllActionStates();
void FRPlayerObject::UpdateActionStates();
void FRPlayerObject::SetupActionState(CoreHash i_actionName);
void FRPlayerObject::ResetActionState(CoreHash i_actionName);
void FRPlayerObject::ProcessEvent(CoreEvent* i_Event, CoreObjectUpdateStruct* io_UpdateStruct);
CoreCameraObject* FRPlayerObject::GetCurrentCamera();
int32_t FRPlayerObject::GetDebugModeSet();
void FRPlayerObject::GetCurrentCameraOrient(CoreEulerAngle& ang);
CoreVector FRPlayerObject::SnapToFloor(CoreVector i_pos);
bool FRPlayerObject::ResetPlayerToLastCheckPoint();
bool FRPlayerObject::CheckFallenOffWorld();
void FRPlayerObject::ClearLeanAngle();
void FRPlayerObject::SetPlayerOnFire(bool i_burn);
void FRPlayerObject::LaunchFlare();
void FRPlayerObject::UpdateFlares();
void FRPlayerObject::PlayerSpecificEffects();
void FRPlayerObject::RemoveGreenCrystal();
void FRPlayerObject::AddGreenCrystal();
void FRPlayerObject::UpdateGreenCrystalDisplay();
void FRPlayerObject::UpdateInventoryFlare();
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\frplayerobject.cpp
void* FRPlayerObject::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn FRPlayerObject::RunFunction(CoreCommand* io_command);
CoreObject* FRPlayerObject::Create(CoreMemory* io_memory);
void FRPlayerObject::Construct(CoreMemory* io_memory);
void FRPlayerObject::InitWeaponData();
void FRPlayerObject::SetInputPad(uint32_t i_PadNumber);
void FRPlayerObject::ReInit();
void FRPlayerObject::Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
void FRPlayerObject::Reset();
void FRPlayerObject::Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
int32_t FRPlayerObject::TakeDamage(int32_t i_damage, bool i_showBar);
void FRPlayerObject::SetMovePlayerTo(CoreVector i_pos, CoreEulerAngle i_rot);
void FRPlayerObject::UpdateMovePlayerTo();
CoreScripted::CommandReturn FRPlayerObject::eFnPlayerInit(CoreCommand* lpoCommand);
void FRPlayerObject::ShouldIBeUnderWater();
bool FRPlayerObject::IsInWater();
CoreDetectResult* FRPlayerObject::DoDetection(CoreVector vOldPos, CoreVector vNewPos);
int32_t FRPlayerObject::GetPlayerID();
void FRPlayerObject::MakeNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, CoreObjectUpdateStruct* lpoUpdateStruct);
void FRPlayerObject::UpdateFromNetworkPacket(CoreObject::CoreObjectNetworkUpdate* lpoData, int32_t& iDataRead, CoreObjectUpdateStruct* lpoUpdateStruct);
void FRPlayerObject::SetDetectionSpheres(bool i_blendSpheres, float i_blendTime);
void FRPlayerObject::EmulateCallBacks();
void FRPlayerObject::GetBonePositions();
CoreScripted::CommandReturn FRPlayerObject::FnSetInputPad(CoreCommand* io_Command);
void FRPlayerObject::OnPostRender();
void InitDebugHashes();
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\frplayerobject.h
void FRPlayerObject::FRPlayerObject();
CoreHash FRPlayerObject::GetTypeID();
void* FRPlayerObject::GetMemoryStack();
int32_t FRPlayerObject::GetMemoryStackSize();
void FRPlayerObject::ClearPlayerFlag(int32_t i_flagIndex);
bool FRPlayerObject::RequestAnim(CoreHash i_animState, uint32_t i_flags);
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\frplayerobjectdata.h
void FRPlayerObjectData::FRPlayerObjectData();
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\frshimmycontrol.cpp
bool FRPlayerObject::ContextGrabbableLedgeFromLRShimmyJump(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableLedgeFromLRHangJump(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableLedgeFromLRClimbableWallJump(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyBlending(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCanShimmyLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCanShimmyRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyInternal90(bool i_goingLeft);
bool FRPlayerObject::ContextShimmyExternal90(bool i_goingLeft);
bool FRPlayerObject::ContextShimmyLeftInternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyRightInternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyLeftExternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyRightExternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCanShimmyJumpRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCanShimmyJumpLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyJumpToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyJumpToHang(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyJumpToClimbableWall(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCanHPoleShimmyLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextCanHPoleShimmyRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextHangToHPole(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionAlignHang(FRPlayerObject* i_obj, int32_t i_temp);
float FRPlayerObject::CalculateShimmyJumpParams(float i_yOff, float i_jumpDist, bool i_jumpLeft, CoreEulerAngle& i_dir, CoreVector& o_source, CoreVector& o_target, CoreVector& o_externalVelocity);
bool FRPlayerObject::GetShimmyJumpLRDistance(float i_stepDist, bool i_setVel);
AttractorTable* FRPlayerObject::GetNearestIntersectingAttractor(CoreVector i_pos, CoreEulerAngle i_dir, bool i_jumpLeft, float i_minXZ, float i_maxXZ, float i_minY, float i_maxY, float& o_xzOffset, float& o_yOffset);
float FRPlayerObject::GetAttractorYPos(TRAttractor* i_currentAttractor, TRAttractor* i_joiningAttractor, float i_distFromEdge, int32_t i_commonPoint, CoreVector& io_newPos);
float FRPlayerObject::GetAttractorYPosByVector(CoreVector& i_p0, CoreVector& i_p1, float i_distFromEdge, CoreVector& io_newPos);
float FRPlayerObject::GetShimmyAngle(TRAttractor* i_currentAttractor, TRAttractor* i_joiningAttractor, int32_t i_commonPoint);
bool FRPlayerObject::ContextCanPlantFeet(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyChangeFootPlantation(bool i_goingLeft, bool i_shimmyToHang);
bool FRPlayerObject::ContextShimmyToHangRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyToHangLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextHangToShimmyRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextHangToShimmyLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyInternal90ToHang(bool i_goingLeft, bool i_execute);
bool FRPlayerObject::ContextShimmyExternal90ToHang(bool i_goingLeft, bool i_execute);
bool FRPlayerObject::ContextShimmyLeftInternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyLeftExternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyRightInternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyRightExternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyLeftInternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyLeftExternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyRightInternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextShimmyRightExternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextHangInternal90(bool i_goingLeft);
bool FRPlayerObject::ContextHangExternal90(bool i_goingLeft);
bool FRPlayerObject::ContextHangLeftInternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextHangLeftExternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextHangRightInternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextHangRightExternal90(FRPlayerObject* i_obj, int32_t i_temp);
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\frtricktable.cpp
void FRTrickTable::FRTrickTable();
void FRTrickTable::Init(CoreScriptStore* scriptPtr, CoreMemory* io_memory, FRPlayerObject* i_player);
void FRTrickTable::Reset(FRPlayerObject* i_player);
CoreHash* FRTrickTable::GetTrick(CoreHash i_currentAnim, FRPlayerObject* player);
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\trclimbcontrol.cpp
void FRPlayerObject::GetClimbWallAttractorData(TRAttractor* i_aPtr, CoreVector& i_playerPos, TRClimbData& o_cd);
void FRPlayerObject::ClimbWallAttractorDataSetup(TRAttractor* i_aPtr, TRClimbData& o_cd);
void FRPlayerObject::ClimbWallAttractorDataSetPos(CoreVector& i_playerPos, TRClimbData& o_cd);
void TRClimbData::FlippertyJibbit(bool i_originAtHands, bool& o_insideHeight, float& o_distFromEdge);
void FRPlayerObject::DrawClimbWallAttractor(TRClimbData& i_cd, bool i_selected);
TRAttractor* FRPlayerObject::GetClimbWallAttractorNext(ClimbWallDirectionType i_climbWallDirection, CoreVector& i_playerPos, TRClimbData& i_cdCurr, TRClimbData& o_cd);
bool FRPlayerObject::CheckClimbableWallHeight(AttractorTable* i_aPtr, float i_minHeight, float i_maxHeight, float i_climbHeight);
bool FRPlayerObject::ContextClimbableWallInFront(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallGetOff(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallDropOff(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallCanClimbUp(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::CheckClimbableWallCanClimbDown(bool i_static);
bool FRPlayerObject::ContextClimbableWallCanClimbDownStatic(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallCanClimbDownDynamic(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallCanClimbLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallCanClimbRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::CheckClimbableWallExternal90(bool i_goingLeft);
bool FRPlayerObject::CheckClimbableWallInternal90(bool i_goingLeft);
bool FRPlayerObject::ContextClimbableWallLeftInternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftExternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightInternal90(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightExternal90(FRPlayerObject* i_obj, int32_t i_temp);
float FRPlayerObject::ClimbableWallGetVerticalSnap(CoreVector& i_playerPos, TRClimbData& i_cd);
bool FRPlayerObject::FunctionClimbableWallAlign(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ClimbWallEdgeCanAlign(ClimbWallDirectionType i_climbWallDirection, TRClimbData& i_cdCurr, bool& o_offsetRequired, CoreVector& o_offset);
void FRPlayerObject::ClimbWallEdgeAlign(ClimbWallDirectionType i_climbWallDirection, TRClimbData& i_cdCurr);
bool FRPlayerObject::CheckClimbableWallGrabbable(float i_dist, float i_yMove, float i_minHeightDiff, float i_maxHeightDiff, float i_atrMaxDist, bool i_scrambleTest, bool i_shimmyTest, float i_maxAngle);
bool FRPlayerObject::ContextGrabbableClimbableWallFromJumpUp(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableClimbableWallFromDropLoopDown(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableClimbableWallFromDropLoop(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableClimbableWallFromJumpForward(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableClimbableWallScramble(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableClimbableWallScramble2_0m(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableClimbableWallScramble2_5m(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableClimbableWallScramble3_0m(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextGrabbableClimbableWallScramble3_5m(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallAllowRelease(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallFromClimb(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallFromShimmyStance(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::CheckClimbableWallConnectsToShimmy(TRClimbData& i_cdCurr, AttractorTable* i_aPtrShimmy, CoreVector& o_nearPointOnLine, CoreVector& o_farPointOnLine, CoreVector& o_wallPoint, CoreVector& i_playerPos, CoreEulerAngle& i_playerRot, float i_moveDirection);
bool FRPlayerObject::CheckClimbableWallFromShimmy(float i_moveDirection, float i_cornerAngle, CoreVector& io_playerPos, AttractorTable*& o_aPtr, CoreVector& o_nearPointOnLine, CoreVector& o_farPointOnLine, CoreVector& o_wallPoint, float& o_edgeDist, TRClimbData& o_cdCurr, float i_maxEdgeDist);
bool FRPlayerObject::CheckClimbableWallFromShimmyStraight(bool i_goingLeft);
bool FRPlayerObject::CheckClimbableWallFromShimmyInternal90(bool i_goingLeft, float i_maxCornerDist, float i_idealCornerDist);
bool FRPlayerObject::CheckClimbableWallFromShimmyExternal90(bool i_goingLeft, float i_maxCornerDist, float i_idealCornerDist);
bool FRPlayerObject::ContextClimbableWallFromShimmyLeft(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallFromShimmyRight(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::CheckClimbableWallToShimmy(float i_moveDirection, float i_cornerAngle, CoreVector& io_playerPos, AttractorTable*& o_aPtr, CoreVector& o_nearPointOnLine, CoreVector& o_farPointOnLine, CoreVector& o_wallPoint, float& o_edgeDist, TRAttractor*& o_atrCurr, float i_maxEdgeDist, bool i_feetPlantable);
bool FRPlayerObject::CheckClimbableWallToShimmyStraight(bool i_goingLeft);
bool FRPlayerObject::CheckClimbableWallToShimmyInternal90(bool i_goingLeft);
bool FRPlayerObject::CheckClimbableWallToShimmyExternal90(bool i_goingLeft);
bool FRPlayerObject::ContextClimbableWallLeftToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftInternal90ToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftExternal90ToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightInternal90ToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightExternal90ToShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftInternal90FromShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftExternal90FromShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightInternal90FromShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightExternal90FromShimmy(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftInternal90FromHang(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftExternal90FromHang(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightInternal90FromHang(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightExternal90FromHang(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::CheckClimbableWallToHangStraight(bool i_goingLeft);
bool FRPlayerObject::CheckClimbableWallToHangInternal90(bool i_goingLeft, bool i_execute);
bool FRPlayerObject::CheckClimbableWallToHangExternal90(bool i_goingLeft, bool i_execute);
bool FRPlayerObject::ContextClimbableWallLeftToHang(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightToHang(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftInternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftExternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightInternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightExternal90ToHang1(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftInternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallLeftExternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightInternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextClimbableWallRightExternal90ToHang2(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::CheckClimbableWallToAnyShimmy(bool i_goingLeft);
bool FRPlayerObject::CheckClimbableWallFromAnyShimmy(bool i_goingLeft);
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\trhair.cpp
void FRPlayerObject::UpdateHair();
void FRPlayerObject::InitialiseHair();
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\trswimcontrol.cpp
bool FRPlayerObject::ContextNoSwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionIncUnderwaterSwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionIncSurfaceSwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionDecSwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionHandleUnderwaterAnalog(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionHandleSurfaceAnalog(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionApplySwimVelocity(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionBlendToWaterSurface(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::GetWaterHeight(CoreVector i_pos, float& o_waterHeight);
bool FRPlayerObject::IsPointUnderwater(CoreVector i_pos);
bool FRPlayerObject::ContextIsHeadAboveWater(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextNotInWater(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextDroppedIntoWater(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextIsHeadBelowWater(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionSetSurfaceSlowSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionSetSurfaceNormalSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionSetSurfaceFastSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionSetUnderwaterNormalSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::FunctionSetUnderwaterFastSwimSpeed(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextDiveUnderwater(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextResetSwimOrient(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::CheckWaterClimbHeight(AttractorTable* i_aPtr, float i_minHeight, float i_maxHeight, float i_climbHeight);
bool FRPlayerObject::ContextClimbOutOfWater(FRPlayerObject* i_obj, int32_t i_temp);
void FRPlayerObject::ApplyWaterCurrent();
#endif

#if 1 // c:\projects\source\tombraider\frplayerobject\trweaponcontrol.cpp
void TRWeaponAimControl::Reset();
void TRWeaponAimControl::StartAiming(CoreObject* i_target);
bool TRWeaponAimControl::HasTarget();
bool TRWeaponAimControl::HasTargetLock();
bool TRWeaponAimControl::HasTargetArmLock();
void TRWeaponAimControl::GetAimAngleLimits(WeaponInfoStruct* i_weapon, float& o_minYaw, float& o_maxYaw, float& o_minPitch, float& o_maxPitch);
bool FRPlayerObject::WeaponTargetIsValid(CoreObject* i_target, float* o_targetDist, CoreEulerAngle* o_targetRot, bool i_checkAngle);
bool FRPlayerObject::WeaponGetTargetPos(CoreObject* m_target, CoreVector& o_pos);
void FRPlayerObject::WeaponUpdate(TRWeaponAimControl& i_weaponAim);
void FRPlayerObject::BoneControlCallback(CoreGeometryObject* i_object, CoreMatrix* io_currMatrix, CoreMatrix* io_parentMatrix, CoreQuat* io_currJointQuat, void* io_data, CoreModelJoint* i_modelJoint);
void FRPlayerObject::WeaponFindTargets(TRWeaponTarget* o_targets, int32_t& o_targetCount, int32_t i_maxTargets);
void FRPlayerObject::WeaponSystemInit();
void FRPlayerObject::WeaponCreation();
void FRPlayerObject::WeaponPlacement();
bool FRPlayerObject::IsWeaponDrawn();
void FRPlayerObject::ForceWeaponHolster();
bool FRPlayerObject::CanDrawWeapon();
bool FRPlayerObject::CanAimBody();
void FRPlayerObject::WeaponEventDraw(CoreHash i_slotID);
void FRPlayerObject::WeaponEventHolster(CoreHash i_slotID);
void FRPlayerObject::WeaponEventFire(CoreHash i_slotID);
void FRPlayerObject::WeaponSystemUpdate();
int32_t FRPlayerObject::WeaponUpdateTargetting(CoreObject** o_targets);
void FRPlayerObject::WeaponControlOneHanded();
void FRPlayerObject::WeaponControlTwoHanded();
void FRPlayerObject::WeaponCameraUpdate();
bool FRPlayerObject::ContextWeaponDrawn(FRPlayerObject* i_obj, int32_t i_temp);
bool FRPlayerObject::ContextWeaponHolstered(FRPlayerObject* i_obj, int32_t i_temp);
#endif

#if 1 // c:\projects\source\tombraider\frworld\frworld.cpp
void* FRWorld::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn FRWorld::RunFunction(CoreCommand* io_command);
void FRWorld::Init(CoreWorldUpdateStruct* lpoWorldUpdateStruct);
void FRWorld::Construct(CoreMemory* lpoMemory, int32_t iNumParams, char** lplpcParams);
void FRWorld::SetPlayerStartPos(int32_t i_index, float i_x, float i_y, float i_z, float i_rot);
CoreScripted::CommandReturn FRWorld::FnSetPaused(CoreCommand* io_command);
CoreLevel* FRWorld::CreateLevel(CoreMemory* io_memory);
CoreAIController* FRWorld::CreateAIController(CoreMemory* io_memory);
void FRWorld::UnpauseForMenu();
void FRWorld::SetPaused(bool i_paused, bool bPauseAudio);
void FRWorld::ForcePaused(bool i_paused, bool bPauseAudio, bool i_dontLoadMenu, bool i_moveCamera);
bool FRWorld::CanPause();
void FRWorld::StartRecordPlayback();
void FRWorld::UpdateRecordPlayback();
void FRWorld::RenderLoadingIcon(CoreGameRender* i_graphics, CoreTextureSet* i_textureSet, int32_t i_flags, float i_x0, float i_y0, CoreRGBA i_col, float i_scale);
void FRWorld::RenderLoadingScreen(CoreGameRender* i_graphics, CoreTextureSet** i_textureSet);
void FRWorld::RememberLevelName(char* i_level, char* i_area);
void FRWorld::SetLoadingScreen(CoreHash i_loadingScreen);
float FRWorld::GetNumDetectCaches();
CorePanel* FRWorld::CreatePanel(CoreMemory* io_memory);
void FRWorld::Update(CoreWorldUpdateStruct* lpoWorldUpdateStruct, float fTimeElapsed);
#endif

#if 1 // c:\projects\source\tombraider\frworld\frworld.h
void FRWorld::FRWorld();
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newbat.cpp
void NewBatControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newbear.cpp
void NewBearControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newcogs.cpp
void NewCogControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newdino.cpp
void NewDinoControl(TRGameObject* i_object);
void NewTrexControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newdoors.cpp
void NewDoorInitialise(TRGameObject* i_object);
void NewDoorControl(TRGameObject* i_object);
void NewDrawBridgeControl(TRGameObject* i_object);
void NewCabinControl(TRGameObject* i_object);
void NewScionControl(TRGameObject* i_object);
void NewScion3Initialise(TRGameObject* i_object);
void NewScion3Control(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newhints.cpp
void NewHintInitialise1(TRGameObject* i_object);
void NewHintInitialise2(TRGameObject* i_object);
void NewHintControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newlightning.cpp
void NewInitialiseLightning(TRItem* item);
void NewLightningCollision(TRItem* item, TRItem* laraItem, TRCollInfo* coll);
void NewInitialiseThorsHandle(TRItem* item);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newmoveblock.cpp
void NewMovingBlockInitialise(TRGameObject* i_object);
void NewMovableBlockControl(TRGameObject* i_object);
void NewMovableBlockCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
int32_t NewTestBlockPush(TRGameObject* i_object, int32_t blokhite, uint32_t quadrant);
int32_t NewTestBlockPull(TRGameObject* i_object, int32_t blokhite, uint32_t quadrant);
void NewRollingBlockControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newpeople.cpp
void TempLarsonPierrePathControl(TRGameObject* i_object, float* i_path, int32_t i_numPathPoints);
void TempLarsonPathControl(TRGameObject* i_object);
void TempPierrePathControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newpickups.cpp
void NewInitialisePickup(TRGameObject* i_object);
void NewPickupControl(TRGameObject* i_object);
void NewPickupCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
void NewPickUpScionCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
void NewPickUpScion4Collision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
void NewMidasCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
void NewKeyHoleCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* i_coll);
void NewPuzzleHoleCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* i_coll);
void NewPickUpSaveGameCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
void NewInitialiseBlueSaveItem(TRGameObject* i_object);
void NewInitialiseRedSaveItem(TRGameObject* i_object);
void NewControlSavegameItem(TRGameObject* i_object);
void StartGreenCrystalSave(FRPlayerObject* i_laraObject, TRGameObject* i_object);
void NewInitialiseGreenSaveItem(TRGameObject* i_object);
void NewControlGreenSaveItem(TRGameObject* i_object);
void NewGreenSaveCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newraptor.cpp
void NewRaptorControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newswitches.cpp
void NewSwitchControl(TRGameObject* i_object);
void NewSwitchCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* i_coll);
void NewSwitchCollision2(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* i_coll);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newtraps.cpp
void NewInitialiseRollingBall(TRGameObject* i_object);
void NewRollingBallControl(TRGameObject* i_object);
void NewRollingBallCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
void NewSpikeCollision(TRGameObject* i_object, FRPlayerObject* i_laraObject, TRCollInfo* coll);
void NewTrapDoorControl(TRGameObject* i_object);
void NewPendulum(TRGameObject* i_object);
void NewFallingBlock(TRGameObject* i_object);
void NewTeethTrapControl(TRGameObject* i_object);
void NewFallingCeilingControl(TRGameObject* i_object);
void NewDamoclesSwordCollision(TRItem* item, TRItem* laraItem, TRCollInfo* coll);
void NewDartsControl(TRItem* item);
void NewWaterFallControl(TRItem* item);
void SkullFlameEmitterInitialise(TRGameObject* i_object);
void SkullFlameEmitterControl(TRGameObject* i_object);
void DartEmitterInitialise(TRGameObject* i_object);
void DartEmitterControl(TRGameObject* i_object);
void SpikeTrapControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newwarrior.cpp
void NewInitialiseWarrior2(TRItem* item);
void NewInitialiseMummy(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\newwolf.cpp
void WolfFall(TRGameObject* i_object);
bool WolfCheckJumps(TRGameObject* i_object, TRNewAIInfo* i_info, TRCreature* i_creature);
void NewWolfControl(TRGameObject* i_object);
void NewInitialiseSpider(TRItem* item);
void NewLionControl(TRItem* item);
#endif

#if 1 // c:\projects\source\tombraider\objectcontrol\specialobjects.cpp
void SpecialObjectInitialise(TRGameObject* i_object);
void SpecialObjectControl(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\trai\traicontroller.cpp
void TRAIController::LevelInit();
bool TRAIController::GetNavTriangle(CREATURE_DEF i_creatureDef, CoreNavPos* io_navPos);
bool TRAIController::PickBoredDestination(TRNav* io_nav);
bool TRAIController::PickEscapeDestination(TRNav* io_nav);
bool TRAIController::GetGibbysMagicTrianglePos(CREATURE_DEF i_creatureDef, CoreNavPos* i_srcNav, CoreNavPos* i_destNav, int32_t i_lookAhead, CoreVector* o_pos);
bool TRAIController::UpdateTarget(CREATURE_DEF i_creatureDef, TRNav* io_nav, CoreNavPos* i_dest, int32_t i_lookAhead);
bool TRAIController::EnableBaddieAI(TRGameObject* object);
void TRAIController::InitialiseSlot(TRGameObject* i_object, int32_t i_slot);
void TRAIController::CreatureAIInfo(TRGameObject* object, TRNewAIInfo* info, TRCreature* i_creature);
void TRAIController::CreatureMood(TRGameObject* object, TRNewAIInfo* info, int32_t violent);
float TRAIController::CreatureTurn(TRGameObject* i_object, float i_maxTurn, TRNewAIInfo* i_aiInfo);
void TRAIController::CreatureTilt(TRGameObject* i_object, float i_tilt);
void TRAIController::CreatureBoneRotation(TRGameObject* object, int32_t i_bone, float i_turn, float i_maxTurn, TRCreature* i_creature);
int32_t TRAIController::CreatureAnimation(TRGameObject* i_object, float angle, TRCreature* i_creature);
int32_t TRAIController::CreatureCreature(TRGameObject* i_object, CoreVector* o_objectPos);
int32_t TRAIController::GetRandomControl();
void TRAIController::DoDebug(CoreDebugInput* i_input);
void TRNav::SetTarget(CoreVector i_target, uint32_t i_navMesh, uint32_t i_triangle);
void TRNav::SetAltTarget(CoreVector i_target, uint32_t i_navMesh, uint32_t i_triangle);
void NewInitialiseCreature(TRGameObject* i_object);
#endif

#if 1 // c:\projects\source\tombraider\trai\traicontroller.h
void TRAIController::TRAIController();
void TRAIController::~TRAIController();
#endif

#if 1 // c:\projects\source\tombraider\trattractors\trattractors.cpp
void TRAttractors::InsertAttractor(AttractorTable* o_atHead, AttractorTable* io_atNew);
int32_t TRAttractors::GetNearbyAttractors(CoreVector i_pos, CoreEulerAngle i_dir, float i_range, AttractorTable* o_attractorHead, AttractorTable* o_attractorTable);
#endif

#if 1 // c:\projects\source\tombraider\trattractors\trattractors.h
CoreHash TRAttractor::GetTypeHash();
bool TRAttractor::IsAnEdge();
bool TRAttractor::IsAWaterEdge();
bool TRAttractor::IsAHangEdge();
bool TRAttractor::IsAnInWall();
bool TRAttractor::IsAHangInWall();
bool TRAttractor::IsAHPole();
bool TRAttractor::IsLastChanceGrabbable();
bool TRAttractor::IsALastChanceGrabEdge();
bool TRAttractor::IsALastChanceGrabHangEdge();
bool TRAttractor::IsHangFeetPlantable();
bool TRAttractor::IsHangFeetNotPlantable();
bool TRAttractor::IsClimbableWall();
bool TRAttractor::IsOverhangEdge();
#endif

#if 1 // c:\projects\source\tombraider\trcamera\trchasecamera.cpp
void* TRChaseCamera::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn TRChaseCamera::RunFunction(CoreCommand* io_command);
CoreHash TRChaseCamera::GetTypeID();
CoreObject* TRChaseCamera::Create(CoreMemory* io_memory);
void TRChaseCamera::TRChaseCamera();
void TRChaseCamera::Construct(CoreMemory* io_memory);
void TRChaseCamera::OnSwitchedTo(CoreCameraObject* io_fromCam);
void TRChaseCamera::SetTarget(CoreGeometryObject* i_object);
void CoreGameOnScreenKeyboardParameters::SetStartSoundHash(CoreHash i_soundHash);
void TRChaseCamera::SetOffset(CoreVector& i_offset);
void TRChaseCamera::AdjustCameraAngle(float i_deltaAngle, float i_deltaPitch, float i_deltaRoll);
void TRChaseCamera::AdjustCameraDistance(float i_requiredDistance);
bool TRChaseCamera::AdjustCameraAngleTo(float i_toAngle, float i_speed);
bool TRChaseCamera::AdjustCameraPitchTo(float i_toPitch, float i_speed, CAMMODE i_mode);
bool TRChaseCamera::AdjustCameraAngleOverride(float i_targetAngleX, float i_targetAngleY, float i_speed);
void TRChaseCamera::UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
void TRChaseCamera::ResetPosition();
CoreScripted::CommandReturn TRChaseCamera::DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
CoreVector TRChaseCamera::GetTargetPosition(float i_time, CoreObjectUpdateStruct* updateStruct);
void TRChaseCamera::UpdateDistance(float i_distance, float i_time);
void TRChaseCamera::UpdateAngleVelocity(float i_angleDelta, float i_time);
#endif

#if 1 // c:\projects\source\tombraider\trcamera\trchasecamera.h
void* TRChaseCamera::GetMemoryStack();
#endif

#if 1 // c:\projects\source\tombraider\trcamera\trfixedcamera.cpp
CoreScripted::CommandReturn TRFixedCamera::RunFunction(CoreCommand* io_command);
CoreHash TRFixedCamera::GetTypeID();
CoreObject* TRFixedCamera::Create(CoreMemory* io_memory);
void TRFixedCamera::TRFixedCamera();
void TRFixedCamera::Construct(CoreMemory* io_memory);
void TRFixedCamera::OnSwitchedTo(CoreCameraObject* io_fromCam);
void TRFixedCamera::UpdateFromViewer(CoreObjectUpdateStruct* i_updateStruct);
CoreScripted::CommandReturn TRFixedCamera::DefaultCameraLogic(CoreObjectUpdateStruct* i_updateStruct);
#endif

#if 1 // c:\projects\source\tombraider\treditor\treditcameras.cpp
void TREditCameras::Init();
void TREditCameras::Render();
#endif

#if 1 // c:\projects\source\tombraider\treditor\tredititems.cpp
void TREditItems::Init();
void TREditItems::Render();
#endif

#if 1 // c:\projects\source\tombraider\treditor\treditor.cpp
void TREditor::GlobalInit();
void TREditor::LevelInit();
void TREditor::Update();
void TREditor::Render();
void TREditor::Save();
void TREditor::CreateMainDialog();
void TREditor::CreateNodeDialog();
void TREditor::CreateEventDialog();
void TREditor::PopulateNodeDialog(TRManipNode* iManip, bool iFullUpdate);
void TREditor::PopulateRoomDialog(TRManipNode* iManip, bool iFullUpdate);
void TREditor::SetActive(bool i_active);
bool TREditor::IsActive();
void TREditor::ReadMouse();
void TREditor::UpdateCamera();
void TREditor::SetupCamera();
void TREditor::RestartLevel();
#endif

#if 1 // c:\projects\source\tombraider\treditor\treditordialog.cpp
void PopulateRoomList(HWND* hDlg);
void SetupRoomsCombo();
int32_t __stdcall GeneralDialogController(HWND* hDlg, uint32_t message, uint32_t wParam, int32_t lParam);
void EditorDialog_UpdateRoomSelection(int32_t iRoom);
#endif

#if 1 // c:\projects\source\tombraider\treditor\tredittriggers.cpp
void TREditTriggers::Init();
void TREditTriggers::SaveData();
void TREditTriggers::Render();
void TREditTriggers::AddText(CoreVector* i_pos, char* i_str, CoreRGBA i_colour);
void TREditTriggers::RenderTriggerLinks(TRETriggerBox* box);
#endif

#if 1 // c:\projects\source\tombraider\treditor\tredobject.cpp
CoreScripted::CommandReturn TREdObject::RunFunction(CoreCommand* io_command);
CoreObject* TREdObject::Create(CoreMemory* io_memory);
void TREdObject::Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
CoreScripted::CommandReturn TREdObject::FnSetDefaultAnimSet(CoreCommand* io_command);
#endif

#if 1 // c:\projects\source\tombraider\treditor\tredobject.h
void TREdObject::TREdObject();
CoreHash TREdObject::GetTypeID();
int32_t TRGameObject::GetMemoryStackSize();
int32_t CoreCutSceneCamera::GetMemoryStackSize();
int32_t CoreChaseCamera::GetMemoryStackSize();
int32_t TRChaseCamera::GetMemoryStackSize();
int32_t CoreGroupCamera::GetMemoryStackSize();
int32_t TRFoliageObject::GetMemoryStackSize();
void* FRBackgroundObject::GetMemoryStack();
void* TREdObject::GetMemoryStack();
void* TRInvObject::GetMemoryStack();
void* TRMultiMeshObject::GetMemoryStack();
int32_t TREdObject::GetMemoryStackSize();
int32_t CoreGroupRailCamera::GetMemoryStackSize();
void* TRFoliageObject::GetMemoryStack();
void* TRGameObject::GetMemoryStack();
int32_t TRMultiMeshObject::GetMemoryStackSize();
int32_t TRInvObject::GetMemoryStackSize();
int32_t TRFixedCamera::GetMemoryStackSize();
void* CoreCutSceneObject::GetMemoryStack();
int32_t CoreFlexibleCamera::GetMemoryStackSize();
int32_t CoreRailCamera::GetMemoryStackSize();
int32_t CoreViewerObject::GetMemoryStackSize();
#endif

#if 1 // c:\projects\source\tombraider\treditor\treventdialog.cpp
void EventDialog_SetEventGroup(uint32_t iGroup);
void onComboEventGroupSelChange(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onComboGroupTypeSelChange(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButtonNewGroup(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButtonNewEvent(HWND* hDlg, uint32_t wParam, int32_t lParam, bool bInsertAfter);
void onButtonDeleteEvent(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButtonRenameGroup(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onComboEventTypeSelChange(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButtonFindSource(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButtonFindTarget(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButtonFindItemTarget(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onEditValueChange(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onEditDelayChange(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onReturnItemSetTarget(TRNode* pRetNode);
void onButtonSetGroupItem(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onReturnSetTarget(TRNode* pRetNode);
void onButtonSetTarget(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onSelChangeEventList(HWND* hDlg, uint32_t wParam, int32_t lParam);
int32_t __stdcall EventDialogProc(HWND* hDlg, uint32_t message, uint32_t wParam, int32_t lParam);
void EventDialog_PopulateEventGroupList(uint32_t iEvent);
void EventDialog_PopulateEventSourceList(uint32_t iEvent);
void EventDialog_PopulateEventCombo(bool bResetSelection);
void EventDialog_ShowCodeBits(HWND* hDlg, uint32_t iCodeBits);
uint32_t EventDialog_GetCodeBits(HWND* hDlg);
void EventDialog_PopulateGroupTab(uint32_t iGroup);
void EventDialog_PopulateEventTab(uint32_t iGroup, uint32_t iEvent);
void EventDialog_PopulateEventDialog();
#endif

#if 1 // c:\projects\source\tombraider\treditor\trhititem.cpp
void TRHitItem::initHitItems();
void TRHitItem::createItemsFromChain(CoreNode* pFirstNode);
CoreNode* TRHitItem::GetPickedItemNode();
CoreSceneContainer* TRHitItem::GetPickedItemRoom();
void TRHitItem::createAndAttachItem(CoreNode* iNode, CoreVector iOffset);
void TRHitItem::processScene(uint32_t* iVisibleList, uint32_t iVisibleCount);
void TRHitItem::renderScene();
void TRHitItem::processNodeChain(CoreNodeRoot* pChainRoot);
CoreVector TRHitItem::GetItemPosition();
CoreVector TRHitItem::GetItemScale();
uint32_t TRHitItem::GetItemNodeType();
void TRHitItem::renderHandle();
TRHitItem* TRHitItem::GetPickedItem();
TRHitItem* TRHitItem::GetItemAddress(int32_t iItem);
void TRHitItem::updateItemPosition(CoreVector iPos);
void TRHitItem::updateItemScale(CoreVector iScl);
uint32_t TRHitItem::GetItemFlags(int32_t iIndex);
void TRHitItem::SetItemFlags(int32_t iIndex, uint32_t iFlags);
void TRHitItem::SetRotation(int32_t iIndex, float iX, float iY, float iZ);
void TRHitItem::SetItemShape(int32_t iIndex, TRHitItem::itemShape iShape);
#endif

#if 1 // c:\projects\source\tombraider\treditor\tritemsdialog.cpp
void FillInItemDialog();
#endif

#if 1 // c:\projects\source\tombraider\treditor\trnodedialog.cpp
void onCombo1SelChange(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onCombo2SelChange(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButton1(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButton2(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButton3(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButton4(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onButton6(HWND* hDlg, uint32_t wParam, int32_t lParam);
void OnChangeEditFogDensity(HWND* hDlg, uint32_t wParam, int32_t lParam, char* iEditText);
void NodeDialog_RenameNode(HWND* hDlg);
void onAssociateReturnSetTarget(TRNode* pRetNode);
void NodeDialog_SetAssociateNode(HWND* hDlg);
void NodeDialog_FillRect(HWND* hWnd, uint32_t rgb);
void NodeDialog_SetRoomFog(HWND* hDlg);
int32_t __stdcall NodeDialogProc(HWND* hDlg, uint32_t message, uint32_t wParam, int32_t lParam);
void NodeDialog_DisplayItemGroup(int32_t iStartItem, int32_t iTermItem, bool bShow);
uint32_t NodeDialog_GetCodeBits(HWND* hDlg);
void NodeDialog_ShowCodeBits(HWND* hDlg, uint32_t iCodeBits);
void NodeDialog_PopulateRoomDialog(TRManipNode* iManip, bool iFullUpdate);
void NodeDialog_PopulateNodeDialog(TRManipNode* iManip, bool iFullUpdate);
void ModelPickDialog_PopulateModelList(HWND* hDlg);
int32_t __stdcall ModelPickDialogProc(HWND* hDlg, uint32_t message, uint32_t wParam, int32_t lParam);
#endif

#if 1 // c:\projects\source\tombraider\treditor\trpicktargetdialog.cpp
void onComboTargetTypeSelChange(HWND* hDlg, uint32_t wParam, int32_t lParam);
void onListTargetSelChange(HWND* hDlg, uint32_t wParam, int32_t lParam);
int32_t __stdcall PickTargetDialogProc(HWND* hDlg, uint32_t message, uint32_t wParam, int32_t lParam);
void TargetDialog_InvokeTargetDialog(HWND* hWnd, uint32_t iMode, void* iExitCallBack);
void TargetDialog_PopulateTargetDialog(uint32_t iMode, bool ibPopulateCombo);
int32_t __stdcall NameDebugDialogProc(HWND* hDlg, uint32_t message, uint32_t wParam, int32_t lParam);
void NameDebugDialog_InvokeNameDebugDialog();
#endif

#if 1 // c:\projects\source\tombraider\treditor\trregval.cpp
void RegVal::RegVal(tagRECT& value, char* subkey, char* key);
void RegVal::~RegVal();
void RegVal::Read();
void RegVal::Write();
#endif

#if 1 // c:\projects\source\tombraider\treditor\trtriggersdialog.cpp
void FillInTriggersDialog();
#endif

#if 1 // c:\projects\source\tombraider\treffects\treffects.cpp
void TREffects::DoEffect(int32_t i_effectNum, TRGameObject* i_object);
void TREffects::DinoStompEffect(TRGameObject* i_object, float i_maxCameraShakeDistance, float i_maxBounce);
#endif

#if 1 // c:\projects\source\tombraider\trfoliage\trfoliageobject.cpp
CoreScripted::CommandReturn TRFoliageObject::RunFunction(CoreCommand* io_command);
CoreObject* TRFoliageObject::Create(CoreMemory* io_memory);
void TRFoliageObject::Construct(CoreMemory* io_memory);
void TRFoliageObject::UpdateGameCycle(float i_time);
void TRFoliageObject::Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
CoreScripted::CommandReturn TRFoliageObject::FnSetDefaultObjectTemplate(CoreCommand* io_command);
CoreScripted::CommandReturn TRFoliageObject::FnSetDefaultTextureTemplate(CoreCommand* io_command);
void TRFoliageObject::SetFileInfo(char* i_pPath, char* i_pFileName);
void TRFoliageObject::SetMaxWobble(float fWobble);
#endif

#if 1 // c:\projects\source\tombraider\trfoliage\trfoliageobject.h
void TRFoliageObject::TRFoliageObject();
CoreHash TRFoliageObject::GetTypeID();
#endif

#if 1 // c:\projects\source\tombraider\trgameobject\trgameobject.cpp
CoreScripted::CommandReturn TRGameObject::RunFunction(CoreCommand* io_command);
CoreObject* TRGameObject::Create(CoreMemory* io_memory);
void TRGameObject::Construct(CoreMemory* io_memory);
void TRGameObject::Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
void TRGameObject::UpdateGameCycle(float i_time);
void TRGameObject::Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
void TRGameObject::BoneControlCallback(CoreGeometryObject* i_object, CoreMatrix* io_currMatrix, CoreMatrix* io_parentMatrix, CoreQuat* io_currJointQuat, void* io_data, CoreModelJoint* i_modelJoint);
int32_t TRGameObject::TriggerActive();
bool TRGameObject::GetFloorSurfaceType(CoreVector& i_detectPosition, uint32_t& o_surfaceType);
CoreScripted::CommandReturn TRGameObject::FnSetDefaultObjectTemplate(CoreCommand* io_command);
CoreScripted::CommandReturn TRGameObject::FnSetDefaultEngineTemplate(CoreCommand* io_command);
CoreScripted::CommandReturn TRGameObject::FnSetDefaultTextureTemplate(CoreCommand* io_command);
CoreScripted::CommandReturn TRGameObject::FnSetDefaultAnimSet(CoreCommand* io_command);
TRItem* TRGameObject::GetTRItem();
TRCreature* TRGameObject::GetAIPtr();
void TRGameObject::InitFromObjectDB();
void TRGameObject::RequestAnim(CoreHash i_animState, int32_t i_flags);
void TRGameObject::NewAnimate(bool i_applyVelocity);
void TRGameObject::NewAnimateMovableBlock(int32_t i_direction);
bool TRGameObject::HandleAnimCommandCallback(CoreHash i_slotID, CoreAnimCommand* i_command);
void TRGameObject::ClearOffsetBlends();
void TRGameObject::ClearOffsetOrientBlends();
void TRGameObject::DoOffsetBlending(bool i_complete);
CoreDetectResult* TRGameObject::DoDetection(CoreVector i_oldPos, CoreVector i_newPos);
#endif

#if 1 // c:\projects\source\tombraider\trgameobject\trgameobject.h
void TRGameObject::TRGameObject();
CoreHash TRGameObject::GetTypeID();
void TRGameObject::SetRoomNumber(int32_t i_room);
void TRGameObject::SetOffsetBlend(CoreVector i_vector, float i_orient, float i_time, int32_t i_slot);
#endif

#if 1 // c:\projects\source\tombraider\trgameobject\trragdoll.cpp
void TRRagdoll::Setup(TRGameObject* i_object);
bool TRRagdoll::SetRagDoll(CoreVector i_initialvel, TRRagDollMode i_mode, float i_seconds, float i_secondsIn, float i_secondsOut, float i_animVelocityScale);
bool TRRagdoll::UpdateRagDoll();
#endif

#if 1 // c:\projects\source\tombraider\trhashes\trhashes.cpp
void $E19();
void $E22();
void $E25();
void $E28();
void $E31();
void $E34();
void $E37();
void $E40();
void $E43();
void $E46();
void $E49();
void $E52();
void $E55();
void $E58();
void $E61();
void $E64();
void $E67();
void $E70();
void $E73();
void $E76();
void $E79();
void $E82();
void $E85();
void $E88();
void $E91();
void $E94();
void $E97();
void $E100();
void $E103();
void $E106();
void $E109();
void $E112();
void $E115();
void $E118();
void $E121();
void $E124();
void $E127();
void $E130();
void $E133();
void $E136();
void $E139();
void $E142();
void $E145();
void $E148();
void $E151();
void $E154();
void $E157();
void $E160();
void $E163();
void $E166();
void $E169();
void $E172();
void $E175();
void $E178();
void $E181();
void $E184();
void $E187();
void $E190();
void $E193();
void $E196();
void $E199();
void $E202();
void $E205();
void $E208();
void $E211();
void $E214();
void $E217();
void $E220();
void $E223();
void $E226();
void $E229();
void $E232();
void $E235();
void $E238();
void $E241();
void $E244();
void $E247();
void $E250();
void $E253();
void $E256();
void $E259();
void $E262();
void $E265();
void $E268();
void $E271();
void $E274();
void $E277();
void $E280();
void $E283();
void $E286();
void $E289();
void $E292();
void $E295();
void $E298();
void $E301();
void $E304();
void $E307();
void $E310();
void $E313();
void $E316();
void $E319();
void $E322();
void $E325();
void $E328();
void $E331();
void $E334();
void $E337();
void $E340();
void $E343();
void $E346();
void $E349();
void $E352();
void $E355();
void $E358();
void $E361();
void $E364();
void $E367();
void $E370();
void $E373();
void $E376();
void $E379();
void $E382();
void $E385();
void $E388();
void $E391();
void $E394();
void $E397();
void $E400();
void $E403();
void $E406();
void $E409();
void $E412();
void $E415();
void $E418();
void $E421();
void $E424();
void $E427();
void $E430();
void $E433();
void $E436();
void $E439();
void $E442();
void $E445();
void $E448();
void $E451();
void $E454();
void $E457();
void $E460();
void $E463();
void $E466();
void $E469();
void $E472();
void $E475();
void $E478();
void $E481();
void $E484();
void $E487();
void $E490();
void $E493();
void $E496();
void $E499();
void $E502();
void $E505();
void $E508();
void $E511();
void $E514();
void $E517();
void $E520();
void $E523();
void $E526();
void $E529();
void $E532();
void $E535();
void $E538();
void $E541();
void $E544();
void $E547();
void $E550();
void $E553();
void $E556();
void $E559();
void $E562();
void $E565();
void $E568();
void $E571();
void $E574();
void $E577();
void $E580();
void $E583();
void $E586();
void $E589();
void $E592();
void $E595();
void $E598();
void $E601();
void $E604();
void $E607();
void $E610();
void $E613();
void $E616();
void $E619();
void $E622();
void $E625();
void $E628();
#endif

#if 1 // c:\projects\source\tombraider\trinventory\trinventory.cpp
void TRInventory::InitNewGame();
void TRInventory::ClearAll();
int32_t TRInventory::AddItem(int32_t i_objectNum);
int32_t TRInventory::RequestItem(int32_t i_objectNum);
void TRInventory::InsertItem(TRInvInit* i_invInit);
int32_t TRInventory::RemoveItem(int32_t i_objectNum);
int32_t TRInventory::GetItemOption(int32_t i_objectNum);
#endif

#if 1 // c:\projects\source\tombraider\trinventory\trinventory.h
void TRInventoryItem::TRInventoryItem();
#endif

#if 1 // c:\projects\source\tombraider\trinventory\trinvobject.cpp
CoreScripted::CommandReturn TRInvObject::RunFunction(CoreCommand* io_command);
CoreObject* TRInvObject::Create(CoreMemory* io_memory);
void TREdObject::Construct(CoreMemory* io_memory);
void TRInvObject::Construct(CoreMemory* io_memory);
void TRGameObject::Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
void TRMultiMeshObject::Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
void FRBackgroundObject::Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
void TRInvObject::Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
void TRFoliageObject::Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
void TREdObject::Destruct(CoreMemory* io_memory, CoreObjectUpdateStruct* io_updateStruct);
void CoreCutSceneObject::Destruct(CoreMemory* lpoMemory, CoreObjectUpdateStruct* lpoUpdateStruct);
void TRMultiMeshObject::Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
void TREdObject::Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
void TRFoliageObject::Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
void TRInvObject::Init(CoreHash i_name, CoreHash i_script, CoreObjectUpdateStruct* io_updateStruct);
void TRInvObject::Reset();
void TRFoliageObject::Reset();
void FRBackgroundObject::Reset();
void TRGameObject::Reset();
void TRMultiMeshObject::Reset();
void CoreCutSceneObject::Reset();
void TREdObject::Reset();
void TRInvObject::UpdateGameCycle(float i_time);
void TRMultiMeshObject::Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
void TRInvObject::Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
void TRFoliageObject::Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
void TREdObject::Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
void TRGameObject::Animate(CoreObjectUpdateStruct* io_updateStruct, float i_time);
void TRInvObject::Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
void TRGameObject::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
void TRFoliageObject::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
void TREdObject::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
void TRInvObject::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
void TRMultiMeshObject::HandleAssetManagerClientCallback(CoreAssetManager* lpoAssetManager, CoreWorld* lpoWorld, CoreHash i_assetID, CoreHash i_assetType);
void TRMultiMeshObject::AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
void FRBackgroundObject::AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
void TRInvObject::AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
void TRFoliageObject::AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
void TREdObject::AttachModelCompiled(CoreModelCompiled* i_modelCompiled, uint32_t i_modelCompiledFile);
CoreScripted::CommandReturn TREdObject::FnSetDefaultObjectTemplate(CoreCommand* io_command);
CoreScripted::CommandReturn TRInvObject::FnSetDefaultObjectTemplate(CoreCommand* io_command);
CoreScripted::CommandReturn TREdObject::FnSetDefaultTextureTemplate(CoreCommand* io_command);
CoreScripted::CommandReturn TRInvObject::FnSetDefaultTextureTemplate(CoreCommand* io_command);
CoreScripted::CommandReturn TRInvObject::FnSetDefaultAnimSet(CoreCommand* io_command);
#endif

#if 1 // c:\projects\source\tombraider\trinventory\trinvobject.h
void TRInvObject::TRInvObject();
CoreHash TRInvObject::GetTypeID();
#endif

#if 1 // c:\projects\source\tombraider\tritem\tritem.cpp
void TRItem::InitialiseItem();
CoreObject* TRItem::GetObjectPtr();
void TRItem::TransferNewToOld();
void TRItem::TransferOldToNew();
#endif

#if 1 // c:\projects\source\tombraider\trmenusystem\trmenusystem.cpp
void* TRMenuSystem::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn TRMenuSystem::RunFunction(CoreCommand* io_command);
void TRMenuSystem::TRMenuSystem();
void TRMenuSystem::Construct(CoreMemory* io_memory);
void TRMenuSystem::InitProfiles();
void TRMenuSystem::Update(CoreObjectUpdateStruct* io_updateStruct);
void TRMenuSystem::SetDampedCameraOn(bool i_onOff);
CoreScripted::CommandReturn TRMenuSystem::FnSetViewerDirectFlag(CoreCommand* io_command);
void TRMenuSystem::Render(CoreGameRender* io_graphics);
void TRMenuSystem::RenderComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
void TRMenuSystem::RenderLeftRightJustifiedThing(CoreMenuComponent* i_component, CoreGameRender* io_graphics, float i_x, float i_y, char* str1, char* str2);
void TRMenuSystem::RenderLevelStats(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
CoreScripted::CommandReturn TRMenuSystem::FnMenuSetDefaultWH(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnMenuSetDefaultAnchor(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnMenuSetDefaultFont(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnMenuSetDefaultCentreScale(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnMenuSetDefaultVisibility(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnMenuSetDefaultSelectable(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnMenuSetDefaultRequireCallbacks(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnMenuSetDefaultRGBA(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnMenuAddDefaultComponent(CoreCommand* io_command);
void TRMenuSystem::TransferProfileSlotToGame(int32_t nSlot);
CoreScripted::CommandReturn TRMenuSystem::FnIsSaveSlotAvailable(CoreCommand* lpoCommand);
CoreScripted::CommandReturn TRMenuSystem::FnSendPlayerDetails(CoreCommand* lpoCommand);
CoreScripted::CommandReturn TRMenuSystem::FnCanSwapInventory(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnMessageBoxNoYes(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnTitleRingOn(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnLoadGameStartup(CoreCommand* io_command);
CAAudioError CAL1_AudioDriver::PauseChannel(uint32_t channel);
CAAudioError CAL1_AudioDriver::EnableAllHWAcceleration(bool enable);
CAAudioError CAL1_AudioDriver::EnableEAXReverb(bool enable);
CAAudioError CAL1_AudioDriver::EnableEAX(bool enable);
CAAudioError CAL1_AudioDriver::Enable3DHWAcceleration(bool enable);
CAAudioError CAL1_AudioDriver::EnableEAXReverbMorphing(bool enable);
CAAudioError CAL1_AudioDriver::EnableNon3DHWAcceleration(bool enable);
CoreScripted::CommandReturn TRMenuSystem::FnMenuWaitForMemCard(CoreCommand* io_command);
CAAudioError CAL1_AudioDriver::ResumeChannel(uint32_t channel);
CAAudioError CAL1_AudioDriver::EnableEAXReverbPanning(bool enable);
CAAudioError CAL1_AudioDriver::EnableEAXOcclusion(bool enable);
CAAudioError CAL1_AudioDriver::StartSample(CAL1_Sample* sample);
CoreScripted::CommandReturn TRMenuSystem::FnStartSavedGame(CoreCommand* io_command);
void TRMenuSystem::ActivateSaveCrystal();
CoreScripted::CommandReturn TRMenuSystem::FnGetCheatStatus(CoreCommand* lpoCommand);
CoreScripted::CommandReturn TRMenuSystem::FnToggleCheatStatus(CoreCommand* lpoCommand);
CoreScripted::CommandReturn TRMenuSystem::FnIsDampedCameraOn(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnSetDampedCameraOn(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnWantToSave(CoreCommand* io_command);
CoreScripted::CommandReturn TRMenuSystem::FnLoadFrontendTextureSet(CoreCommand* io_command);
#endif

#if 1 // c:\projects\source\tombraider\trmenusystem\trprofile.cpp
void CoreGraphicsDeviceInternalData::CoreGraphicsDeviceInternalData();
void CoreEulerAngle::CoreEulerAngle();
void TRHitItem::TRHitItem();
void CoreUV::CoreUV();
char* CoreLevelDynamicLight::GetName();
void TRProfile::TRProfile();
void CoreVector::CoreVector();
char* CoreLevelDynamicFlap::GetName();
void CoreInput::CoreInput();
void CoreDetectionMeshInfo::CoreDetectionMeshInfo();
#endif

#if 1 // c:\projects\source\tombraider\trmultimesh\trmultimeshobject.cpp
void* TRFoliageObject::GetVariablePointer(CoreHash i_variableName);
void* TREdObject::GetVariablePointer(CoreHash i_variableName);
void* TRInvObject::GetVariablePointer(CoreHash i_variableName);
void* TRMultiMeshObject::GetVariablePointer(CoreHash i_variableName);
void* TRGameObject::GetVariablePointer(CoreHash i_variableName);
CoreScripted::CommandReturn TRMultiMeshObject::RunFunction(CoreCommand* io_command);
CoreObject* TRMultiMeshObject::Create(CoreMemory* io_memory);
void TRMultiMeshObject::Construct(CoreMemory* io_memory);
void TRMultiMeshObject::UpdateGameCycle(float i_time);
void TRMultiMeshObject::Render(float fTime, uint32_t ulDrawFlags, CoreGameRender* lpoGraphics);
CoreScripted::CommandReturn TRMultiMeshObject::FnSetDefaultObjectTemplate(CoreCommand* io_command);
CoreScripted::CommandReturn TRMultiMeshObject::FnSetDefaultTextureTemplate(CoreCommand* io_command);
#endif

#if 1 // c:\projects\source\tombraider\trmultimesh\trmultimeshobject.h
void TRMultiMeshObject::TRMultiMeshObject();
CoreHash TRMultiMeshObject::GetTypeID();
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trbglightnode.cpp
void TRBGLightNode::Construct();
uint32_t TRBGLightNode::CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
void TRBGLightNode::onChangeCodeBits();
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trcameranode.cpp
uint32_t TRCameraNode::CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
uint32_t TRCameraNode::LoadNodes(CoreLevelCompiled* iLevelCompiled);
uint32_t TRCameraNode::Read(uint32_t* iBuffer);
void TRCameraNode::Construct();
void TRCameraNode::CreateNodeName(uint32_t iNum);
void TRCameraNode::CreateFromEditorNode(TRNode* pNode);
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trecameranode.cpp
uint32_t TRECameraNode::CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
void TRECameraNode::SetupFromCameraNode(TRCameraNode* iNode);
void TRECameraNode::Construct();
void TRECameraNode::RenderDebug();
uint32_t TRECameraNode::Write(uint32_t* iBuffer);
TRECameraNode* TRECameraNode::CreateAndConnectNode(CoreVector iPos);
void TRECameraNode::CreateNodeName(uint32_t iNum);
#endif

#if 1 // c:\projects\source\tombraider\trnodes\treditemnode.cpp
void TREdItemNode::CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
void TREdItemNode::Construct();
void TREdItemNode::SetupFromObjectNode(TRObjectNode* iNode);
void TREdItemNode::ForceUpdate();
void TREdItemNode::RenderDebug();
uint32_t TREdItemNode::WriteItemsFile(char* iFileName);
void TREdItemNode::CreateNodeName(uint32_t iNum);
TREdItemNode* TREdItemNode::CreateAndConnectNode(CoreVector iPos, uint32_t iModel);
void TREdItemNode::OnDelete();
#endif

#if 1 // c:\projects\source\tombraider\trnodes\tretriggernode.cpp
void TRETriggerNode::CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
void TRETriggerNode::SetupFromTriggerNode(TRTriggerNode* iNode);
void TRETriggerNode::Construct();
void TRETriggerNode::RenderDebug();
void TRETriggerNode::ForceUpdate();
uint32_t TRETriggerNode::Write(uint32_t* iBuffer);
TRETriggerNode* TRETriggerNode::CreateAndConnectNode(CoreVector iPos);
void TRETriggerNode::CreateNodeName(uint32_t iNum);
#endif

#if 1 // c:\projects\source\tombraider\trnodes\tretriggernode.h
void TRETriggerNode::SetEventGroupHash(CoreHash iHash);
void TRFXNode::SetEmitterItemGroup(CoreHash iHash);
void CAL1_API::SetAudioData_DataMask(uint32_t dataMask);
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trfxnode.cpp
void TRFXNode::Construct();
void TRFXNode::RenderDebug();
TRFXNode* TRFXNode::CreateAndConnectNode(CoreVector pos);
uint32_t TRFXNode::CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
void TRFXNode::ForceEmitterReallocate();
void TRFXNode::CreateEmitter(CoreHash itemTemplate, float iGlobalRate, CoreVector iBoxSize);
void TRFXNode::AddEmitterItems(CoreHash itemTemplate);
void TRFXNode::Update();
void TRFXNode::ForceUpdate();
uint32_t TRFXNode::Write(uint32_t* iBuffer);
uint32_t TRFXNode::Read(uint32_t* iBuffer);
void TRFXNode::Duplicate();
void TRFXNode::CreateNodeName(uint32_t iNum);
void TRFXNode::OnBeginEdit(bool iBeginEdit);
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trmanipnode.cpp
void TRManipNode::Construct();
void TRManipNode::InitManipulator();
void TRManipNode::updateManipNode(TRHitItem* pHitItem);
void TRManipNode::resetManipHandles();
void TRManipNode::releaseCapture();
void TRManipNode::captureHitItem(TRHitItem* pHitItem);
void TRManipNode::SetHitIndex(int32_t iIndex);
void TRManipNode::renderManip();
int32_t TRManipNode::GetHitIndex(uint32_t iUseIndex);
void TRManipNode::duplicateSelection();
void TRManipNode::deleteSelection();
void TRManipNode::setManipType(uint32_t iType);
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trnodes.cpp
uint32_t TRNode::Write(uint32_t* iBuffer);
void TRNode::BodgeCodeFlags();
uint32_t TRNode::Read(uint32_t* iBuffer);
CoreVector TRNode::ReadVector(uint32_t*& iBuffer, uint32_t& iCount);
void $E10();
void $E15();
void TRWadFileManager::BeginFile(char* iFileName);
void TRWadFileManager::AddFile(CoreStringBuffer<256> iFullName, CoreHash iShortName, uint32_t iFileSize);
bool TRWadFileManager::Write();
bool TRWadFileManager::Open(char* iFileName);
void TRWadFileManager::Close();
uint32_t* TRWadFileManager::GetFile(CoreHash iFileHash);
int32_t TRWadFileManager::GetFileSize(CoreHash iFileHash);
void TRNode::WriteSceneNodes();
void TRNode::CreateSceneNodes();
void TRNode::CreateEditorScene();
uint32_t* TRNode::LoadNodeFile(char* iFileName, uint32_t iNodeType, uint32_t& ioNumNodes, CoreHash& ioAssetHash);
void TRNode::UnloadNodeFile(CoreHash iAssetHash);
void TRNode::SetNodeVisibility(uint32_t iType, bool iVal);
bool TRNode::GetNodeVisibility(uint32_t iType);
void TRNode::UpdateNodes(bool bLimitedUpdate);
void TRNode::CleanupAllNodeArrays();
CoreNode* TRNode::GetNodeChainByType(uint32_t iRoomNumber, uint32_t iNodeType);
uint32_t TRNode::GetNodeTotalByType(uint32_t iType);
uint32_t TRNode::CountNodesByType(CoreNodeType iType);
TRNode* TRNode::GetNodeByCreateIndex(uint32_t iIndex, uint32_t iType);
void TRNode::UpdateOnMove(bool iUpdateChain);
void TRNode::InitStringBuffer();
void TRNode::DeInitStringBuffer();
uint32_t TRNode::AddString(char* iString);
char* TRNode::GetString(uint32_t iIndex);
void TRNode::SetString(uint32_t iIndex, char* iString);
uint32_t TRNode::GetStringIndexFromHash(CoreHash iHash);
bool TRNode::DoesNameExist(uint32_t iNameHash);
uint32_t TRNode::WriteNodeNames(char* iFileName);
uint32_t TRNode::RemoveDuplicateStrings();
uint32_t TRNode::GetNodeStringIndexUsageCount(uint32_t iStringIndex);
void TRNode::CreateNodeSceneFromEditor();
void TRNode::CreateFromEditorNode(TRNode* pNode);
void TRNode::OnBeginEdit();
void TRNode::CreateDuplicateNodeName();
void TRNode::OnDelete();
uint32_t TRNode::WriteRoomData(char* iFileName);
void TRNode::LoadRoomData();
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trnodes.h
[! NO TYPE] TRNode::LoadNodeWadFile<TRECameraNode>();
[! NO TYPE] TRNode::LoadNodeWadFile<TRSceneryNode>();
[! NO TYPE] TRNode::LoadNodeWadFile<TRETriggerNode>();
[! NO TYPE] TRNode::LoadNodeWadFile<TRFXNode>();
[! NO TYPE] TRNode::CreateFromEditorScene<TRCameraNode>();
[! NO TYPE] TRNode::CreateFromEditorScene<TRObjectNode>();
[! NO TYPE] TRNode::CreateFromEditorScene<TRTriggerNode>();
[! NO TYPE] TRNode::WriteChain<TRSceneryNode>();
[! NO TYPE] TRNode::WriteChain<TRECameraNode>();
[! NO TYPE] TRNode::WriteChain<TRFXNode>();
[! NO TYPE] TRNode::WriteChain<TRETriggerNode>();
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trobjectnode.cpp
uint32_t TRObjectNode::CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
void TRObjectNode::CreateFromEditorNode(TRNode* pNode);
void TRObjectNode::Construct();
void TRObjectNode::SetupFromCoreObject(CoreObject* iObject);
void TRObjectNode::Update();
void TRObjectNode::RenderDebug();
void TRObjectNode::CreateNodeName(uint32_t iNum);
TRNode* TRObjectNode::GetNodeFromTRItem(TRItem* iItem);
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trscenerynode.cpp
uint32_t TRSceneryNode::CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled);
TRSceneryNode* TRSceneryNode::CreateAndConnectNode(CoreVector iPos, uint32_t iType);
void TRSceneryNode::Construct();
void TRSceneryNode::Update();
void TRSceneryNode::ForceUpdate();
void TRSceneryNode::UpdateVineType(uint32_t iIndex);
void TRSceneryNode::Duplicate();
uint32_t TRSceneryNode::Write(uint32_t* iBuffer);
uint32_t TRSceneryNode::Read(uint32_t* iBuffer);
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trtriggernode.cpp
uint32_t TRTriggerNode::CreateAndConnectNodes(CoreLevelCompiled* iLevelCompiled, int32_t i_numTriggers);
uint32_t TRTriggerNode::LoadNodes(CoreLevelCompiled* iLevelCompiled);
uint32_t TRTriggerNode::GetTriggerRoomArray(CoreVector iMin, CoreVector iMax, uint32_t* oRoomArray);
void TRTriggerNode::Construct();
void TRTriggerNode::SetupFromTriggerBox(TRTriggerBox* i_trigBox);
uint32_t TRTriggerNode::Read(uint32_t* iBuffer);
bool TRTriggerNode::CheckTrigger(CoreVector iPos, uint32_t iFlip);
void TRTriggerNode::RenderDebug();
void TRTriggerNode::CreateNodeName(uint32_t iNum);
void TRTriggerNode::ParseTRTriggerEvents();
void TRTriggerNode::MakeTriggerEventGroup(uint32_t* iData, uint32_t iGroupIndex);
uint32_t TRTriggerNode::FixTriggerConnections(CoreHash iNewGroup, CoreHash iOldGroup, TRTriggerNode** oFixedTriggers);
uint32_t TRTriggerNode::FixEventConnections(CoreHash iNewNodeName, CoreHash iOldNodeName, uint32_t iNodeType, TRTriggerNode::trigEventGroup** oFixedEventGroups);
uint32_t TRTriggerNode::WriteTriggerEvents(char* iFileName);
void TRTriggerNode::LoadTriggerEvents();
int32_t TRTriggerNode::GetEventGroupIndexFromHash(CoreHash iHash);
CoreHash TRTriggerNode::GetEventGroupHashFromIndex(int32_t iIndex);
TRTriggerNode::trigEventGroup* TRTriggerNode::GetEventGroup(uint32_t iIndex);
void TRTriggerNode::TestTriggers(FRPlayerObject* iPlayer, int32_t iEventIndex, int32_t iHeavy);
void TRTriggerNode::TriggerEventGroup(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pEventGroup, uint32_t iEventIndex);
uint32_t TRTriggerNode::TriggerSingleEvent(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pEventGroup, TRTriggerNode::trigEvent* pEvent);
bool TRTriggerNode::SwitchTrigger(TRTriggerNode::trigEventGroup* pEventGroup);
bool TRTriggerNode::KeyTrigger(TRTriggerNode::trigEventGroup* pEventGroup, FRPlayerObject* iPlayer);
bool TRTriggerNode::PickupTrigger(TRTriggerNode::trigEventGroup* pEventGroup);
void TRTriggerNode::TriggerEventSink(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
void TRTriggerNode::TriggerEventObject(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
void TRTriggerNode::TriggerEventTarget(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
uint32_t TRTriggerNode::TriggerEventFlipMap(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
uint32_t TRTriggerNode::TriggerEventFlipOn(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
uint32_t TRTriggerNode::TriggerEventFlipOff(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
void TRTriggerNode::TriggerEventCamera(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
void TRTriggerNode::TriggerEventFX(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
void TRTriggerNode::TriggerEventHint(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
void TRTriggerNode::TriggerEventLight(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, TRTriggerNode::trigEvent* pEvent);
void TRTriggerNode::UpdateEventScheduleList();
void TRTriggerNode::AddScheduledGroup(FRPlayerObject* iPlayer, TRTriggerNode::trigEventGroup* pGroup, uint32_t iEventIndex);
void TRTriggerNode::GlobalUpdate();
void TRTriggerNode::CreateFromEditorNode(TRNode* pNode);
#endif

#if 1 // c:\projects\source\tombraider\trnodes\trtriggernode.h
CoreHash CoreObject::GetType();
CoreHash TRTriggerNode::GetEventHash();
CoreHash TRFXNode::GetEmitterItemGroup();
int32_t TRTriggerNode::GetEventIndex();
#endif

#if 1 // c:\projects\source\tombraider\trpanel\trpanel.cpp
CoreScripted::CommandReturn TRPanel::RunFunction(CoreCommand* io_command);
void TRPanel::Construct(CoreMemory* io_memory);
void TRPanel::InitForNewLevel();
void TRPanelPolyGroup::CalculateNumPolys();
CoreScripted::CommandReturn TRPanel::FnResetPolylist(CoreCommand* io_command);
CoreScripted::CommandReturn TRPanel::FnAddPolylist(CoreCommand* io_command);
CoreScripted::CommandReturn TRPanel::FnAddPolylistPoint(CoreCommand* io_command);
CoreScripted::CommandReturn TRPanel::FnAddPolylistPoly(CoreCommand* io_command);
void TRPanel::InitialiseInventoryDisplay();
void TRPanel::AddToInventoryDisplay(int32_t objnum, InventoryType invType, int32_t nAmount);
void TRPanel::PopulateInventoryDisplay();
void TRPanel::KillInventoryDisplay();
uint32_t TRPanel::FindInventoryItemName(int32_t nItemNum);
int32_t TRPanel::FindInventoryItemIndex(int32_t nItemNum);
bool TRPanel::AreKeysAvailable();
bool TRPanel::SendInvItemToNetworkPlayer();
void TRPanel::HandleQuickInvDisplay(float fTimeElapsed);
void TRPanel::QuickInvOff();
bool TRPanel::IsQuickInvOn();
void TRPanel::HandleInventoryDisplay(float fTimeElapsed);
void TRPanel::SetupInventoryRingLayout();
void TRPanel::CheckForRecievedItem();
void TRPanel::UpdateSelectionMovement();
void TRPanel::SetInvObjectPositions();
void TRPanel::ProcessItemSelection();
void TRPanel::ProcessItemUse();
void TRPanel::ProcessRingMovement();
void TRPanel::ShowInventoryType(InventoryType nType);
void TRPanel::HandlePickups();
int32_t TRPanel::GetPlayerIndex();
void TRPanel::AddDisplayPickup(int32_t objnum);
void TRPanel::Update(CoreObjectUpdateStruct* io_updateStruct, float fTimeElapsed);
void TRPanel::ProcessBarFade(float& io_fFadeLevel, float& io_fFadeDir, float fTimeElapsed);
void TRPanel::Render(CoreGameRender* io_graphics);
void TRPanel::RenderWhiteOut(CoreGameRender* pGR);
void TRPanel::RenderHint(CoreGameRender* io_graphics);
void TRPanel::RenderComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
void TRPanel::RenderMyComponent(CoreMenuComponent* i_component, CoreGameRender* io_graphics);
void TRPanel::RenderComponentPosUV(CoreMenuComponent* i_component, CoreGameRender* io_graphics, float i_x0, float i_y0, float i_x1, float i_y1, float i_u0, float i_v0, float i_u1, float i_v1, CoreRGBA i_rgba);
void TRPanel::RenderAir(CoreMenuComponent* i_component, CoreGameRender* io_graphics, CoreHash i_name, FRPlayerObject* i_player);
void TRPanel::RenderAmmoClips(CoreMenuComponent* i_component, CoreGameRender* io_graphics, CoreHash i_name, FRPlayerObject* i_player);
void TRPanel::RenderBullets(CoreMenuComponent* i_component, CoreGameRender* io_graphics, CoreHash i_name, FRPlayerObject* i_player);
void TRPanel::HealthHit();
void TRPanel::HealthBarUpdate(float fTimeElapsed);
void TRPanel::AirHit();
void TRPanel::AirBarUpdate(float fTimeElapsed);
bool TRPanel::IsInventoryOn();
void TRPanel::InventoryOn(InventoryType invType);
void TRPanel::InventoryOff();
bool TRPanel::CanSwapItemType();
bool TRPanel::ArePlayersWithinGivenDistance(float fDistance);
void TRPanel::ActivateInventoryMenuOptions();
void TRPanel::ShowHint(int32_t nHintId, float fTimer);
void TRPanel::HintUpdate(float fTimeElapsed);
void TRPanel::SetHintPressActive(bool bTF);
void TRPanel::WhiteOutUpdate(float fTimeElapsed);
void TRPanel::StartWhiteOut();
void TRPanel::EndWhiteOut();
void TRPanel::DoDebug(CoreDebugInput* i_input);
#endif

#if 1 // f:\vs70builds\3077\vc\crtbld\crt\src\atonexit.c
int32_t* _onexit(int32_t* func);
int32_t atexit(void* func);
#endif

#if 1 // f:\vs70builds\3077\vc\crtbld\crt\src\crtexe.c
int32_t mainCRTStartup();
#endif

#if 1 // f:\vs70builds\3077\vc\crtbld\crt\src\dllargv.c
int32_t _setargv();
int32_t _matherr(_exception* pexcept);
#endif

#if 1 // f:\vs70builds\3077\vc\crtbld\crt\src\intel\fp8.c
void _setdefaultprecision();
#endif

#if 1 // f:\vs70builds\3077\vc\crtbld\crt\src\secchk.c
void __fastcall __security_check_cookie(uint32_t cookie);
void report_failure();
#endif

#if 1 // f:\vs70builds\3077\vc\crtbld\crt\src\seccinit.c
void __security_init_cookie();
#endif
